# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/series/apply/test_series_apply.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/series/apply/test_series_apply.py
@@ -11,7 +11,19 @@
 
 
 class TestSeriesApply:
+    """ """
     def test_apply(self, datetime_series):
+        """
+
+        Parameters
+        ----------
+        datetime_series :
+            
+
+        Returns
+        -------
+
+        """
         with np.errstate(all="ignore"):
             tm.assert_series_equal(
                 datetime_series.apply(np.sqrt), np.sqrt(datetime_series)
@@ -41,9 +53,21 @@
         tm.assert_series_equal(s, rs)
 
     def test_apply_same_length_inference_bug(self):
+        """ """
         s = Series([1, 2])
 
         def f(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             return (x, x + 1)
 
         result = s.apply(f)
@@ -56,15 +80,38 @@
         tm.assert_series_equal(result, expected)
 
     def test_apply_dont_convert_dtype(self):
+        """ """
         s = Series(np.random.randn(10))
 
         def f(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             return x if x > 0 else np.nan
 
         result = s.apply(f, convert_dtype=False)
         assert result.dtype == object
 
     def test_with_string_args(self, datetime_series):
+        """
+
+        Parameters
+        ----------
+        datetime_series :
+            
+
+        Returns
+        -------
+
+        """
 
         for arg in ["sum", "mean", "min", "max", "std"]:
             result = datetime_series.apply(arg)
@@ -72,6 +119,7 @@
             assert result == expected
 
     def test_apply_args(self):
+        """ """
         s = Series(["foo,bar"])
 
         result = s.apply(str.split, args=(",",))
@@ -79,10 +127,22 @@
         assert isinstance(result[0], list)
 
     def test_series_map_box_timestamps(self):
+        """ """
         # GH#2689, GH#2627
         ser = Series(pd.date_range("1/1/2000", periods=10))
 
         def func(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             return (x.hour, x.day, x.month)
 
         # it works!
@@ -90,6 +150,7 @@
         ser.apply(func)
 
     def test_apply_box(self):
+        """ """
         # ufunc will not be boxed. Same test cases as the test_map_box
         vals = [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-01-02")]
         s = pd.Series(vals)
@@ -126,6 +187,7 @@
         tm.assert_series_equal(res, exp)
 
     def test_apply_datetimetz(self):
+        """ """
         values = pd.date_range("2011-01-01", "2011-01-02", freq="H").tz_localize(
             "Asia/Tokyo"
         )
@@ -146,6 +208,17 @@
 
         # not vectorized
         def f(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             if not isinstance(x, pd.Timestamp):
                 raise ValueError
             return str(x.tz)
@@ -155,6 +228,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_apply_dict_depr(self):
+        """ """
 
         tsdf = pd.DataFrame(
             np.random.randn(10, 3),
@@ -166,6 +240,7 @@
             tsdf.A.agg({"foo": ["sum", "mean"]})
 
     def test_apply_categorical(self):
+        """ """
         values = pd.Categorical(list("ABBABCD"), categories=list("DCBA"), ordered=True)
         ser = pd.Series(values, name="XX", index=list("abcdefg"))
         result = ser.apply(lambda x: x.lower())
@@ -184,6 +259,17 @@
 
     @pytest.mark.parametrize("series", [["1-1", "1-1", np.NaN], ["1-1", "1-2", np.NaN]])
     def test_apply_categorical_with_nan_values(self, series):
+        """
+
+        Parameters
+        ----------
+        series :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20714 bug fixed in: GH 24275
         s = pd.Series(series, dtype="category")
         result = s.apply(lambda x: x.split("-")[0])
@@ -193,6 +279,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_apply_empty_integer_series_with_datetime_index(self):
+        """ """
         # GH 21245
         s = pd.Series([], index=pd.date_range(start="2018-01-01", periods=0), dtype=int)
         result = s.apply(lambda x: x)
@@ -200,7 +287,19 @@
 
 
 class TestSeriesAggregate:
+    """ """
     def test_transform(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         # transforming functions
 
         with np.errstate(all="ignore"):
@@ -249,6 +348,17 @@
             tm.assert_series_equal(result.reindex_like(expected), expected)
 
     def test_transform_and_agg_error(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         # we are trying to transform with an aggregator
         msg = "transforms cannot produce aggregated results"
         with pytest.raises(ValueError, match=msg):
@@ -269,6 +379,7 @@
                 string_series.agg({"foo": np.sqrt, "bar": "sum"})
 
     def test_demo(self):
+        """ """
         # demonstration tests
         s = Series(range(6), dtype="int64", name="series")
 
@@ -286,6 +397,7 @@
             s.agg({"foo": ["min", "max"]})
 
     def test_multiple_aggregators_with_dict_api(self):
+        """ """
 
         s = Series(range(6), dtype="int64", name="series")
         # nested renaming
@@ -294,6 +406,17 @@
             s.agg({"foo": ["min", "max"], "bar": ["sum", "mean"]})
 
     def test_agg_apply_evaluate_lambdas_the_same(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         # test that we are evaluating row-by-row first
         # before vectorized evaluation
         result = string_series.apply(lambda x: str(x))
@@ -305,6 +428,17 @@
         tm.assert_series_equal(result, expected)
 
     def test_with_nested_series(self, datetime_series):
+        """
+
+        Parameters
+        ----------
+        datetime_series :
+            
+
+        Returns
+        -------
+
+        """
         # GH 2316
         # .agg with a reducer and a transform, what to do
         result = datetime_series.apply(
@@ -317,6 +451,17 @@
         tm.assert_frame_equal(result, expected)
 
     def test_replicate_describe(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         # this also tests a result set that is all scalars
         expected = string_series.describe()
         result = string_series.apply(
@@ -334,6 +479,17 @@
         tm.assert_series_equal(result, expected)
 
     def test_reduce(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         # reductions with named functions
         result = string_series.agg(["sum", "mean"])
         expected = Series(
@@ -344,6 +500,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_non_callable_aggregates(self):
+        """ """
         # test agg using non-callable series attributes
         s = Series([1, 2, None])
 
@@ -403,6 +560,21 @@
         ),
     )
     def test_agg_cython_table(self, series, func, expected):
+        """
+
+        Parameters
+        ----------
+        series :
+            
+        func :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH21224
         # test reducing functions in
         # pandas.core.base.SelectionMixin._cython_table
@@ -435,6 +607,21 @@
         ),
     )
     def test_agg_cython_table_transform(self, series, func, expected):
+        """
+
+        Parameters
+        ----------
+        series :
+            
+        func :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH21224
         # test transforming functions in
         # pandas.core.base.SelectionMixin._cython_table (cumprod, cumsum)
@@ -458,12 +645,28 @@
         ),
     )
     def test_agg_cython_table_raises(self, series, func, expected):
+        """
+
+        Parameters
+        ----------
+        series :
+            
+        func :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH21224
         with pytest.raises(expected):
             # e.g. Series('a b'.split()).cumprod() will raise
             series.agg(func)
 
     def test_transform_none_to_type(self):
+        """ """
         # GH34377
         df = pd.DataFrame({"a": [None]})
 
@@ -472,6 +675,7 @@
             df.transform({"a": int})
 
     def test_series_apply_no_suffix_index(self):
+        """ """
         # GH36189
         s = pd.Series([4] * 3)
         result = s.apply(["sum", lambda x: x.sum(), lambda x: x.sum()])
@@ -481,7 +685,19 @@
 
 
 class TestSeriesMap:
+    """ """
     def test_map(self, datetime_series):
+        """
+
+        Parameters
+        ----------
+        datetime_series :
+            
+
+        Returns
+        -------
+
+        """
         index, data = tm.getMixedTypeDict()
 
         source = Series(data["B"], index=data["C"])
@@ -537,6 +753,17 @@
         tm.assert_series_equal(a.map(c), exp)
 
     def test_map_empty(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(index, MultiIndex):
             pytest.skip("Initializing a Series from a MultiIndex is not supported")
 
@@ -547,6 +774,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_compat(self):
+        """ """
         # related GH 8024
         s = Series([True, True, False], index=[1, 2, 3])
         result = s.map({True: "foo", False: "bar"})
@@ -554,6 +782,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_int(self):
+        """ """
         left = Series({"a": 1.0, "b": 2.0, "c": 3.0, "d": 4})
         right = Series({1: 11, 2: 22, 3: 33})
 
@@ -566,11 +795,23 @@
         assert not isna(merged["c"])
 
     def test_map_type_inference(self):
+        """ """
         s = Series(range(3))
         s2 = s.map(lambda x: np.where(x == 0, 0, 1))
         assert issubclass(s2.dtype.type, np.integer)
 
     def test_map_decimal(self, string_series):
+        """
+
+        Parameters
+        ----------
+        string_series :
+            
+
+        Returns
+        -------
+
+        """
         from decimal import Decimal
 
         result = string_series.map(lambda x: Decimal(str(x)))
@@ -578,6 +819,7 @@
         assert isinstance(result[0], Decimal)
 
     def test_map_na_exclusion(self):
+        """ """
         s = Series([1.5, np.nan, 3, np.nan, 5])
 
         result = s.map(lambda x: x * 2, na_action="ignore")
@@ -585,11 +827,17 @@
         tm.assert_series_equal(result, exp)
 
     def test_map_dict_with_tuple_keys(self):
-        """
-        Due to new MultiIndex-ing behaviour in v0.14.0,
+        """Due to new MultiIndex-ing behaviour in v0.14.0,
         dicts with tuple keys passed to map were being
         converted to a multi-index, preventing tuple values
         from being mapped properly.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # GH 18496
         df = pd.DataFrame({"a": [(1,), (2,), (3, 4), (5, 6)]})
@@ -601,6 +849,7 @@
         tm.assert_series_equal(df["labels"], df["expected_labels"], check_names=False)
 
     def test_map_counter(self):
+        """ """
         s = Series(["a", "b", "c"], index=[1, 2, 3])
         counter = Counter()
         counter["b"] = 5
@@ -610,6 +859,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_defaultdict(self):
+        """ """
         s = Series([1, 2, 3], index=["a", "b", "c"])
         default_dict = defaultdict(lambda: "blank")
         default_dict[1] = "stuff"
@@ -618,6 +868,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_dict_na_key(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/17648
         # Checks that np.nan key is appropriately mapped
         s = Series([1, 2, np.nan])
@@ -626,12 +877,19 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_dict_subclass_with_missing(self):
-        """
-        Test Series.map with a dictionary subclass that defines __missing__,
+        """Test Series.map with a dictionary subclass that defines __missing__,
         i.e. sets a default value (GH #15999).
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         class DictWithMissing(dict):
+            """ """
             def __missing__(self, key):
                 return "missing"
 
@@ -642,7 +900,9 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_dict_subclass_without_missing(self):
+        """ """
         class DictWithoutMissing(dict):
+            """ """
             pass
 
         s = Series([1, 2, 3])
@@ -652,6 +912,17 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_abc_mapping(self, non_dict_mapping_subclass):
+        """
+
+        Parameters
+        ----------
+        non_dict_mapping_subclass :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/29733
         # Check collections.abc.Mapping support as mapper for Series.map
         s = Series([1, 2, 3])
@@ -661,9 +932,21 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_abc_mapping_with_missing(self, non_dict_mapping_subclass):
+        """
+
+        Parameters
+        ----------
+        non_dict_mapping_subclass :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/29733
         # Check collections.abc.Mapping support as mapper for Series.map
         class NonDictMappingWithMissing(non_dict_mapping_subclass):
+            """ """
             def __missing__(self, key):
                 return "missing"
 
@@ -676,6 +959,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_map_box(self):
+        """ """
         vals = [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-01-02")]
         s = pd.Series(vals)
         assert s.dtype == "datetime64[ns]"
@@ -711,6 +995,7 @@
         tm.assert_series_equal(res, exp)
 
     def test_map_categorical(self):
+        """ """
         values = pd.Categorical(list("ABBABCD"), categories=list("DCBA"), ordered=True)
         s = pd.Series(values, name="XX", index=list("abcdefg"))
 
@@ -731,6 +1016,7 @@
             s.map(lambda x: x, na_action="ignore")
 
     def test_map_datetimetz(self):
+        """ """
         values = pd.date_range("2011-01-01", "2011-01-02", freq="H").tz_localize(
             "Asia/Tokyo"
         )
@@ -755,6 +1041,17 @@
 
         # not vectorized
         def f(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             if not isinstance(x, pd.Timestamp):
                 raise ValueError
             return str(x.tz)
@@ -772,6 +1069,21 @@
         ],
     )
     def test_map_missing_mixed(self, vals, mapping, exp):
+        """
+
+        Parameters
+        ----------
+        vals :
+            
+        mapping :
+            
+        exp :
+            
+
+        Returns
+        -------
+
+        """
         # GH20495
         s = pd.Series(vals + [np.nan])
         result = s.map(mapping)
@@ -792,6 +1104,19 @@
         ],
     )
     def test_apply_series_on_date_time_index_aware_series(self, dti, exp):
+        """
+
+        Parameters
+        ----------
+        dti :
+            
+        exp :
+            
+
+        Returns
+        -------
+
+        """
         # GH 25959
         # Calling apply on a localized time series should not cause an error
         index = dti.tz_localize("UTC").index
@@ -799,6 +1124,7 @@
         tm.assert_frame_equal(result, exp)
 
     def test_apply_scaler_on_date_time_index_aware_series(self):
+        """ """
         # GH 25959
         # Calling apply on a localized time series should not cause an error
         series = tm.makeTimeSeries(nper=30).tz_localize("UTC")
@@ -806,6 +1132,7 @@
         tm.assert_series_equal(result, pd.Series(np.ones(30), dtype="int64"))
 
     def test_map_float_to_string_precision(self):
+        """ """
         # GH 13228
         ser = pd.Series(1 / 3)
         result = ser.map(lambda val: str(val)).to_dict()
@@ -813,6 +1140,7 @@
         assert result == expected
 
     def test_map_with_invalid_na_action_raises(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/32815
         s = pd.Series([1, 2, 3])
         msg = "na_action must either be 'ignore' or None"
@@ -820,6 +1148,7 @@
             s.map(lambda x: x, na_action="____")
 
     def test_apply_to_timedelta(self):
+        """ """
         list_of_valid_strings = ["00:00:01", "00:00:02"]
         a = pd.to_timedelta(list_of_valid_strings)
         b = Series(list_of_valid_strings).apply(pd.to_timedelta)
