# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_unicode.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_unicode.py
@@ -2,6 +2,17 @@
 from numpy.testing import assert_, assert_equal, assert_array_equal
 
 def buffer_length(arr):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(arr, str):
         if not arr:
             charmax = 0
@@ -29,6 +40,7 @@
 
 
 def test_string_cast():
+    """ """
     str_arr = np.array(["1234", "1234\0\0"], dtype='S')
     uni_arr1 = str_arr.astype('>U')
     uni_arr2 = str_arr.astype('<U')
@@ -46,6 +58,21 @@
     """Check the creation of zero-valued arrays"""
 
     def content_check(self, ua, ua_scalar, nbytes):
+        """
+
+        Parameters
+        ----------
+        ua :
+            
+        ua_scalar :
+            
+        nbytes :
+            
+
+        Returns
+        -------
+
+        """
 
         # Check the length of the unicode base type
         assert_(int(ua.dtype.str[2:]) == self.ulen)
@@ -59,17 +86,20 @@
         assert_(buffer_length(ua_scalar) == 0)
 
     def test_zeros0D(self):
+        """ """
         # Check creation of 0-dimensional objects
         ua = np.zeros((), dtype='U%s' % self.ulen)
         self.content_check(ua, ua[()], 4*self.ulen)
 
     def test_zerosSD(self):
+        """ """
         # Check creation of single-dimensional objects
         ua = np.zeros((2,), dtype='U%s' % self.ulen)
         self.content_check(ua, ua[0], 4*self.ulen*2)
         self.content_check(ua, ua[1], 4*self.ulen*2)
 
     def test_zerosMD(self):
+        """ """
         # Check creation of multi-dimensional objects
         ua = np.zeros((2, 3, 4), dtype='U%s' % self.ulen)
         self.content_check(ua, ua[0, 0, 0], 4*self.ulen*2*3*4)
@@ -95,6 +125,21 @@
     """Check the creation of unicode arrays with values"""
 
     def content_check(self, ua, ua_scalar, nbytes):
+        """
+
+        Parameters
+        ----------
+        ua :
+            
+        ua_scalar :
+            
+        nbytes :
+            
+
+        Returns
+        -------
+
+        """
 
         # Check the length of the unicode base type
         assert_(int(ua.dtype.str[2:]) == self.ulen)
@@ -116,17 +161,20 @@
             assert_(buffer_length(ua_scalar) == 2*self.ulen)
 
     def test_values0D(self):
+        """ """
         # Check creation of 0-dimensional objects with values
         ua = np.array(self.ucs_value*self.ulen, dtype='U%s' % self.ulen)
         self.content_check(ua, ua[()], 4*self.ulen)
 
     def test_valuesSD(self):
+        """ """
         # Check creation of single-dimensional objects with values
         ua = np.array([self.ucs_value*self.ulen]*2, dtype='U%s' % self.ulen)
         self.content_check(ua, ua[0], 4*self.ulen*2)
         self.content_check(ua, ua[1], 4*self.ulen*2)
 
     def test_valuesMD(self):
+        """ """
         # Check creation of multi-dimensional objects with values
         ua = np.array([[[self.ucs_value*self.ulen]*2]*3]*4, dtype='U%s' % self.ulen)
         self.content_check(ua, ua[0, 0, 0], 4*self.ulen*2*3*4)
@@ -177,6 +225,21 @@
     """Check the assignment of unicode arrays with values"""
 
     def content_check(self, ua, ua_scalar, nbytes):
+        """
+
+        Parameters
+        ----------
+        ua :
+            
+        ua_scalar :
+            
+        nbytes :
+            
+
+        Returns
+        -------
+
+        """
 
         # Check the length of the unicode base type
         assert_(int(ua.dtype.str[2:]) == self.ulen)
@@ -198,12 +261,14 @@
             assert_(buffer_length(ua_scalar) == 2*self.ulen)
 
     def test_values0D(self):
+        """ """
         # Check assignment of 0-dimensional objects with values
         ua = np.zeros((), dtype='U%s' % self.ulen)
         ua[()] = self.ucs_value*self.ulen
         self.content_check(ua, ua[()], 4*self.ulen)
 
     def test_valuesSD(self):
+        """ """
         # Check assignment of single-dimensional objects with values
         ua = np.zeros((2,), dtype='U%s' % self.ulen)
         ua[0] = self.ucs_value*self.ulen
@@ -212,6 +277,7 @@
         self.content_check(ua, ua[1], 4*self.ulen*2)
 
     def test_valuesMD(self):
+        """ """
         # Check assignment of multi-dimensional objects with values
         ua = np.zeros((2, 3, 4), dtype='U%s' % self.ulen)
         ua[0, 0, 0] = self.ucs_value*self.ulen
@@ -264,6 +330,7 @@
     """Check the byteorder of unicode arrays in round-trip conversions"""
 
     def test_values0D(self):
+        """ """
         # Check byteorder of 0-dimensional objects
         ua = np.array(self.ucs_value*self.ulen, dtype='U%s' % self.ulen)
         ua2 = ua.newbyteorder()
@@ -276,6 +343,7 @@
         assert_equal(ua, ua3)
 
     def test_valuesSD(self):
+        """ """
         # Check byteorder of single-dimensional objects
         ua = np.array([self.ucs_value*self.ulen]*2, dtype='U%s' % self.ulen)
         ua2 = ua.newbyteorder()
@@ -286,6 +354,7 @@
         assert_equal(ua, ua3)
 
     def test_valuesMD(self):
+        """ """
         # Check byteorder of multi-dimensional objects
         ua = np.array([[[self.ucs_value*self.ulen]*2]*3]*4,
                       dtype='U%s' % self.ulen)
@@ -297,6 +366,7 @@
         assert_equal(ua, ua3)
 
     def test_values_cast(self):
+        """ """
         # Check byteorder of when casting the array for a strided and
         # contiguous array:
         test1 = np.array([self.ucs_value*self.ulen]*2, dtype='U%s' % self.ulen)
@@ -310,6 +380,7 @@
             assert_equal(ua, ua3)
 
     def test_values_updowncast(self):
+        """ """
         # Check byteorder of when casting the array to a longer and shorter
         # string length for strided and contiguous arrays
         test1 = np.array([self.ucs_value*self.ulen]*2, dtype='U%s' % self.ulen)
