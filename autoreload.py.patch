# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/extensions/autoreload.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/extensions/autoreload.py
@@ -125,6 +125,7 @@
 #------------------------------------------------------------------------------
 
 class ModuleReloader(object):
+    """ """
     enabled = False
     """Whether this reloader is enabled"""
 
@@ -147,7 +148,17 @@
         self.check(check_all=True, do_reload=False)
 
     def mark_module_skipped(self, module_name):
-        """Skip reloading the named module in the future"""
+        """Skip reloading the named module in the future
+
+        Parameters
+        ----------
+        module_name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             del self.modules[module_name]
         except KeyError:
@@ -155,7 +166,17 @@
         self.skip_modules[module_name] = True
 
     def mark_module_reloadable(self, module_name):
-        """Reload the named module in the future (if it is imported)"""
+        """Reload the named module in the future (if it is imported)
+
+        Parameters
+        ----------
+        module_name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             del self.skip_modules[module_name]
         except KeyError:
@@ -165,13 +186,15 @@
     def aimport_module(self, module_name):
         """Import a module, and mark it reloadable
 
+        Parameters
+        ----------
+        module_name :
+            
+
         Returns
         -------
-        top_module : module
-            The imported module if it is top-level, or the top-level
-        top_name : module
-            Name of top_module
-
+
+        
         """
         self.mark_module_reloadable(module_name)
 
@@ -181,6 +204,17 @@
         return top_module, top_name
 
     def filename_and_mtime(self, module):
+        """
+
+        Parameters
+        ----------
+        module :
+            
+
+        Returns
+        -------
+
+        """
         if not hasattr(module, '__file__') or module.__file__ is None:
             return None, None
 
@@ -207,7 +241,19 @@
         return py_filename, pymtime
 
     def check(self, check_all=False, do_reload=True):
-        """Check whether some modules need to be reloaded."""
+        """Check whether some modules need to be reloaded.
+
+        Parameters
+        ----------
+        check_all :
+             (Default value = False)
+        do_reload :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
 
         if not self.enabled and not check_all:
             return
@@ -260,7 +306,19 @@
 
 
 def update_function(old, new):
-    """Upgrade the code object of a function"""
+    """Upgrade the code object of a function
+
+    Parameters
+    ----------
+    old :
+        
+    new :
+        
+
+    Returns
+    -------
+
+    """
     for name in func_attrs:
         try:
             setattr(old, name, getattr(new, name))
@@ -271,7 +329,19 @@
 def update_instances(old, new):
     """Use garbage collector to find all instances that refer to the old
     class definition and update their __class__ to point to the new class
-    definition"""
+    definition
+
+    Parameters
+    ----------
+    old :
+        
+    new :
+        
+
+    Returns
+    -------
+
+    """
     
     refs = gc.get_referrers(old)
 
@@ -282,7 +352,19 @@
 
 def update_class(old, new):
     """Replace stuff in the __dict__ of a class, and upgrade
-    method code objects, and add new methods, if any"""
+    method code objects, and add new methods, if any
+
+    Parameters
+    ----------
+    old :
+        
+    new :
+        
+
+    Returns
+    -------
+
+    """
     for key in list(old.__dict__.keys()):
         old_obj = getattr(old, key)
         try:
@@ -318,13 +400,40 @@
 
 
 def update_property(old, new):
-    """Replace get/set/del functions of a property"""
+    """Replace get/set/del functions of a property
+
+    Parameters
+    ----------
+    old :
+        
+    new :
+        
+
+    Returns
+    -------
+
+    """
     update_generic(old.fdel, new.fdel)
     update_generic(old.fget, new.fget)
     update_generic(old.fset, new.fset)
 
 
 def isinstance2(a, b, typ):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+    typ :
+        
+
+    Returns
+    -------
+
+    """
     return isinstance(a, typ) and isinstance(b, typ)
 
 
@@ -342,6 +451,19 @@
 
 
 def update_generic(a, b):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     for type_check, update in UPDATE_RULES:
         if type_check(a, b):
             update(a, b)
@@ -350,6 +472,7 @@
 
 
 class StrongRef(object):
+    """ """
     def __init__(self, obj):
         self.obj = obj
     def __call__(self):
@@ -358,12 +481,24 @@
 
 def superreload(module, reload=reload, old_objects=None):
     """Enhanced version of the builtin reload function.
-
+    
     superreload remembers objects previously in the module, and
-
+    
     - upgrades the class dictionary of every old class in the module
     - upgrades the code object of every old function and method
     - clears the module's namespace before reloading
+
+    Parameters
+    ----------
+    module :
+        
+    reload :
+         (Default value = reload)
+    old_objects :
+         (Default value = None)
+
+    Returns
+    -------
 
     """
     if old_objects is None:
@@ -424,6 +559,7 @@
 
 @magics_class
 class AutoreloadMagics(Magics):
+    """ """
     def __init__(self, *a, **kw):
         super(AutoreloadMagics, self).__init__(*a, **kw)
         self._reloader = ModuleReloader()
@@ -432,49 +568,55 @@
 
     @line_magic
     def autoreload(self, parameter_s=''):
-        r"""%autoreload => Reload modules automatically
-
+        """r"""%autoreload => Reload modules automatically
+        
         %autoreload
         Reload all modules (except those excluded by %aimport) automatically
         now.
-
+        
         %autoreload 0
         Disable automatic reloading.
-
+        
         %autoreload 1
         Reload all modules imported with %aimport every time before executing
         the Python code typed.
-
+        
         %autoreload 2
         Reload all modules (except those excluded by %aimport) every time
         before executing the Python code typed.
-
+        
         Reloading Python modules in a reliable way is in general
         difficult, and unexpected things may occur. %autoreload tries to
         work around common pitfalls by replacing function code objects and
         parts of classes previously in the module with new versions. This
         makes the following things to work:
-
+        
         - Functions and classes imported via 'from xxx import foo' are upgraded
           to new versions when 'xxx' is reloaded.
-
+        
         - Methods and properties of classes are upgraded on reload, so that
           calling 'c.foo()' on an object 'c' created before the reload causes
           the new code for 'foo' to be executed.
-
+        
         Some of the known remaining caveats are:
-
+        
         - Replacing code objects does not always succeed: changing a @property
           in a class to an ordinary method or a method to a member variable
           can cause problems (but in old objects only).
-
+        
         - Functions that are removed (eg. via monkey-patching) from a module
           before it is reloaded are not upgraded.
-
+        
         - C extension modules cannot be reloaded, and so cannot be
           autoreloaded.
 
-        """
+        Parameters
+        ----------
+        parameter_s :
+             (Default value = '')
+
+        Returns
+        -------
         if parameter_s == '':
             self._reloader.check(True)
         elif parameter_s == '0':
@@ -489,18 +631,29 @@
     @line_magic
     def aimport(self, parameter_s='', stream=None):
         """%aimport => Import modules for automatic reloading.
-
+        
         %aimport
         List modules to automatically import and not to import.
-
+        
         %aimport foo
         Import module 'foo' and mark it to be autoreloaded for %autoreload 1
-
+        
         %aimport foo, bar
         Import modules 'foo', 'bar' and mark them to be autoreloaded for %autoreload 1
-
+        
         %aimport -foo
         Mark module 'foo' to not be autoreloaded for %autoreload 1
+
+        Parameters
+        ----------
+        parameter_s :
+             (Default value = '')
+        stream :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         modname = parameter_s
         if not modname:
@@ -524,6 +677,7 @@
                 self.shell.push({top_name: top_module})
 
     def pre_run_cell(self):
+        """ """
         if self._reloader.enabled:
             try:
                 self._reloader.check()
@@ -531,8 +685,7 @@
                 pass
 
     def post_execute_hook(self):
-        """Cache the modification times of any modules imported in this execution
-        """
+        """Cache the modification times of any modules imported in this execution"""
         newly_loaded_modules = set(sys.modules) - self.loaded_modules
         for modname in newly_loaded_modules:
             _, pymtime = self._reloader.filename_and_mtime(sys.modules[modname])
@@ -543,7 +696,17 @@
 
 
 def load_ipython_extension(ip):
-    """Load the extension in IPython."""
+    """Load the extension in IPython.
+
+    Parameters
+    ----------
+    ip :
+        
+
+    Returns
+    -------
+
+    """
     auto_reload = AutoreloadMagics(ip)
     ip.register_magics(auto_reload)
     ip.events.register('pre_run_cell', auto_reload.pre_run_cell)
