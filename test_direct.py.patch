# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/random/tests/test_direct.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/random/tests/test_direct.py
@@ -37,6 +37,19 @@
 
 
 def assert_state_equal(actual, target):
+    """
+
+    Parameters
+    ----------
+    actual :
+        
+    target :
+        
+
+    Returns
+    -------
+
+    """
     for key in actual:
         if isinstance(actual[key], dict):
             assert_state_equal(actual[key], target[key])
@@ -47,6 +60,17 @@
 
 
 def uniform32_from_uint64(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     x = np.uint64(x)
     upper = np.array(x >> np.uint64(32), dtype=np.uint32)
     lower = np.uint64(0xffffffff)
@@ -57,6 +81,17 @@
 
 
 def uniform32_from_uint53(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     x = np.uint64(x) >> np.uint64(16)
     x = np.uint32(x & np.uint64(0xffffffff))
     out = (x >> np.uint32(9)) * (1.0 / 2 ** 23)
@@ -64,10 +99,34 @@
 
 
 def uniform32_from_uint32(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return (x >> np.uint32(9)) * (1.0 / 2 ** 23)
 
 
 def uniform32_from_uint(x, bits):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    bits :
+        
+
+    Returns
+    -------
+
+    """
     if bits == 64:
         return uniform32_from_uint64(x)
     elif bits == 53:
@@ -79,6 +138,19 @@
 
 
 def uniform_from_uint(x, bits):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    bits :
+        
+
+    Returns
+    -------
+
+    """
     if bits in (64, 63, 53):
         return uniform_from_uint64(x)
     elif bits == 32:
@@ -86,10 +158,32 @@
 
 
 def uniform_from_uint64(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return (x >> np.uint64(11)) * (1.0 / 9007199254740992.0)
 
 
 def uniform_from_uint32(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     out = np.empty(len(x) // 2)
     for i in range(0, len(x), 2):
         a = x[i] >> 5
@@ -99,10 +193,36 @@
 
 
 def uniform_from_dsfmt(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return x.view(np.double) - 1.0
 
 
 def gauss_from_uint(x, n, bits):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    n :
+        
+    bits :
+        
+
+    Returns
+    -------
+
+    """
     if bits in (64, 63):
         doubles = uniform_from_uint64(x)
     elif bits == 32:
@@ -127,6 +247,7 @@
     return gauss[:n]
 
 def test_seedsequence():
+    """ """
     from numpy.random.bit_generator import (ISeedSequence,
                                             ISpawnableSeedSequence,
                                             SeedlessSeedSequence)
@@ -146,11 +267,13 @@
 
 
 class Base:
+    """ """
     dtype = np.uint64
     data2 = data1 = {}
 
     @classmethod
     def setup_class(cls):
+        """ """
         cls.bit_generator = PCG64
         cls.bits = 64
         cls.dtype = np.uint64
@@ -160,6 +283,17 @@
 
     @classmethod
     def _read_csv(cls, filename):
+        """
+
+        Parameters
+        ----------
+        filename :
+            
+
+        Returns
+        -------
+
+        """
         with open(filename) as csv:
             seed = csv.readline()
             seed = seed.split(',')
@@ -170,6 +304,7 @@
             return {'seed': seed, 'data': np.array(data, dtype=cls.dtype)}
 
     def test_raw(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         uints = bit_generator.random_raw(1000)
         assert_equal(uints, self.data1['data'])
@@ -183,6 +318,7 @@
         assert_equal(uints, self.data2['data'])
 
     def test_random_raw(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         uints = bit_generator.random_raw(output=False)
         assert uints is None
@@ -190,6 +326,7 @@
         assert uints is None
 
     def test_gauss_inv(self):
+        """ """
         n = 25
         rs = RandomState(self.bit_generator(*self.data1['seed']))
         gauss = rs.standard_normal(n)
@@ -202,6 +339,7 @@
                         gauss_from_uint(self.data2['data'], n, self.bits))
 
     def test_uniform_double(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         vals = uniform_from_uint(self.data1['data'], self.bits)
         uniforms = rs.random(len(vals))
@@ -215,6 +353,7 @@
         assert_equal(uniforms.dtype, np.float64)
 
     def test_uniform_float(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         vals = uniform32_from_uint(self.data1['data'], self.bits)
         uniforms = rs.random(len(vals), dtype=np.float32)
@@ -228,17 +367,20 @@
         assert_equal(uniforms.dtype, np.float32)
 
     def test_repr(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         assert 'Generator' in repr(rs)
         assert '{:#x}'.format(id(rs)).upper().replace('X', 'x') in repr(rs)
 
     def test_str(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         assert 'Generator' in str(rs)
         assert str(self.bit_generator.__name__) in str(rs)
         assert '{:#x}'.format(id(rs)).upper().replace('X', 'x') not in str(rs)
 
     def test_pickle(self):
+        """ """
         import pickle
 
         bit_generator = self.bit_generator(*self.data1['seed'])
@@ -256,11 +398,13 @@
         assert_equal(ss.state, aa.state)
 
     def test_invalid_state_type(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         with pytest.raises(TypeError):
             bit_generator.state = {'1'}
 
     def test_invalid_state_value(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         state = bit_generator.state
         state['bit_generator'] = 'otherBitGenerator'
@@ -268,18 +412,21 @@
             bit_generator.state = state
 
     def test_invalid_init_type(self):
+        """ """
         bit_generator = self.bit_generator
         for st in self.invalid_init_types:
             with pytest.raises(TypeError):
                 bit_generator(*st)
 
     def test_invalid_init_values(self):
+        """ """
         bit_generator = self.bit_generator
         for st in self.invalid_init_values:
             with pytest.raises((ValueError, OverflowError)):
                 bit_generator(*st)
 
     def test_benchmark(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         bit_generator._benchmark(1)
         bit_generator._benchmark(1, 'double')
@@ -288,6 +435,7 @@
 
     @pytest.mark.skipif(MISSING_CFFI, reason='cffi not available')
     def test_cffi(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         cffi_interface = bit_generator.cffi
         assert isinstance(cffi_interface, interface)
@@ -296,6 +444,7 @@
 
     @pytest.mark.skipif(MISSING_CTYPES, reason='ctypes not available')
     def test_ctypes(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         ctypes_interface = bit_generator.ctypes
         assert isinstance(ctypes_interface, interface)
@@ -303,6 +452,7 @@
         assert other_ctypes_interface is ctypes_interface
 
     def test_getstate(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         state = bit_generator.state
         alt_state = bit_generator.__getstate__()
@@ -310,8 +460,10 @@
 
 
 class TestPhilox(Base):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.bit_generator = Philox
         cls.bits = 64
         cls.dtype = np.uint64
@@ -324,6 +476,7 @@
         cls.invalid_init_values = [(1, None, 1), (-1,), (None, None, 2 ** 257 + 1)]
 
     def test_set_key(self):
+        """ """
         bit_generator = self.bit_generator(*self.data1['seed'])
         state = bit_generator.state
         keyed = self.bit_generator(counter=state['state']['counter'],
@@ -332,8 +485,10 @@
 
 
 class TestPCG64(Base):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.bit_generator = PCG64
         cls.bits = 64
         cls.dtype = np.uint64
@@ -344,6 +499,7 @@
         cls.invalid_init_values = [(-1,)]
 
     def test_advance_symmetry(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         state = rs.bit_generator.state
         step = -0x9e3779b97f4a7c150000000000000000
@@ -360,8 +516,10 @@
 
 
 class TestMT19937(Base):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.bit_generator = MT19937
         cls.bits = 32
         cls.dtype = np.uint32
@@ -372,6 +530,7 @@
         cls.invalid_init_values = [(-1,)]
 
     def test_seed_float_array(self):
+        """ """
         assert_raises(TypeError, self.bit_generator, np.array([np.pi]))
         assert_raises(TypeError, self.bit_generator, np.array([-np.pi]))
         assert_raises(TypeError, self.bit_generator, np.array([np.pi, -np.pi]))
@@ -380,6 +539,7 @@
         assert_raises(TypeError, self.bit_generator, [0, np.pi])
 
     def test_state_tuple(self):
+        """ """
         rs = Generator(self.bit_generator(*self.data1['seed']))
         bit_generator = rs.bit_generator
         state = bit_generator.state
@@ -396,8 +556,10 @@
 
 
 class TestSFC64(Base):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.bit_generator = SFC64
         cls.bits = 64
         cls.dtype = np.uint64
@@ -411,12 +573,15 @@
 
 
 class TestDefaultRNG:
+    """ """
     def test_seed(self):
+        """ """
         for args in [(), (None,), (1234,), ([1234, 5678],)]:
             rg = default_rng(*args)
             assert isinstance(rg.bit_generator, PCG64)
 
     def test_passthrough(self):
+        """ """
         bg = Philox()
         rg = default_rng(bg)
         assert rg.bit_generator is bg
