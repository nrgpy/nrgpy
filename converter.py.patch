# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/plotting/_matplotlib/converter.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/plotting/_matplotlib/converter.py
@@ -43,6 +43,7 @@
 
 
 def get_pairs():
+    """ """
     pairs = [
         (Timestamp, DatetimeConverter),
         (Period, PeriodConverter),
@@ -55,12 +56,33 @@
 
 
 def register_pandas_matplotlib_converters(func):
-    """
-    Decorator applying pandas_converters.
+    """Decorator applying pandas_converters.
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
     """
 
     @functools.wraps(func)
     def wrapper(*args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         with pandas_converters():
             return func(*args, **kwargs)
 
@@ -69,13 +91,7 @@
 
 @contextlib.contextmanager
 def pandas_converters():
-    """
-    Context manager registering pandas' converters for a plot.
-
-    See Also
-    --------
-    register_pandas_matplotlib_converters : Decorator that applies this.
-    """
+    """Context manager registering pandas' converters for a plot."""
     value = get_option("plotting.matplotlib.register_converters")
 
     if value:
@@ -90,6 +106,7 @@
 
 
 def register():
+    """ """
     pairs = get_pairs()
     for type_, cls in pairs:
         # Cache previous converter if present
@@ -101,6 +118,7 @@
 
 
 def deregister():
+    """ """
     # Renamed in pandas.plotting.__init__
     for type_, cls in get_pairs():
         # We use type to catch our classes directly, no inheritance
@@ -115,11 +133,33 @@
 
 
 def _to_ordinalf(tm: pydt.time) -> float:
+    """
+
+    Parameters
+    ----------
+    tm: pydt.time :
+        
+
+    Returns
+    -------
+
+    """
     tot_sec = tm.hour * 3600 + tm.minute * 60 + tm.second + float(tm.microsecond / 1e6)
     return tot_sec
 
 
 def time2num(d):
+    """
+
+    Parameters
+    ----------
+    d :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(d, str):
         parsed = tools.to_datetime(d)
         if not isinstance(parsed, datetime):
@@ -131,8 +171,24 @@
 
 
 class TimeConverter(units.ConversionInterface):
+    """ """
     @staticmethod
     def convert(value, unit, axis):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        unit :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         valid_types = (str, pydt.time)
         if isinstance(value, valid_types) or is_integer(value) or is_float(value):
             return time2num(value)
@@ -144,6 +200,19 @@
 
     @staticmethod
     def axisinfo(unit, axis):
+        """
+
+        Parameters
+        ----------
+        unit :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         if unit != "time":
             return None
 
@@ -153,11 +222,25 @@
 
     @staticmethod
     def default_units(x, axis):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         return "time"
 
 
 # time formatter
 class TimeFormatter(Formatter):
+    """ """
     def __init__(self, locs):
         self.locs = locs
 
@@ -201,8 +284,24 @@
 
 
 class PeriodConverter(dates.DateConverter):
+    """ """
     @staticmethod
     def convert(values, units, axis):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        units :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         if is_nested_list_like(values):
             values = [PeriodConverter._convert_1d(v, units, axis) for v in values]
         else:
@@ -211,6 +310,21 @@
 
     @staticmethod
     def _convert_1d(values, units, axis):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        units :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         if not hasattr(axis, "freq"):
             raise TypeError("Axis must have `freq` set to convert to Periods")
         valid_types = (str, datetime, Period, pydt.date, pydt.time, np.datetime64)
@@ -230,6 +344,19 @@
 
 
 def get_datevalue(date, freq):
+    """
+
+    Parameters
+    ----------
+    date :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(date, Period):
         return date.asfreq(freq).ordinal
     elif isinstance(date, (str, datetime, pydt.date, pydt.time, np.datetime64)):
@@ -247,8 +374,24 @@
 
 # Datetime Conversion
 class DatetimeConverter(dates.DateConverter):
+    """ """
     @staticmethod
     def convert(values, unit, axis):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        unit :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         # values might be a 1-d array, or a list-like of arrays.
         if is_nested_list_like(values):
             values = [DatetimeConverter._convert_1d(v, unit, axis) for v in values]
@@ -258,7 +401,33 @@
 
     @staticmethod
     def _convert_1d(values, unit, axis):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        unit :
+            
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         def try_parse(values):
+            """
+
+            Parameters
+            ----------
+            values :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 return dates.date2num(tools.to_datetime(values))
             except Exception:
@@ -295,10 +464,20 @@
     @staticmethod
     def axisinfo(unit, axis):
         """
-        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.
-
-        *unit* is a tzinfo instance or None.
-        The *axis* argument is required but not used.
+
+        Parameters
+        ----------
+        unit :
+            
+        axis :
+            
+
+        Returns
+        -------
+        type
+            *unit* is a tzinfo instance or None.
+            The *axis* argument is required but not used.
+
         """
         tz = unit
 
@@ -313,13 +492,27 @@
 
 
 class PandasAutoDateFormatter(dates.AutoDateFormatter):
+    """ """
     def __init__(self, locator, tz=None, defaultfmt="%Y-%m-%d"):
         dates.AutoDateFormatter.__init__(self, locator, tz, defaultfmt)
 
 
 class PandasAutoDateLocator(dates.AutoDateLocator):
+    """ """
     def get_locator(self, dmin, dmax):
-        """Pick the best locator based on a distance."""
+        """Pick the best locator based on a distance.
+
+        Parameters
+        ----------
+        dmin :
+            
+        dmax :
+            
+
+        Returns
+        -------
+
+        """
         delta = relativedelta(dmax, dmin)
 
         num_days = (delta.years * 12.0 + delta.months) * 31.0 + delta.days
@@ -338,10 +531,12 @@
         return dates.AutoDateLocator.get_locator(self, dmin, dmax)
 
     def _get_unit(self):
+        """ """
         return MilliSecondLocator.get_unit_generic(self._freq)
 
 
 class MilliSecondLocator(dates.DateLocator):
+    """ """
 
     UNIT = 1.0 / (24 * 3600 * 1000)
 
@@ -350,10 +545,22 @@
         self._interval = 1.0
 
     def _get_unit(self):
+        """ """
         return self.get_unit_generic(-1)
 
     @staticmethod
     def get_unit_generic(freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         unit = dates.RRuleLocator.get_unit_generic(freq)
         if unit < 0:
             return MilliSecondLocator.UNIT
@@ -406,12 +613,11 @@
         return lims
 
     def _get_interval(self):
+        """ """
         return self._interval
 
     def autoscale(self):
-        """
-        Set the view limits to include the data range.
-        """
+        """Set the view limits to include the data range."""
         # We need to cap at the endpoints of valid datetime
         dmin, dmax = self.datalim_to_dt()
 
@@ -422,6 +628,19 @@
 
 
 def _from_ordinal(x, tz=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    tz :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     ix = int(x)
     dt = datetime.fromordinal(ix)
     remainder = float(x) - ix
@@ -451,8 +670,16 @@
 
 
 def _get_default_annual_spacing(nyears):
-    """
-    Returns a default spacing between consecutive ticks for annual data.
+    """Returns a default spacing between consecutive ticks for annual data.
+
+    Parameters
+    ----------
+    nyears :
+        
+
+    Returns
+    -------
+
     """
     if nyears < 11:
         (min_spacing, maj_spacing) = (1, 1)
@@ -473,15 +700,19 @@
 
 
 def period_break(dates, period):
-    """
-    Returns the indices where the given period changes.
+    """Returns the indices where the given period changes.
 
     Parameters
     ----------
-    dates : PeriodIndex
-        Array of intervals to monitor.
-    period : string
-        Name of the period to monitor.
+    dates :
+        
+    period :
+        
+
+    Returns
+    -------
+
+    
     """
     current = getattr(dates, period)
     previous = getattr(dates - 1 * dates.freq, period)
@@ -489,12 +720,22 @@
 
 
 def has_level_label(label_flags, vmin):
-    """
-    Returns true if the ``label_flags`` indicate there is at least one label
+    """Returns true if the ``label_flags`` indicate there is at least one label
     for this level.
-
+    
     if the minimum view limit is not an exact integer, then the first tick
     label won't be shown, so we must adjust for that.
+
+    Parameters
+    ----------
+    label_flags :
+        
+    vmin :
+        
+
+    Returns
+    -------
+
     """
     if label_flags.size == 0 or (
         label_flags.size == 1 and label_flags[0] == 0 and vmin % 1 > 0.0
@@ -505,6 +746,21 @@
 
 
 def _daily_finder(vmin, vmax, freq: BaseOffset):
+    """
+
+    Parameters
+    ----------
+    vmin :
+        
+    vmax :
+        
+    freq: BaseOffset :
+        
+
+    Returns
+    -------
+
+    """
     dtype_code = freq._period_dtype_code
 
     periodsperday = -1
@@ -561,6 +817,17 @@
     info_fmt = info["fmt"]
 
     def first_label(label_flags):
+        """
+
+        Parameters
+        ----------
+        label_flags :
+            
+
+        Returns
+        -------
+
+        """
         if (label_flags[0] == 0) and (label_flags.size > 1) and ((vmin_orig % 1) > 0.0):
             return label_flags[1]
         else:
@@ -572,6 +839,19 @@
         month_start = period_break(dates_, "month")
 
         def _hour_finder(label_interval, force_year_start):
+            """
+
+            Parameters
+            ----------
+            label_interval :
+                
+            force_year_start :
+                
+
+            Returns
+            -------
+
+            """
             _hour = dates_.hour
             _prev_hour = (dates_ - 1 * dates_.freq).hour
             hour_start = (_hour - _prev_hour) != 0
@@ -585,6 +865,17 @@
                 info_fmt[first_label(day_start)] = "%H:%M\n%d-%b\n%Y"
 
         def _minute_finder(label_interval):
+            """
+
+            Parameters
+            ----------
+            label_interval :
+                
+
+            Returns
+            -------
+
+            """
             hour_start = period_break(dates_, "hour")
             _minute = dates_.minute
             _prev_minute = (dates_ - 1 * dates_.freq).minute
@@ -598,6 +889,17 @@
             info_fmt[year_start] = "%H:%M\n%d-%b\n%Y"
 
         def _second_finder(label_interval):
+            """
+
+            Parameters
+            ----------
+            label_interval :
+                
+
+            Returns
+            -------
+
+            """
             minute_start = period_break(dates_, "minute")
             _second = dates_.second
             _prev_second = (dates_ - 1 * dates_.freq).second
@@ -733,6 +1035,21 @@
 
 
 def _monthly_finder(vmin, vmax, freq):
+    """
+
+    Parameters
+    ----------
+    vmin :
+        
+    vmax :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     periodsperyear = 12
 
     vmin_orig = vmin
@@ -803,6 +1120,21 @@
 
 
 def _quarterly_finder(vmin, vmax, freq):
+    """
+
+    Parameters
+    ----------
+    vmin :
+        
+    vmax :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     periodsperyear = 4
     vmin_orig = vmin
     (vmin, vmax) = (int(vmin), int(vmax))
@@ -849,6 +1181,21 @@
 
 
 def _annual_finder(vmin, vmax, freq):
+    """
+
+    Parameters
+    ----------
+    vmin :
+        
+    vmax :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     (vmin, vmax) = (int(vmin), int(vmax + 1))
     span = vmax - vmin + 1
 
@@ -869,6 +1216,17 @@
 
 
 def get_finder(freq: BaseOffset):
+    """
+
+    Parameters
+    ----------
+    freq: BaseOffset :
+        
+
+    Returns
+    -------
+
+    """
     dtype_code = freq._period_dtype_code
     fgroup = (dtype_code // 1000) * 1000
 
@@ -885,22 +1243,7 @@
 
 
 class TimeSeries_DateLocator(Locator):
-    """
-    Locates the ticks along an axis controlled by a :class:`Series`.
-
-    Parameters
-    ----------
-    freq : {var}
-        Valid frequency specifier.
-    minor_locator : {False, True}, optional
-        Whether the locator is for minor ticks (True) or not.
-    dynamic_mode : {True, False}, optional
-        Whether the locator should work in dynamic mode.
-    base : {int}, optional
-    quarter : {int}, optional
-    month : {int}, optional
-    day : {int}, optional
-    """
+    """Locates the ticks along an axis controlled by a :class:`Series`."""
 
     def __init__(
         self,
@@ -924,7 +1267,19 @@
         self.finder = get_finder(freq)
 
     def _get_default_locs(self, vmin, vmax):
-        """Returns the default locations of ticks."""
+        """Returns the default locations of ticks.
+
+        Parameters
+        ----------
+        vmin :
+            
+        vmax :
+            
+
+        Returns
+        -------
+
+        """
         if self.plot_obj.date_axis_info is None:
             self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
 
@@ -955,9 +1310,15 @@
         return locs
 
     def autoscale(self):
-        """
-        Sets the view limits to the nearest multiples of base that contain the
+        """Sets the view limits to the nearest multiples of base that contain the
         data.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # requires matplotlib >= 0.98.0
         (vmin, vmax) = self.axis.get_data_interval()
@@ -976,19 +1337,7 @@
 
 
 class TimeSeries_DateFormatter(Formatter):
-    """
-    Formats the ticks along an axis controlled by a :class:`PeriodIndex`.
-
-    Parameters
-    ----------
-    freq : {int, string}
-        Valid frequency specifier.
-    minor_locator : {False, True}
-        Whether the current formatter should apply to minor ticks (True) or
-        major ticks (False).
-    dynamic_mode : {True, False}
-        Whether the formatter works in dynamic mode or not.
-    """
+    """Formats the ticks along an axis controlled by a :class:`PeriodIndex`."""
 
     def __init__(self, freq, minor_locator=False, dynamic_mode=True, plot_obj=None):
         freq = to_offset(freq)
@@ -1003,7 +1352,19 @@
         self.finder = get_finder(freq)
 
     def _set_default_format(self, vmin, vmax):
-        """Returns the default ticks spacing."""
+        """Returns the default ticks spacing.
+
+        Parameters
+        ----------
+        vmin :
+            
+        vmax :
+            
+
+        Returns
+        -------
+
+        """
         if self.plot_obj.date_axis_info is None:
             self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
         info = self.plot_obj.date_axis_info
@@ -1016,7 +1377,17 @@
         return self.formatdict
 
     def set_locs(self, locs):
-        """Sets the locations of the ticks"""
+        """Sets the locations of the ticks
+
+        Parameters
+        ----------
+        locs :
+            
+
+        Returns
+        -------
+
+        """
         # don't actually use the locs. This is just needed to work with
         # matplotlib. Force to use vmin, vmax
 
@@ -1042,14 +1413,24 @@
 
 
 class TimeSeries_TimedeltaFormatter(Formatter):
-    """
-    Formats the ticks along an axis controlled by a :class:`TimedeltaIndex`.
-    """
+    """Formats the ticks along an axis controlled by a :class:`TimedeltaIndex`."""
 
     @staticmethod
     def format_timedelta_ticks(x, pos, n_decimals: int) -> str:
-        """
-        Convert seconds to 'D days HH:MM:SS.F'
+        """Convert seconds to 'D days HH:MM:SS.F'
+
+        Parameters
+        ----------
+        x :
+            
+        pos :
+            
+        n_decimals: int :
+            
+
+        Returns
+        -------
+
         """
         s, ns = divmod(x, 1e9)
         m, s = divmod(s, 60)
