# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_numpy.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_numpy.py
@@ -12,25 +12,44 @@
 
 @pytest.fixture(params=["float", "object"])
 def dtype(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return PandasDtype(np.dtype(request.param))
 
 
 @pytest.fixture
 def allow_in_pandas(monkeypatch):
-    """
-    A monkeypatch to tells pandas to let us in.
-
+    """A monkeypatch to tells pandas to let us in.
+    
     By default, passing a PandasArray to an index / series / frame
     constructor will unbox that PandasArray to an ndarray, and treat
     it as a non-EA column. We don't want people using EAs without
     reason.
-
+    
     The mechanism for this is a check against ABCPandasArray
     in each constructor.
-
+    
     But, for testing, we need to allow them in pandas. So we patch
     the _typ of PandasArray, so that we evade the ABCPandasArray
     check.
+
+    Parameters
+    ----------
+    monkeypatch :
+        
+
+    Returns
+    -------
+
     """
     with monkeypatch.context() as m:
         m.setattr(PandasArray, "_typ", "extension")
@@ -39,6 +58,19 @@
 
 @pytest.fixture
 def data(allow_in_pandas, dtype):
+    """
+
+    Parameters
+    ----------
+    allow_in_pandas :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     if dtype.numpy_dtype == "object":
         return pd.Series([(i,) for i in range(100)]).array
     return PandasArray(np.arange(1, 101, dtype=dtype._dtype))
@@ -46,6 +78,19 @@
 
 @pytest.fixture
 def data_missing(allow_in_pandas, dtype):
+    """
+
+    Parameters
+    ----------
+    allow_in_pandas :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     # For NumPy <1.16, np.array([np.nan, (1,)]) raises
     # ValueError: setting an array element with a sequence.
     if dtype.numpy_dtype == "object":
@@ -57,12 +102,27 @@
 
 @pytest.fixture
 def na_value():
+    """ """
     return np.nan
 
 
 @pytest.fixture
 def na_cmp():
+    """ """
     def cmp(a, b):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
+        """
         return np.isnan(a) and np.isnan(b)
 
     return cmp
@@ -71,9 +131,20 @@
 @pytest.fixture
 def data_for_sorting(allow_in_pandas, dtype):
     """Length-3 array with a known sort order.
-
+    
     This should be three items [B, C, A] with
     A < B < C
+
+    Parameters
+    ----------
+    allow_in_pandas :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
     """
     if dtype.numpy_dtype == "object":
         # Use an empty tuple for first element, then remove,
@@ -85,9 +156,20 @@
 @pytest.fixture
 def data_missing_for_sorting(allow_in_pandas, dtype):
     """Length-3 array with a known sort order.
-
+    
     This should be three items [B, NA, A] with
     A < B and NA missing.
+
+    Parameters
+    ----------
+    allow_in_pandas :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
     """
     if dtype.numpy_dtype == "object":
         return PandasArray(np.array([(1,), np.nan, (0,)], dtype=object))
@@ -97,10 +179,21 @@
 @pytest.fixture
 def data_for_grouping(allow_in_pandas, dtype):
     """Data for factorization, grouping, and unique tests.
-
+    
     Expected to be like [B, B, NA, NA, A, A, B, C]
-
+    
     Where A < B < C and NA is missing
+
+    Parameters
+    ----------
+    allow_in_pandas :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
     """
     if dtype.numpy_dtype == "object":
         a, b, c = (1,), (2,), (3,)
@@ -113,14 +206,22 @@
 
 @pytest.fixture
 def skip_numpy_object(dtype):
-    """
-    Tests for PandasArray with nested data. Users typically won't create
+    """Tests for PandasArray with nested data. Users typically won't create
     these objects via `pd.array`, but they can show up through `.array`
     on a Series with nested data. Many of the base tests fail, as they aren't
     appropriate for nested data.
-
+    
     This fixture allows these tests to be skipped when used as a usefixtures
     marker to either an individual test or a test class.
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
     """
     if dtype == "object":
         raise pytest.skip("Skipping for object dtype.")
@@ -130,58 +231,166 @@
 
 
 class BaseNumPyTests:
+    """ """
     pass
 
 
 class TestCasting(BaseNumPyTests, base.BaseCastingTests):
+    """ """
     @skip_nested
     def test_astype_str(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: setting an array element with a sequence
         super().test_astype_str(data)
 
     @skip_nested
     def test_astype_string(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH-33465
         # ValueError: setting an array element with a sequence
         super().test_astype_string(data)
 
 
 class TestConstructors(BaseNumPyTests, base.BaseConstructorsTests):
+    """ """
     @pytest.mark.skip(reason="We don't register our dtype")
     # We don't want to register. This test should probably be split in two.
     def test_from_dtype(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @skip_nested
     def test_array_from_scalars(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: PandasArray must be 1-dimensional.
         super().test_array_from_scalars(data)
 
     @skip_nested
     def test_series_constructor_scalar_with_index(self, data, dtype):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: Length of passed values is 1, index implies 3.
         super().test_series_constructor_scalar_with_index(data, dtype)
 
 
 class TestDtype(BaseNumPyTests, base.BaseDtypeTests):
+    """ """
     @pytest.mark.skip(reason="Incorrect expected.")
     # we unsurprisingly clash with a NumPy name.
     def test_check_dtype(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
 
 class TestGetitem(BaseNumPyTests, base.BaseGetitemTests):
+    """ """
     @skip_nested
     def test_getitem_scalar(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_getitem_scalar(data)
 
     @skip_nested
     def test_take_series(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: PandasArray must be 1-dimensional.
         super().test_take_series(data)
 
     def test_loc_iloc_frame_single_dtype(self, data, request):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        request :
+            
+
+        Returns
+        -------
+
+        """
         npdtype = data.dtype.numpy_dtype
         if npdtype == object or npdtype == np.float64:
             # GH#33125
@@ -193,10 +402,26 @@
 
 
 class TestGroupby(BaseNumPyTests, base.BaseGroupbyTests):
+    """ """
     @skip_nested
     def test_groupby_extension_apply(
         self, data_for_grouping, groupby_apply_op, request
     ):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        groupby_apply_op :
+            
+        request :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: Names should be list-like for a MultiIndex
         a = "a"
         is_identity = groupby_apply_op(a) is a
@@ -209,34 +434,104 @@
 
 
 class TestInterface(BaseNumPyTests, base.BaseInterfaceTests):
+    """ """
     @skip_nested
     def test_array_interface(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # NumPy array shape inference
         super().test_array_interface(data)
 
 
 class TestMethods(BaseNumPyTests, base.BaseMethodsTests):
+    """ """
     @pytest.mark.skip(reason="TODO: remove?")
     def test_value_counts(self, all_data, dropna):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+        dropna :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @pytest.mark.xfail(reason="not working. will be covered by #32028")
     def test_value_counts_with_normalize(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         return super().test_value_counts_with_normalize(data)
 
     @pytest.mark.skip(reason="Incorrect expected")
     # We have a bool dtype, so the result is an ExtensionArray
     # but expected is not
     def test_combine_le(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         super().test_combine_le(data_repeated)
 
     @skip_nested
     def test_combine_add(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         # Not numeric
         super().test_combine_add(data_repeated)
 
     @skip_nested
     def test_shift_fill_value(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # np.array shape inference. Shift implementation fails.
         super().test_shift_fill_value(data)
 
@@ -244,84 +539,288 @@
     @pytest.mark.parametrize("box", [pd.Series, lambda x: x])
     @pytest.mark.parametrize("method", [lambda x: x.unique(), pd.unique])
     def test_unique(self, data, box, method):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box :
+            
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating expected
         super().test_unique(data, box, method)
 
     @skip_nested
     def test_fillna_copy_frame(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # The "scalar" for this array isn't a scalar.
         super().test_fillna_copy_frame(data_missing)
 
     @skip_nested
     def test_fillna_copy_series(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # The "scalar" for this array isn't a scalar.
         super().test_fillna_copy_series(data_missing)
 
     @skip_nested
     def test_hash_pandas_object_works(self, data, as_frame):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        as_frame :
+            
+
+        Returns
+        -------
+
+        """
         # ndarray of tuples not hashable
         super().test_hash_pandas_object_works(data, as_frame)
 
     @skip_nested
     def test_searchsorted(self, data_for_sorting, as_series):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        as_series :
+            
+
+        Returns
+        -------
+
+        """
         # Test setup fails.
         super().test_searchsorted(data_for_sorting, as_series)
 
     @skip_nested
     def test_where_series(self, data, na_value, as_frame):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_frame :
+            
+
+        Returns
+        -------
+
+        """
         # Test setup fails.
         super().test_where_series(data, na_value, as_frame)
 
     @skip_nested
     @pytest.mark.parametrize("repeats", [0, 1, 2, [1, 2, 3]])
     def test_repeat(self, data, repeats, as_series, use_numpy):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        repeats :
+            
+        as_series :
+            
+        use_numpy :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating expected
         super().test_repeat(data, repeats, as_series, use_numpy)
 
     @pytest.mark.xfail(reason="PandasArray.diff may fail on dtype")
     def test_diff(self, data, periods):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        periods :
+            
+
+        Returns
+        -------
+
+        """
         return super().test_diff(data, periods)
 
     @skip_nested
     @pytest.mark.parametrize("box", [pd.array, pd.Series, pd.DataFrame])
     def test_equals(self, data, na_value, as_series, box):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_series :
+            
+        box :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating with _from_sequence
         super().test_equals(data, na_value, as_series, box)
 
 
 @skip_nested
 class TestArithmetics(BaseNumPyTests, base.BaseArithmeticOpsTests):
+    """ """
     divmod_exc = None
     series_scalar_exc = None
     frame_scalar_exc = None
     series_array_exc = None
 
     def test_divmod_series_array(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data)
         self._check_divmod_op(s, divmod, data, exc=None)
 
     @pytest.mark.skip("We implement ops")
     def test_error(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         super().test_arith_series_with_scalar(data, all_arithmetic_operators)
 
     def test_arith_series_with_array(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         super().test_arith_series_with_array(data, all_arithmetic_operators)
 
 
 class TestPrinting(BaseNumPyTests, base.BasePrintingTests):
+    """ """
     @pytest.mark.xfail(
         reason="GH#33125 PandasArray.astype does not recognize PandasDtype"
     )
     def test_series_repr(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_series_repr(data)
 
 
 @skip_nested
 class TestNumericReduce(BaseNumPyTests, base.BaseNumericReduceTests):
+    """ """
     def check_reduce(self, s, op_name, skipna):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         result = getattr(s, op_name)(skipna=skipna)
         # avoid coercing int -> float. Just cast to the actual numpy type.
         expected = getattr(s.astype(s.dtype._dtype), op_name)(skipna=skipna)
@@ -330,127 +829,391 @@
 
 @skip_nested
 class TestBooleanReduce(BaseNumPyTests, base.BaseBooleanReduceTests):
+    """ """
     pass
 
 
 class TestMissing(BaseNumPyTests, base.BaseMissingTests):
+    """ """
     @skip_nested
     def test_fillna_scalar(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # Non-scalar "scalar" values.
         super().test_fillna_scalar(data_missing)
 
     @skip_nested
     def test_fillna_series_method(self, data_missing, fillna_method):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+        fillna_method :
+            
+
+        Returns
+        -------
+
+        """
         # Non-scalar "scalar" values.
         super().test_fillna_series_method(data_missing, fillna_method)
 
     @skip_nested
     def test_fillna_series(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # Non-scalar "scalar" values.
         super().test_fillna_series(data_missing)
 
     @skip_nested
     def test_fillna_frame(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # Non-scalar "scalar" values.
         super().test_fillna_frame(data_missing)
 
     @pytest.mark.skip("Invalid test")
     def test_fillna_fill_other(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # inplace update doesn't work correctly with patched extension arrays
         # extract_array returns PandasArray, while dtype is a numpy dtype
         super().test_fillna_fill_other(data_missing)
 
 
 class TestReshaping(BaseNumPyTests, base.BaseReshapingTests):
+    """ """
     @pytest.mark.skip("Incorrect parent test")
     # not actually a mixed concat, since we concat int and int.
     def test_concat_mixed_dtypes(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_concat_mixed_dtypes(data)
 
     @pytest.mark.xfail(
         reason="GH#33125 PandasArray.astype does not recognize PandasDtype"
     )
     def test_concat(self, data, in_frame):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        in_frame :
+            
+
+        Returns
+        -------
+
+        """
         super().test_concat(data, in_frame)
 
     @pytest.mark.xfail(
         reason="GH#33125 PandasArray.astype does not recognize PandasDtype"
     )
     def test_concat_all_na_block(self, data_missing, in_frame):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+        in_frame :
+            
+
+        Returns
+        -------
+
+        """
         super().test_concat_all_na_block(data_missing, in_frame)
 
     @skip_nested
     def test_merge(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating expected
         super().test_merge(data, na_value)
 
     @skip_nested
     def test_merge_on_extension_array(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating expected
         super().test_merge_on_extension_array(data)
 
     @skip_nested
     def test_merge_on_extension_array_duplicates(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # Fails creating expected
         super().test_merge_on_extension_array_duplicates(data)
 
     @skip_nested
     def test_transpose(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_transpose(data)
 
 
 class TestSetitem(BaseNumPyTests, base.BaseSetitemTests):
+    """ """
     @skip_nested
     def test_setitem_scalar_series(self, data, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_setitem_scalar_series(data, box_in_series)
 
     @skip_nested
     def test_setitem_sequence(self, data, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: shape mismatch: value array of shape (2,1) could not
         # be broadcast to indexing result of shape (2,)
         super().test_setitem_sequence(data, box_in_series)
 
     @skip_nested
     def test_setitem_sequence_mismatched_length_raises(self, data, as_array):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        as_array :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: PandasArray must be 1-dimensional.
         super().test_setitem_sequence_mismatched_length_raises(data, as_array)
 
     @skip_nested
     def test_setitem_sequence_broadcasts(self, data, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: cannot set using a list-like indexer with a different
         # length than the value
         super().test_setitem_sequence_broadcasts(data, box_in_series)
 
     @skip_nested
     def test_setitem_loc_scalar_mixed(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_setitem_loc_scalar_mixed(data)
 
     @skip_nested
     def test_setitem_loc_scalar_multiple_homogoneous(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_setitem_loc_scalar_multiple_homogoneous(data)
 
     @skip_nested
     def test_setitem_iloc_scalar_mixed(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_setitem_iloc_scalar_mixed(data)
 
     @skip_nested
     def test_setitem_iloc_scalar_multiple_homogoneous(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # AssertionError
         super().test_setitem_iloc_scalar_multiple_homogoneous(data)
 
     @skip_nested
     @pytest.mark.parametrize("setter", ["loc", None])
     def test_setitem_mask_broadcast(self, data, setter):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        setter :
+            
+
+        Returns
+        -------
+
+        """
         # ValueError: cannot set using a list-like indexer with a different
         # length than the value
         super().test_setitem_mask_broadcast(data, setter)
 
     @skip_nested
     def test_setitem_scalar_key_sequence_raise(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # Failed: DID NOT RAISE <class 'ValueError'>
         super().test_setitem_scalar_key_sequence_raise(data)
 
@@ -467,10 +1230,38 @@
         ids=["numpy-array", "boolean-array"],
     )
     def test_setitem_mask(self, data, mask, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        mask :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_mask(data, mask, box_in_series)
 
     @skip_nested
     def test_setitem_mask_raises(self, data, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_mask_raises(data, box_in_series)
 
     @skip_nested
@@ -480,6 +1271,21 @@
         ids=["list", "integer-array", "numpy-array"],
     )
     def test_setitem_integer_array(self, data, idx, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        idx :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_integer_array(data, idx, box_in_series)
 
     @skip_nested
@@ -494,17 +1300,57 @@
         ids=["list-False", "list-True", "integer-array-False", "integer-array-True"],
     )
     def test_setitem_integer_with_missing_raises(self, data, idx, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        idx :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_integer_with_missing_raises(data, idx, box_in_series)
 
     @skip_nested
     def test_setitem_slice(self, data, box_in_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box_in_series :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_slice(data, box_in_series)
 
     @skip_nested
     def test_setitem_loc_iloc_slice(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_setitem_loc_iloc_slice(data)
 
 
 @skip_nested
 class TestParsing(BaseNumPyTests, base.BaseParsingTests):
+    """ """
     pass
