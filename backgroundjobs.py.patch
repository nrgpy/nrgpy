# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/lib/backgroundjobs.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/lib/backgroundjobs.py
@@ -40,34 +40,41 @@
 
 class BackgroundJobManager(object):
     """Class to manage a pool of backgrounded threaded jobs.
-
+    
     Below, we assume that 'jobs' is a BackgroundJobManager instance.
     
     Usage summary (see the method docstrings for details):
-
+    
       jobs.new(...) -> start a new job
-      
+    
       jobs() or jobs.status() -> print status summary of all jobs
-
+    
       jobs[N] -> returns job number N.
-
+    
       foo = jobs[N].result -> assign to variable foo the result of job N
-
+    
       jobs[N].traceback() -> print the traceback of dead job N
-
+    
       jobs.remove(N) -> remove (finished) job N
-
+    
       jobs.flush() -> remove all finished jobs
-      
+    
     As a convenience feature, BackgroundJobManager instances provide the
     utility result and traceback methods which retrieve the corresponding
     information from the jobs list:
-
+    
       jobs.result(N) <--> jobs[N].result
       jobs.traceback(N) <--> jobs[N].traceback()
-
+    
     While this appears minor, it allows you to use tab completion
     interactively on the job manager instance.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self):
@@ -90,29 +97,32 @@
 
     @property
     def running(self):
+        """ """
         self._update_status()
         return self._running
 
     @property
     def dead(self):
+        """ """
         self._update_status()
         return self._dead
 
     @property
     def completed(self):
+        """ """
         self._update_status()
         return self._completed
 
     def new(self, func_or_exp, *args, **kwargs):
         """Add a new background job and start it in a separate thread.
-
+        
         There are two types of jobs which can be created:
-
+        
         1. Jobs based on expressions which can be passed to an eval() call.
         The expression must be given as a string.  For example:
-
+        
           job_manager.new('myfunc(x,y,z=1)'[,glob[,loc]])
-
+        
         The given expression is passed to eval(), along with the optional
         global/local dicts provided.  If no dicts are given, they are
         extracted automatically from the caller's frame.
@@ -120,53 +130,67 @@
         A Python statement is NOT a valid eval() expression.  Basically, you
         can only use as an eval() argument something which can go on the right
         of an '=' sign and be assigned to a variable.
-
+        
         For example,"print 'hello'" is not valid, but '2+3' is.
-
+        
         2. Jobs given a function object, optionally passing additional
         positional arguments:
-
+        
           job_manager.new(myfunc, x, y)
-
+        
         The function is called with the given arguments.
-
+        
         If you need to pass keyword arguments to your function, you must
         supply them as a dict named kw:
-
+        
           job_manager.new(myfunc, x, y, kw=dict(z=1))
-
+        
         The reason for this assymmetry is that the new() method needs to
         maintain access to its own keywords, and this prevents name collisions
         between arguments to new() and arguments to your own functions.
-
+        
         In both cases, the result is stored in the job.result field of the
         background job object.
-
+        
         You can set `daemon` attribute of the thread by giving the keyword
         argument `daemon`.
-
+        
         Notes and caveats:
-
+        
         1. All threads running share the same standard output.  Thus, if your
         background jobs generate output, it will come out on top of whatever
         you are currently writing.  For this reason, background jobs are best
         used with silent functions which simply return their output.
-
+        
         2. Threads also all work within the same global namespace, and this
         system does not lock interactive variables.  So if you send job to the
         background which operates on a mutable object for a long time, and
         start modifying that same mutable object interactively (or in another
         backgrounded job), all sorts of bizarre behaviour will occur.
-
+        
         3. If a background job is spending a lot of time inside a C extension
         module which does not release the Python Global Interpreter Lock
         (GIL), this will block the IPython prompt.  This is simply because the
         Python interpreter can only switch between threads at Python
         bytecodes.  While the execution is inside C code, the interpreter must
         simply wait unless the extension module releases the GIL.
-
+        
         4. There is no way, due to limitations in the Python threads library,
-        to kill a thread once it has started."""
+        to kill a thread once it has started.
+
+        Parameters
+        ----------
+        func_or_exp :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         
         if callable(func_or_exp):
             kw  = kwargs.get('kw',{})
@@ -210,14 +234,22 @@
 
     def _update_status(self):
         """Update the status of the job lists.
-
+        
         This method moves finished jobs to one of two lists:
           - self.completed: jobs which completed successfully
           - self.dead: jobs which finished but died.
-
+        
         It also copies those jobs to corresponding _report lists.  These lists
         are used to report jobs completed/dead since the last update, and are
-        then cleared by the reporting function after each call."""
+        then cleared by the reporting function after each call.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         # Status codes
         srun, scomp, sdead = self._s_running, self._s_completed, self._s_dead
@@ -244,7 +276,19 @@
     def _group_report(self,group,name):
         """Report summary for a given job group.
 
-        Return True if the group had any elements."""
+        Parameters
+        ----------
+        group :
+            
+        name :
+            
+
+        Returns
+        -------
+        type
+            
+
+        """
 
         if group:
             print('%s jobs:' % name)
@@ -256,7 +300,19 @@
     def _group_flush(self,group,name):
         """Flush a given job group
 
-        Return True if the group had any elements."""
+        Parameters
+        ----------
+        group :
+            
+        name :
+            
+
+        Returns
+        -------
+        type
+            
+
+        """
 
         njobs = len(group)
         if njobs:
@@ -268,10 +324,16 @@
     def _status_new(self):
         """Print the status of newly finished jobs.
 
-        Return True if any new jobs are reported.
-
-        This call resets its own state every time, so it only reports jobs
-        which have finished since the last time it was called."""
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            This call resets its own state every time, so it only reports jobs
+            which have finished since the last time it was called.
+
+        """
 
         self._update_status()
         new_comp = self._group_report(self._comp_report, 'Completed')
@@ -282,7 +344,17 @@
         return new_comp or new_dead
                 
     def status(self,verbose=0):
-        """Print a status of all jobs currently being managed."""
+        """Print a status of all jobs currently being managed.
+
+        Parameters
+        ----------
+        verbose :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
 
         self._update_status()
         self._group_report(self.running,'Running')
@@ -293,7 +365,17 @@
         self._dead_report[:] = []
 
     def remove(self,num):
-        """Remove a finished (completed or dead) job."""
+        """Remove a finished (completed or dead) job.
+
+        Parameters
+        ----------
+        num :
+            
+
+        Returns
+        -------
+
+        """
 
         try:
             job = self.all[num]
@@ -311,12 +393,20 @@
 
     def flush(self):
         """Flush all finished jobs (completed and dead) from lists.
-
+        
         Running jobs are never flushed.
-
+        
         It first calls _status_new(), to update info. If any jobs have
         completed since the last _status_new() call, the flush operation
-        aborts."""
+        aborts.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         # Remove the finished jobs from the master dict
         alljobs = self.all
@@ -330,13 +420,34 @@
             print('No jobs to flush.')
 
     def result(self,num):
-        """result(N) -> return the result of job N."""
+        """result(N) -> return the result of job N.
+
+        Parameters
+        ----------
+        num :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self.all[num].result
         except KeyError:
             error('Job #%s not found' % num)
 
     def _traceback(self, job):
+        """
+
+        Parameters
+        ----------
+        job :
+            
+
+        Returns
+        -------
+
+        """
         num = job if isinstance(job, int) else job.num
         try:
             self.all[num].traceback()
@@ -344,6 +455,17 @@
             error('Job #%s not found' % num)
 
     def traceback(self, job=None):
+        """
+
+        Parameters
+        ----------
+        job :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if job is None:
             self._update_status()
             for deadjob in self.dead:
@@ -356,17 +478,25 @@
 
 class BackgroundJobBase(threading.Thread):
     """Base class to build BackgroundJob classes.
-
+    
     The derived classes must implement:
-
+    
     - Their own __init__, since the one here raises NotImplementedError.  The
       derived constructor must call self._init() at the end, to provide common
       initialization.
-
+    
     - A strform attribute used in calls to __str__.
-
+    
     - A call() method, which will make the actual execution call and must
-      return a value to be held in the 'result' field of the job object.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        
+
     """
 
     # Class constants for status, in string and as numerical codes (when
@@ -423,9 +553,11 @@
         return '<BackgroundJob #%d: %s>' % (self.num, self.strform)
 
     def traceback(self):
+        """ """
         print(self._tb)
         
     def run(self):
+        """ """
         try:
             self.status    = BackgroundJobBase.stat_running
             self.stat_code = BackgroundJobBase.stat_running_c
@@ -462,6 +594,7 @@
         self._init()
         
     def call(self):
+        """ """
         return eval(self.code,self.glob,self.loc)
 
 
@@ -488,4 +621,5 @@
         self._init()
 
     def call(self):
+        """ """
         return self.func(*self.args, **self.kwargs)
