# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/httputil.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/httputil.py
@@ -67,6 +67,14 @@
 def _normalize_header(name: str) -> str:
     """Map a header name to Http-Header-Case.
 
+    Parameters
+    ----------
+    name: str :
+        
+
+    Returns
+    -------
+
     >>> _normalize_header("coNtent-TYPE")
     'Content-Type'
     """
@@ -75,25 +83,31 @@
 
 class HTTPHeaders(collections.abc.MutableMapping):
     """A dictionary that maintains ``Http-Header-Case`` for all keys.
-
+    
     Supports multiple values per key via a pair of new methods,
     `add()` and `get_list()`.  The regular dictionary interface
     returns a single value per key, with multiple values joined by a
     comma.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     >>> h = HTTPHeaders({"content-type": "text/html"})
     >>> list(h.keys())
     ['Content-Type']
     >>> h["Content-Type"]
     'text/html'
-
+    
     >>> h.add("Set-Cookie", "A=B")
     >>> h.add("Set-Cookie", "C=D")
     >>> h["set-cookie"]
     'A=B,C=D'
     >>> h.get_list("set-cookie")
     ['A=B', 'C=D']
-
+    
     >>> for (k,v) in sorted(h.get_all()):
     ...    print('%s: %s' % (k,v))
     ...
@@ -133,7 +147,19 @@
     # new public methods
 
     def add(self, name: str, value: str) -> None:
-        """Adds a new value for the given key."""
+        """Adds a new value for the given key.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         norm_name = _normalize_header(name)
         self._last_key = norm_name
         if norm_name in self:
@@ -145,15 +171,33 @@
             self[norm_name] = value
 
     def get_list(self, name: str) -> List[str]:
-        """Returns all values for the given header as a list."""
+        """Returns all values for the given header as a list.
+
+        Parameters
+        ----------
+        name: str :
+            
+
+        Returns
+        -------
+
+        """
         norm_name = _normalize_header(name)
         return self._as_list.get(norm_name, [])
 
     def get_all(self) -> Iterable[Tuple[str, str]]:
         """Returns an iterable of all (name, value) pairs.
-
+        
         If a header has multiple values, multiple pairs will be
-        returned with the same name.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            
+
         """
         for name, values in self._as_list.items():
             for value in values:
@@ -161,6 +205,14 @@
 
     def parse_line(self, line: str) -> None:
         """Updates the dictionary with a single header line.
+
+        Parameters
+        ----------
+        line: str :
+            
+
+        Returns
+        -------
 
         >>> h = HTTPHeaders()
         >>> h.parse_line("Content-Type: text/html")
@@ -184,16 +236,24 @@
     @classmethod
     def parse(cls, headers: str) -> "HTTPHeaders":
         """Returns a dictionary from HTTP header text.
+        
+        
+        .. versionchanged:: 5.1
+        
+           Raises `HTTPInputError` on malformed headers instead of a
+           mix of `KeyError`, and `ValueError`.
+
+        Parameters
+        ----------
+        headers: str :
+            
+
+        Returns
+        -------
 
         >>> h = HTTPHeaders.parse("Content-Type: text/html\\r\\nContent-Length: 42\\r\\n")
         >>> sorted(h.items())
         [('Content-Length', '42'), ('Content-Type', 'text/html')]
-
-        .. versionchanged:: 5.1
-
-           Raises `HTTPInputError` on malformed headers instead of a
-           mix of `KeyError`, and `ValueError`.
-
         """
         h = cls()
         # RFC 7230 section 3.5: a recipient MAY recognize a single LF as a line
@@ -227,6 +287,7 @@
         return iter(self._dict)
 
     def copy(self) -> "HTTPHeaders":
+        """ """
         # defined in dict but not in MutableMapping.
         return HTTPHeaders(self)
 
@@ -246,95 +307,102 @@
 
 class HTTPServerRequest(object):
     """A single HTTP request.
-
+    
     All attributes are type `str` unless otherwise noted.
-
+    
     .. attribute:: method
-
+    
        HTTP request method, e.g. "GET" or "POST"
-
+    
     .. attribute:: uri
-
+    
        The requested uri.
-
+    
     .. attribute:: path
-
+    
        The path portion of `uri`
-
+    
     .. attribute:: query
-
+    
        The query portion of `uri`
-
+    
     .. attribute:: version
-
+    
        HTTP version specified in request, e.g. "HTTP/1.1"
-
+    
     .. attribute:: headers
-
+    
        `.HTTPHeaders` dictionary-like object for request headers.  Acts like
        a case-insensitive dictionary with additional methods for repeated
        headers.
-
+    
     .. attribute:: body
-
+    
        Request body, if present, as a byte string.
-
+    
     .. attribute:: remote_ip
-
+    
        Client's IP address as a string.  If ``HTTPServer.xheaders`` is set,
        will pass along the real IP address provided by a load balancer
        in the ``X-Real-Ip`` or ``X-Forwarded-For`` header.
-
+    
     .. versionchanged:: 3.1
        The list format of ``X-Forwarded-For`` is now supported.
-
+    
     .. attribute:: protocol
-
+    
        The protocol used, either "http" or "https".  If ``HTTPServer.xheaders``
        is set, will pass along the protocol used by a load balancer if
        reported via an ``X-Scheme`` header.
-
+    
     .. attribute:: host
-
+    
        The requested hostname, usually taken from the ``Host`` header.
-
+    
     .. attribute:: arguments
-
+    
        GET/POST arguments are available in the arguments property, which
        maps arguments names to lists of values (to support multiple values
        for individual names). Names are of type `str`, while arguments
        are byte strings.  Note that this is different from
        `.RequestHandler.get_argument`, which returns argument values as
        unicode strings.
-
+    
     .. attribute:: query_arguments
-
+    
        Same format as ``arguments``, but contains only arguments extracted
        from the query string.
-
+    
        .. versionadded:: 3.2
-
+    
     .. attribute:: body_arguments
-
+    
        Same format as ``arguments``, but contains only arguments extracted
        from the request body.
-
+    
        .. versionadded:: 3.2
-
+    
     .. attribute:: files
-
+    
        File uploads are available in the files property, which maps file
        names to lists of `.HTTPFile`.
-
+    
     .. attribute:: connection
-
+    
        An HTTP request is attached to a single HTTP connection, which can
        be accessed through the "connection" attribute. Since connections
        are typically kept open in HTTP/1.1, multiple requests can be handled
        sequentially on a single connection.
-
+    
     .. versionchanged:: 4.0
        Moved from ``tornado.httpserver.HTTPRequest``.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     path = None  # type: str
@@ -421,22 +489,31 @@
         self, binary_form: bool = False
     ) -> Union[None, Dict, bytes]:
         """Returns the client's SSL certificate, if any.
-
+        
         To use client certificates, the HTTPServer's
         `ssl.SSLContext.verify_mode` field must be set, e.g.::
-
+        
             ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
             ssl_ctx.load_cert_chain("foo.crt", "foo.key")
             ssl_ctx.load_verify_locations("cacerts.pem")
             ssl_ctx.verify_mode = ssl.CERT_REQUIRED
             server = HTTPServer(app, ssl_options=ssl_ctx)
-
+        
         By default, the return value is a dictionary (or None, if no
         client certificate is present).  If ``binary_form`` is true, a
         DER-encoded form of the certificate is returned instead.  See
         SSLSocket.getpeercert() in the standard library for more
         details.
         http://docs.python.org/library/ssl.html#sslsocket-objects
+
+        Parameters
+        ----------
+        binary_form: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         try:
             if self.connection is None:
@@ -449,6 +526,7 @@
             return None
 
     def _parse_body(self) -> None:
+        """ """
         parse_body_arguments(
             self.headers.get("Content-Type", ""),
             self.body,
@@ -467,19 +545,40 @@
 
 
 class HTTPInputError(Exception):
-    """Exception class for malformed HTTP requests or responses
-    from remote sources.
-
-    .. versionadded:: 4.0
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    from
+        remote sources
+    .
+        versionadded
+
     """
 
     pass
 
 
 class HTTPOutputError(Exception):
-    """Exception class for errors in HTTP output.
-
-    .. versionadded:: 4.0
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    .
+        versionadded
+
     """
 
     pass
@@ -487,37 +586,71 @@
 
 class HTTPServerConnectionDelegate(object):
     """Implement this interface to handle requests from `.HTTPServer`.
-
+    
     .. versionadded:: 4.0
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def start_request(
         self, server_conn: object, request_conn: "HTTPConnection"
     ) -> "HTTPMessageDelegate":
         """This method is called by the server when a new request has started.
-
+        
         :arg server_conn: is an opaque object representing the long-lived
             (e.g. tcp-level) connection.
         :arg request_conn: is a `.HTTPConnection` object for a single
             request/response exchange.
-
+        
         This method should return a `.HTTPMessageDelegate`.
+
+        Parameters
+        ----------
+        server_conn: object :
+            
+        request_conn: "HTTPConnection" :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def on_close(self, server_conn: object) -> None:
         """This method is called when a connection has been closed.
-
+        
         :arg server_conn: is a server connection that has previously been
             passed to ``start_request``.
+
+        Parameters
+        ----------
+        server_conn: object :
+            
+
+        Returns
+        -------
+
         """
         pass
 
 
 class HTTPMessageDelegate(object):
     """Implement this interface to handle an HTTP request or response.
-
+    
     .. versionadded:: 4.0
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # TODO: genericize this class to avoid exposing the Union.
@@ -527,23 +660,45 @@
         headers: HTTPHeaders,
     ) -> Optional[Awaitable[None]]:
         """Called when the HTTP headers have been received and parsed.
-
+        
         :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`
             depending on whether this is a client or server message.
         :arg headers: a `.HTTPHeaders` instance.
-
+        
         Some `.HTTPConnection` methods can only be called during
         ``headers_received``.
-
+        
         May return a `.Future`; if it does the body will not be read
         until it is done.
+
+        Parameters
+        ----------
+        start_line: Union["RequestStartLine" :
+            
+        "ResponseStartLine"] :
+            
+        headers: HTTPHeaders :
+            
+
+        Returns
+        -------
+
         """
         pass
 
     def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:
         """Called when a chunk of data has been received.
-
+        
         May return a `.Future` for flow control.
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
         """
         pass
 
@@ -553,17 +708,31 @@
 
     def on_connection_close(self) -> None:
         """Called if the connection is closed without finishing the request.
-
+        
         If ``headers_received`` is called, either ``finish`` or
         ``on_connection_close`` will be called, but not both.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
 
 class HTTPConnection(object):
     """Applications use this interface to write their responses.
-
+    
     .. versionadded:: 4.0
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def write_headers(
@@ -573,37 +742,60 @@
         chunk: Optional[bytes] = None,
     ) -> "Future[None]":
         """Write an HTTP header block.
-
+        
         :arg start_line: a `.RequestStartLine` or `.ResponseStartLine`.
         :arg headers: a `.HTTPHeaders` instance.
         :arg chunk: the first (optional) chunk of data.  This is an optimization
             so that small responses can be written in the same call as their
             headers.
-
+        
         The ``version`` field of ``start_line`` is ignored.
-
+        
         Returns a future for flow control.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed.
+
+        Parameters
+        ----------
+        start_line: Union["RequestStartLine" :
+            
+        "ResponseStartLine"] :
+            
+        headers: HTTPHeaders :
+            
+        chunk: Optional[bytes] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def write(self, chunk: bytes) -> "Future[None]":
         """Writes a chunk of body data.
-
+        
         Returns a future for flow control.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed.
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def finish(self) -> None:
-        """Indicates that the last body data has been written.
-        """
+        """Indicates that the last body data has been written."""
         raise NotImplementedError()
 
 
@@ -615,9 +807,31 @@
 ) -> str:
     """Concatenate url and arguments regardless of whether
     url has existing query parameters.
-
+    
     ``args`` may be either a dictionary or a list of key-value pairs
     (the latter allows for multiple values with the same key.
+
+    Parameters
+    ----------
+    url: str :
+        
+    args: Union[None :
+        
+    Dict[str :
+        
+    str] :
+        
+    List[Tuple[str :
+        
+    str]] :
+        
+    Tuple[Tuple[str :
+        
+    ...]] :
+        
+
+    Returns
+    -------
 
     >>> url_concat("http://example.com/foo", dict(c="d"))
     'http://example.com/foo?c=d'
@@ -656,13 +870,20 @@
 
 class HTTPFile(ObjectDict):
     """Represents a file uploaded via a form.
-
+    
     For backwards compatibility, its instance attributes are also
     accessible as dictionary keys.
-
+    
     * ``filename``
     * ``body``
     * ``content_type``
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     pass
@@ -672,10 +893,25 @@
     range_header: str,
 ) -> Optional[Tuple[Optional[int], Optional[int]]]:
     """Parses a Range header.
-
+    
     Returns either ``None`` or tuple ``(start, end)``.
     Note that while the HTTP headers use inclusive byte positions,
     this method returns indexes suitable for use in slices.
+    
+    
+    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).
+    
+    See [0] for the details of the range header.
+    
+    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges
+
+    Parameters
+    ----------
+    range_header: str :
+        
+
+    Returns
+    -------
 
     >>> start, end = _parse_request_range("bytes=1-2")
     >>> start, end
@@ -692,12 +928,6 @@
     (None, None)
     >>> _parse_request_range("foo=42")
     >>> _parse_request_range("bytes=1-2,6-10")
-
-    Note: only supports one range (ex, ``bytes=1-2,6-10`` is not allowed).
-
-    See [0] for the details of the range header.
-
-    [0]: http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges
     """
     unit, _, value = range_header.partition("=")
     unit, value = unit.strip(), value.strip()
@@ -722,6 +952,18 @@
 def _get_content_range(start: Optional[int], end: Optional[int], total: int) -> str:
     """Returns a suitable Content-Range header:
 
+    Parameters
+    ----------
+    start: Optional[int] :
+        
+    end: Optional[int] :
+        
+    total: int :
+        
+
+    Returns
+    -------
+
     >>> print(_get_content_range(None, 1, 4))
     bytes 0-0/4
     >>> print(_get_content_range(1, 3, 4))
@@ -735,6 +977,17 @@
 
 
 def _int_or_none(val: str) -> Optional[int]:
+    """
+
+    Parameters
+    ----------
+    val: str :
+        
+
+    Returns
+    -------
+
+    """
     val = val.strip()
     if val == "":
         return None
@@ -749,12 +1002,33 @@
     headers: Optional[HTTPHeaders] = None,
 ) -> None:
     """Parses a form request body.
-
+    
     Supports ``application/x-www-form-urlencoded`` and
     ``multipart/form-data``.  The ``content_type`` parameter should be
     a string and ``body`` should be a byte string.  The ``arguments``
     and ``files`` parameters are dictionaries that will be updated
     with the parsed contents.
+
+    Parameters
+    ----------
+    content_type: str :
+        
+    body: bytes :
+        
+    arguments: Dict[str :
+        
+    List[bytes]] :
+        
+    files: Dict[str :
+        
+    List[HTTPFile]] :
+        
+    headers: Optional[HTTPHeaders] :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if content_type.startswith("application/x-www-form-urlencoded"):
         if headers and "Content-Encoding" in headers:
@@ -797,15 +1071,34 @@
     files: Dict[str, List[HTTPFile]],
 ) -> None:
     """Parses a ``multipart/form-data`` body.
-
+    
     The ``boundary`` and ``data`` parameters are both byte strings.
     The dictionaries given in the arguments and files parameters
     will be updated with the contents of the body.
-
+    
     .. versionchanged:: 5.1
-
+    
        Now recognizes non-ASCII filenames in RFC 2231/5987
        (``filename*=``) format.
+
+    Parameters
+    ----------
+    boundary: bytes :
+        
+    data: bytes :
+        
+    arguments: Dict[str :
+        
+    List[bytes]] :
+        
+    files: Dict[str :
+        
+    List[HTTPFile]] :
+        
+
+    Returns
+    -------
+
     """
     # The standard allows for the boundary to be quoted in the header,
     # although it's rare (it happens at least for google app engine
@@ -852,10 +1145,26 @@
     ts: Union[int, float, tuple, time.struct_time, datetime.datetime]
 ) -> str:
     """Formats a timestamp in the format used by HTTP.
-
+    
     The argument may be a numeric timestamp as returned by `time.time`,
     a time tuple as returned by `time.gmtime`, or a `datetime.datetime`
     object.
+
+    Parameters
+    ----------
+    ts: Union[int :
+        
+    float :
+        
+    tuple :
+        
+    time.struct_time :
+        
+    datetime.datetime] :
+        
+
+    Returns
+    -------
 
     >>> format_timestamp(1359312200)
     'Sun, 27 Jan 2013 18:43:20 GMT'
@@ -881,8 +1190,16 @@
 
 def parse_request_start_line(line: str) -> RequestStartLine:
     """Returns a (method, path, version) tuple for an HTTP 1.x request line.
-
+    
     The response is a `collections.namedtuple`.
+
+    Parameters
+    ----------
+    line: str :
+        
+
+    Returns
+    -------
 
     >>> parse_request_start_line("GET /foo HTTP/1.1")
     RequestStartLine(method='GET', path='/foo', version='HTTP/1.1')
@@ -910,8 +1227,16 @@
 
 def parse_response_start_line(line: str) -> ResponseStartLine:
     """Returns a (version, code, reason) tuple for an HTTP 1.x response line.
-
+    
     The response is a `collections.namedtuple`.
+
+    Parameters
+    ----------
+    line: str :
+        
+
+    Returns
+    -------
 
     >>> parse_response_start_line("HTTP/1.1 200 OK")
     ResponseStartLine(version='HTTP/1.1', code=200, reason='OK')
@@ -932,6 +1257,17 @@
 
 
 def _parseparam(s: str) -> Generator[str, None, None]:
+    """
+
+    Parameters
+    ----------
+    s: str :
+        
+
+    Returns
+    -------
+
+    """
     while s[:1] == ";":
         s = s[1:]
         end = s.find(";")
@@ -945,9 +1281,17 @@
 
 
 def _parse_header(line: str) -> Tuple[str, Dict[str, str]]:
-    r"""Parse a Content-type like header.
-
-    Return the main content-type and a dictionary of options.
+    """r"""Parse a Content-type like header.
+
+    Parameters
+    ----------
+    line: str :
+        
+
+    Returns
+    -------
+    type
+        
 
     >>> d = "form-data; foo=\"b\\\\a\\\"r\"; file*=utf-8''T%C3%A4st"
     >>> ct, d = _parse_header(d)
@@ -957,7 +1301,6 @@
     True
     >>> d['foo']
     'b\\a"r'
-    """
     parts = _parseparam(";" + line)
     key = next(parts)
     # decode_params treats first argument special, but we already stripped key
@@ -982,6 +1325,18 @@
 def _encode_header(key: str, pdict: Dict[str, str]) -> str:
     """Inverse of _parse_header.
 
+    Parameters
+    ----------
+    key: str :
+        
+    pdict: Dict[str :
+        
+    str] :
+        
+
+    Returns
+    -------
+
     >>> _encode_header('permessage-deflate',
     ...     {'client_max_window_bits': 15, 'client_no_context_takeover': None})
     'permessage-deflate; client_max_window_bits=15; client_no_context_takeover'
@@ -1003,10 +1358,23 @@
     username: Union[str, bytes], password: Union[str, bytes]
 ) -> bytes:
     """Encodes a username/password pair in the format used by HTTP auth.
-
+    
     The return value is a byte string in the form ``username:password``.
-
+    
     .. versionadded:: 5.1
+
+    Parameters
+    ----------
+    username: Union[str :
+        
+    bytes] :
+        
+    password: Union[str :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(username, unicode_type):
         username = unicodedata.normalize("NFC", username)
@@ -1016,6 +1384,7 @@
 
 
 def doctests():
+    """ """
     # type: () -> unittest.TestSuite
     import doctest
 
@@ -1028,9 +1397,16 @@
 def split_host_and_port(netloc: str) -> Tuple[str, Optional[int]]:
     """Returns ``(host, port)`` tuple from ``netloc``.
 
-    Returned ``port`` will be ``None`` if not present.
-
-    .. versionadded:: 4.1
+    Parameters
+    ----------
+    netloc: str :
+        
+
+    Returns
+    -------
+    type
+        .. versionadded:: 4.1
+
     """
     match = _netloc_re.match(netloc)
     if match:
@@ -1044,8 +1420,19 @@
 
 def qs_to_qsl(qs: Dict[str, List[AnyStr]]) -> Iterable[Tuple[str, AnyStr]]:
     """Generator converting a result of ``parse_qs`` back to name-value pairs.
-
+    
     .. versionadded:: 5.0
+
+    Parameters
+    ----------
+    qs: Dict[str :
+        
+    List[AnyStr]] :
+        
+
+    Returns
+    -------
+
     """
     for k, vs in qs.items():
         for v in vs:
@@ -1059,10 +1446,19 @@
 
 def _unquote_cookie(s: str) -> str:
     """Handle double quotes and escaping in cookie values.
-
+    
     This method is copied verbatim from the Python 3.5 standard
     library (http.cookies._unquote) so we don't have to depend on
     non-public interfaces.
+
+    Parameters
+    ----------
+    s: str :
+        
+
+    Returns
+    -------
+
     """
     # If there aren't any doublequotes,
     # then there can't be any special characters.  See RFC 2109.
@@ -1109,14 +1505,23 @@
 
 def parse_cookie(cookie: str) -> Dict[str, str]:
     """Parse a ``Cookie`` HTTP header into a dict of name/value pairs.
-
+    
     This function attempts to mimic browser cookie parsing behavior;
     it specifically does not follow any of the cookie-related RFCs
     (because browsers don't either).
-
+    
     The algorithm used is identical to that used by Django version 1.9.10.
-
+    
     .. versionadded:: 4.4.2
+
+    Parameters
+    ----------
+    cookie: str :
+        
+
+    Returns
+    -------
+
     """
     cookiedict = {}
     for chunk in cookie.split(str(";")):
