# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/polynomial.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/polynomial.py
@@ -27,25 +27,40 @@
 
 @set_module('numpy')
 class RankWarning(UserWarning):
-    """
-    Issued by `polyfit` when the Vandermonde matrix is rank deficient.
-
+    """Issued by `polyfit` when the Vandermonde matrix is rank deficient.
+    
     For more information, a way to suppress the warning, and an example of
     `RankWarning` being issued, see `polyfit`.
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     pass
 
 
 def _poly_dispatcher(seq_of_zeros):
+    """
+
+    Parameters
+    ----------
+    seq_of_zeros :
+        
+
+    Returns
+    -------
+
+    """
     return seq_of_zeros
 
 
 @array_function_dispatch(_poly_dispatcher)
 def poly(seq_of_zeros):
-    """
-    Find the coefficients of a polynomial with the given sequence of roots.
-
+    """Find the coefficients of a polynomial with the given sequence of roots.
+    
     Returns the coefficients of the polynomial whose leading coefficient
     is one for the given sequence of zeros (multiple roots must be included
     in the sequence as many times as their multiplicity; see Examples).
@@ -62,7 +77,6 @@
     -------
     c : ndarray
         1D array of polynomial coefficients from highest to lowest degree:
-
         ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``
         where c[0] always equals 1.
 
@@ -78,7 +92,6 @@
     roots : Return the roots of a polynomial.
     polyfit : Least squares polynomial fit.
     poly1d : A one-dimensional polynomial class.
-
     Notes
     -----
     Specifying the roots of a polynomial still leaves one degree of
@@ -87,47 +100,47 @@
     the first one in the returned array - is always taken as one. (If
     for some reason you have one other point, the only automatic way
     presently to leverage that information is to use ``polyfit``.)
-
+    
     The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`
     matrix **A** is given by
-
+    
         :math:`p_a(t) = \\mathrm{det}(t\\, \\mathbf{I} - \\mathbf{A})`,
-
+    
     where **I** is the `n`-by-`n` identity matrix. [2]_
-
     References
     ----------
     .. [1] M. Sullivan and M. Sullivan, III, "Algebra and Trignometry,
        Enhanced With Graphing Utilities," Prentice-Hall, pg. 318, 1996.
-
+    
     .. [2] G. Strang, "Linear Algebra and Its Applications, 2nd Edition,"
        Academic Press, pg. 182, 1980.
-
     Examples
     --------
     Given a sequence of a polynomial's zeros:
-
+    
+    
+    The line above represents z**3 + 0*z**2 + 0*z + 0.
+    
+    
+    The line above represents z**3 - z/4
+    
+    
+    Given a square array object:
+    
+    
+    Note how in all cases the leading coefficient is always 1.
     >>> np.poly((0, 0, 0)) # Multiple root example
     array([1., 0., 0., 0.])
-
-    The line above represents z**3 + 0*z**2 + 0*z + 0.
-
+    
     >>> np.poly((-1./2, 0, 1./2))
     array([ 1.  ,  0.  , -0.25,  0.  ])
-
-    The line above represents z**3 - z/4
-
+    
     >>> np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))
     array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random
-
-    Given a square array object:
-
+    
     >>> P = np.array([[0, 1./3], [-1./2, 0]])
     >>> np.poly(P)
     array([1.        , 0.        , 0.16666667])
-
-    Note how in all cases the leading coefficient is always 1.
-
     """
     seq_of_zeros = atleast_1d(seq_of_zeros)
     sh = seq_of_zeros.shape
@@ -160,17 +173,27 @@
 
 
 def _roots_dispatcher(p):
+    """
+
+    Parameters
+    ----------
+    p :
+        
+
+    Returns
+    -------
+
+    """
     return p
 
 
 @array_function_dispatch(_roots_dispatcher)
 def roots(p):
-    """
-    Return the roots of a polynomial with coefficients given in p.
-
+    """Return the roots of a polynomial with coefficients given in p.
+    
     The values in the rank-1 array `p` are coefficients of a polynomial.
     If the length of `p` is n+1 then the polynomial is described by::
-
+    
       p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]
 
     Parameters
@@ -195,23 +218,19 @@
     polyval : Compute polynomial values.
     polyfit : Least squares polynomial fit.
     poly1d : A one-dimensional polynomial class.
-
     Notes
     -----
     The algorithm relies on computing the eigenvalues of the
     companion matrix [1]_.
-
     References
     ----------
     .. [1] R. A. Horn & C. R. Johnson, *Matrix Analysis*.  Cambridge, UK:
         Cambridge University Press, 1999, pp. 146-7.
-
     Examples
     --------
     >>> coeff = [3.2, 2, 1]
     >>> np.roots(coeff)
     array([-0.3125+0.46351241j, -0.3125-0.46351241j])
-
     """
     # If input is scalar, this makes it an array
     p = atleast_1d(p)
@@ -250,21 +269,35 @@
 
 
 def _polyint_dispatcher(p, m=None, k=None):
+    """
+
+    Parameters
+    ----------
+    p :
+        
+    m :
+         (Default value = None)
+    k :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (p,)
 
 
 @array_function_dispatch(_polyint_dispatcher)
 def polyint(p, m=1, k=None):
-    """
-    Return an antiderivative (indefinite integral) of a polynomial.
-
+    """Return an antiderivative (indefinite integral) of a polynomial.
+    
     The returned order `m` antiderivative `P` of polynomial `p` satisfies
     :math:`\\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`
     integration constants `k`. The constants determine the low-order
     polynomial part
-
+    
     .. math:: \\frac{k_{m-1}}{0!} x^0 + \\ldots + \\frac{k_0}{(m-1)!}x^{m-1}
-
+    
     of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.
 
     Parameters
@@ -277,28 +310,33 @@
     k : list of `m` scalars or scalar, optional
         Integration constants. They are given in the order of integration:
         those corresponding to highest-order terms come first.
-
         If ``None`` (default), all constants are assumed to be zero.
         If `m = 1`, a single scalar can be given instead of a list.
 
+    Returns
+    -------
+
     See Also
     --------
     polyder : derivative of a polynomial
     poly1d.integ : equivalent method
-
     Examples
     --------
     The defining property of the antiderivative:
-
+    
+    
+    The integration constants default to zero, but can be specified:
+    
+    
+    Note that 3 = 6 / 2!, and that the constants are given in the order of
+    integrations. Constant of the highest-order polynomial term comes first:
     >>> p = np.poly1d([1,1,1])
     >>> P = np.polyint(p)
     >>> P
      poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary
     >>> np.polyder(P) == p
     True
-
-    The integration constants default to zero, but can be specified:
-
+    
     >>> P = np.polyint(p, 3)
     >>> P(0)
     0.0
@@ -309,17 +347,13 @@
     >>> P = np.polyint(p, 3, k=[6,5,3])
     >>> P
     poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary
-
-    Note that 3 = 6 / 2!, and that the constants are given in the order of
-    integrations. Constant of the highest-order polynomial term comes first:
-
+    
     >>> np.polyder(P, 2)(0)
     6.0
     >>> np.polyder(P, 1)(0)
     5.0
     >>> P(0)
     3.0
-
     """
     m = int(m)
     if m < 0:
@@ -349,13 +383,25 @@
 
 
 def _polyder_dispatcher(p, m=None):
+    """
+
+    Parameters
+    ----------
+    p :
+        
+    m :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (p,)
 
 
 @array_function_dispatch(_polyder_dispatcher)
 def polyder(p, m=1):
-    """
-    Return the derivative of the specified order of a polynomial.
+    """Return the derivative of the specified order of a polynomial.
 
     Parameters
     ----------
@@ -374,36 +420,36 @@
     --------
     polyint : Anti-derivative of a polynomial.
     poly1d : Class for one-dimensional polynomials.
-
     Examples
     --------
     The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:
-
+    
+    
+    which evaluates to:
+    
+    
+    We can verify this, approximating the derivative with
+    ``(f(x + h) - f(x))/h``:
+    
+    
+    The fourth-order derivative of a 3rd-order polynomial is zero:
     >>> p = np.poly1d([1,1,1,1])
     >>> p2 = np.polyder(p)
     >>> p2
     poly1d([3, 2, 1])
-
-    which evaluates to:
-
+    
     >>> p2(2.)
     17.0
-
-    We can verify this, approximating the derivative with
-    ``(f(x + h) - f(x))/h``:
-
+    
     >>> (p(2. + 0.001) - p(2.)) / 0.001
     17.007000999997857
-
-    The fourth-order derivative of a 3rd-order polynomial is zero:
-
+    
     >>> np.polyder(p, 2)
     poly1d([6, 2])
     >>> np.polyder(p, 3)
     poly1d([6])
     >>> np.polyder(p, 4)
     poly1d([0.])
-
     """
     m = int(m)
     if m < 0:
@@ -423,18 +469,40 @@
 
 
 def _polyfit_dispatcher(x, y, deg, rcond=None, full=None, w=None, cov=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+    deg :
+        
+    rcond :
+         (Default value = None)
+    full :
+         (Default value = None)
+    w :
+         (Default value = None)
+    cov :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (x, y, w)
 
 
 @array_function_dispatch(_polyfit_dispatcher)
 def polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):
-    """
-    Least squares polynomial fit.
-
+    """Least squares polynomial fit.
+    
     Fit a polynomial ``p(x) = p[0] * x**deg + ... + p[deg]`` of degree `deg`
     to points `(x, y)`. Returns a vector of coefficients `p` that minimises
     the squared error in the order `deg`, `deg-1`, ... `0`.
-
+    
     The `Polynomial.fit <numpy.polynomial.polynomial.Polynomial.fit>` class
     method is recommended for new code as it is more stable numerically. See
     the documentation of the method for more information.
@@ -460,7 +528,7 @@
         information from the singular value decomposition is also returned.
     w : array_like, shape (M,), optional
         Weights to apply to the y-coordinates of the sample points. For
-        gaussian uncertainties, use 1/sigma (not 1/sigma**2).
+        gaussian uncertainties, use 1/sigma (not 1/sigma**2). (Default value = None)
     cov : bool or str, optional
         If given and not `False`, return not just the estimate but also its
         covariance matrix. By default, the covariance are scaled by
@@ -475,54 +543,47 @@
     p : ndarray, shape (deg + 1,) or (deg + 1, K)
         Polynomial coefficients, highest power first.  If `y` was 2-D, the
         coefficients for `k`-th data set are in ``p[:,k]``.
-
     residuals, rank, singular_values, rcond
         Present only if `full` = True.  Residuals is sum of squared residuals
         of the least-squares fit, the effective rank of the scaled Vandermonde
         coefficient matrix, its singular values, and the specified value of
         `rcond`. For more details, see `linalg.lstsq`.
-
     V : ndarray, shape (M,M) or (M,M,K)
         Present only if `full` = False and `cov`=True.  The covariance
         matrix of the polynomial coefficient estimates.  The diagonal of
         this matrix are the variance estimates for each coefficient.  If y
         is a 2-D array, then the covariance matrix for the `k`-th data set
         are in ``V[:,:,k]``
-
-
     Warns
+        
     -----
+        
     RankWarning
         The rank of the coefficient matrix in the least-squares fit is
         deficient. The warning is only raised if `full` = False.
-
         The warnings can be turned off by
-
-        >>> import warnings
-        >>> warnings.simplefilter('ignore', np.RankWarning)
 
     See Also
     --------
     polyval : Compute polynomial values.
     linalg.lstsq : Computes a least-squares fit.
     scipy.interpolate.UnivariateSpline : Computes spline fits.
-
     Notes
     -----
     The solution minimizes the squared error
-
+    
     .. math ::
         E = \\sum_{j=0}^k |p(x_j) - y_j|^2
-
+    
     in the equations::
-
+    
         x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
         x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
         ...
         x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]
-
+    
     The coefficient matrix of the coefficients `p` is a Vandermonde matrix.
-
+    
     `polyfit` issues a `RankWarning` when the least-squares fit is badly
     conditioned. This implies that the best fit is not well-defined due
     to numerical error. The results may be improved by lowering the polynomial
@@ -530,31 +591,38 @@
     can also be set to a value smaller than its default, but the resulting
     fit may be spurious: including contributions from the small singular
     values can add numerical noise to the result.
-
+    
     Note that fitting polynomial coefficients is inherently badly conditioned
     when the degree of the polynomial is large or the interval of sample points
     is badly centered. The quality of the fit should always be checked in these
     cases. When polynomial fits are not satisfactory, splines may be a good
     alternative.
-
     References
     ----------
     .. [1] Wikipedia, "Curve fitting",
            https://en.wikipedia.org/wiki/Curve_fitting
     .. [2] Wikipedia, "Polynomial interpolation",
            https://en.wikipedia.org/wiki/Polynomial_interpolation
-
     Examples
     --------
+    
+    It is convenient to use `poly1d` objects for dealing with polynomials:
+    
+    
+    High-order polynomials may oscillate wildly:
+    
+    
+    Illustration:
+    >>> import warnings
+        >>> warnings.simplefilter('ignore', np.RankWarning)
+    
     >>> import warnings
     >>> x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])
     >>> y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])
     >>> z = np.polyfit(x, y, 3)
     >>> z
     array([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary
-
-    It is convenient to use `poly1d` objects for dealing with polynomials:
-
+    
     >>> p = np.poly1d(z)
     >>> p(0.5)
     0.6143849206349179 # may vary
@@ -562,9 +630,7 @@
     -0.34732142857143039 # may vary
     >>> p(10)
     22.579365079365115 # may vary
-
-    High-order polynomials may oscillate wildly:
-
+    
     >>> with warnings.catch_warnings():
     ...     warnings.simplefilter('ignore', np.RankWarning)
     ...     p30 = np.poly1d(np.polyfit(x, y, 30))
@@ -575,16 +641,13 @@
     -0.99999999999999445 # may vary
     >>> p30(4.5)
     -0.10547061179440398 # may vary
-
-    Illustration:
-
+    
     >>> import matplotlib.pyplot as plt
     >>> xp = np.linspace(-2, 6, 100)
     >>> _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')
     >>> plt.ylim(-2,2)
     (-2, 2)
     >>> plt.show()
-
     """
     order = int(deg) + 1
     x = NX.asarray(x) + 0.0
@@ -659,18 +722,30 @@
 
 
 def _polyval_dispatcher(p, x):
+    """
+
+    Parameters
+    ----------
+    p :
+        
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return (p, x)
 
 
 @array_function_dispatch(_polyval_dispatcher)
 def polyval(p, x):
-    """
-    Evaluate a polynomial at specific values.
-
+    """Evaluate a polynomial at specific values.
+    
     If `p` is of length N, this function returns the value:
-
+    
         ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``
-
+    
     If `x` is a sequence, then `p(x)` is returned for each element of `x`.
     If `x` is another polynomial then the composite polynomial `p(x(t))`
     is returned.
@@ -678,40 +753,37 @@
     Parameters
     ----------
     p : array_like or poly1d object
-       1D array of polynomial coefficients (including coefficients equal
-       to zero) from highest degree to the constant term, or an
-       instance of poly1d.
+        1D array of polynomial coefficients (including coefficients equal
+        to zero) from highest degree to the constant term, or an
+        instance of poly1d.
     x : array_like or poly1d object
-       A number, an array of numbers, or an instance of poly1d, at
-       which to evaluate `p`.
+        A number, an array of numbers, or an instance of poly1d, at
+        which to evaluate `p`.
 
     Returns
     -------
     values : ndarray or poly1d
-       If `x` is a poly1d instance, the result is the composition of the two
-       polynomials, i.e., `x` is "substituted" in `p` and the simplified
-       result is returned. In addition, the type of `x` - array_like or
-       poly1d - governs the type of the output: `x` array_like => `values`
-       array_like, `x` a poly1d object => `values` is also.
+        If `x` is a poly1d instance, the result is the composition of the two
+        polynomials, i.e., `x` is "substituted" in `p` and the simplified
+        result is returned. In addition, the type of `x` - array_like or
+        poly1d - governs the type of the output: `x` array_like => `values`
+        array_like, `x` a poly1d object => `values` is also.
 
     See Also
     --------
     poly1d: A polynomial class.
-
     Notes
     -----
     Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
     for polynomials of high degree the values may be inaccurate due to
     rounding errors. Use carefully.
-
+    
     If `x` is a subtype of `ndarray` the return value will be of the same type.
-
     References
     ----------
     .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
        trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand
        Reinhold Co., 1985, pg. 720.
-
     Examples
     --------
     >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1
@@ -722,7 +794,6 @@
     76
     >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
     poly1d([76.])
-
     """
     p = NX.asarray(p)
     if isinstance(x, poly1d):
@@ -736,14 +807,26 @@
 
 
 def _binary_op_dispatcher(a1, a2):
+    """
+
+    Parameters
+    ----------
+    a1 :
+        
+    a2 :
+        
+
+    Returns
+    -------
+
+    """
     return (a1, a2)
 
 
 @array_function_dispatch(_binary_op_dispatcher)
 def polyadd(a1, a2):
-    """
-    Find the sum of two polynomials.
-
+    """Find the sum of two polynomials.
+    
     Returns the polynomial resulting from the sum of two input polynomials.
     Each input must be either a poly1d object or a 1D sequence of polynomial
     coefficients, from highest to lowest degree.
@@ -752,6 +835,10 @@
     ----------
     a1, a2 : array_like or poly1d object
         Input polynomials.
+    a1 :
+        
+    a2 :
+        
 
     Returns
     -------
@@ -764,14 +851,13 @@
     --------
     poly1d : A one-dimensional polynomial class.
     poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
-
     Examples
     --------
+    
+    Using poly1d objects:
     >>> np.polyadd([1, 2], [9, 5, 4])
     array([9, 6, 6])
-
-    Using poly1d objects:
-
+    
     >>> p1 = np.poly1d([1, 2])
     >>> p2 = np.poly1d([9, 5, 4])
     >>> print(p1)
@@ -782,7 +868,6 @@
     >>> print(np.polyadd(p1, p2))
        2
     9 x + 6 x + 6
-
     """
     truepoly = (isinstance(a1, poly1d) or isinstance(a2, poly1d))
     a1 = atleast_1d(a1)
@@ -803,9 +888,8 @@
 
 @array_function_dispatch(_binary_op_dispatcher)
 def polysub(a1, a2):
-    """
-    Difference (subtraction) of two polynomials.
-
+    """Difference (subtraction) of two polynomials.
+    
     Given two polynomials `a1` and `a2`, returns ``a1 - a2``.
     `a1` and `a2` can be either array_like sequences of the polynomials'
     coefficients (including coefficients equal to zero), or `poly1d` objects.
@@ -814,6 +898,10 @@
     ----------
     a1, a2 : array_like or poly1d
         Minuend and subtrahend polynomials, respectively.
+    a1 :
+        
+    a2 :
+        
 
     Returns
     -------
@@ -823,14 +911,11 @@
     See Also
     --------
     polyval, polydiv, polymul, polyadd
-
     Examples
     --------
     .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)
-
     >>> np.polysub([2, 10, -2], [3, 10, -4])
     array([-1,  0,  2])
-
     """
     truepoly = (isinstance(a1, poly1d) or isinstance(a2, poly1d))
     a1 = atleast_1d(a1)
@@ -851,9 +936,8 @@
 
 @array_function_dispatch(_binary_op_dispatcher)
 def polymul(a1, a2):
-    """
-    Find the product of two polynomials.
-
+    """Find the product of two polynomials.
+    
     Finds the polynomial resulting from the multiplication of the two input
     polynomials. Each input must be either a poly1d object or a 1D sequence
     of polynomial coefficients, from highest to lowest degree.
@@ -862,6 +946,10 @@
     ----------
     a1, a2 : array_like or poly1d object
         Input polynomials.
+    a1 :
+        
+    a2 :
+        
 
     Returns
     -------
@@ -877,14 +965,13 @@
     poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
     convolve : Array convolution. Same output as polymul, but has parameter
                for overlap mode.
-
     Examples
     --------
+    
+    Using poly1d objects:
     >>> np.polymul([1, 2, 3], [9, 5, 1])
     array([ 9, 23, 38, 17,  3])
-
-    Using poly1d objects:
-
+    
     >>> p1 = np.poly1d([1, 2, 3])
     >>> p2 = np.poly1d([9, 5, 1])
     >>> print(p1)
@@ -896,7 +983,6 @@
     >>> print(np.polymul(p1, p2))
        4      3      2
     9 x + 23 x + 38 x + 17 x + 3
-
     """
     truepoly = (isinstance(a1, poly1d) or isinstance(a2, poly1d))
     a1, a2 = poly1d(a1), poly1d(a2)
@@ -907,14 +993,26 @@
 
 
 def _polydiv_dispatcher(u, v):
+    """
+
+    Parameters
+    ----------
+    u :
+        
+    v :
+        
+
+    Returns
+    -------
+
+    """
     return (u, v)
 
 
 @array_function_dispatch(_polydiv_dispatcher)
 def polydiv(u, v):
-    """
-    Returns the quotient and remainder of polynomial division.
-
+    """Returns the quotient and remainder of polynomial division.
+    
     The input arrays are the coefficients (including any coefficients
     equal to zero) of the "numerator" (dividend) and "denominator"
     (divisor) polynomials, respectively.
@@ -923,7 +1021,6 @@
     ----------
     u : array_like or poly1d
         Dividend polynomial's coefficients.
-
     v : array_like or poly1d
         Divisor polynomial's coefficients.
 
@@ -938,23 +1035,19 @@
     --------
     poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub
     polyval
-
     Notes
     -----
     Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need
     not equal `v.ndim`. In other words, all four possible combinations -
     ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,
     ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.
-
     Examples
     --------
     .. math:: \\frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25
-
     >>> x = np.array([3.0, 5.0, 2.0])
     >>> y = np.array([2.0, 1.0])
     >>> np.polydiv(x, y)
     (array([1.5 , 1.75]), array([0.25]))
-
     """
     truepoly = (isinstance(u, poly1d) or isinstance(u, poly1d))
     u = atleast_1d(u) + 0.0
@@ -978,6 +1071,19 @@
 
 _poly_mat = re.compile(r"[*][*]([0-9]*)")
 def _raise_power(astr, wrap=70):
+    """
+
+    Parameters
+    ----------
+    astr :
+        
+    wrap :
+         (Default value = 70)
+
+    Returns
+    -------
+
+    """
     n = 0
     line1 = ''
     line2 = ''
@@ -1006,9 +1112,8 @@
 
 @set_module('numpy')
 class poly1d:
-    """
-    A one-dimensional polynomial class.
-
+    """A one-dimensional polynomial class.
+    
     A convenience class, used to encapsulate "natural" operations on
     polynomials so that said operations may take on their customary
     form in code (see Examples).
@@ -1029,118 +1134,154 @@
         Changes the variable used when printing `p` from `x` to `variable`
         (see Examples).
 
+    Returns
+    -------
+
     Examples
     --------
     Construct the polynomial :math:`x^2 + 2x + 3`:
-
+    
+    
+    Evaluate the polynomial at :math:`x = 0.5`:
+    
+    
+    Find the roots:
+    
+    
+    These numbers in the previous line represent (0, 0) to machine precision
+    
+    Show the coefficients:
+    
+    
+    Display the order (the leading zero-coefficients are removed):
+    
+    
+    Show the coefficient of the k-th power in the polynomial
+    (which is equivalent to ``p.c[-(i+1)]``):
+    
+    
+    Polynomials can be added, subtracted, multiplied, and divided
+    (returns quotient and remainder):
+    
+    
+    
+    ``asarray(p)`` gives the coefficient array, so polynomials can be
+    used in all functions that accept arrays:
+    
+    
+    
+    The variable used in the string representation of `p` can be modified,
+    using the `variable` parameter:
+    
+    
+    Construct a polynomial from its roots:
+    
+    
+    This is the same polynomial as obtained by:
     >>> p = np.poly1d([1, 2, 3])
     >>> print(np.poly1d(p))
        2
     1 x + 2 x + 3
-
-    Evaluate the polynomial at :math:`x = 0.5`:
-
+    
     >>> p(0.5)
     4.25
-
-    Find the roots:
-
+    
     >>> p.r
     array([-1.+1.41421356j, -1.-1.41421356j])
     >>> p(p.r)
     array([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary
-
-    These numbers in the previous line represent (0, 0) to machine precision
-
-    Show the coefficients:
-
+    
     >>> p.c
     array([1, 2, 3])
-
-    Display the order (the leading zero-coefficients are removed):
-
+    
     >>> p.order
     2
-
-    Show the coefficient of the k-th power in the polynomial
-    (which is equivalent to ``p.c[-(i+1)]``):
-
+    
     >>> p[1]
     2
-
-    Polynomials can be added, subtracted, multiplied, and divided
-    (returns quotient and remainder):
-
+    
     >>> p * p
     poly1d([ 1,  4, 10, 12,  9])
-
+    
     >>> (p**3 + 4) / p
     (poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))
-
-    ``asarray(p)`` gives the coefficient array, so polynomials can be
-    used in all functions that accept arrays:
-
+    
     >>> p**2 # square of polynomial
     poly1d([ 1,  4, 10, 12,  9])
-
+    
     >>> np.square(p) # square of individual coefficients
     array([1, 4, 9])
-
-    The variable used in the string representation of `p` can be modified,
-    using the `variable` parameter:
-
+    
     >>> p = np.poly1d([1,2,3], variable='z')
     >>> print(p)
        2
     1 z + 2 z + 3
-
-    Construct a polynomial from its roots:
-
+    
     >>> np.poly1d([1, 2], True)
     poly1d([ 1., -3.,  2.])
-
-    This is the same polynomial as obtained by:
-
+    
     >>> np.poly1d([1, -1]) * np.poly1d([1, -2])
     poly1d([ 1, -3,  2])
-
     """
     __hash__ = None
 
     @property
     def coeffs(self):
-        """ The polynomial coefficients """
+        """The polynomial coefficients"""
         return self._coeffs
 
     @coeffs.setter
     def coeffs(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         # allowing this makes p.coeffs *= 2 legal
         if value is not self._coeffs:
             raise AttributeError("Cannot set attribute")
 
     @property
     def variable(self):
-        """ The name of the polynomial variable """
+        """The name of the polynomial variable"""
         return self._variable
 
     # calculated attributes
     @property
     def order(self):
-        """ The order or degree of the polynomial """
+        """The order or degree of the polynomial"""
         return len(self._coeffs) - 1
 
     @property
     def roots(self):
-        """ The roots of the polynomial, where self(x) == 0 """
+        """The roots of the polynomial, where self(x) == 0"""
         return roots(self._coeffs)
 
     # our internal _coeffs property need to be backed by __dict__['coeffs'] for
     # scipy to work correctly.
     @property
     def _coeffs(self):
+        """ """
         return self.__dict__['coeffs']
     @_coeffs.setter
     def _coeffs(self, coeffs):
+        """
+
+        Parameters
+        ----------
+        coeffs :
+            
+
+        Returns
+        -------
+
+        """
         self.__dict__['coeffs'] = coeffs
 
     # alias attributes
@@ -1198,6 +1339,17 @@
         N = len(coeffs)-1
 
         def fmt_float(q):
+            """
+
+            Parameters
+            ----------
+            q :
+                
+
+            Returns
+            -------
+
+            """
             s = '%.4g' % q
             if s.endswith('.0000'):
                 s = s[:-5]
@@ -1347,28 +1499,42 @@
         return iter(self.coeffs)
 
     def integ(self, m=1, k=0):
-        """
-        Return an antiderivative (indefinite integral) of this polynomial.
-
+        """Return an antiderivative (indefinite integral) of this polynomial.
+        
         Refer to `polyint` for full documentation.
+
+        Parameters
+        ----------
+        m :
+             (Default value = 1)
+        k :
+             (Default value = 0)
+
+        Returns
+        -------
 
         See Also
         --------
         polyint : equivalent function
-
         """
         return poly1d(polyint(self.coeffs, m=m, k=k))
 
     def deriv(self, m=1):
-        """
-        Return a derivative of this polynomial.
-
+        """Return a derivative of this polynomial.
+        
         Refer to `polyder` for full documentation.
+
+        Parameters
+        ----------
+        m :
+             (Default value = 1)
+
+        Returns
+        -------
 
         See Also
         --------
         polyder : equivalent function
-
         """
         return poly1d(polyder(self.coeffs, m=m))
 
