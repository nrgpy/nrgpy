# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/arraysetops.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/arraysetops.py
@@ -42,22 +42,36 @@
 
 
 def _ediff1d_dispatcher(ary, to_end=None, to_begin=None):
+    """
+
+    Parameters
+    ----------
+    ary :
+        
+    to_end :
+         (Default value = None)
+    to_begin :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ary, to_end, to_begin)
 
 
 @array_function_dispatch(_ediff1d_dispatcher)
 def ediff1d(ary, to_end=None, to_begin=None):
-    """
-    The differences between consecutive elements of an array.
+    """The differences between consecutive elements of an array.
 
     Parameters
     ----------
     ary : array_like
         If necessary, will be flattened before the differences are taken.
     to_end : array_like, optional
-        Number(s) to append at the end of the returned differences.
+        Number(s) to append at the end of the returned differences. (Default value = None)
     to_begin : array_like, optional
-        Number(s) to prepend at the beginning of the returned differences.
+        Number(s) to prepend at the beginning of the returned differences. (Default value = None)
 
     Returns
     -------
@@ -67,27 +81,25 @@
     See Also
     --------
     diff, gradient
-
     Notes
     -----
     When applied to masked arrays, this function drops the mask information
     if the `to_begin` and/or `to_end` parameters are used.
-
     Examples
     --------
+    
+    
+    The returned array is always 1D.
     >>> x = np.array([1, 2, 4, 7, 0])
     >>> np.ediff1d(x)
     array([ 1,  2,  3, -7])
-
+    
     >>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
     array([-99,   1,   2, ...,  -7,  88,  99])
-
-    The returned array is always 1D.
-
+    
     >>> y = [[1, 2, 4], [1, 6, 24]]
     >>> np.ediff1d(y)
     array([ 1,  2, -3,  5, 18])
-
     """
     # force a 1d array
     ary = np.asanyarray(ary).ravel()
@@ -134,7 +146,17 @@
 
 
 def _unpack_tuple(x):
-    """ Unpacks one-element tuples for use as return values """
+    """Unpacks one-element tuples for use as return values
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     if len(x) == 1:
         return x[0]
     else:
@@ -143,18 +165,36 @@
 
 def _unique_dispatcher(ar, return_index=None, return_inverse=None,
                        return_counts=None, axis=None):
+    """
+
+    Parameters
+    ----------
+    ar :
+        
+    return_index :
+         (Default value = None)
+    return_inverse :
+         (Default value = None)
+    return_counts :
+         (Default value = None)
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ar,)
 
 
 @array_function_dispatch(_unique_dispatcher)
 def unique(ar, return_index=False, return_inverse=False,
            return_counts=False, axis=None):
-    """
-    Find the unique elements of an array.
-
+    """Find the unique elements of an array.
+    
     Returns the sorted unique elements of an array. There are three optional
     outputs in addition to the unique elements:
-
+    
     * the indices of the input array that give the unique values
     * the indices of the unique array that reconstruct the input array
     * the number of times each unique value comes up in the input array
@@ -166,16 +206,14 @@
         is not already 1-D.
     return_index : bool, optional
         If True, also return the indices of `ar` (along the specified axis,
-        if provided, or in the flattened array) that result in the unique array.
+        if provided, or in the flattened array) that result in the unique array. (Default value = False)
     return_inverse : bool, optional
         If True, also return the indices of the unique array (for the specified
-        axis, if provided) that can be used to reconstruct `ar`.
+        axis, if provided) that can be used to reconstruct `ar`. (Default value = False)
     return_counts : bool, optional
         If True, also return the number of times each unique item appears
         in `ar`.
-
-        .. versionadded:: 1.9.0
-
+        .. versionadded:: 1.9.0 (Default value = False)
     axis : int or None, optional
         The axis to operate on. If None, `ar` will be flattened. If an integer,
         the subarrays indexed by the given axis will be flattened and treated
@@ -183,7 +221,6 @@
         see the notes for more details.  Object arrays or structured arrays
         that contain objects are not supported if the `axis` kwarg is used. The
         default is None.
-
         .. versionadded:: 1.13.0
 
     Returns
@@ -199,14 +236,12 @@
     unique_counts : ndarray, optional
         The number of times each of the unique values comes up in the
         original array. Only provided if `return_counts` is True.
-
         .. versionadded:: 1.9.0
 
     See Also
     --------
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Notes
     -----
     When an axis is specified the subarrays indexed by the axis are sorted.
@@ -218,23 +253,26 @@
     treated in the same way as any other 1-D array. The result is that the
     flattened subarrays are sorted in lexicographic order starting with the
     first element.
-
     Examples
     --------
+    
+    Return the unique rows of a 2D array
+    
+    
+    Return the indices of the original array that give the unique values:
+    
+    
+    Reconstruct the input array from the unique values:
     >>> np.unique([1, 1, 2, 2, 3, 3])
     array([1, 2, 3])
     >>> a = np.array([[1, 1], [2, 3]])
     >>> np.unique(a)
     array([1, 2, 3])
-
-    Return the unique rows of a 2D array
-
+    
     >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
     >>> np.unique(a, axis=0)
     array([[1, 0, 0], [2, 3, 4]])
-
-    Return the indices of the original array that give the unique values:
-
+    
     >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
     >>> u, indices = np.unique(a, return_index=True)
     >>> u
@@ -243,9 +281,7 @@
     array([0, 1, 3])
     >>> a[indices]
     array(['a', 'b', 'c'], dtype='<U1')
-
-    Reconstruct the input array from the unique values:
-
+    
     >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
     >>> u, indices = np.unique(a, return_inverse=True)
     >>> u
@@ -254,7 +290,6 @@
     array([0, 1, 4, 3, 1, 2, 1])
     >>> u[indices]
     array([1, 2, 6, 4, 2, 3, 2])
-
     """
     ar = np.asanyarray(ar)
     if axis is None:
@@ -294,6 +329,17 @@
         raise TypeError(msg.format(dt=ar.dtype))
 
     def reshape_uniq(uniq):
+        """
+
+        Parameters
+        ----------
+        uniq :
+            
+
+        Returns
+        -------
+
+        """
         n = len(uniq)
         uniq = uniq.view(orig_dtype)
         uniq = uniq.reshape(n, *orig_shape[1:])
@@ -308,8 +354,22 @@
 
 def _unique1d(ar, return_index=False, return_inverse=False,
               return_counts=False):
-    """
-    Find the unique elements of an array, ignoring shape.
+    """Find the unique elements of an array, ignoring shape.
+
+    Parameters
+    ----------
+    ar :
+        
+    return_index :
+         (Default value = False)
+    return_inverse :
+         (Default value = False)
+    return_counts :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     ar = np.asanyarray(ar).flatten()
 
@@ -341,14 +401,30 @@
 
 def _intersect1d_dispatcher(
         ar1, ar2, assume_unique=None, return_indices=None):
+    """
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = None)
+    return_indices :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ar1, ar2)
 
 
 @array_function_dispatch(_intersect1d_dispatcher)
 def intersect1d(ar1, ar2, assume_unique=False, return_indices=False):
-    """
-    Find the intersection of two arrays.
-
+    """Find the intersection of two arrays.
+    
     Return the sorted, unique values that are in both of the input arrays.
 
     Parameters
@@ -362,8 +438,11 @@
         If True, the indices which correspond to the intersection of the two
         arrays are returned. The first instance of a value is used if there are
         multiple. Default is False.
-
         .. versionadded:: 1.15.0
+    ar1 :
+        
+    ar2 :
+        
 
     Returns
     -------
@@ -376,26 +455,25 @@
         The indices of the first occurrences of the common values in `ar2`.
         Only provided if `return_indices` is True.
 
-
     See Also
     --------
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Examples
     --------
+    
+    To intersect more than two arrays, use functools.reduce:
+    
+    
+    To return the indices of the values common to the input arrays
+    along with the intersected values:
     >>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
     array([1, 3])
-
-    To intersect more than two arrays, use functools.reduce:
-
+    
     >>> from functools import reduce
     >>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
     array([3])
-
-    To return the indices of the values common to the input arrays
-    along with the intersected values:
-
+    
     >>> x = np.array([1, 1, 2, 3, 4])
     >>> y = np.array([2, 1, 4, 6])
     >>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
@@ -403,7 +481,6 @@
     (array([0, 2, 4]), array([1, 0, 2]))
     >>> xy, x[x_ind], y[y_ind]
     (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))
-
     """
     ar1 = np.asanyarray(ar1)
     ar2 = np.asanyarray(ar2)
@@ -442,14 +519,28 @@
 
 
 def _setxor1d_dispatcher(ar1, ar2, assume_unique=None):
+    """
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ar1, ar2)
 
 
 @array_function_dispatch(_setxor1d_dispatcher)
 def setxor1d(ar1, ar2, assume_unique=False):
-    """
-    Find the set exclusive-or of two arrays.
-
+    """Find the set exclusive-or of two arrays.
+    
     Return the sorted, unique values that are in only one (not both) of the
     input arrays.
 
@@ -460,6 +551,10 @@
     assume_unique : bool
         If True, the input arrays are both assumed to be unique, which
         can speed up the calculation.  Default is False.
+    ar1 :
+        
+    ar2 :
+        
 
     Returns
     -------
@@ -473,7 +568,6 @@
     >>> b = np.array([2, 3, 5, 7, 5])
     >>> np.setxor1d(a,b)
     array([1, 4, 5, 7])
-
     """
     if not assume_unique:
         ar1 = unique(ar1)
@@ -489,17 +583,33 @@
 
 
 def _in1d_dispatcher(ar1, ar2, assume_unique=None, invert=None):
+    """
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = None)
+    invert :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ar1, ar2)
 
 
 @array_function_dispatch(_in1d_dispatcher)
 def in1d(ar1, ar2, assume_unique=False, invert=False):
-    """
-    Test whether each element of a 1-D array is also present in a second array.
-
+    """Test whether each element of a 1-D array is also present in a second array.
+    
     Returns a boolean array the same length as `ar1` that is True
     where an element of `ar1` is in `ar2` and False otherwise.
-
+    
     We recommend using :func:`isin` instead of `in1d` for new code.
 
     Parameters
@@ -516,7 +626,6 @@
         False where an element of `ar1` is in `ar2` and True otherwise).
         Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
         to (but is faster than) ``np.invert(in1d(a, b))``.
-
         .. versionadded:: 1.8.0
 
     Returns
@@ -530,7 +639,6 @@
                             shape of ar1.
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Notes
     -----
     `in1d` can be considered as an element-wise function version of the
@@ -540,9 +648,8 @@
     container:  As ``ar2`` is converted to an array, in those cases
     ``asarray(ar2)`` is an object array rather than the expected array of
     contained values.
-
+    
     .. versionadded:: 1.4.0
-
     Examples
     --------
     >>> test = np.array([0, 1, 2, 5, 0])
@@ -606,13 +713,29 @@
 
 
 def _isin_dispatcher(element, test_elements, assume_unique=None, invert=None):
+    """
+
+    Parameters
+    ----------
+    element :
+        
+    test_elements :
+        
+    assume_unique :
+         (Default value = None)
+    invert :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (element, test_elements)
 
 
 @array_function_dispatch(_isin_dispatcher)
 def isin(element, test_elements, assume_unique=False, invert=False):
-    """
-    Calculates `element in test_elements`, broadcasting over `element` only.
+    """Calculates `element in test_elements`, broadcasting over `element` only.
     Returns a boolean array of the same shape as `element` that is True
     where an element of `element` is in `test_elements` and False otherwise.
 
@@ -644,25 +767,35 @@
     in1d                  : Flattened version of this function.
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Notes
     -----
-
+    
     `isin` is an element-wise function version of the python keyword `in`.
     ``isin(a, b)`` is roughly equivalent to
     ``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.
-
+    
     `element` and `test_elements` are converted to arrays if they are not
     already. If `test_elements` is a set (or other non-sequence collection)
     it will be converted to an object array with one element, rather than an
     array of the values contained in `test_elements`. This is a consequence
     of the `array` constructor's way of handling non-sequence collections.
     Converting the set to a list usually gives the desired behavior.
-
+    
     .. versionadded:: 1.13.0
-
     Examples
     --------
+    
+    The indices of the matched values can be obtained with `nonzero`:
+    
+    
+    The test can also be inverted:
+    
+    
+    Because of how `array` handles sets, the following does not
+    work as expected:
+    
+    
+    Casting the set to a list gives the expected result:
     >>> element = 2*np.arange(4).reshape((2, 2))
     >>> element
     array([[0, 2],
@@ -674,31 +807,22 @@
            [ True, False]])
     >>> element[mask]
     array([2, 4])
-
-    The indices of the matched values can be obtained with `nonzero`:
-
+    
     >>> np.nonzero(mask)
     (array([0, 1]), array([1, 0]))
-
-    The test can also be inverted:
-
+    
     >>> mask = np.isin(element, test_elements, invert=True)
     >>> mask
     array([[ True, False],
            [False,  True]])
     >>> element[mask]
     array([0, 6])
-
-    Because of how `array` handles sets, the following does not
-    work as expected:
-
+    
     >>> test_set = {1, 2, 4, 8}
     >>> np.isin(element, test_set)
     array([[False, False],
            [False, False]])
-
-    Casting the set to a list gives the expected result:
-
+    
     >>> np.isin(element, list(test_set))
     array([[False,  True],
            [ True, False]])
@@ -709,14 +833,26 @@
 
 
 def _union1d_dispatcher(ar1, ar2):
+    """
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+
+    Returns
+    -------
+
+    """
     return (ar1, ar2)
 
 
 @array_function_dispatch(_union1d_dispatcher)
 def union1d(ar1, ar2):
-    """
-    Find the union of two arrays.
-
+    """Find the union of two arrays.
+    
     Return the unique, sorted array of values that are in either of the two
     input arrays.
 
@@ -724,6 +860,10 @@
     ----------
     ar1, ar2 : array_like
         Input arrays. They are flattened if they are not already 1D.
+    ar1 :
+        
+    ar2 :
+        
 
     Returns
     -------
@@ -734,14 +874,13 @@
     --------
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Examples
     --------
+    
+    To find the union of more than two arrays, use functools.reduce:
     >>> np.union1d([-1, 0, 1], [-2, 0, 2])
     array([-2, -1,  0,  1,  2])
-
-    To find the union of more than two arrays, use functools.reduce:
-
+    
     >>> from functools import reduce
     >>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
     array([1, 2, 3, 4, 6])
@@ -750,14 +889,28 @@
 
 
 def _setdiff1d_dispatcher(ar1, ar2, assume_unique=None):
+    """
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (ar1, ar2)
 
 
 @array_function_dispatch(_setdiff1d_dispatcher)
 def setdiff1d(ar1, ar2, assume_unique=False):
-    """
-    Find the set difference of two arrays.
-
+    """Find the set difference of two arrays.
+    
     Return the unique values in `ar1` that are not in `ar2`.
 
     Parameters
@@ -781,14 +934,12 @@
     --------
     numpy.lib.arraysetops : Module with a number of other functions for
                             performing set operations on arrays.
-
     Examples
     --------
     >>> a = np.array([1, 2, 3, 2, 4, 1])
     >>> b = np.array([3, 4, 5, 6])
     >>> np.setdiff1d(a, b)
     array([1, 2])
-
     """
     if assume_unique:
         ar1 = np.asarray(ar1).ravel()
