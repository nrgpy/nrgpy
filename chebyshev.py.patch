# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/polynomial/chebyshev.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/polynomial/chebyshev.py
@@ -132,7 +132,7 @@
 
 def _cseries_to_zseries(c):
     """Covert Chebyshev series to z-series.
-
+    
     Covert a Chebyshev series to the equivalent z-series. The result is
     never an empty array. The dtype of the return is the same as that of
     the input. No checks are run on the arguments as this routine is for
@@ -145,9 +145,8 @@
 
     Returns
     -------
-    zs : 1-D ndarray
-        Odd length symmetric z-series, ordered from  low to high.
-
+
+    
     """
     n = c.size
     zs = np.zeros(2*n-1, dtype=c.dtype)
@@ -157,7 +156,7 @@
 
 def _zseries_to_cseries(zs):
     """Covert z-series to a Chebyshev series.
-
+    
     Covert a z series to the equivalent Chebyshev series. The result is
     never an empty array. The dtype of the return is the same as that of
     the input. No checks are run on the arguments as this routine is for
@@ -170,9 +169,8 @@
 
     Returns
     -------
-    c : 1-D ndarray
-        Chebyshev coefficients, ordered from  low to high.
-
+
+    
     """
     n = (zs.size + 1)//2
     c = zs[n-1:].copy()
@@ -182,13 +180,17 @@
 
 def _zseries_mul(z1, z2):
     """Multiply two z-series.
-
+    
     Multiply two z-series to produce a z-series.
 
     Parameters
     ----------
     z1, z2 : 1-D ndarray
         The arrays must be 1-D but this is not checked.
+    z1 :
+        
+    z2 :
+        
 
     Returns
     -------
@@ -199,17 +201,16 @@
     -----
     This is simply convolution. If symmetric/anti-symmetric z-series are
     denoted by S/A then the following rules apply:
-
+    
     S*S, A*A -> S
     S*A, A*S -> A
-
     """
     return np.convolve(z1, z2)
 
 
 def _zseries_div(z1, z2):
     """Divide the first z-series by the second.
-
+    
     Divide `z1` by `z2` and return the quotient and remainder as z-series.
     Warning: this implementation only applies when both z1 and z2 have the
     same symmetry, which is sufficient for present purposes.
@@ -219,10 +220,13 @@
     z1, z2 : 1-D ndarray
         The arrays must be 1-D and have the same symmetry, but this is not
         checked.
-
-    Returns
-    -------
-
+    z1 :
+        
+    z2 :
+        
+
+    Returns
+    -------
     (quotient, remainder) : 1-D ndarrays
         Quotient and remainder as z-series.
 
@@ -231,14 +235,13 @@
     This is not the same as polynomial division on account of the desired form
     of the remainder. If symmetric/anti-symmetric z-series are denoted by S/A
     then the following rules apply:
-
+    
     S/S -> S,S
     A/A -> S,A
-
+    
     The restriction to types of the same symmetry could be fixed but seems like
     unneeded generality. There is no natural form for the remainder in the case
     where there is no symmetry.
-
     """
     z1 = z1.copy()
     z2 = z2.copy()
@@ -276,7 +279,7 @@
 
 def _zseries_der(zs):
     """Differentiate a z-series.
-
+    
     The derivative is with respect to x, not z. This is achieved using the
     chain rule and the value of dx/dz given in the module notes.
 
@@ -297,7 +300,6 @@
     specialized scalar types. This scaling has been compensated by
     multiplying the value of zs by two also so that the two cancels in the
     division.
-
     """
     n = len(zs)//2
     ns = np.array([-1, 0, 1], dtype=zs.dtype)
@@ -308,7 +310,7 @@
 
 def _zseries_int(zs):
     """Integrate a z-series.
-
+    
     The integral is with respect to x, not z. This is achieved by a change
     of variable using dx/dz given in the module notes.
 
@@ -328,7 +330,6 @@
     using floats that are incompatible with Decimal and likely other
     specialized scalar types. This scaling has been compensated by
     dividing the resulting zs by two.
-
     """
     n = 1 + len(zs)//2
     ns = np.array([-1, 0, 1], dtype=zs.dtype)
@@ -345,9 +346,8 @@
 
 
 def poly2cheb(pol):
-    """
-    Convert a polynomial to a Chebyshev series.
-
+    """Convert a polynomial to a Chebyshev series.
+    
     Convert an array representing the coefficients of a polynomial (relative
     to the "standard" basis) ordered from lowest degree to highest, to an
     array of the coefficients of the equivalent Chebyshev series, ordered
@@ -367,12 +367,10 @@
     See Also
     --------
     cheb2poly
-
     Notes
     -----
     The easy way to do conversions between polynomial basis sets
     is to use the convert method of a class instance.
-
     Examples
     --------
     >>> from numpy import polynomial as P
@@ -384,7 +382,6 @@
     Chebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1.,  1.])
     >>> P.chebyshev.poly2cheb(range(4))
     array([1.  , 3.25, 1.  , 0.75])
-
     """
     [pol] = pu.as_series([pol])
     deg = len(pol) - 1
@@ -395,9 +392,8 @@
 
 
 def cheb2poly(c):
-    """
-    Convert a Chebyshev series to a polynomial.
-
+    """Convert a Chebyshev series to a polynomial.
+    
     Convert an array representing the coefficients of a Chebyshev series,
     ordered from lowest degree to highest, to an array of the coefficients
     of the equivalent polynomial (relative to the "standard" basis) ordered
@@ -419,12 +415,10 @@
     See Also
     --------
     poly2cheb
-
     Notes
     -----
     The easy way to do conversions between polynomial basis sets
     is to use the convert method of a class instance.
-
     Examples
     --------
     >>> from numpy import polynomial as P
@@ -436,7 +430,6 @@
     Polynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.])
     >>> P.chebyshev.cheb2poly(range(4))
     array([-2.,  -8.,   4.,  12.])
-
     """
     from .polynomial import polyadd, polysub, polymulx
 
@@ -474,15 +467,16 @@
 
 
 def chebline(off, scl):
-    """
-    Chebyshev series whose graph is a straight line.
-
-
+    """Chebyshev series whose graph is a straight line.
 
     Parameters
     ----------
     off, scl : scalars
         The specified line is given by ``off + scl*x``.
+    off :
+        
+    scl :
+        
 
     Returns
     -------
@@ -493,7 +487,6 @@
     See Also
     --------
     polyline
-
     Examples
     --------
     >>> import numpy.polynomial.chebyshev as C
@@ -501,7 +494,6 @@
     array([3, 2])
     >>> C.chebval(-3, C.chebline(3,2)) # should be -3
     -3.0
-
     """
     if scl != 0:
         return np.array([off, scl])
@@ -510,23 +502,22 @@
 
 
 def chebfromroots(roots):
-    """
-    Generate a Chebyshev series with given roots.
-
+    """Generate a Chebyshev series with given roots.
+    
     The function returns the coefficients of the polynomial
-
+    
     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
-
+    
     in Chebyshev form, where the `r_n` are the roots specified in `roots`.
     If a zero has multiplicity n, then it must appear in `roots` n times.
     For instance, if 2 is a root of multiplicity three and 3 is a root of
     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
     roots can appear in any order.
-
+    
     If the returned coefficients are `c`, then
-
+    
     .. math:: p(x) = c_0 + c_1 * T_1(x) + ... +  c_n * T_n(x)
-
+    
     The coefficient of the last term is not generally 1 for monic
     polynomials in Chebyshev form.
 
@@ -546,7 +537,6 @@
     See Also
     --------
     polyfromroots, legfromroots, lagfromroots, hermfromroots, hermefromroots
-
     Examples
     --------
     >>> import numpy.polynomial.chebyshev as C
@@ -555,15 +545,13 @@
     >>> j = complex(0,1)
     >>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
     array([1.5+0.j, 0. +0.j, 0.5+0.j])
-
     """
     return pu._fromroots(chebline, chebmul, roots)
 
 
 def chebadd(c1, c2):
-    """
-    Add one Chebyshev series to another.
-
+    """Add one Chebyshev series to another.
+    
     Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
     are sequences of coefficients ordered from lowest order term to
     highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
@@ -573,6 +561,10 @@
     c1, c2 : array_like
         1-D arrays of Chebyshev series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -582,14 +574,12 @@
     See Also
     --------
     chebsub, chebmulx, chebmul, chebdiv, chebpow
-
     Notes
     -----
     Unlike multiplication, division, etc., the sum of two Chebyshev series
     is a Chebyshev series (without having to "reproject" the result onto
     the basis set) so addition, just like that of "standard" polynomials,
     is simply "component-wise."
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -597,15 +587,13 @@
     >>> c2 = (3,2,1)
     >>> C.chebadd(c1,c2)
     array([4., 4., 4.])
-
     """
     return pu._add(c1, c2)
 
 
 def chebsub(c1, c2):
-    """
-    Subtract one Chebyshev series from another.
-
+    """Subtract one Chebyshev series from another.
+    
     Returns the difference of two Chebyshev series `c1` - `c2`.  The
     sequences of coefficients are from lowest order term to highest, i.e.,
     [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
@@ -615,6 +603,10 @@
     c1, c2 : array_like
         1-D arrays of Chebyshev series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -624,14 +616,12 @@
     See Also
     --------
     chebadd, chebmulx, chebmul, chebdiv, chebpow
-
     Notes
     -----
     Unlike multiplication, division, etc., the difference of two Chebyshev
     series is a Chebyshev series (without having to "reproject" the result
     onto the basis set) so subtraction, just like that of "standard"
     polynomials, is simply "component-wise."
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -641,17 +631,15 @@
     array([-2.,  0.,  2.])
     >>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)
     array([ 2.,  0., -2.])
-
     """
     return pu._sub(c1, c2)
 
 
 def chebmulx(c):
     """Multiply a Chebyshev series by x.
-
+    
     Multiply the polynomial `c` by x, where x is the independent
     variable.
-
 
     Parameters
     ----------
@@ -666,15 +654,13 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.5.0
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
     >>> C.chebmulx([1,2,3])
     array([1. , 2.5, 1. , 1.5])
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -693,9 +679,8 @@
 
 
 def chebmul(c1, c2):
-    """
-    Multiply one Chebyshev series by another.
-
+    """Multiply one Chebyshev series by another.
+    
     Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
     are sequences of coefficients, from lowest order "term" to highest,
     e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
@@ -705,6 +690,10 @@
     c1, c2 : array_like
         1-D arrays of Chebyshev series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -714,7 +703,6 @@
     See Also
     --------
     chebadd, chebsub, chebmulx, chebdiv, chebpow
-
     Notes
     -----
     In general, the (polynomial) product of two C-series results in terms
@@ -722,7 +710,6 @@
     the product as a C-series, it is typically necessary to "reproject"
     the product onto said basis set, which typically produces
     "unintuitive live" (but correct) results; see Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -730,7 +717,6 @@
     >>> c2 = (3,2,1)
     >>> C.chebmul(c1,c2) # multiplication requires "reprojection"
     array([  6.5,  12. ,  12. ,   4. ,   1.5])
-
     """
     # c1, c2 are trimmed copies
     [c1, c2] = pu.as_series([c1, c2])
@@ -742,9 +728,8 @@
 
 
 def chebdiv(c1, c2):
-    """
-    Divide one Chebyshev series by another.
-
+    """Divide one Chebyshev series by another.
+    
     Returns the quotient-with-remainder of two Chebyshev series
     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
     order "term" to highest, e.g., [1,2,3] represents the series
@@ -755,6 +740,10 @@
     c1, c2 : array_like
         1-D arrays of Chebyshev series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -765,7 +754,6 @@
     See Also
     --------
     chebadd, chebsub, chemulx, chebmul, chebpow
-
     Notes
     -----
     In general, the (polynomial) division of one C-series by another
@@ -774,7 +762,6 @@
     is typically necessary to "reproject" the results onto said basis
     set, which typically produces "unintuitive" (but correct) results;
     see Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -785,7 +772,6 @@
     >>> c2 = (0,1,2,3)
     >>> C.chebdiv(c2,c1) # neither "intuitive"
     (array([0., 2.]), array([-2., -4.]))
-
     """
     # c1, c2 are trimmed copies
     [c1, c2] = pu.as_series([c1, c2])
@@ -810,7 +796,7 @@
 
 def chebpow(c, pow, maxpower=16):
     """Raise a Chebyshev series to a power.
-
+    
     Returns the Chebyshev series `c` raised to the power `pow`. The
     argument `c` is a sequence of coefficients ordered from low to high.
     i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``
@@ -834,13 +820,11 @@
     See Also
     --------
     chebadd, chebsub, chebmulx, chebmul, chebdiv
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
     >>> C.chebpow([1, 2, 3, 4], 2)
     array([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])
-
     """
     # note: this is more efficient than `pu._pow(chebmul, c1, c2)`, as it
     # avoids converting between z and c series repeatedly
@@ -867,9 +851,8 @@
 
 
 def chebder(c, m=1, scl=1, axis=0):
-    """
-    Differentiate a Chebyshev series.
-
+    """Differentiate a Chebyshev series.
+    
     Returns the Chebyshev series coefficients `c` differentiated `m` times
     along `axis`.  At each iteration the result is multiplied by `scl` (the
     scaling factor is for use in a linear change of variable). The argument
@@ -893,7 +876,6 @@
         variable. (Default: 1)
     axis : int, optional
         Axis over which the derivative is taken. (Default: 0).
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -904,14 +886,12 @@
     See Also
     --------
     chebint
-
     Notes
     -----
     In general, the result of differentiating a C-series needs to be
     "reprojected" onto the C-series basis set. Thus, typically, the
     result of this function is "unintuitive," albeit correct; see Examples
     section below.
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -924,7 +904,6 @@
     array([-14., -12., -24.])
     >>> C.chebder(c,2,-1)
     array([12.,  96.])
-
     """
     c = np.array(c, ndmin=1, copy=True)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -959,9 +938,8 @@
 
 
 def chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
-    """
-    Integrate a Chebyshev series.
-
+    """Integrate a Chebyshev series.
+    
     Returns the Chebyshev series coefficients `c` integrated `m` times from
     `lbnd` along `axis`. At each iteration the resulting series is
     **multiplied** by `scl` and an integration constant, `k`, is added.
@@ -995,7 +973,6 @@
         before the integration constant is added. (Default: 1)
     axis : int, optional
         Axis over which the integral is taken. (Default: 0).
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -1012,7 +989,6 @@
     See Also
     --------
     chebder
-
     Notes
     -----
     Note that the result of each integration is *multiplied* by `scl`.
@@ -1020,12 +996,11 @@
     variable :math:`u = ax + b` in an integral relative to `x`.  Then
     :math:`dx = du/a`, so one will need to set `scl` equal to
     :math:`1/a`- perhaps not what one would have first thought.
-
+    
     Also note that, in general, the result of integrating a C-series needs
     to be "reprojected" onto the C-series basis set.  Thus, typically,
     the result of this function is "unintuitive," albeit correct; see
     Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial import chebyshev as C
@@ -1041,7 +1016,6 @@
     array([ 8.5, -0.5,  0.5,  0.5])
     >>> C.chebint(c,scl=-2)
     array([-1.,  1., -1., -1.])
-
     """
     c = np.array(c, ndmin=1, copy=True)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -1086,24 +1060,23 @@
 
 
 def chebval(x, c, tensor=True):
-    """
-    Evaluate a Chebyshev series at points x.
-
+    """Evaluate a Chebyshev series at points x.
+    
     If `c` is of length `n + 1`, this function returns the value:
-
+    
     .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)
-
+    
     The parameter `x` is converted to an array only if it is a tuple or a
     list, otherwise it is treated as a scalar. In either case, either `x`
     or its elements must support multiplication and addition both with
     themselves and with the elements of `c`.
-
+    
     If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
     `c` is multidimensional, then the shape of the result depends on the
     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
     scalars have shape (,).
-
+    
     Trailing zeros in the coefficients will be used in the evaluation, so
     they should be avoided if efficiency is a concern.
 
@@ -1127,7 +1100,6 @@
         `c` is evaluated for every element of `x`. If False, `x` is broadcast
         over the columns of `c` for the evaluation.  This keyword is useful
         when `c` is multidimensional. The default value is True.
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -1138,14 +1110,11 @@
     See Also
     --------
     chebval2d, chebgrid2d, chebval3d, chebgrid3d
-
     Notes
     -----
     The evaluation uses Clenshaw recursion, aka synthetic division.
-
     Examples
     --------
-
     """
     c = np.array(c, ndmin=1, copy=True)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -1173,19 +1142,18 @@
 
 
 def chebval2d(x, y, c):
-    """
-    Evaluate a 2-D Chebyshev series at points (x, y).
-
+    """Evaluate a 2-D Chebyshev series at points (x, y).
+    
     This function returns the values:
-
+    
     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * T_i(x) * T_j(y)
-
+    
     The parameters `x` and `y` are converted to arrays only if they are
     tuples or a lists, otherwise they are treated as a scalars and they
     must have the same shape after conversion. In either case, either `x`
     and `y` or their elements must support multiplication and addition both
     with themselves and with the elements of `c`.
-
+    
     If `c` is a 1-D array a one is implicitly appended to its shape to make
     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
 
@@ -1201,6 +1169,10 @@
         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
         dimension greater than 2 the remaining indices enumerate multiple
         sets of coefficients.
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -1211,33 +1183,30 @@
     See Also
     --------
     chebval, chebgrid2d, chebval3d, chebgrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._valnd(chebval, c, x, y)
 
 
 def chebgrid2d(x, y, c):
-    """
-    Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.
-
+    """Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.
+    
     This function returns the values:
-
+    
     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * T_i(a) * T_j(b),
-
+    
     where the points `(a, b)` consist of all pairs formed by taking
     `a` from `x` and `b` from `y`. The resulting points form a grid with
     `x` in the first dimension and `y` in the second.
-
+    
     The parameters `x` and `y` are converted to arrays only if they are
     tuples or a lists, otherwise they are treated as a scalars. In either
     case, either `x` and `y` or their elements must support multiplication
     and addition both with themselves and with the elements of `c`.
-
+    
     If `c` has fewer than two dimensions, ones are implicitly appended to
     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
     x.shape + y.shape.
@@ -1254,6 +1223,10 @@
         multi-degree i,j is contained in `c[i,j]`. If `c` has dimension
         greater than two the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -1264,30 +1237,27 @@
     See Also
     --------
     chebval, chebval2d, chebval3d, chebgrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._gridnd(chebval, c, x, y)
 
 
 def chebval3d(x, y, z, c):
-    """
-    Evaluate a 3-D Chebyshev series at points (x, y, z).
-
+    """Evaluate a 3-D Chebyshev series at points (x, y, z).
+    
     This function returns the values:
-
+    
     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * T_i(x) * T_j(y) * T_k(z)
-
+    
     The parameters `x`, `y`, and `z` are converted to arrays only if
     they are tuples or a lists, otherwise they are treated as a scalars and
     they must have the same shape after conversion. In either case, either
     `x`, `y`, and `z` or their elements must support multiplication and
     addition both with themselves and with the elements of `c`.
-
+    
     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
     shape to make it 3-D. The shape of the result will be c.shape[3:] +
     x.shape.
@@ -1305,6 +1275,12 @@
         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
         greater than 3 the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1315,35 +1291,32 @@
     See Also
     --------
     chebval, chebval2d, chebgrid2d, chebgrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._valnd(chebval, c, x, y, z)
 
 
 def chebgrid3d(x, y, z, c):
-    """
-    Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.
-
+    """Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.
+    
     This function returns the values:
-
+    
     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)
-
+    
     where the points `(a, b, c)` consist of all triples formed by taking
     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
     a grid with `x` in the first dimension, `y` in the second, and `z` in
     the third.
-
+    
     The parameters `x`, `y`, and `z` are converted to arrays only if they
     are tuples or a lists, otherwise they are treated as a scalars. In
     either case, either `x`, `y`, and `z` or their elements must support
     multiplication and addition both with themselves and with the elements
     of `c`.
-
+    
     If `c` has fewer than three dimensions, ones are implicitly appended to
     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
     x.shape + y.shape + z.shape.
@@ -1361,6 +1334,12 @@
         degree i,j are contained in ``c[i,j]``. If `c` has dimension
         greater than two the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1371,27 +1350,25 @@
     See Also
     --------
     chebval, chebval2d, chebgrid2d, chebval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._gridnd(chebval, c, x, y, z)
 
 
 def chebvander(x, deg):
     """Pseudo-Vandermonde matrix of given degree.
-
+    
     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
     `x`. The pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., i] = T_i(x),
-
+    
     where `0 <= i <= deg`. The leading indices of `V` index the elements of
     `x` and the last index is the degree of the Chebyshev polynomial.
-
+    
     If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
     matrix ``V = chebvander(x, n)``, then ``np.dot(V, c)`` and
     ``chebval(x, c)`` are the same up to roundoff.  This equivalence is
@@ -1409,12 +1386,8 @@
 
     Returns
     -------
-    vander : ndarray
-        The pseudo Vandermonde matrix. The shape of the returned matrix is
-        ``x.shape + (deg + 1,)``, where The last index is the degree of the
-        corresponding Chebyshev polynomial.  The dtype will be the same as
-        the converted `x`.
-
+
+    
     """
     ideg = pu._deprecate_as_int(deg, "deg")
     if ideg < 0:
@@ -1436,22 +1409,22 @@
 
 def chebvander2d(x, y, deg):
     """Pseudo-Vandermonde matrix of given degrees.
-
+    
     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
     points `(x, y)`. The pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., (deg[1] + 1)*i + j] = T_i(x) * T_j(y),
-
+    
     where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
     `V` index the points `(x, y)` and the last index encodes the degrees of
     the Chebyshev polynomials.
-
+    
     If ``V = chebvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
     correspond to the elements of a 2-D coefficient array `c` of shape
     (xdeg + 1, ydeg + 1) in the order
-
+    
     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
-
+    
     and ``np.dot(V, c.flat)`` and ``chebval2d(x, y, c)`` will be the same
     up to roundoff. This equivalence is useful both for least squares
     fitting and for the evaluation of a large number of 2-D Chebyshev
@@ -1466,6 +1439,10 @@
         1-D arrays.
     deg : list of ints
         List of maximum degrees of the form [x_deg, y_deg].
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -1477,35 +1454,33 @@
     See Also
     --------
     chebvander, chebvander3d, chebval2d, chebval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._vander_nd_flat((chebvander, chebvander), (x, y), deg)
 
 
 def chebvander3d(x, y, z, deg):
     """Pseudo-Vandermonde matrix of given degrees.
-
+    
     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
     points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
     then The pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),
-
+    
     where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
     indices of `V` index the points `(x, y, z)` and the last index encodes
     the degrees of the Chebyshev polynomials.
-
+    
     If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
     of `V` correspond to the elements of a 3-D coefficient array `c` of
     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
-
+    
     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
-
+    
     and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the
     same up to roundoff. This equivalence is useful both for least squares
     fitting and for the evaluation of a large number of 3-D Chebyshev
@@ -1520,6 +1495,12 @@
         arrays.
     deg : list of ints
         List of maximum degrees of the form [x_deg, y_deg, z_deg].
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1531,29 +1512,26 @@
     See Also
     --------
     chebvander, chebvander3d, chebval2d, chebval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._vander_nd_flat((chebvander, chebvander, chebvander), (x, y, z), deg)
 
 
 def chebfit(x, y, deg, rcond=None, full=False, w=None):
-    """
-    Least squares fit of Chebyshev series to data.
-
+    """Least squares fit of Chebyshev series to data.
+    
     Return the coefficients of a Chebyshev series of degree `deg` that is the
     least squares fit to the data values `y` given at points `x`. If `y` is
     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
     fits are done, one for each column of `y`, and the resulting
     coefficients are stored in the corresponding columns of a 2-D return.
     The fitted polynomial(s) are in the form
-
+    
     .. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),
-
+    
     where `n` is `deg`.
 
     Parameters
@@ -1583,7 +1561,6 @@
         ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
         weights are chosen so that the errors of the products ``w[i]*y[i]``
         all have the same variance.  The default value is None.
-
         .. versionadded:: 1.5.0
 
     Returns
@@ -1592,26 +1569,21 @@
         Chebyshev coefficients ordered from low to high. If `y` was 2-D,
         the coefficients for the data in column k  of `y` are in column
         `k`.
-
     [residuals, rank, singular_values, rcond] : list
         These values are only returned if `full` = True
-
         resid -- sum of squared residuals of the least squares fit
         rank -- the numerical rank of the scaled Vandermonde matrix
         sv -- singular values of the scaled Vandermonde matrix
         rcond -- value of `rcond`.
-
         For more details, see `linalg.lstsq`.
-
     Warns
-    -----
+        
+    -----
+        
     RankWarning
         The rank of the coefficient matrix in the least-squares fit is
         deficient. The warning is only raised if `full` = False.  The
         warnings can be turned off by
-
-        >>> import warnings
-        >>> warnings.simplefilter('ignore', np.RankWarning)
 
     See Also
     --------
@@ -1621,51 +1593,49 @@
     chebweight : Chebyshev weight function.
     linalg.lstsq : Computes a least-squares fit from the matrix.
     scipy.interpolate.UnivariateSpline : Computes spline fits.
-
     Notes
     -----
     The solution is the coefficients of the Chebyshev series `p` that
     minimizes the sum of the weighted squared errors
-
+    
     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
-
+    
     where :math:`w_j` are the weights. This problem is solved by setting up
     as the (typically) overdetermined matrix equation
-
+    
     .. math:: V(x) * c = w * y,
-
+    
     where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
     coefficients to be solved for, `w` are the weights, and `y` are the
     observed values.  This equation is then solved using the singular value
     decomposition of `V`.
-
+    
     If some of the singular values of `V` are so small that they are
     neglected, then a `RankWarning` will be issued. This means that the
     coefficient values may be poorly determined. Using a lower order fit
     will usually get rid of the warning.  The `rcond` parameter can also be
     set to a value smaller than its default, but the resulting fit may be
     spurious and have large contributions from roundoff error.
-
+    
     Fits using Chebyshev series are usually better conditioned than fits
     using power series, but much can depend on the distribution of the
     sample points and the smoothness of the data. If the quality of the fit
     is inadequate splines may be a good alternative.
-
     References
     ----------
     .. [1] Wikipedia, "Curve fitting",
            https://en.wikipedia.org/wiki/Curve_fitting
-
     Examples
     --------
-
+    >>> import warnings
+        >>> warnings.simplefilter('ignore', np.RankWarning)
     """
     return pu._fit(chebvander, x, y, deg, rcond, full, w)
 
 
 def chebcompanion(c):
     """Return the scaled companion matrix of c.
-
+    
     The basis polynomials are scaled so that the companion matrix is
     symmetric when `c` is a Chebyshev basis polynomial. This provides
     better eigenvalue estimates than the unscaled case and for basis
@@ -1685,9 +1655,8 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.7.0
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -1709,11 +1678,10 @@
 
 
 def chebroots(c):
-    """
-    Compute the roots of a Chebyshev series.
-
+    """Compute the roots of a Chebyshev series.
+    
     Return the roots (a.k.a. "zeros") of the polynomial
-
+    
     .. math:: p(x) = \\sum_i c[i] * T_i(x).
 
     Parameters
@@ -1730,7 +1698,6 @@
     See Also
     --------
     polyroots, legroots, lagroots, hermroots, hermeroots
-
     Notes
     -----
     The root estimates are obtained as the eigenvalues of the companion
@@ -1740,16 +1707,14 @@
     errors as the value of the series near such points is relatively
     insensitive to errors in the roots. Isolated roots near the origin can
     be improved by a few iterations of Newton's method.
-
+    
     The Chebyshev series basis polynomials aren't powers of `x` so the
     results of this function may seem unintuitive.
-
     Examples
     --------
     >>> import numpy.polynomial.chebyshev as cheb
     >>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots
     array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -1767,12 +1732,12 @@
 
 def chebinterpolate(func, deg, args=()):
     """Interpolate a function at the Chebyshev points of the first kind.
-
+    
     Returns the Chebyshev series that interpolates `func` at the Chebyshev
     points of the first kind in the interval [-1, 1]. The interpolating
     series tends to a minmax approximation to `func` with increasing `deg`
     if the function is continuous in the interval.
-
+    
     .. versionadded:: 1.14.0
 
     Parameters
@@ -1795,15 +1760,9 @@
 
     Examples
     --------
-    >>> import numpy.polynomial.chebyshev as C
-    >>> C.chebfromfunction(lambda x: np.tanh(x) + 0.5, 8)
-    array([  5.00000000e-01,   8.11675684e-01,  -9.86864911e-17,
-            -5.42457905e-02,  -2.71387850e-16,   4.51658839e-03,
-             2.46716228e-17,  -3.79694221e-04,  -3.26899002e-16])
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     The Chebyshev polynomials used in the interpolation are orthogonal when
     sampled at the Chebyshev points of the first kind. If it is desired to
     constrain some of the coefficients they can simply be set to the desired
@@ -1811,7 +1770,11 @@
     is especially useful if it is known apriori that some of coefficients are
     zero. For instance, if the function is even then the coefficients of the
     terms of odd degree in the result can be set to zero.
-
+    >>> import numpy.polynomial.chebyshev as C
+    >>> C.chebfromfunction(lambda x: np.tanh(x) + 0.5, 8)
+    array([  5.00000000e-01,   8.11675684e-01,  -9.86864911e-17,
+            -5.42457905e-02,  -2.71387850e-16,   4.51658839e-03,
+             2.46716228e-17,  -3.79694221e-04,  -3.26899002e-16])
     """
     deg = np.asarray(deg)
 
@@ -1833,9 +1796,8 @@
 
 
 def chebgauss(deg):
-    """
-    Gauss-Chebyshev quadrature.
-
+    """Gauss-Chebyshev quadrature.
+    
     Computes the sample points and weights for Gauss-Chebyshev quadrature.
     These sample points and weights will correctly integrate polynomials of
     degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
@@ -1855,17 +1817,16 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.7.0
-
+    
     The results have only been tested up to degree 100, higher degrees may
     be problematic. For Gauss-Chebyshev there are closed form solutions for
     the sample points and weights. If n = `deg`, then
-
+    
     .. math:: x_i = \\cos(\\pi (2 i - 1) / (2 n))
-
+    
     .. math:: w_i = \\pi / n
-
     """
     ideg = pu._deprecate_as_int(deg, "deg")
     if ideg <= 0:
@@ -1878,9 +1839,8 @@
 
 
 def chebweight(x):
-    """
-    The weight function of the Chebyshev polynomials.
-
+    """The weight function of the Chebyshev polynomials.
+    
     The weight function is :math:`1/\\sqrt{1 - x^2}` and the interval of
     integration is :math:`[-1, 1]`. The Chebyshev polynomials are
     orthogonal, but not normalized, with respect to this weight function.
@@ -1888,27 +1848,25 @@
     Parameters
     ----------
     x : array_like
-       Values at which the weight function will be computed.
+        Values at which the weight function will be computed.
 
     Returns
     -------
     w : ndarray
-       The weight function at `x`.
-
-    Notes
-    -----
-
+        The weight function at `x`.
+
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     w = 1./(np.sqrt(1. + x) * np.sqrt(1. - x))
     return w
 
 
 def chebpts1(npts):
-    """
-    Chebyshev points of the first kind.
-
+    """Chebyshev points of the first kind.
+    
     The Chebyshev points of the first kind are the points ``cos(x)``,
     where ``x = [pi*(k + .5)/npts for k in range(npts)]``.
 
@@ -1925,12 +1883,10 @@
     See Also
     --------
     chebpts2
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.5.0
-
     """
     _npts = int(npts)
     if _npts != npts:
@@ -1943,9 +1899,8 @@
 
 
 def chebpts2(npts):
-    """
-    Chebyshev points of the second kind.
-
+    """Chebyshev points of the second kind.
+    
     The Chebyshev points of the second kind are the points ``cos(x)``,
     where ``x = [pi*k/(npts - 1) for k in range(npts)]``.
 
@@ -1961,9 +1916,8 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.5.0
-
     """
     _npts = int(npts)
     if _npts != npts:
@@ -1981,25 +1935,18 @@
 
 class Chebyshev(ABCPolyBase):
     """A Chebyshev series class.
-
+    
     The Chebyshev class provides the standard Python numerical methods
     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
     methods listed below.
 
     Parameters
     ----------
-    coef : array_like
-        Chebyshev coefficients in order of increasing degree, i.e.,
-        ``(1, 2, 3)`` gives ``1*T_0(x) + 2*T_1(x) + 3*T_2(x)``.
-    domain : (2,) array_like, optional
-        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
-        to the interval ``[window[0], window[1]]`` by shifting and scaling.
-        The default value is [-1, 1].
-    window : (2,) array_like, optional
-        Window, see `domain` for its use. The default value is [-1, 1].
-
-        .. versionadded:: 1.6.0
-
+
+    Returns
+    -------
+
+    
     """
     # Virtual Functions
     _add = staticmethod(chebadd)
@@ -2018,12 +1965,12 @@
     @classmethod
     def interpolate(cls, func, deg, domain=None, args=()):
         """Interpolate a function at the Chebyshev points of the first kind.
-
+        
         Returns the series that interpolates `func` at the Chebyshev points of
         the first kind scaled and shifted to the `domain`. The resulting series
         tends to a minmax approximation of `func` when the function is
         continuous in the domain.
-
+        
         .. versionadded:: 1.14.0
 
         Parameters
@@ -2049,7 +1996,6 @@
         Notes
         -----
         See `numpy.polynomial.chebfromfunction` for more details.
-
         """
         if domain is None:
             domain = cls.domain
