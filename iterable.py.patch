# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/value/iterable.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/value/iterable.py
@@ -23,10 +23,23 @@
 
 
 class IterableMixin(object):
+    """ """
     def py__next__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self.py__iter__(contextualized_node)
 
     def py__stop_iteration_returns(self):
+        """ """
         return ValueSet([compiled.builtin_from_name(self.inference_state, u'None')])
 
     # At the moment, safe values are simple values like "foo", 1 and not
@@ -38,6 +51,17 @@
     if sys.version_info[0] == 2:
         # Python 2...........
         def get_safe_value(self, default=sentinel):
+            """
+
+            Parameters
+            ----------
+            default :
+                 (Default value = sentinel)
+
+            Returns
+            -------
+
+            """
             if default is sentinel:
                 raise ValueError("There exists no safe value for value %s" % self)
             return default
@@ -46,37 +70,66 @@
 
 
 class GeneratorBase(LazyAttributeOverwrite, IterableMixin):
+    """ """
     array_type = None
 
     def _get_wrapped_value(self):
+        """ """
         instance, = self._get_cls().execute_annotation()
         return instance
 
     def _get_cls(self):
+        """ """
         generator, = self.inference_state.typing_module.py__getattribute__('Generator')
         return generator
 
     def py__bool__(self):
+        """ """
         return True
 
     @publish_method('__iter__')
     def _iter(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet([self])
 
     @publish_method('send')
     @publish_method('next', python_version_match=2)
     @publish_method('__next__', python_version_match=3)
     def _next(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())
 
     def py__stop_iteration_returns(self):
+        """ """
         return ValueSet([compiled.builtin_from_name(self.inference_state, u'None')])
 
     @property
     def name(self):
+        """ """
         return compiled.CompiledValueName(self, 'Generator')
 
     def get_annotated_class_object(self):
+        """ """
         from jedi.inference.gradual.generics import TupleGenericManager
         gen_values = self.merge_types_of_iterate().py__class__()
         gm = TupleGenericManager((gen_values, NO_VALUES, NO_VALUES))
@@ -90,12 +143,24 @@
         self._func_execution_context = func_execution_context
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         iterators = self._func_execution_context.infer_annotations()
         if iterators:
             return iterators.iterate(contextualized_node)
         return self._func_execution_context.get_yield_lazy_values()
 
     def py__stop_iteration_returns(self):
+        """ """
         return self._func_execution_context.get_return_values()
 
     def __repr__(self):
@@ -103,6 +168,21 @@
 
 
 def comprehension_from_atom(inference_state, value, atom):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    value :
+        
+    atom :
+        
+
+    Returns
+    -------
+
+    """
     bracket = atom.children[0]
     test_list_comp = atom.children[1]
 
@@ -139,11 +219,38 @@
 
 
 class ComprehensionMixin(object):
+    """ """
     @inference_state_method_cache()
     def _get_comp_for_context(self, parent_context, comp_for):
+        """
+
+        Parameters
+        ----------
+        parent_context :
+            
+        comp_for :
+            
+
+        Returns
+        -------
+
+        """
         return CompForContext(parent_context, comp_for)
 
     def _nested(self, comp_fors, parent_context=None):
+        """
+
+        Parameters
+        ----------
+        comp_fors :
+            
+        parent_context :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         comp_for = comp_fors[0]
 
         is_async = comp_for.parent.type == 'comp_for'
@@ -176,11 +283,23 @@
     @inference_state_method_cache(default=[])
     @to_list
     def _iterate(self):
+        """ """
         comp_fors = tuple(get_sync_comp_fors(self._sync_comp_for_node))
         for result in self._nested(comp_fors):
             yield result
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for set_ in self._iterate():
             yield LazyKnownValues(set_)
 
@@ -189,25 +308,32 @@
 
 
 class _DictMixin(object):
+    """ """
     def _get_generics(self):
+        """ """
         return tuple(c_set.py__class__() for c_set in self.get_mapping_item_values())
 
 
 class Sequence(LazyAttributeOverwrite, IterableMixin):
+    """ """
     api_type = u'instance'
 
     @property
     def name(self):
+        """ """
         return compiled.CompiledValueName(self, self.array_type)
 
     def _get_generics(self):
+        """ """
         return (self.merge_types_of_iterate().py__class__(),)
 
     @inference_state_method_cache(default=())
     def _cached_generics(self):
+        """ """
         return self._get_generics()
 
     def _get_wrapped_value(self):
+        """ """
         from jedi.inference.gradual.base import GenericClass
         from jedi.inference.gradual.generics import TupleGenericManager
         klass = compiled.builtin_from_name(self.inference_state, self.array_type)
@@ -218,19 +344,35 @@
         return c
 
     def py__bool__(self):
+        """ """
         return None  # We don't know the length, because of appends.
 
     @safe_property
     def parent(self):
+        """ """
         return self.inference_state.builtins_module
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         if self.array_type == 'dict':
             return self._dict_values()
         return iterate_values(ValueSet([self]))
 
 
 class _BaseComprehension(ComprehensionMixin):
+    """ """
     def __init__(self, inference_state, defining_context, sync_comp_for_node, entry_node):
         assert sync_comp_for_node.type == 'sync_comp_for'
         super(_BaseComprehension, self).__init__(inference_state)
@@ -240,9 +382,21 @@
 
 
 class ListComprehension(_BaseComprehension, Sequence):
+    """ """
     array_type = u'list'
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(index, slice):
             return ValueSet([self])
 
@@ -253,24 +407,30 @@
 
 
 class SetComprehension(_BaseComprehension, Sequence):
+    """ """
     array_type = u'set'
 
 
 class GeneratorComprehension(_BaseComprehension, GeneratorBase):
+    """ """
     pass
 
 
 class _DictKeyMixin(object):
+    """ """
     # TODO merge with _DictMixin?
     def get_mapping_item_values(self):
+        """ """
         return self._dict_keys(), self._dict_values()
 
     def get_key_values(self):
+        """ """
         # TODO merge with _dict_keys?
         return self._dict_keys()
 
 
 class DictComprehension(ComprehensionMixin, Sequence, _DictKeyMixin):
+    """ """
     array_type = u'dict'
 
     def __init__(self, inference_state, defining_context, sync_comp_for_node, key_node, value_node):
@@ -282,10 +442,32 @@
         self._value_node = value_node
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for keys, values in self._iterate():
             yield LazyKnownValues(keys)
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         for keys, values in self._iterate():
             for k in keys:
                 # Be careful in the future if refactoring, index could be a
@@ -295,18 +477,42 @@
         raise SimpleGetItemNotFound()
 
     def _dict_keys(self):
+        """ """
         return ValueSet.from_sets(keys for keys, values in self._iterate())
 
     def _dict_values(self):
+        """ """
         return ValueSet.from_sets(values for keys, values in self._iterate())
 
     @publish_method('values')
     def _imitate_values(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         lazy_value = LazyKnownValues(self._dict_values())
         return ValueSet([FakeList(self.inference_state, [lazy_value])])
 
     @publish_method('items')
     def _imitate_items(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         lazy_values = [
             LazyKnownValue(
                 FakeTuple(
@@ -321,12 +527,14 @@
         return ValueSet([FakeList(self.inference_state, lazy_values)])
 
     def exact_key_items(self):
+        """ """
         # NOTE: A smarter thing can probably done here to achieve better
         # completions, but at least like this jedi doesn't crash
         return []
 
 
 class SequenceLiteralValue(Sequence):
+    """ """
     _TUPLE_LIKE = 'testlist_star_expr', 'testlist', 'subscriptlist'
     mapping = {'(': u'tuple',
                '[': u'list',
@@ -344,12 +552,23 @@
             """The builtin name of the array (list, set, tuple or dict)."""
 
     def _get_generics(self):
+        """ """
         if self.array_type == u'tuple':
             return tuple(x.infer().py__class__() for x in self.py__iter__())
         return super(SequenceLiteralValue, self)._get_generics()
 
     def py__simple_getitem__(self, index):
-        """Here the index is an int/str. Raises IndexError/KeyError."""
+        """Here the index is an int/str. Raises IndexError/KeyError.
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(index, slice):
             return ValueSet([self])
         else:
@@ -358,9 +577,17 @@
             return self._defining_context.infer_node(node)
 
     def py__iter__(self, contextualized_node=None):
-        """
-        While values returns the possible values for any array field, this
+        """While values returns the possible values for any array field, this
         function returns the value for a certain index.
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         for node in self.get_tree_entries():
             if node == ':' or node.type == 'subscript':
@@ -373,10 +600,12 @@
             yield addition
 
     def py__len__(self):
+        """ """
         # This function is not really used often. It's more of a try.
         return len(self.get_tree_entries())
 
     def get_tree_entries(self):
+        """ """
         c = self.atom.children
 
         if self.atom.type in self._TUPLE_LIKE:
@@ -422,9 +651,15 @@
                 return [array_node]
 
     def exact_key_items(self):
-        """
-        Returns a generator of tuples like dict.items(), where the key is
+        """Returns a generator of tuples like dict.items(), where the key is
         resolved (as a string) and the values are still lazy values.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         for key_node, value in self.get_tree_entries():
             for key in self._defining_context.infer_node(key_node):
@@ -436,6 +671,7 @@
 
 
 class DictLiteralValue(_DictMixin, SequenceLiteralValue, _DictKeyMixin):
+    """ """
     array_type = u'dict'
 
     def __init__(self, inference_state, defining_context, atom):
@@ -444,7 +680,17 @@
         self.atom = atom
 
     def py__simple_getitem__(self, index):
-        """Here the index is an int/str. Raises IndexError/KeyError."""
+        """Here the index is an int/str. Raises IndexError/KeyError.
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         compiled_value_index = compiled.create_simple_object(self.inference_state, index)
         for key, value in self.get_tree_entries():
             for k in self._defining_context.infer_node(key):
@@ -454,9 +700,17 @@
         raise SimpleGetItemNotFound('No key found in dictionary %s.' % self)
 
     def py__iter__(self, contextualized_node=None):
-        """
-        While values returns the possible values for any array field, this
+        """While values returns the possible values for any array field, this
         function returns the value for a certain index.
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         # Get keys.
         types = NO_VALUES
@@ -469,11 +723,33 @@
 
     @publish_method('values')
     def _imitate_values(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         lazy_value = LazyKnownValues(self._dict_values())
         return ValueSet([FakeList(self.inference_state, [lazy_value])])
 
     @publish_method('items')
     def _imitate_items(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         lazy_values = [
             LazyKnownValue(FakeTuple(
                 self.inference_state,
@@ -485,12 +761,14 @@
         return ValueSet([FakeList(self.inference_state, lazy_values)])
 
     def _dict_values(self):
+        """ """
         return ValueSet.from_sets(
             self._defining_context.infer_node(v)
             for k, v in self.get_tree_entries()
         )
 
     def _dict_keys(self):
+        """ """
         return ValueSet.from_sets(
             self._defining_context.infer_node(k)
             for k, v in self.get_tree_entries()
@@ -499,13 +777,22 @@
 
 class _FakeSequence(Sequence):
     def __init__(self, inference_state, lazy_value_list):
-        """
-        type should be one of "tuple", "list"
-        """
+    """type should be one of "tuple", "list""""
         super(_FakeSequence, self).__init__(inference_state)
         self._lazy_value_list = lazy_value_list
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(index, slice):
             return ValueSet([self])
 
@@ -514,9 +801,21 @@
         return lazy_value.infer()
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self._lazy_value_list
 
     def py__bool__(self):
+        """ """
         return bool(len(self._lazy_value_list))
 
     def __repr__(self):
@@ -524,14 +823,17 @@
 
 
 class FakeTuple(_FakeSequence):
+    """ """
     array_type = u'tuple'
 
 
 class FakeList(_FakeSequence):
+    """ """
     array_type = u'tuple'
 
 
 class FakeDict(_DictMixin, Sequence, _DictKeyMixin):
+    """ """
     array_type = u'dict'
 
     def __init__(self, inference_state, dct):
@@ -539,10 +841,32 @@
         self._dct = dct
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for key in self._dct:
             yield LazyKnownValue(compiled.create_simple_object(self.inference_state, key))
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if is_py3 and self.inference_state.environment.version_info.major == 2:
             # In Python 2 bytes and unicode compare.
             if isinstance(index, bytes):
@@ -564,18 +888,32 @@
 
     @publish_method('values')
     def _values(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet([FakeTuple(
             self.inference_state,
             [LazyKnownValues(self._dict_values())]
         )])
 
     def _dict_values(self):
+        """ """
         return ValueSet.from_sets(lazy_value.infer() for lazy_value in self._dct.values())
 
     def _dict_keys(self):
+        """ """
         return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())
 
     def exact_key_items(self):
+        """ """
         return self._dct.items()
 
     def __repr__(self):
@@ -583,23 +921,58 @@
 
 
 class MergedArray(Sequence):
+    """ """
     def __init__(self, inference_state, arrays):
         super(MergedArray, self).__init__(inference_state)
         self.array_type = arrays[-1].array_type
         self._arrays = arrays
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for array in self._arrays:
             for lazy_value in array.py__iter__():
                 yield lazy_value
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(lazy_value.infer() for lazy_value in self.py__iter__())
 
 
 def unpack_tuple_to_dict(context, types, exprlist):
-    """
-    Unpacking tuple assignments in for statements and expr_stmts.
+    """Unpacking tuple assignments in for statements and expr_stmts.
+
+    Parameters
+    ----------
+    context :
+        
+    types :
+        
+    exprlist :
+        
+
+    Returns
+    -------
+
     """
     if exprlist.type == 'name':
         return {exprlist.value: types}
@@ -636,6 +1009,7 @@
 
 
 class Slice(LazyValueWrapper):
+    """ """
     def __init__(self, python_context, start, stop, step):
         self.inference_state = python_context.inference_state
         self._context = python_context
@@ -645,16 +1019,36 @@
         self._step = step
 
     def _get_wrapped_value(self):
+        """ """
         value = compiled.builtin_from_name(self._context.inference_state, 'slice')
         slice_value, = value.execute_with_values()
         return slice_value
 
     def get_safe_value(self, default=sentinel):
-        """
-        Imitate CompiledValue.obj behavior and return a ``builtin.slice()``
+        """Imitate CompiledValue.obj behavior and return a ``builtin.slice()``
         object.
+
+        Parameters
+        ----------
+        default :
+             (Default value = sentinel)
+
+        Returns
+        -------
+
         """
         def get(element):
+            """
+
+            Parameters
+            ----------
+            element :
+                
+
+            Returns
+            -------
+
+            """
             if element is None:
                 return None
 
