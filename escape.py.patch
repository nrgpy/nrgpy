# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/escape.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/escape.py
@@ -42,14 +42,25 @@
 
 def xhtml_escape(value: Union[str, bytes]) -> str:
     """Escapes a string so it is valid within HTML or XML.
-
+    
     Escapes the characters ``<``, ``>``, ``"``, ``'``, and ``&``.
     When used in attribute values the escaped strings must be enclosed
     in quotes.
-
+    
     .. versionchanged:: 3.2
-
+    
        Added the single quote to the list of escaped characters.
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
     """
     return _XHTML_ESCAPE_RE.sub(
         lambda match: _XHTML_ESCAPE_DICT[match.group(0)], to_basestring(value)
@@ -57,7 +68,19 @@
 
 
 def xhtml_unescape(value: Union[str, bytes]) -> str:
-    """Un-escapes an XML-escaped string."""
+    """Un-escapes an XML-escaped string.
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
+    """
     return re.sub(r"&(#?)(\w+?);", _convert_entity, _unicode(value))
 
 
@@ -65,7 +88,17 @@
 # Please see https://github.com/tornadoweb/tornado/pull/706
 # before sending a pull request that adds **kwargs to this function.
 def json_encode(value: Any) -> str:
-    """JSON-encodes the given Python object."""
+    """JSON-encodes the given Python object.
+
+    Parameters
+    ----------
+    value: Any :
+        
+
+    Returns
+    -------
+
+    """
     # JSON permits but does not require forward slashes to be escaped.
     # This is useful when json data is emitted in a <script> tag
     # in HTML, as it prevents </script> tags from prematurely terminating
@@ -77,27 +110,61 @@
 
 def json_decode(value: Union[str, bytes]) -> Any:
     """Returns Python objects for the given JSON string.
-
+    
     Supports both `str` and `bytes` inputs.
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
     """
     return json.loads(to_basestring(value))
 
 
 def squeeze(value: str) -> str:
-    """Replace all sequences of whitespace chars with a single space."""
+    """Replace all sequences of whitespace chars with a single space.
+
+    Parameters
+    ----------
+    value: str :
+        
+
+    Returns
+    -------
+
+    """
     return re.sub(r"[\x00-\x20]+", " ", value).strip()
 
 
 def url_escape(value: Union[str, bytes], plus: bool = True) -> str:
     """Returns a URL-encoded version of the given value.
-
+    
     If ``plus`` is true (the default), spaces will be represented
     as "+" instead of "%20".  This is appropriate for query strings
     but not for the path component of a URL.  Note that this default
     is the reverse of Python's urllib module.
-
+    
     .. versionadded:: 3.1
         The ``plus`` argument
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+    plus: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     quote = urllib.parse.quote_plus if plus else urllib.parse.quote
     return quote(utf8(value))
@@ -105,6 +172,23 @@
 
 @typing.overload
 def url_unescape(value: Union[str, bytes], encoding: None, plus: bool = True) -> bytes:
+    """
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+    encoding: None :
+        
+    plus: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     pass
 
 
@@ -112,6 +196,23 @@
 def url_unescape(
     value: Union[str, bytes], encoding: str = "utf-8", plus: bool = True
 ) -> str:
+    """
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+    encoding: str :
+         (Default value = "utf-8")
+    plus: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     pass
 
 
@@ -119,20 +220,35 @@
     value: Union[str, bytes], encoding: Optional[str] = "utf-8", plus: bool = True
 ) -> Union[str, bytes]:
     """Decodes the given value from a URL.
-
+    
     The argument may be either a byte or unicode string.
-
+    
     If encoding is None, the result will be a byte string.  Otherwise,
     the result is a unicode string in the specified encoding.
-
+    
     If ``plus`` is true (the default), plus signs will be interpreted
     as spaces (literal plus signs must be represented as "%2B").  This
     is appropriate for query strings and form-encoded values but not
     for the path component of a URL.  Note that this default is the
     reverse of Python's urllib module.
-
+    
     .. versionadded:: 3.1
        The ``plus`` argument
+
+    Parameters
+    ----------
+    # noqa: F811value: Union[str :
+        
+    bytes] :
+        
+    encoding: Optional[str] :
+         (Default value = "utf-8")
+    plus: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     if encoding is None:
         if plus:
@@ -149,10 +265,25 @@
 ) -> Dict[str, List[bytes]]:
     """Parses a query string like urlparse.parse_qs,
     but takes bytes and returns the values as byte strings.
-
+    
     Keys still become type str (interpreted as latin1 in python3!)
     because it's too painful to keep them as byte strings in
     python3 and in practice they're nearly always ascii anyway.
+
+    Parameters
+    ----------
+    qs: Union[str :
+        
+    bytes] :
+        
+    keep_blank_values: bool :
+         (Default value = False)
+    strict_parsing: bool :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     # This is gross, but python3 doesn't give us another way.
     # Latin1 is the universal donor of character encodings.
@@ -172,24 +303,70 @@
 
 @typing.overload
 def utf8(value: bytes) -> bytes:
+    """
+
+    Parameters
+    ----------
+    value: bytes :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 @typing.overload  # noqa: F811
 def utf8(value: str) -> bytes:
+    """
+
+    Parameters
+    ----------
+    value: str :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 @typing.overload  # noqa: F811
 def utf8(value: None) -> None:
+    """
+
+    Parameters
+    ----------
+    value: None :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 def utf8(value: Union[None, str, bytes]) -> Optional[bytes]:  # noqa: F811
     """Converts a string argument to a byte string.
-
+    
     If the argument is already a byte string or None, it is returned unchanged.
     Otherwise it must be a unicode string and is encoded as utf8.
+
+    Parameters
+    ----------
+    value: Union[None :
+        
+    str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(value, _UTF8_TYPES):
         return value
@@ -203,24 +380,70 @@
 
 @typing.overload
 def to_unicode(value: str) -> str:
+    """
+
+    Parameters
+    ----------
+    value: str :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 @typing.overload  # noqa: F811
 def to_unicode(value: bytes) -> str:
+    """
+
+    Parameters
+    ----------
+    value: bytes :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 @typing.overload  # noqa: F811
 def to_unicode(value: None) -> None:
+    """
+
+    Parameters
+    ----------
+    value: None :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 def to_unicode(value: Union[None, str, bytes]) -> Optional[str]:  # noqa: F811
     """Converts a string argument to a unicode string.
-
+    
     If the argument is already a unicode string or None, it is returned
     unchanged.  Otherwise it must be a byte string and is decoded as utf8.
+
+    Parameters
+    ----------
+    value: Union[None :
+        
+    str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(value, _TO_UNICODE_TYPES):
         return value
@@ -241,8 +464,17 @@
 
 def recursive_unicode(obj: Any) -> Any:
     """Walks a simple data structure, converting byte strings to unicode.
-
+    
     Supports lists, tuples, and dictionaries.
+
+    Parameters
+    ----------
+    obj: Any :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(obj, dict):
         return dict(
@@ -280,38 +512,78 @@
     permitted_protocols: List[str] = ["http", "https"],
 ) -> str:
     """Converts plain text into HTML with links.
-
+    
     For example: ``linkify("Hello http://tornadoweb.org!")`` would return
     ``Hello <a href="http://tornadoweb.org">http://tornadoweb.org</a>!``
 
-    Parameters:
-
-    * ``shorten``: Long urls will be shortened for display.
-
-    * ``extra_params``: Extra text to include in the link tag, or a callable
-      taking the link as an argument and returning the extra text
-      e.g. ``linkify(text, extra_params='rel="nofollow" class="external"')``,
-      or::
-
-          def extra_params_cb(url):
-              if url.startswith("http://example.com"):
-                  return 'class="internal"'
-              else:
-                  return 'class="external" rel="nofollow"'
-          linkify(text, extra_params=extra_params_cb)
-
-    * ``require_protocol``: Only linkify urls which include a protocol. If
-      this is False, urls such as www.facebook.com will also be linkified.
-
-    * ``permitted_protocols``: List (or set) of protocols which should be
-      linkified, e.g. ``linkify(text, permitted_protocols=["http", "ftp",
-      "mailto"])``. It is very unsafe to include protocols such as
-      ``javascript``.
+    Parameters
+    ----------
+    shorten :
+        Long urls will be shortened for display
+    extra_params :
+        Extra text to include in the link tag
+    taking :
+        the link as an argument and returning the extra text
+    e :
+        
+    or :
+        
+    def :
+        extra_params_cb
+    if :
+        url
+    return :
+        class
+    else :
+        
+    text: Union[str :
+        
+    bytes] :
+        
+    shorten: bool :
+         (Default value = False)
+    extra_params: Union[str :
+        
+    Callable[[str] :
+        
+    str]] :
+         (Default value = "")
+    require_protocol: bool :
+         (Default value = False)
+    permitted_protocols: List[str] :
+         (Default value = ["http")
+    "https"] :
+        
+
+    Returns
+    -------
+    type
+        linkify(text, extra_params=extra_params_cb)
+        
+        * ``require_protocol``: Only linkify urls which include a protocol. If
+        this is False, urls such as www.facebook.com will also be linkified.
+        
+        * ``permitted_protocols``: List (or set) of protocols which should be
+        linkified, e.g. ``linkify(text, permitted_protocols=["http", "ftp",
+        "mailto"])``. It is very unsafe to include protocols such as
+        ``javascript``.
+
     """
     if extra_params and not callable(extra_params):
         extra_params = " " + extra_params.strip()
 
     def make_link(m: typing.Match) -> str:
+        """
+
+        Parameters
+        ----------
+        m: typing.Match :
+            
+
+        Returns
+        -------
+
+        """
         url = m.group(1)
         proto = m.group(2)
         if require_protocol and not proto:
@@ -378,6 +650,17 @@
 
 
 def _convert_entity(m: typing.Match) -> str:
+    """
+
+    Parameters
+    ----------
+    m: typing.Match :
+        
+
+    Returns
+    -------
+
+    """
     if m.group(1) == "#":
         try:
             if m.group(2)[:1].lower() == "x":
@@ -393,6 +676,7 @@
 
 
 def _build_unicode_map() -> Dict[str, str]:
+    """ """
     unicode_map = {}
     for name, value in html.entities.name2codepoint.items():
         unicode_map[name] = chr(value)
