# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/api/classes.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/api/classes.py
@@ -35,15 +35,33 @@
 
 
 def _sort_names_by_start_pos(names):
+    """
+
+    Parameters
+    ----------
+    names :
+        
+
+    Returns
+    -------
+
+    """
     return sorted(names, key=lambda s: s.start_pos or (0, 0))
 
 
 def defined_names(inference_state, context):
-    """
-    List sub-definitions (e.g., methods in class).
-
-    :type scope: Scope
-    :rtype: list of Name
+    """List sub-definitions (e.g., methods in class).
+
+    Parameters
+    ----------
+    inference_state :
+        
+    context :
+        
+
+    Returns
+    -------
+
     """
     filter = next(context.get_filters())
     names = [name for name in filter.values()]
@@ -51,13 +69,22 @@
 
 
 def _values_to_definitions(values):
+    """
+
+    Parameters
+    ----------
+    values :
+        
+
+    Returns
+    -------
+
+    """
     return [Name(c.inference_state, c.name) for c in values]
 
 
 class BaseName(object):
-    """
-    The base class for all definitions, completions and signatures.
-    """
+    """The base class for all definitions, completions and signatures."""
     _mapping = {
         'posixpath': 'os.path',
         'riscospath': 'os.path',
@@ -88,6 +115,7 @@
 
     @memoize_method
     def _get_module_context(self):
+        """ """
         # This can take a while to complete, because in the worst case of
         # imports (consider `import a` completions), we need to load all
         # modules starting with a first.
@@ -95,11 +123,7 @@
 
     @property
     def module_path(self):
-        """
-        Shows the file path of a module. e.g. ``/usr/lib/python2.7/os.py``
-
-        :rtype: str or None
-        """
+        """Shows the file path of a module. e.g. ``/usr/lib/python2.7/os.py``"""
         module = self._get_module_context()
         if module.is_stub() or not module.is_compiled():
             # Compiled modules should not return a module path even if they
@@ -110,24 +134,45 @@
 
     @property
     def name(self):
-        """
-        Name of variable/function/class/module.
-
+        """Name of variable/function/class/module.
+        
         For example, for ``x = None`` it returns ``'x'``.
 
-        :rtype: str or None
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._name.get_public_name()
 
     @property
     def type(self):
-        """
-        The type of the definition.
-
+        """The type of the definition.
+        
         Here is an example of the value of this attribute.  Let's consider
         the following source.  As what is in ``variable`` is unambiguous
         to Jedi, :meth:`jedi.Script.infer` should return a list of
         definition for ``sys``, ``f``, ``C`` and ``x``.
+        
+        
+        
+        Before showing what is in ``defs``, let's sort it by :attr:`line`
+        so that it is easy to relate the result to the source code.
+        
+        
+        Finally, here is what you can get from :attr:`type`:
+        
+        
+        Valid values for type are ``module``, ``class``, ``instance``, ``function``,
+        ``param``, ``path``, ``keyword`` and ``statement``.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         >>> from jedi._compatibility import no_unicode_pprint
         >>> from jedi import Script
@@ -147,22 +192,17 @@
         ...
         ... for variable in [keyword, f, C, x]:
         ...     variable'''
-
+        
         >>> script = Script(source)
         >>> defs = script.infer()
-
-        Before showing what is in ``defs``, let's sort it by :attr:`line`
-        so that it is easy to relate the result to the source code.
-
+        
         >>> defs = sorted(defs, key=lambda d: d.line)
         >>> no_unicode_pprint(defs)  # doctest: +NORMALIZE_WHITESPACE
         [<Name full_name='keyword', description='module keyword'>,
          <Name full_name='__main__.C', description='class C'>,
          <Name full_name='__main__.D', description='instance D'>,
          <Name full_name='__main__.f', description='def f'>]
-
-        Finally, here is what you can get from :attr:`type`:
-
+        
         >>> defs = [str(d.type) for d in defs]  # It's unicode and in Py2 has u before it.
         >>> defs[0]
         'module'
@@ -172,10 +212,6 @@
         'instance'
         >>> defs[3]
         'function'
-
-        Valid values for type are ``module``, ``class``, ``instance``, ``function``,
-        ``param``, ``path``, ``keyword`` and ``statement``.
-
         """
         tree_name = self._name.tree_name
         resolve = False
@@ -193,9 +229,14 @@
 
     @property
     def module_name(self):
-        """
-        The module name, a bit similar to what ``__name__`` is in a random
+        """The module name, a bit similar to what ``__name__`` is in a random
         Python module.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         >>> from jedi import Script
         >>> source = 'import json'
@@ -207,9 +248,7 @@
         return self._get_module_context().py__name__()
 
     def in_builtin_module(self):
-        """
-        Returns True, if this is a builtin module.
-        """
+        """Returns True, if this is a builtin module."""
         value = self._get_module_context().get_value()
         if isinstance(value, StubModuleValue):
             return any(v.is_compiled() for v in value.non_stub_value_set)
@@ -232,11 +271,15 @@
         return start_pos[1]
 
     def get_definition_start_position(self):
-        """
-        The (row, column) of the start of the definition range. Rows start with
+        """The (row, column) of the start of the definition range. Rows start with
         1, columns start with 0.
 
-        :rtype: Optional[Tuple[int, int]]
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._name.tree_name is None:
             return None
@@ -246,11 +289,15 @@
         return definition.start_pos
 
     def get_definition_end_position(self):
-        """
-        The (row, column) of the end of the definition range. Rows start with
+        """The (row, column) of the end of the definition range. Rows start with
         1, columns start with 0.
 
-        :rtype: Optional[Tuple[int, int]]
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._name.tree_name is None:
             return None
@@ -265,10 +312,29 @@
         return definition.end_pos
 
     def docstring(self, raw=False, fast=True):
-        r"""
+        """r"""
         Return a document string for this completion object.
-
+        
         Example:
+        
+        
+        Notice that useful extra information is added to the actual
+        docstring, e.g. function signatures are prepended to their docstrings.
+        If you need the actual docstring, use ``raw=True`` instead.
+
+        Parameters
+        ----------
+        fast :
+            Don't follow imports that are only one level deep like
+            ``import foo``, but follow ``from foo import bar``. This makes
+            sense for speed reasons. Completing `import a` is slow if you use
+            the ``foo.docstring(fast=False)`` on every object, because it
+            parses all libraries starting with ``a``. (Default value = True)
+        raw :
+             (Default value = False)
+
+        Returns
+        -------
 
         >>> from jedi import Script
         >>> source = '''\
@@ -281,20 +347,9 @@
         f(a, b=1)
         <BLANKLINE>
         Document for function f.
-
-        Notice that useful extra information is added to the actual
-        docstring, e.g. function signatures are prepended to their docstrings.
-        If you need the actual docstring, use ``raw=True`` instead.
-
+        
         >>> print(script.infer(1, len('def f'))[0].docstring(raw=True))
         Document for function f.
-
-        :param fast: Don't follow imports that are only one level deep like
-            ``import foo``, but follow ``from foo import bar``. This makes
-            sense for speed reasons. Completing `import a` is slow if you use
-            the ``foo.docstring(fast=False)`` on every object, because it
-            parses all libraries starting with ``a``.
-        """
         if isinstance(self._name, ImportName) and fast:
             return ''
         doc = self._get_docstring()
@@ -308,9 +363,11 @@
             return signature_text + doc
 
     def _get_docstring(self):
+        """ """
         return self._name.py__doc__()
 
     def _get_docstring_signature(self):
+        """ """
         return '\n'.join(
             signature.to_string()
             for signature in self._get_signatures(for_docstring=True)
@@ -318,11 +375,16 @@
 
     @property
     def description(self):
-        """
-        A description of the :class:`.Name` object, which is heavily used
+        """A description of the :class:`.Name` object, which is heavily used
         in testing. e.g. for ``isinstance`` it returns ``def isinstance``.
-
+        
         Example:
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         >>> from jedi._compatibility import no_unicode_pprint
         >>> from jedi import Script
@@ -344,7 +406,6 @@
         'def f'
         >>> str(defs[1].description)
         'class C'
-
         """
         typ = self.type
         tree_name = self._name.tree_name
@@ -368,14 +429,25 @@
 
     @property
     def full_name(self):
-        """
-        Dot-separated path of this object.
-
+        """Dot-separated path of this object.
+        
         It is in the form of ``<module>[.<submodule>[...]][.<object>]``.
         It is useful when you want to look up Python manual of the
         object at hand.
-
+        
         Example:
+        
+        
+        Notice that it returns ``'os.path.join'`` instead of (for example)
+        ``'posixpath.join'``. This is not correct, since the modules name would
+        be ``<module 'posixpath' ...>```. However most users find the latter
+        more practical.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         >>> from jedi import Script
         >>> source = '''
@@ -384,11 +456,6 @@
         >>> script = Script(source, path='example.py')
         >>> print(script.infer(3, len('os.path.join'))[0].full_name)
         os.path.join
-
-        Notice that it returns ``'os.path.join'`` instead of (for example)
-        ``'posixpath.join'``. This is not correct, since the modules name would
-        be ``<module 'posixpath' ...>```. However most users find the latter
-        more practical.
         """
         if not self._name.is_value_name:
             return None
@@ -406,18 +473,22 @@
         return '.'.join(names)
 
     def is_stub(self):
-        """
-        Returns True if the current name is defined in a stub file.
-        """
+        """Returns True if the current name is defined in a stub file."""
         if not self._name.is_value_name:
             return False
 
         return self._name.get_root_context().is_stub()
 
     def is_side_effect(self):
-        """
-        Checks if a name is defined as ``self.foo = 3``. In case of self, this
+        """Checks if a name is defined as ``self.foo = 3``. In case of self, this
         function would return False, for foo it would return True.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         tree_name = self._name.tree_name
         if tree_name is None:
@@ -425,22 +496,43 @@
         return tree_name.is_definition() and tree_name.parent.type == 'trailer'
 
     def goto(self, **kwargs):
-        """
-        Like :meth:`.Script.goto` (also supports the same params), but does it
+        """Like :meth:`.Script.goto` (also supports the same params), but does it
         for the current name. This is typically useful if you are using
         something like :meth:`.Script.get_names()`.
 
-        :param follow_imports: The goto call will follow imports.
-        :param follow_builtin_imports: If follow_imports is True will try to
+        Parameters
+        ----------
+        follow_imports :
+            The goto call will follow imports.
+        follow_builtin_imports :
+            If follow_imports is True will try to
             look up names in builtins (i.e. compiled or extension modules).
-        :param only_stubs: Only return stubs for this goto call.
-        :param prefer_stubs: Prefer stubs to Python objects for this goto call.
-        :rtype: list of :class:`Name`
+        only_stubs :
+            Only return stubs for this goto call.
+        prefer_stubs :
+            Prefer stubs to Python objects for this goto call.
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         with debug.increase_indent_cm('goto for %s' % self._name):
             return self._goto(**kwargs)
 
     def goto_assignments(self, **kwargs):  # Python 2...
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         warnings.warn(
             "Deprecated since version 0.16.0. Use .goto.",
             DeprecationWarning,
@@ -450,6 +542,23 @@
 
     def _goto(self, follow_imports=False, follow_builtin_imports=False,
               only_stubs=False, prefer_stubs=False):
+        """
+
+        Parameters
+        ----------
+        follow_imports :
+             (Default value = False)
+        follow_builtin_imports :
+             (Default value = False)
+        only_stubs :
+             (Default value = False)
+        prefer_stubs :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
 
         if not self._name.is_value_name:
             return []
@@ -466,10 +575,9 @@
                 for n in names]
 
     def infer(self, **kwargs):  # Python 2...
-        """
-        Like :meth:`.Script.infer`, it can be useful to understand which type
+        """Like :meth:`.Script.infer`, it can be useful to understand which type
         the current name has.
-
+        
         Return the actual definitions. I strongly recommend not using it for
         your completions, because it might slow down |jedi|. If you want to
         read only a few objects (<=20), it might be useful, especially to get
@@ -477,15 +585,37 @@
         follows all results. This means with 1000 completions (e.g.  numpy),
         it's just very, very slow.
 
-        :param only_stubs: Only return stubs for this goto call.
-        :param prefer_stubs: Prefer stubs to Python objects for this type
+        Parameters
+        ----------
+        only_stubs :
+            Only return stubs for this goto call.
+        prefer_stubs :
+            Prefer stubs to Python objects for this type
             inference call.
-        :rtype: list of :class:`Name`
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         with debug.increase_indent_cm('infer for %s' % self._name):
             return self._infer(**kwargs)
 
     def _infer(self, only_stubs=False, prefer_stubs=False):
+        """
+
+        Parameters
+        ----------
+        only_stubs :
+             (Default value = False)
+        prefer_stubs :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         assert not (only_stubs and prefer_stubs)
 
         if not self._name.is_value_name:
@@ -507,6 +637,7 @@
     @property
     @memoize_method
     def params(self):
+        """ """
         warnings.warn(
             "Deprecated since version 0.16.0. Use get_signatures()[...].params",
             DeprecationWarning,
@@ -527,11 +658,7 @@
         raise AttributeError('There are no params defined on this.')
 
     def parent(self):
-        """
-        Returns the parent scope of this identifier.
-
-        :rtype: Name
-        """
+        """Returns the parent scope of this identifier."""
         if not self._name.is_value_name:
             return None
 
@@ -568,14 +695,21 @@
         )
 
     def get_line_code(self, before=0, after=0):
-        """
-        Returns the line of code where this object was defined.
-
-        :param before: Add n lines before the current line to the output.
-        :param after: Add n lines after the current line to the output.
-
-        :return str: Returns the line(s) of code or an empty string if it's a
-                     builtin.
+        """Returns the line of code where this object was defined.
+
+        Parameters
+        ----------
+        before :
+            Add n lines before the current line to the output. (Default value = 0)
+        after :
+            Add n lines after the current line to the output.
+            
+            :return str: Returns the line(s) of code or an empty string if it's a
+            builtin. (Default value = 0)
+
+        Returns
+        -------
+
         """
         if not self._name.is_value_name:
             return ''
@@ -590,6 +724,17 @@
         return ''.join(lines[start_index:index + after + 1])
 
     def _get_signatures(self, for_docstring=False):
+        """
+
+        Parameters
+        ----------
+        for_docstring :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if for_docstring and self._name.api_type == 'statement' and not self.is_stub():
             # For docstrings we don't resolve signatures if they are simple
             # statements and not stubs. This is a speed optimization.
@@ -605,11 +750,15 @@
         return [sig for name in names for sig in name.infer().get_signatures()]
 
     def get_signatures(self):
-        """
-        Returns all potential signatures for a function or a class. Multiple
+        """Returns all potential signatures for a function or a class. Multiple
         signatures are typical if you use Python stubs with ``@overload``.
 
-        :rtype: list of :class:`BaseSignature`
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return [
             BaseSignature(self._inference_state, s)
@@ -617,31 +766,45 @@
         ]
 
     def execute(self):
-        """
-        Uses type inference to "execute" this identifier and returns the
+        """Uses type inference to "execute" this identifier and returns the
         executed objects.
 
-        :rtype: list of :class:`Name`
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return _values_to_definitions(self._name.infer().execute_with_values())
 
     def get_type_hint(self):
-        """
-        Returns type hints like ``Iterable[int]`` or ``Union[int, str]``.
-
+        """Returns type hints like ``Iterable[int]`` or ``Union[int, str]``.
+        
         This method might be quite slow, especially for functions. The problem
         is finding executions for those functions to return something like
         ``Callable[[int, str], str]``.
 
-        :rtype: str
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._name.infer().get_type_hint()
 
 
 class Completion(BaseName):
-    """
-    ``Completion`` objects are returned from :meth:`.Script.complete`. They
+    """``Completion`` objects are returned from :meth:`.Script.complete`. They
     provide additional information about a completion.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, inference_state, name, stack, like_name_length,
                  is_fuzzy, cached_name=None):
@@ -657,6 +820,17 @@
         self._same_name_completions = []
 
     def _complete(self, like_name):
+        """
+
+        Parameters
+        ----------
+        like_name :
+            
+
+        Returns
+        -------
+
+        """
         append = ''
         if settings.add_bracket_after_function \
                 and self.type == 'function':
@@ -669,24 +843,28 @@
 
     @property
     def complete(self):
-        """
-        Only works with non-fuzzy completions. Returns None if fuzzy
+        """Only works with non-fuzzy completions. Returns None if fuzzy
         completions are used.
 
-        Return the rest of the word, e.g. completing ``isinstance``::
-
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
             isinstan# <-- Cursor is here
-
-        would return the string 'ce'. It also adds additional stuff, depending
-        on your ``settings.py``.
-
-        Assuming the following function definition::
-
+            
+            would return the string 'ce'. It also adds additional stuff, depending
+            on your ``settings.py``.
+            
+            Assuming the following function definition::
+            
             def foo(param=0):
-                pass
-
-        completing ``foo(par`` would give a ``Completion`` which ``complete``
-        would be ``am=``.
+            pass
+            
+            completing ``foo(par`` would give a ``Completion`` which ``complete``
+            would be ``am=``.
+
         """
         if self._is_fuzzy:
             return None
@@ -694,22 +872,37 @@
 
     @property
     def name_with_symbols(self):
-        """
-        Similar to :attr:`.name`, but like :attr:`.name` returns also the
+        """Similar to :attr:`.name`, but like :attr:`.name` returns also the
         symbols, for example assuming the following function definition::
-
+        
             def foo(param=0):
                 pass
-
+        
         completing ``foo(`` would give a ``Completion`` which
         ``name_with_symbols`` would be "param=".
 
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._complete(False)
 
     def docstring(self, raw=False, fast=True):
-        """
-        Documented under :meth:`BaseName.docstring`.
+        """Documented under :meth:`BaseName.docstring`.
+
+        Parameters
+        ----------
+        raw :
+             (Default value = False)
+        fast :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         if self._like_name_length >= 3:
             # In this case we can just resolve the like name, because we
@@ -719,6 +912,7 @@
         return super(Completion, self).docstring(raw=raw, fast=fast)
 
     def _get_docstring(self):
+        """ """
         if self._cached_name is not None:
             return completion_cache.get_docstring(
                 self._cached_name,
@@ -728,6 +922,7 @@
         return super(Completion, self)._get_docstring()
 
     def _get_docstring_signature(self):
+        """ """
         if self._cached_name is not None:
             return completion_cache.get_docstring_signature(
                 self._cached_name,
@@ -737,6 +932,7 @@
         return super(Completion, self)._get_docstring_signature()
 
     def _get_cache(self):
+        """ """
         return (
             super(Completion, self).type,
             super(Completion, self)._get_docstring_signature(),
@@ -745,9 +941,7 @@
 
     @property
     def type(self):
-        """
-        Documented under :meth:`BaseName.type`.
-        """
+        """Documented under :meth:`BaseName.type`."""
         # Purely a speed optimization.
         if self._cached_name is not None:
             return completion_cache.get_type(
@@ -763,15 +957,22 @@
 
 
 class Name(BaseName):
-    """
-    *Name* objects are returned from many different APIs including
+    """*Name* objects are returned from many different APIs including
     :meth:`.Script.goto` or :meth:`.Script.infer`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, inference_state, definition):
         super(Name, self).__init__(inference_state, definition)
 
     @property
     def desc_with_module(self):
+        """ """
         warnings.warn(
             "Deprecated since version 0.17.0. No replacement for now, maybe .full_name helps",
             DeprecationWarning,
@@ -781,11 +982,7 @@
 
     @memoize_method
     def defined_names(self):
-        """
-        List sub-definitions (e.g., methods in class).
-
-        :rtype: list of :class:`Name`
-        """
+        """List sub-definitions (e.g., methods in class)."""
         defs = self._name.infer()
         return sorted(
             unite(defined_names(self._inference_state, d.as_context()) for d in defs),
@@ -793,9 +990,15 @@
         )
 
     def is_definition(self):
-        """
-        Returns True, if defined as a name in a statement, function or class.
+        """Returns True, if defined as a name in a statement, function or class.
         Returns False, if it's a reference to such a definition.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._name.tree_name is None:
             return True
@@ -816,9 +1019,15 @@
 
 
 class BaseSignature(Name):
-    """
-    These signatures are returned by :meth:`BaseName.get_signatures`
+    """These signatures are returned by :meth:`BaseName.get_signatures`
     calls.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, inference_state, signature):
         super(BaseSignature, self).__init__(inference_state, signature.name)
@@ -826,29 +1035,43 @@
 
     @property
     def params(self):
-        """
-        Returns definitions for all parameters that a signature defines.
+        """Returns definitions for all parameters that a signature defines.
         This includes stuff like ``*args`` and ``**kwargs``.
 
-        :rtype: list of :class:`.ParamName`
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return [ParamName(self._inference_state, n)
                 for n in self._signature.get_param_names(resolve_stars=True)]
 
     def to_string(self):
-        """
-        Returns a text representation of the signature. This could for example
+        """Returns a text representation of the signature. This could for example
         look like ``foo(bar, baz: int, **kwargs)``.
 
-        :rtype: str
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._signature.to_string()
 
 
 class Signature(BaseSignature):
-    """
-    A full signature object is the return value of
+    """A full signature object is the return value of
     :meth:`.Script.get_signatures`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, inference_state, signature, call_details):
         super(Signature, self).__init__(inference_state, signature)
@@ -857,11 +1080,15 @@
 
     @property
     def index(self):
-        """
-        Returns the param index of the current cursor position.
+        """Returns the param index of the current cursor position.
         Returns None if the index cannot be found in the curent call.
 
-        :rtype: int
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._call_details.calculate_index(
             self._signature.get_param_names(resolve_stars=True)
@@ -869,11 +1096,15 @@
 
     @property
     def bracket_start(self):
-        """
-        Returns a line/column tuple of the bracket that is responsible for the
+        """Returns a line/column tuple of the bracket that is responsible for the
         last function call. The first line is 1 and the first column 0.
 
-        :rtype: int, int
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._call_details.bracket_leaf.start_pos
 
@@ -886,38 +1117,44 @@
 
 
 class ParamName(Name):
+    """ """
     def infer_default(self):
-        """
-        Returns default values like the ``1`` of ``def foo(x=1):``.
-
-        :rtype: list of :class:`.Name`
-        """
+        """Returns default values like the ``1`` of ``def foo(x=1):``."""
         return _values_to_definitions(self._name.infer_default())
 
     def infer_annotation(self, **kwargs):
         """
-        :param execute_annotation: Default True; If False, values are not
+
+        Parameters
+        ----------
+        execute_annotation :
+            Default True; If False, values are not
             executed and classes are returned instead of instances.
-        :rtype: list of :class:`.Name`
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         return _values_to_definitions(self._name.infer_annotation(ignore_stars=True, **kwargs))
 
     def to_string(self):
-        """
-        Returns a simple representation of a param, like
+        """Returns a simple representation of a param, like
         ``f: Callable[..., Any]``.
 
-        :rtype: str
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._name.to_string()
 
     @property
     def kind(self):
-        """
-        Returns an enum instance of :mod:`inspect`'s ``Parameter`` enum.
-
-        :rtype: :py:attr:`inspect.Parameter.kind`
-        """
+        """Returns an enum instance of :mod:`inspect`'s ``Parameter`` enum."""
         if sys.version_info < (3, 5):
             raise NotImplementedError(
                 'Python 2 is end-of-life, the new feature is not available for it'
