# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_sparse.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_sparse.py
@@ -13,6 +13,17 @@
 
 
 def make_data(fill_value):
+    """
+
+    Parameters
+    ----------
+    fill_value :
+        
+
+    Returns
+    -------
+
+    """
     if np.isnan(fill_value):
         data = np.random.uniform(size=100)
     else:
@@ -26,32 +37,87 @@
 
 @pytest.fixture
 def dtype():
+    """ """
     return SparseDtype()
 
 
 @pytest.fixture(params=[0, np.nan])
 def data(request):
-    """Length-100 PeriodArray for semantics test."""
+    """Length-100 PeriodArray for semantics test.
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     res = SparseArray(make_data(request.param), fill_value=request.param)
     return res
 
 
 @pytest.fixture
 def data_for_twos(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return SparseArray(np.ones(100) * 2)
 
 
 @pytest.fixture(params=[0, np.nan])
 def data_missing(request):
-    """Length 2 array with [NA, Valid]"""
+    """Length 2 array with [NA, Valid]
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return SparseArray([np.nan, 1], fill_value=request.param)
 
 
 @pytest.fixture(params=[0, np.nan])
 def data_repeated(request):
-    """Return different versions of data for count times"""
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
 
     def gen(count):
+        """
+
+        Parameters
+        ----------
+        count :
+            
+
+        Returns
+        -------
+
+        """
         for _ in range(count):
             yield SparseArray(make_data(request.param), fill_value=request.param)
 
@@ -60,63 +126,182 @@
 
 @pytest.fixture(params=[0, np.nan])
 def data_for_sorting(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return SparseArray([2, 3, 1], fill_value=request.param)
 
 
 @pytest.fixture(params=[0, np.nan])
 def data_missing_for_sorting(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return SparseArray([2, np.nan, 1], fill_value=request.param)
 
 
 @pytest.fixture
 def na_value():
+    """ """
     return np.nan
 
 
 @pytest.fixture
 def na_cmp():
+    """ """
     return lambda left, right: pd.isna(left) and pd.isna(right)
 
 
 @pytest.fixture(params=[0, np.nan])
 def data_for_grouping(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return SparseArray([1, 1, np.nan, np.nan, 2, 2, 1, 3], fill_value=request.param)
 
 
 class BaseSparseTests:
+    """ """
     def _check_unsupported(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         if data.dtype == SparseDtype(int, 0):
             pytest.skip("Can't store nan in int array.")
 
     @pytest.mark.xfail(reason="SparseArray does not support setitem")
     def test_ravel(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_ravel(data)
 
 
 class TestDtype(BaseSparseTests, base.BaseDtypeTests):
+    """ """
     def test_array_type_with_arg(self, data, dtype):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         assert dtype.construct_array_type() is SparseArray
 
 
 class TestInterface(BaseSparseTests, base.BaseInterfaceTests):
+    """ """
     def test_no_values_attribute(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         pytest.skip("We have values")
 
     def test_copy(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # __setitem__ does not work, so we only have a smoke-test
         data.copy()
 
     def test_view(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # __setitem__ does not work, so we only have a smoke-test
         data.view()
 
 
 class TestConstructors(BaseSparseTests, base.BaseConstructorsTests):
+    """ """
     pass
 
 
 class TestReshaping(BaseSparseTests, base.BaseReshapingTests):
+    """ """
     def test_concat_mixed_dtypes(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/20762
         # This should be the same, aside from concat([sparse, float])
         df1 = pd.DataFrame({"A": data[:3]})
@@ -132,32 +317,122 @@
         self.assert_frame_equal(result, expected)
 
     def test_concat_columns(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_concat_columns(data, na_value)
 
     def test_concat_extension_arrays_copy_false(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_concat_extension_arrays_copy_false(data, na_value)
 
     def test_align(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_align(data, na_value)
 
     def test_align_frame(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_align_frame(data, na_value)
 
     def test_align_series_frame(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_align_series_frame(data, na_value)
 
     def test_merge(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_merge(data, na_value)
 
 
 class TestGetitem(BaseSparseTests, base.BaseGetitemTests):
+    """ """
     def test_get(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data, index=[2 * i for i in range(len(data))])
         if np.isnan(s.values.fill_value):
             assert np.isnan(s.get(4)) and np.isnan(s.iloc[2])
@@ -166,6 +441,19 @@
         assert s.get(2) == s.iloc[1]
 
     def test_reindex(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_reindex(data, na_value)
 
@@ -174,7 +462,19 @@
 
 
 class TestMissing(BaseSparseTests, base.BaseMissingTests):
+    """ """
     def test_isna(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         expected_dtype = SparseDtype(bool, pd.isna(data_missing.dtype.fill_value))
         expected = SparseArray([True, False], dtype=expected_dtype)
 
@@ -191,23 +491,68 @@
         self.assert_series_equal(result, expected)
 
     def test_fillna_limit_pad(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         with tm.assert_produces_warning(PerformanceWarning):
             super().test_fillna_limit_pad(data_missing)
 
     def test_fillna_limit_backfill(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         with tm.assert_produces_warning(PerformanceWarning):
             super().test_fillna_limit_backfill(data_missing)
 
     def test_fillna_series_method(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         with tm.assert_produces_warning(PerformanceWarning):
             super().test_fillna_limit_backfill(data_missing)
 
     @pytest.mark.skip(reason="Unsupported")
     def test_fillna_series(self):
+        """ """
         # this one looks doable.
         pass
 
     def test_fillna_frame(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # Have to override to specify that fill_value will change.
         fill_value = data_missing[1]
 
@@ -229,7 +574,19 @@
 
 
 class TestMethods(BaseSparseTests, base.BaseMethodsTests):
+    """ """
     def test_combine_le(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         # We return a Series[SparseArray].__le__ returns a
         # Series[Sparse[bool]]
         # rather than Series[bool]
@@ -253,6 +610,17 @@
         self.assert_series_equal(result, expected)
 
     def test_fillna_copy_frame(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         arr = data_missing.take([1, 1])
         df = pd.DataFrame({"A": arr})
 
@@ -263,6 +631,17 @@
         assert df.A._values.to_dense() is arr.to_dense()
 
     def test_fillna_copy_series(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         arr = data_missing.take([1, 1])
         ser = pd.Series(arr)
 
@@ -274,9 +653,33 @@
 
     @pytest.mark.skip(reason="Not Applicable")
     def test_fillna_length_mismatch(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def test_where_series(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         assert data[0] != data[1]
         cls = type(data)
         a, b = data[:2]
@@ -299,6 +702,17 @@
         self.assert_series_equal(result, expected)
 
     def test_combine_first(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         if data.dtype.subtype == "int":
             # Right now this is upcasted to float, just like combine_first
             # for Series[int]
@@ -306,10 +720,34 @@
         super().test_combine_first(data)
 
     def test_searchsorted(self, data_for_sorting, as_series):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        as_series :
+            
+
+        Returns
+        -------
+
+        """
         with tm.assert_produces_warning(PerformanceWarning):
             super().test_searchsorted(data_for_sorting, as_series)
 
     def test_shift_0_periods(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH#33856 shifting with periods=0 should return a copy, not same obj
         result = data.shift(0)
 
@@ -320,18 +758,62 @@
         "method", ["argmax", "argmin"],
     )
     def test_argmin_argmax_all_na(self, method, data, na_value):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # overriding because Sparse[int64, 0] cannot handle na_value
         self._check_unsupported(data)
         super().test_argmin_argmax_all_na(method, data, na_value)
 
     @pytest.mark.parametrize("box", [pd.array, pd.Series, pd.DataFrame])
     def test_equals(self, data, na_value, as_series, box):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_series :
+            
+        box :
+            
+
+        Returns
+        -------
+
+        """
         self._check_unsupported(data)
         super().test_equals(data, na_value, as_series, box)
 
 
 class TestCasting(BaseSparseTests, base.BaseCastingTests):
+    """ """
     def test_astype_object_series(self, all_data):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+
+        Returns
+        -------
+
+        """
         # Unlike the base class, we do not expect the resulting Block
         #  to be ObjectBlock
         ser = pd.Series(all_data, name="A")
@@ -339,6 +821,17 @@
         assert is_object_dtype(result._data.blocks[0].dtype)
 
     def test_astype_object_frame(self, all_data):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+
+        Returns
+        -------
+
+        """
         # Unlike the base class, we do not expect the resulting Block
         #  to be ObjectBlock
         df = pd.DataFrame({"A": all_data})
@@ -352,6 +845,17 @@
         # assert not comp.any()
 
     def test_astype_str(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         result = pd.Series(data[:5]).astype(str)
         expected_dtype = pd.SparseDtype(str, str(data.fill_value))
         expected = pd.Series([str(x) for x in data[:5]], dtype=expected_dtype)
@@ -359,16 +863,39 @@
 
     @pytest.mark.xfail(raises=TypeError, reason="no sparse StringDtype")
     def test_astype_string(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         super().test_astype_string(data)
 
 
 class TestArithmeticOps(BaseSparseTests, base.BaseArithmeticOpsTests):
+    """ """
     series_scalar_exc = None
     frame_scalar_exc = None
     divmod_exc = None
     series_array_exc = None
 
     def _skip_if_different_combine(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         if data.fill_value == 0:
             # arith ops call on dtype.fill_value so that the sparsity
             # is maintained. Combine can't be called on a dtype in
@@ -376,19 +903,76 @@
             raise pytest.skip("Incorrected expected from Series.combine")
 
     def test_error(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         self._skip_if_different_combine(data)
         super().test_arith_series_with_scalar(data, all_arithmetic_operators)
 
     def test_arith_series_with_array(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         self._skip_if_different_combine(data)
         super().test_arith_series_with_array(data, all_arithmetic_operators)
 
 
 class TestComparisonOps(BaseSparseTests, base.BaseComparisonOpsTests):
+    """ """
     def _compare_other(self, s, data, op_name, other):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        data :
+            
+        op_name :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         op = self.get_op_from_name(op_name)
 
         # array
@@ -416,14 +1000,42 @@
 
 
 class TestPrinting(BaseSparseTests, base.BasePrintingTests):
+    """ """
     @pytest.mark.xfail(reason="Different repr", strict=True)
     def test_array_repr(self, data, size):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        size :
+            
+
+        Returns
+        -------
+
+        """
         super().test_array_repr(data, size)
 
 
 class TestParsing(BaseSparseTests, base.BaseParsingTests):
+    """ """
     @pytest.mark.parametrize("engine", ["c", "python"])
     def test_EA_types(self, engine, data):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        data :
+            
+
+        Returns
+        -------
+
+        """
         expected_msg = r".*must implement _from_sequence_of_strings.*"
         with pytest.raises(NotImplementedError, match=expected_msg):
             super().test_EA_types(engine, data)
