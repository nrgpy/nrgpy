# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/syntax_tree.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/syntax_tree.py
@@ -53,15 +53,38 @@
 
 
 def _limit_value_infers(func):
-    """
-    This is for now the way how we limit type inference going wild. There are
+    """This is for now the way how we limit type inference going wild. There are
     other ways to ensure recursion limits as well. This is mostly necessary
     because of instance (self) access that can be quite tricky to limit.
-
+    
     I'm still not sure this is the way to go, but it looks okay for now and we
     can still go anther way in the future. Tests are there. ~ dave
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
     """
     def wrapper(context, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        context :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         n = context.tree_node
         inference_state = context.inference_state
         try:
@@ -86,6 +109,19 @@
 
 
 def infer_node(context, element):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    element :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(context, CompForContext):
         return _infer_node(context, element)
 
@@ -158,8 +194,18 @@
 
 
 def _infer_node_if_inferred(context, element):
-    """
-    TODO This function is temporary: Merge with infer_node.
+    """TODO This function is temporary: Merge with infer_node.
+
+    Parameters
+    ----------
+    context :
+        
+    element :
+        
+
+    Returns
+    -------
+
     """
     parent = element
     while parent is not None:
@@ -172,12 +218,38 @@
 
 @inference_state_method_cache(default=NO_VALUES)
 def _infer_node_cached(context, element):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    element :
+        
+
+    Returns
+    -------
+
+    """
     return _infer_node(context, element)
 
 
 @debug.increase_indent
 @_limit_value_infers
 def _infer_node(context, element):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    element :
+        
+
+    Returns
+    -------
+
+    """
     debug.dbg('infer_node %s@%s in %s', element, element.start_pos, context)
     inference_state = context.inference_state
     typ = element.type
@@ -258,6 +330,21 @@
 
 
 def infer_trailer(context, atom_values, trailer):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    atom_values :
+        
+    trailer :
+        
+
+    Returns
+    -------
+
+    """
     trailer_op, node = trailer.children[:2]
     if node == ')':  # `arglist` is optional.
         node = None
@@ -282,10 +369,20 @@
 
 
 def infer_atom(context, atom):
-    """
-    Basically to process ``atom`` nodes. The parser sometimes doesn't
+    """Basically to process ``atom`` nodes. The parser sometimes doesn't
     generate the node (because it has just one child). In that case an atom
     might be a name or a literal as well.
+
+    Parameters
+    ----------
+    context :
+        
+    atom :
+        
+
+    Returns
+    -------
+
     """
     state = context.inference_state
     if atom.type == 'name':
@@ -374,6 +471,21 @@
 
 @_limit_value_infers
 def infer_expr_stmt(context, stmt, seek_name=None):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    stmt :
+        
+    seek_name :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     with recursion.execution_allowed(context.inference_state, stmt) as allowed:
         if allowed:
             if seek_name is not None:
@@ -388,21 +500,42 @@
 
 @debug.increase_indent
 def _infer_expr_stmt(context, stmt, seek_name=None):
-    """
-    The starting point of the completion. A statement always owns a call
+    """The starting point of the completion. A statement always owns a call
     list, which are the calls, that a statement does. In case multiple
     names are defined in the statement, `seek_name` returns the result for
     this name.
-
+    
     expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                      ('=' (yield_expr|testlist_star_expr))*)
     annassign: ':' test ['=' test]
     augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                 '<<=' | '>>=' | '**=' | '//=')
 
-    :param stmt: A `tree.ExprStmt`.
+    Parameters
+    ----------
+    stmt :
+        A `tree.ExprStmt`.
+    context :
+        
+    seek_name :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     def check_setitem(stmt):
+        """
+
+        Parameters
+        ----------
+        stmt :
+            
+
+        Returns
+        -------
+
+        """
         atom_expr = stmt.children[0]
         if atom_expr.type not in ('atom_expr', 'power'):
             return False, None
@@ -431,6 +564,17 @@
 
         if is_setitem:
             def to_mod(v):
+                """
+
+                Parameters
+                ----------
+                v :
+                    
+
+                Returns
+                -------
+
+                """
                 c = ContextualizedSubscriptListNode(context, subscriptlist)
                 if v.array_type == 'dict':
                     return DictModification(v, value_set, c)
@@ -465,6 +609,19 @@
 
 
 def infer_or_test(context, or_test):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    or_test :
+        
+
+    Returns
+    -------
+
+    """
     iterator = iter(or_test.children)
     types = context.infer_node(next(iterator))
     for operator in iterator:
@@ -491,8 +648,18 @@
 
 @iterator_to_value_set
 def infer_factor(value_set, operator):
-    """
-    Calculates `+`, `-`, `~` and `not` prefixes.
+    """Calculates `+`, `-`, `~` and `not` prefixes.
+
+    Parameters
+    ----------
+    value_set :
+        
+    operator :
+        
+
+    Returns
+    -------
+
     """
     for value in value_set:
         if operator == '-':
@@ -508,6 +675,19 @@
 
 
 def _literals_to_types(inference_state, result):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    result :
+        
+
+    Returns
+    -------
+
+    """
     # Changes literals ('a', 1, 1.0, etc) to its type instances (str(),
     # int(), float(), etc).
     new_result = NO_VALUES
@@ -523,6 +703,23 @@
 
 
 def _infer_comparison(context, left_values, operator, right_values):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    left_values :
+        
+    operator :
+        
+    right_values :
+        
+
+    Returns
+    -------
+
+    """
     state = context.inference_state
     if not left_values or not right_values:
         # illegal slices e.g. cause left/right_result to be None
@@ -543,6 +740,17 @@
 
 
 def _is_annotation_name(name):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     ancestor = tree.search_ancestor(name, 'param', 'funcdef', 'expr_stmt')
     if ancestor is None:
         return False
@@ -559,18 +767,64 @@
 
 
 def _is_list(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return value.array_type == 'list'
 
 
 def _is_tuple(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return value.array_type == 'tuple'
 
 
 def _bool_to_value(inference_state, bool_):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    bool_ :
+        
+
+    Returns
+    -------
+
+    """
     return compiled.builtin_from_name(inference_state, force_unicode(str(bool_)))
 
 
 def _get_tuple_ints(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     if not isinstance(value, iterable.SequenceLiteralValue):
         return None
     numbers = []
@@ -588,6 +842,25 @@
 
 
 def _infer_comparison_part(inference_state, context, left, operator, right):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    context :
+        
+    left :
+        
+    operator :
+        
+    right :
+        
+
+    Returns
+    -------
+
+    """
     l_is_num = is_number(left)
     r_is_num = is_number(right)
     if isinstance(operator, unicode):
@@ -646,7 +919,17 @@
         return NO_VALUES
 
     def check(obj):
-        """Checks if a Jedi object is either a float or an int."""
+        """Checks if a Jedi object is either a float or an int.
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         return isinstance(obj, TreeInstance) and \
             obj.name.string_name in ('int', 'float')
 
@@ -682,6 +965,21 @@
 
 @plugin_manager.decorate()
 def tree_name_to_values(inference_state, context, tree_name):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    context :
+        
+    tree_name :
+        
+
+    Returns
+    -------
+
+    """
     value_set = NO_VALUES
     module_node = context.get_root_context().tree_node
     # First check for annotations, like: `foo: int = 3`
@@ -772,9 +1070,19 @@
 # tree_node.
 @inference_state_method_cache()
 def _apply_decorators(context, node):
-    """
-    Returns the function, that should to be executed in the end.
+    """Returns the function, that should to be executed in the end.
     This is also the places where the decorators are processed.
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+
+    Returns
+    -------
+
     """
     if node.type == 'classdef':
         decoratee_value = ClassValue(
@@ -821,8 +1129,18 @@
 
 
 def check_tuple_assignments(name, value_set):
-    """
-    Checks if tuples are assigned.
+    """Checks if tuples are assigned.
+
+    Parameters
+    ----------
+    name :
+        
+    value_set :
+        
+
+    Returns
+    -------
+
     """
     lazy_value = None
     for index, node in name.assignment_indexes():
@@ -848,13 +1166,25 @@
 
 
 class ContextualizedSubscriptListNode(ContextualizedNode):
+    """ """
     def infer(self):
+        """ """
         return _infer_subscript_list(self.context, self.node)
 
 
 def _infer_subscript_list(context, index):
-    """
-    Handles slices in subscript nodes.
+    """Handles slices in subscript nodes.
+
+    Parameters
+    ----------
+    context :
+        
+    index :
+        
+
+    Returns
+    -------
+
     """
     if index == ':':
         # Like array[:]
