# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpydoc/numpydoc.py
+++ b/..//venv/lib/python3.8/site-packages/numpydoc/numpydoc.py
@@ -42,6 +42,27 @@
 HASH_LEN = 12
 
 def rename_references(app, what, name, obj, options, lines):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    what :
+        
+    name :
+        
+    obj :
+        
+    options :
+        
+    lines :
+        
+
+    Returns
+    -------
+
+    """
     # decorate reference numbers so that there are no duplicates
     # these are later undecorated in the doctree, in relabel_references
     references = set()
@@ -69,12 +90,34 @@
 
 
 def _is_cite_in_numpydoc_docstring(citation_node):
+    """
+
+    Parameters
+    ----------
+    citation_node :
+        
+
+    Returns
+    -------
+
+    """
     # Find DEDUPLICATION_TAG in comment as last node of sibling section
 
     # XXX: I failed to use citation_node.traverse to do this:
     section_node = citation_node.parent
 
     def is_docstring_section(node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return isinstance(node, (section, desc_content))
 
     while not is_docstring_section(section_node):
@@ -101,6 +144,19 @@
 
 
 def relabel_references(app, doc):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    doc :
+        
+
+    Returns
+    -------
+
+    """
     # Change 'hash-ref' to 'ref' in label text
     for citation_node in doc.traverse(citation):
         if not _is_cite_in_numpydoc_docstring(citation_node):
@@ -117,6 +173,17 @@
 
             # Sphinx has created pending_xref nodes with [reftext] text.
             def matching_pending_xref(node):
+                """
+
+                Parameters
+                ----------
+                node :
+                    
+
+                Returns
+                -------
+
+                """
                 return (isinstance(node, pending_xref) and
                         node[0].astext() == '[%s]' % ref_text)
 
@@ -126,6 +193,21 @@
 
 
 def clean_backrefs(app, doc, docname):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    doc :
+        
+    docname :
+        
+
+    Returns
+    -------
+
+    """
     # only::latex directive has resulted in citation backrefs without reference
     known_ref_ids = set()
     for ref in doc.traverse(reference, descend=True):
@@ -141,6 +223,27 @@
 
 
 def mangle_docstrings(app, what, name, obj, options, lines):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    what :
+        
+    name :
+        
+    obj :
+        
+    options :
+        
+    lines :
+        
+
+    Returns
+    -------
+
+    """
     if DEDUPLICATION_TAG in lines:
         return
 
@@ -191,6 +294,29 @@
 
 
 def mangle_signature(app, what, name, obj, options, sig, retann):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    what :
+        
+    name :
+        
+    obj :
+        
+    options :
+        
+    sig :
+        
+    retann :
+        
+
+    Returns
+    -------
+
+    """
     # Do not try to inspect classes that don't define `__init__`
     if (inspect.isclass(obj) and
         (not hasattr(obj, '__init__') or
@@ -212,6 +338,17 @@
 
 
 def _clean_text_signature(sig):
+    """
+
+    Parameters
+    ----------
+    sig :
+        
+
+    Returns
+    -------
+
+    """
     if sig is None:
         return None
     start_pattern = re.compile(r"^[^(]*\(")
@@ -224,6 +361,19 @@
 
 
 def setup(app, get_doc_object_=get_doc_object):
+    """
+
+    Parameters
+    ----------
+    app :
+        
+    get_doc_object_ :
+         (Default value = get_doc_object)
+
+    Returns
+    -------
+
+    """
     if not hasattr(app, 'add_config_value'):
         return  # probably called by nose, better bail out
 
@@ -265,7 +415,19 @@
 
 
 def update_config(app, config=None):
-    """Update the configuration with default values."""
+    """Update the configuration with default values.
+
+    Parameters
+    ----------
+    app :
+        
+    config :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if config is None:  # needed for testing and old Sphinx
         config = app.config
     # Do not simply overwrite the `app.config.numpydoc_xref_aliases`
@@ -289,6 +451,7 @@
 
 
 class ManglingDomainBase(object):
+    """ """
     directive_mangling_map = {}
 
     def __init__(self, *a, **kw):
@@ -296,12 +459,14 @@
         self.wrap_mangling_directives()
 
     def wrap_mangling_directives(self):
+        """ """
         for name, objtype in list(self.directive_mangling_map.items()):
             self.directives[name] = wrap_mangling_directive(
                 self.directives[name], objtype)
 
 
 class NumpyPythonDomain(ManglingDomainBase, PythonDomain):
+    """ """
     name = 'np'
     directive_mangling_map = {
         'function': 'function',
@@ -316,6 +481,7 @@
 
 
 class NumpyCDomain(ManglingDomainBase, CDomain):
+    """ """
     name = 'np-c'
     directive_mangling_map = {
         'function': 'function',
@@ -328,25 +494,41 @@
 
 def match_items(lines, content_old):
     """Create items for mangled lines.
-
+    
     This function tries to match the lines in ``lines`` with the items (source
     file references and line numbers) in ``content_old``. The
     ``mangle_docstrings`` function changes the actual docstrings, but doesn't
     keep track of where each line came from. The manging does many operations
     on the original lines, which are hard to track afterwards.
-
+    
     Many of the line changes come from deleting or inserting blank lines. This
     function tries to match lines by ignoring blank lines. All other changes
     (such as inserting figures or changes in the references) are completely
     ignored, so the generated line numbers will be off if ``mangle_docstrings``
     does anything non-trivial.
-
+    
     This is a best-effort function and the real fix would be to make
     ``mangle_docstrings`` actually keep track of the ``items`` together with
     the ``lines``.
 
+    Parameters
+    ----------
+    lines :
+        
+    content_old :
+        
+
+    Returns
+    -------
+
     Examples
     --------
+    Notes
+    -----
+    The algorithm tries to match any line in ``lines`` with one in
+    ``lines_old``.  It skips over all empty lines in ``lines_old`` and assigns
+    this line number to all lines in ``lines``, unless a non-empty line is
+    found in ``lines`` in which case it goes to the next line in ``lines_old``.
     >>> lines = ['', 'A', '', 'B', '   ', '', 'C', 'D']
     >>> lines_old = ['a', '', '', 'b', '', 'c']
     >>> items_old = [('file1.py', 0), ('file1.py', 1), ('file1.py', 2),
@@ -357,14 +539,6 @@
      ('file2.py', 2), ('file2.py', 2), ('file2.py', 2), ('file2.py', 2)]
     >>> # first 2 ``lines`` are matched to 'a', second 2 to 'b', rest to 'c'
     >>> # actual content is completely ignored.
-
-    Notes
-    -----
-    The algorithm tries to match any line in ``lines`` with one in
-    ``lines_old``.  It skips over all empty lines in ``lines_old`` and assigns
-    this line number to all lines in ``lines``, unless a non-empty line is
-    found in ``lines`` in which case it goes to the next line in ``lines_old``.
-
     """
     items_new = []
     lines_old = content_old.data
@@ -383,8 +557,23 @@
 
 
 def wrap_mangling_directive(base_directive, objtype):
+    """
+
+    Parameters
+    ----------
+    base_directive :
+        
+    objtype :
+        
+
+    Returns
+    -------
+
+    """
     class directive(base_directive):
+        """ """
         def run(self):
+            """ """
             env = self.state.document.settings.env
 
             name = None
