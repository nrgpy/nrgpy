# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_print.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_print.py
@@ -14,12 +14,20 @@
 
 @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
 def test_float_types(tp):
-    """ Check formatting.
-
+    """Check formatting.
+    
         This is only for the str function, and only for simple types.
         The precision of np.float32 and np.longdouble aren't the same as the
         python float precision.
 
+    Parameters
+    ----------
+    tp :
+        
+
+    Returns
+    -------
+
     """
     for x in [0, 1, -1, 1e20]:
         assert_equal(str(tp(x)), str(float(x)),
@@ -36,12 +44,20 @@
 
 @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
 def test_nan_inf_float(tp):
-    """ Check formatting of nan & inf.
-
+    """Check formatting of nan & inf.
+    
         This is only for the str function, and only for simple types.
         The precision of np.float32 and np.longdouble aren't the same as the
         python float precision.
 
+    Parameters
+    ----------
+    tp :
+        
+
+    Returns
+    -------
+
     """
     for x in [np.inf, -np.inf, np.nan]:
         assert_equal(str(tp(x)), _REF[x],
@@ -51,11 +67,19 @@
 @pytest.mark.parametrize('tp', [np.complex64, np.cdouble, np.clongdouble])
 def test_complex_types(tp):
     """Check formatting of complex types.
-
+    
         This is only for the str function, and only for simple types.
         The precision of np.float32 and np.longdouble aren't the same as the
         python float precision.
 
+    Parameters
+    ----------
+    tp :
+        
+
+    Returns
+    -------
+
     """
     for x in [0, 1, -1, 1e20]:
         assert_equal(str(tp(x)), str(complex(x)),
@@ -76,7 +100,17 @@
 
 @pytest.mark.parametrize('dtype', [np.complex64, np.cdouble, np.clongdouble])
 def test_complex_inf_nan(dtype):
-    """Check inf/nan formatting of complex types."""
+    """Check inf/nan formatting of complex types.
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     TESTS = {
         complex(np.inf, 0): "(inf+0j)",
         complex(0, np.inf): "infj",
@@ -101,6 +135,21 @@
 
 # print tests
 def _test_redirected_print(x, tp, ref=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    tp :
+        
+    ref :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     file = StringIO()
     file_tp = StringIO()
     stdout = sys.stdout
@@ -121,7 +170,17 @@
 
 @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
 def test_float_type_print(tp):
-    """Check formatting when using print """
+    """Check formatting when using print
+
+    Parameters
+    ----------
+    tp :
+        
+
+    Returns
+    -------
+
+    """
     for x in [0, 1, -1, 1e20]:
         _test_redirected_print(float(x), tp)
 
@@ -137,7 +196,17 @@
 
 @pytest.mark.parametrize('tp', [np.complex64, np.cdouble, np.clongdouble])
 def test_complex_type_print(tp):
-    """Check formatting when using print """
+    """Check formatting when using print
+
+    Parameters
+    ----------
+    tp :
+        
+
+    Returns
+    -------
+
+    """
     # We do not create complex with inf/nan directly because the feature is
     # missing in python < 2.6
     for x in [0, 1, -1, 1e20]:
@@ -189,12 +258,16 @@
 #
 
 class TestCommaDecimalPointLocale(CommaDecimalPointLocale):
+    """ """
 
     def test_locale_single(self):
+        """ """
         assert_equal(str(np.float32(1.2)), str(float(1.2)))
 
     def test_locale_double(self):
+        """ """
         assert_equal(str(np.double(1.2)), str(float(1.2)))
 
     def test_locale_longdouble(self):
+        """ """
         assert_equal(str(np.longdouble('1.2')), str(float(1.2)))
