# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/frame/test_query_eval.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/frame/test_query_eval.py
@@ -17,26 +17,72 @@
 
 @pytest.fixture(params=PARSERS, ids=lambda x: x)
 def parser(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=ENGINES, ids=lambda x: x)
 def engine(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 def skip_if_no_pandas_parser(parser):
+    """
+
+    Parameters
+    ----------
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     if parser != "pandas":
         pytest.skip(f"cannot evaluate with parser {repr(parser)}")
 
 
 class TestCompat:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.df = DataFrame({"A": [1, 2, 3]})
         self.expected1 = self.df[self.df.A > 0]
         self.expected2 = self.df.A + 1
 
     def test_query_default(self):
+        """ """
 
         # GH 12749
         # this should always work, whether _NUMEXPR_INSTALLED or not
@@ -47,6 +93,7 @@
         tm.assert_series_equal(result, self.expected2, check_names=False)
 
     def test_query_None(self):
+        """ """
 
         df = self.df
         result = df.query("A>0", engine=None)
@@ -55,6 +102,7 @@
         tm.assert_series_equal(result, self.expected2, check_names=False)
 
     def test_query_python(self):
+        """ """
 
         df = self.df
         result = df.query("A>0", engine="python")
@@ -63,6 +111,7 @@
         tm.assert_series_equal(result, self.expected2, check_names=False)
 
     def test_query_numexpr(self):
+        """ """
 
         df = self.df
         if _NUMEXPR_INSTALLED:
@@ -83,6 +132,7 @@
 
 
 class TestDataFrameEval:
+    """ """
 
     # smaller hits python, larger hits numexpr
     @pytest.mark.parametrize("n", [4, 4000])
@@ -96,6 +146,23 @@
         ],
     )
     def test_ops(self, op_str, op, rop, n):
+        """
+
+        Parameters
+        ----------
+        op_str :
+            
+        op :
+            
+        rop :
+            
+        n :
+            
+
+        Returns
+        -------
+
+        """
 
         # tst ops and reversed ops in evaluation
         # GH7198
@@ -125,6 +192,7 @@
             tm.assert_frame_equal(result, expected)
 
     def test_dataframe_sub_numexpr_path(self):
+        """ """
         # GH7192: Note we need a large number of rows to ensure this
         #  goes through the numexpr path
         df = DataFrame(dict(A=np.random.randn(25000)))
@@ -134,6 +202,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_query_non_str(self):
+        """ """
         # GH 11485
         df = pd.DataFrame({"A": [1, 2, 3], "B": ["a", "b", "b"]})
 
@@ -145,6 +214,7 @@
             df.query(111)
 
     def test_query_empty_string(self):
+        """ """
         # GH 13139
         df = pd.DataFrame({"A": [1, 2, 3]})
 
@@ -153,6 +223,7 @@
             df.query("")
 
     def test_eval_resolvers_as_list(self):
+        """ """
         # GH 14095
         df = DataFrame(np.random.randn(10, 2), columns=list("ab"))
         dict1 = {"a": 1}
@@ -161,6 +232,7 @@
         assert pd.eval("a + b", resolvers=[dict1, dict2]) == dict1["a"] + dict2["b"]
 
     def test_eval_object_dtype_binop(self):
+        """ """
         # GH#24883
         df = pd.DataFrame({"a1": ["Y", "N"]})
         res = df.eval("c = ((a1 == 'Y') & True)")
@@ -169,7 +241,21 @@
 
 
 class TestDataFrameQueryWithMultiIndex:
+    """ """
     def test_query_with_named_multiindex(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         a = np.random.choice(["red", "green"], size=10)
         b = np.random.choice(["eggs", "ham"], size=10)
@@ -220,6 +306,19 @@
         tm.assert_frame_equal(res2, exp)
 
     def test_query_with_unnamed_multiindex(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         a = np.random.choice(["red", "green"], size=10)
         b = np.random.choice(["eggs", "ham"], size=10)
@@ -308,6 +407,19 @@
         tm.assert_frame_equal(res2, exp)
 
     def test_query_with_partially_named_multiindex(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         a = np.random.choice(["red", "green"], size=10)
         b = np.arange(10)
@@ -339,12 +451,26 @@
         tm.assert_frame_equal(res, exp)
 
     def test_query_multiindex_get_index_resolvers(self):
+        """ """
         df = tm.makeCustomDataframe(
             10, 3, r_idx_nlevels=2, r_idx_names=["spam", "eggs"]
         )
         resolvers = df._get_index_resolvers()
 
         def to_series(mi, level):
+            """
+
+            Parameters
+            ----------
+            mi :
+                
+            level :
+                
+
+            Returns
+            -------
+
+            """
             level_values = mi.get_level_values(level)
             s = level_values.to_series()
             s.index = mi
@@ -369,16 +495,20 @@
 
 @td.skip_if_no_ne
 class TestDataFrameQueryNumExprPandas:
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.engine = "numexpr"
         cls.parser = "pandas"
 
     @classmethod
     def teardown_class(cls):
+        """ """
         del cls.engine, cls.parser
 
     def test_date_query_with_attribute_access(self):
+        """ """
         engine, parser = self.engine, self.parser
         skip_if_no_pandas_parser(parser)
         df = DataFrame(np.random.randn(5, 3))
@@ -392,6 +522,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_query_no_attribute_access(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame(np.random.randn(5, 3))
         df["dates1"] = date_range("1/1/2012", periods=5)
@@ -402,6 +533,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_query_with_NaT(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -415,6 +547,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -427,6 +560,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query_with_NaT(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -440,6 +574,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query_with_NaT_duplicates(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         d = {}
@@ -454,6 +589,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_query_with_non_date(self):
+        """ """
         engine, parser = self.engine, self.parser
 
         n = 10
@@ -473,6 +609,7 @@
                 df.query(f"dates {op} nondate", parser=parser, engine=engine)
 
     def test_query_syntax_error(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame({"i": range(10), "+": range(3, 13), "r": range(4, 14)})
         msg = "invalid syntax"
@@ -480,6 +617,7 @@
             df.query("i - +", engine=engine, parser=parser)
 
     def test_query_scope(self):
+        """ """
         from pandas.core.computation.ops import UndefinedVariableError
 
         engine, parser = self.engine, self.parser
@@ -507,6 +645,7 @@
             df.query("@a > b > c", engine=engine, parser=parser)
 
     def test_query_doesnt_pickup_local(self):
+        """ """
         from pandas.core.computation.ops import UndefinedVariableError
 
         engine, parser = self.engine, self.parser
@@ -518,6 +657,7 @@
             df.query("sin > 5", engine=engine, parser=parser)
 
     def test_query_builtin(self):
+        """ """
         from pandas.core.computation.engines import NumExprClobberingError
 
         engine, parser = self.engine, self.parser
@@ -531,6 +671,7 @@
             df.query("sin > 5", engine=engine, parser=parser)
 
     def test_query(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame(np.random.randn(10, 3), columns=["a", "b", "c"])
 
@@ -543,6 +684,7 @@
         )
 
     def test_query_index_with_name(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame(
             np.random.randint(10, size=(10, 3)),
@@ -559,6 +701,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_query_index_without_name(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame(
             np.random.randint(10, size=(10, 3)),
@@ -577,6 +720,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_nested_scope(self):
+        """ """
         engine = self.engine
         parser = self.parser
 
@@ -603,6 +747,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_nested_raises_on_local_self_reference(self):
+        """ """
         from pandas.core.computation.ops import UndefinedVariableError
 
         df = DataFrame(np.random.randn(5, 3))
@@ -612,6 +757,7 @@
             df.query("df > 0", engine=self.engine, parser=self.parser)
 
     def test_local_syntax(self):
+        """ """
         skip_if_no_pandas_parser(self.parser)
 
         engine, parser = self.engine, self.parser
@@ -626,6 +772,7 @@
         tm.assert_frame_equal(result, expect)
 
     def test_chained_cmp_and_in(self):
+        """ """
         skip_if_no_pandas_parser(self.parser)
         engine, parser = self.engine, self.parser
         cols = list("abc")
@@ -640,6 +787,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_local_variable_with_in(self):
+        """ """
         engine, parser = self.engine, self.parser
         skip_if_no_pandas_parser(parser)
         a = Series(np.random.randint(3, size=15), name="a")
@@ -656,6 +804,7 @@
         tm.assert_frame_equal(expected, result)
 
     def test_at_inside_string(self):
+        """ """
         engine, parser = self.engine, self.parser
         skip_if_no_pandas_parser(parser)
         c = 1  # noqa
@@ -665,6 +814,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_query_undefined_local(self):
+        """ """
         from pandas.core.computation.ops import UndefinedVariableError
 
         engine, parser = self.engine, self.parser
@@ -677,6 +827,7 @@
             df.query("a == @c", engine=engine, parser=parser)
 
     def test_index_resolvers_come_after_columns_with_the_same_name(self):
+        """ """
         n = 1  # noqa
         a = np.r_[20:101:20]
 
@@ -702,6 +853,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_inf(self):
+        """ """
         n = 10
         df = DataFrame({"a": np.random.rand(n), "b": np.random.rand(n)})
         df.loc[::2, 0] = np.inf
@@ -713,6 +865,17 @@
             tm.assert_frame_equal(result, expected)
 
     def test_check_tz_aware_index_query(self, tz_aware_fixture):
+        """
+
+        Parameters
+        ----------
+        tz_aware_fixture :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/29463
         tz = tz_aware_fixture
         df_index = pd.date_range(
@@ -730,13 +893,16 @@
 
 @td.skip_if_no_ne
 class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "numexpr"
         cls.parser = "python"
 
     def test_date_query_no_attribute_access(self):
+        """ """
         engine, parser = self.engine, self.parser
         df = DataFrame(np.random.randn(5, 3))
         df["dates1"] = date_range("1/1/2012", periods=5)
@@ -749,6 +915,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_query_with_NaT(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -764,6 +931,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -778,6 +946,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query_with_NaT(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -793,6 +962,7 @@
         tm.assert_frame_equal(res, expec)
 
     def test_date_index_query_with_NaT_duplicates(self):
+        """ """
         engine, parser = self.engine, self.parser
         n = 10
         df = DataFrame(np.random.randn(n, 3))
@@ -806,6 +976,7 @@
             df.query("index < 20130101 < dates3", engine=engine, parser=parser)
 
     def test_nested_scope(self):
+        """ """
         from pandas.core.computation.ops import UndefinedVariableError
 
         engine = self.engine
@@ -838,13 +1009,16 @@
 
 
 class TestDataFrameQueryPythonPandas(TestDataFrameQueryNumExprPandas):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "python"
         cls.parser = "pandas"
 
     def test_query_builtin(self):
+        """ """
         engine, parser = self.engine, self.parser
 
         n = m = 10
@@ -857,12 +1031,15 @@
 
 
 class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = cls.parser = "python"
 
     def test_query_builtin(self):
+        """ """
         engine, parser = self.engine, self.parser
 
         n = m = 10
@@ -875,7 +1052,21 @@
 
 
 class TestDataFrameQueryStrings:
+    """ """
     def test_str_query_method(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(np.random.randn(10, 1), columns=["b"])
         df["strings"] = Series(list("aabbccddee"))
         expect = df[df.strings == "a"]
@@ -917,6 +1108,19 @@
             tm.assert_frame_equal(res, df[~df.strings.isin(["a"])])
 
     def test_str_list_query_method(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(np.random.randn(10, 1), columns=["b"])
         df["strings"] = Series(list("aabbccddee"))
         expect = df[df.strings.isin(["a", "b"])]
@@ -952,6 +1156,19 @@
             tm.assert_frame_equal(res, expect)
 
     def test_query_with_string_columns(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(
             {
                 "a": list("aaaabbbbcccc"),
@@ -978,6 +1195,19 @@
                 df.query("a in b and c < d", parser=parser, engine=engine)
 
     def test_object_array_eq_ne(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(
             {
                 "a": list("aaaabbbbcccc"),
@@ -995,6 +1225,19 @@
         tm.assert_frame_equal(res, exp)
 
     def test_query_with_nested_strings(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         raw = """id          event          timestamp
         1   "page 1 load"   1/1/2014 0:00:01
@@ -1018,6 +1261,19 @@
         tm.assert_frame_equal(expected, res)
 
     def test_query_with_nested_special_character(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         df = DataFrame({"a": ["a", "b", "test & test"], "b": [1, 2, 3]})
         res = df.query('a == "test & test"', parser=parser, engine=engine)
@@ -1025,6 +1281,19 @@
         tm.assert_frame_equal(res, expec)
 
     def test_query_lex_compare_strings(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
 
         a = Series(np.random.choice(list("abcde"), 20))
         b = Series(np.arange(a.size))
@@ -1038,6 +1307,19 @@
             tm.assert_frame_equal(res, expected)
 
     def test_query_single_element_booleans(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         columns = "bid", "bidsize", "ask", "asksize"
         data = np.random.randint(2, size=(1, len(columns))).astype(bool)
         df = DataFrame(data, columns=columns)
@@ -1046,6 +1328,19 @@
         tm.assert_frame_equal(res, expected)
 
     def test_query_string_scalar_variable(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         skip_if_no_pandas_parser(parser)
         df = pd.DataFrame(
             {
@@ -1060,24 +1355,88 @@
 
 
 class TestDataFrameEvalWithFrame:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.frame = DataFrame(np.random.randn(10, 3), columns=list("abc"))
 
     def teardown_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         del self.frame
 
     def test_simple_expr(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         res = self.frame.eval("a + b", engine=engine, parser=parser)
         expect = self.frame.a + self.frame.b
         tm.assert_series_equal(res, expect)
 
     def test_bool_arith_expr(self, parser, engine):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+
+        Returns
+        -------
+
+        """
         res = self.frame.eval("a[a < 1] + b", engine=engine, parser=parser)
         expect = self.frame.a[self.frame.a < 1] + self.frame.b
         tm.assert_series_equal(res, expect)
 
     @pytest.mark.parametrize("op", ["+", "-", "*", "/"])
     def test_invalid_type_for_operator_raises(self, parser, engine, op):
+        """
+
+        Parameters
+        ----------
+        parser :
+            
+        engine :
+            
+        op :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame({"a": [1, 2], "b": ["c", "d"]})
         msg = r"unsupported operand type\(s\) for .+: '.+' and '.+'"
 
@@ -1086,12 +1445,19 @@
 
 
 class TestDataFrameQueryBacktickQuoting:
+    """ """
     @pytest.fixture(scope="class")
     def df(self):
-        """
-        Yields a dataframe with strings that may or may not need escaping
+        """Yields a dataframe with strings that may or may not need escaping
         by backticks. The last two columns cannot be escaped by backticks
         and should raise a ValueError.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         yield DataFrame(
             {
@@ -1121,119 +1487,369 @@
         )
 
     def test_single_backtick_variable_query(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("1 < `B B`")
         expect = df[1 < df["B B"]]
         tm.assert_frame_equal(res, expect)
 
     def test_two_backtick_variables_query(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("1 < `B B` and 4 < `C C`")
         expect = df[(1 < df["B B"]) & (4 < df["C C"])]
         tm.assert_frame_equal(res, expect)
 
     def test_single_backtick_variable_expr(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("A + `B B`")
         expect = df["A"] + df["B B"]
         tm.assert_series_equal(res, expect)
 
     def test_two_backtick_variables_expr(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("`B B` + `C C`")
         expect = df["B B"] + df["C C"]
         tm.assert_series_equal(res, expect)
 
     def test_already_underscore_variable(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("`C_C` + A")
         expect = df["C_C"] + df["A"]
         tm.assert_series_equal(res, expect)
 
     def test_same_name_but_underscores(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("C_C + `C C`")
         expect = df["C_C"] + df["C C"]
         tm.assert_series_equal(res, expect)
 
     def test_mixed_underscores_and_spaces(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("A + `D_D D`")
         expect = df["A"] + df["D_D D"]
         tm.assert_series_equal(res, expect)
 
     def test_backtick_quote_name_with_no_spaces(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("A + `C_C`")
         expect = df["A"] + df["C_C"]
         tm.assert_series_equal(res, expect)
 
     def test_special_characters(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("`E.E` + `F-F` - A")
         expect = df["E.E"] + df["F-F"] - df["A"]
         tm.assert_series_equal(res, expect)
 
     def test_start_with_digit(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("A + `1e1`")
         expect = df["A"] + df["1e1"]
         tm.assert_series_equal(res, expect)
 
     def test_keyword(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("A + `def`")
         expect = df["A"] + df["def"]
         tm.assert_series_equal(res, expect)
 
     def test_unneeded_quoting(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("`A` > 2")
         expect = df[df["A"] > 2]
         tm.assert_frame_equal(res, expect)
 
     def test_parenthesis(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("`A (x)` > 2")
         expect = df[df["A (x)"] > 2]
         tm.assert_frame_equal(res, expect)
 
     def test_empty_string(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("`` > 5")
         expect = df[df[""] > 5]
         tm.assert_frame_equal(res, expect)
 
     def test_multiple_spaces(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("`C  C` > 5")
         expect = df[df["C  C"] > 5]
         tm.assert_frame_equal(res, expect)
 
     def test_start_with_spaces(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.eval("` A` + `  `")
         expect = df[" A"] + df["  "]
         tm.assert_series_equal(res, expect)
 
     def test_lots_of_operators_string(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         res = df.query("`  &^ :!€$?(} >    <++*''  ` > 4")
         expect = df[df["  &^ :!€$?(} >    <++*''  "] > 4]
         tm.assert_frame_equal(res, expect)
 
     def test_missing_attribute(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         message = "module 'pandas' has no attribute 'thing'"
         with pytest.raises(AttributeError, match=message):
             df.eval("@pd.thing")
 
     def test_failing_quote(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         msg = r"(Could not convert ).*( to a valid Python identifier.)"
         with pytest.raises(SyntaxError, match=msg):
             df.query("`it's` > `that's`")
 
     def test_failing_character_outside_range(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         msg = r"(Could not convert ).*( to a valid Python identifier.)"
         with pytest.raises(SyntaxError, match=msg):
             df.query("`☺` > 4")
 
     def test_failing_hashtag(self, df):
+        """
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
+        """
         msg = "Failed to parse backticks"
         with pytest.raises(SyntaxError, match=msg):
             df.query("`foo#bar` > 4")
 
     def test_call_non_named_expression(self, df):
-        """
-        Only attributes and variables ('named functions') can be called.
+        """Only attributes and variables ('named functions') can be called.
         .__call__() is not an allowed attribute because that would allow
         calling anything.
         https://github.com/pandas-dev/pandas/pull/32460
+
+        Parameters
+        ----------
+        df :
+            
+
+        Returns
+        -------
+
         """
 
         def func(*_):
+            """
+
+            Parameters
+            ----------
+            *_ :
+                
+
+            Returns
+            -------
+
+            """
             return 1
 
         funcs = [func]  # noqa
