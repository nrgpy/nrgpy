# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/value.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/value.py
@@ -42,11 +42,23 @@
 
 
 class CompiledValue(Value):
+    """ """
     def __init__(self, inference_state, access_handle, parent_context=None):
         super(CompiledValue, self).__init__(inference_state, parent_context)
         self.access_handle = access_handle
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return_annotation = self.access_handle.get_return_annotation()
         if return_annotation is not None:
             # TODO the return annotation may also be a string.
@@ -70,10 +82,12 @@
 
     @CheckAttribute()
     def py__class__(self):
+        """ """
         return create_from_access_path(self.inference_state, self.access_handle.py__class__())
 
     @CheckAttribute()
     def py__mro__(self):
+        """ """
         return (self,) + tuple(
             create_from_access_path(self.inference_state, access)
             for access in self.access_handle.py__mro__accesses()
@@ -81,40 +95,51 @@
 
     @CheckAttribute()
     def py__bases__(self):
+        """ """
         return tuple(
             create_from_access_path(self.inference_state, access)
             for access in self.access_handle.py__bases__()
         )
 
     def get_qualified_names(self):
+        """ """
         return self.access_handle.get_qualified_names()
 
     def py__bool__(self):
+        """ """
         return self.access_handle.py__bool__()
 
     def is_class(self):
+        """ """
         return self.access_handle.is_class()
 
     def is_function(self):
+        """ """
         return self.access_handle.is_function()
 
     def is_module(self):
+        """ """
         return self.access_handle.is_module()
 
     def is_compiled(self):
+        """ """
         return True
 
     def is_stub(self):
+        """ """
         return False
 
     def is_instance(self):
+        """ """
         return self.access_handle.is_instance()
 
     def py__doc__(self):
+        """ """
         return self.access_handle.py__doc__()
 
     @to_list
     def get_param_names(self):
+        """ """
         try:
             signature_params = self.access_handle.get_signature_params()
         except ValueError:  # Has no signature
@@ -133,6 +158,7 @@
                 yield SignatureParamName(self, signature_param)
 
     def get_signatures(self):
+        """ """
         _, return_string = self._parse_function_doc()
         return [BuiltinSignature(self, return_string)]
 
@@ -141,6 +167,7 @@
 
     @memoize_method
     def _parse_function_doc(self):
+        """ """
         doc = self.py__doc__()
         if doc is None:
             return '', ''
@@ -149,16 +176,52 @@
 
     @property
     def api_type(self):
+        """ """
         return self.access_handle.get_api_type()
 
     def get_filters(self, is_instance=False, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        is_instance :
+             (Default value = False)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield self._ensure_one_filter(is_instance)
 
     @memoize_method
     def _ensure_one_filter(self, is_instance):
+        """
+
+        Parameters
+        ----------
+        is_instance :
+            
+
+        Returns
+        -------
+
+        """
         return CompiledValueFilter(self.inference_state, self, is_instance)
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         with reraise_getitem_errors(IndexError, KeyError, TypeError):
             try:
                 access = self.access_handle.py__simple_getitem__(index)
@@ -170,6 +233,19 @@
         return ValueSet([create_from_access_path(self.inference_state, access)])
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         all_access_paths = self.access_handle.py__getitem__all_values()
         if all_access_paths is None:
             # This means basically that no __getitem__ has been defined on this
@@ -181,6 +257,17 @@
         )
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Python iterators are a bit strange, because there's no need for
         # the __iter__ function as long as __getitem__ is defined (it will
         # just start with __getitem__(0). This is especially true for
@@ -198,16 +285,29 @@
             yield LazyKnownValue(create_from_access_path(self.inference_state, access))
 
     def py__name__(self):
+        """ """
         return self.access_handle.py__name__()
 
     @property
     def name(self):
+        """ """
         name = self.py__name__()
         if name is None:
             name = self.access_handle.get_repr()
         return CompiledValueName(self, name)
 
     def _execute_function(self, params):
+        """
+
+        Parameters
+        ----------
+        params :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference import docstrings
         from jedi.inference.compiled import builtin_from_name
         if self.api_type != 'function':
@@ -228,6 +328,17 @@
             yield type_
 
     def get_safe_value(self, default=_sentinel):
+        """
+
+        Parameters
+        ----------
+        default :
+             (Default value = _sentinel)
+
+        Returns
+        -------
+
+        """
         try:
             return self.access_handle.get_safe_value()
         except ValueError:
@@ -236,6 +347,19 @@
             return default
 
     def execute_operation(self, other, operator):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        operator :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return ValueSet([create_from_access_path(
                 self.inference_state,
@@ -245,6 +369,7 @@
             return NO_VALUES
 
     def execute_annotation(self):
+        """ """
         if self.access_handle.get_repr() == 'None':
             # None as an annotation doesn't need to be executed.
             return ValueSet([self])
@@ -267,47 +392,68 @@
         return super(CompiledValue, self).execute_annotation()
 
     def negate(self):
+        """ """
         return create_from_access_path(self.inference_state, self.access_handle.negate())
 
     def get_metaclasses(self):
+        """ """
         return NO_VALUES
 
     def _as_context(self):
+        """ """
         return CompiledContext(self)
 
     @property
     def array_type(self):
+        """ """
         return self.access_handle.get_array_type()
 
     def get_key_values(self):
+        """ """
         return [
             create_from_access_path(self.inference_state, k)
             for k in self.access_handle.get_key_paths()
         ]
 
     def get_type_hint(self, add_class_info=True):
+        """
+
+        Parameters
+        ----------
+        add_class_info :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if self.access_handle.get_repr() in ('None', "<class 'NoneType'>"):
             return 'None'
         return None
 
 
 class CompiledModule(CompiledValue):
+    """ """
     file_io = None  # For modules
 
     def _as_context(self):
+        """ """
         return CompiledModuleContext(self)
 
     def py__path__(self):
+        """ """
         paths = self.access_handle.py__path__()
         if paths is None:
             return None
         return map(cast_path, paths)
 
     def is_package(self):
+        """ """
         return self.py__path__() is not None
 
     @property
     def string_names(self):
+        """ """
         # For modules
         name = self.py__name__()
         if name is None:
@@ -315,10 +461,12 @@
         return tuple(name.split('.'))
 
     def py__file__(self):
+        """ """
         return cast_path(self.access_handle.py__file__())
 
 
 class CompiledName(AbstractNameDefinition):
+    """ """
     def __init__(self, inference_state, parent_value, name):
         self._inference_state = inference_state
         self.parent_context = parent_value.as_context()
@@ -326,16 +474,19 @@
         self.string_name = name
 
     def py__doc__(self):
+        """ """
         value, = self.infer()
         return value.py__doc__()
 
     def _get_qualified_names(self):
+        """ """
         parent_qualified_names = self.parent_context.get_qualified_names()
         if parent_qualified_names is None:
             return None
         return parent_qualified_names + (self.string_name,)
 
     def get_defining_qualified_value(self):
+        """ """
         context = self.parent_context
         if context.is_module() or context.is_class():
             return self.parent_context.get_value()  # Might be None
@@ -351,6 +502,7 @@
 
     @property
     def api_type(self):
+        """ """
         api = self.infer()
         # If we can't find the type, assume it is an instance variable
         if not api:
@@ -359,22 +511,27 @@
 
     @memoize_method
     def infer(self):
+        """ """
         return ValueSet([self.infer_compiled_value()])
 
     def infer_compiled_value(self):
+        """ """
         return create_from_name(self._inference_state, self._parent_value, self.string_name)
 
 
 class SignatureParamName(ParamNameInterface, AbstractNameDefinition):
+    """ """
     def __init__(self, compiled_value, signature_param):
         self.parent_context = compiled_value.parent_context
         self._signature_param = signature_param
 
     @property
     def string_name(self):
+        """ """
         return self._signature_param.name
 
     def to_string(self):
+        """ """
         s = self._kind_string() + self.string_name
         if self._signature_param.has_annotation:
             s += ': ' + self._signature_param.annotation_string
@@ -383,9 +540,11 @@
         return s
 
     def get_kind(self):
+        """ """
         return getattr(Parameter, self._signature_param.kind_name)
 
     def infer(self):
+        """ """
         p = self._signature_param
         inference_state = self.parent_context.inference_state
         values = NO_VALUES
@@ -398,25 +557,30 @@
 
 
 class UnresolvableParamName(ParamNameInterface, AbstractNameDefinition):
+    """ """
     def __init__(self, compiled_value, name, default):
         self.parent_context = compiled_value.parent_context
         self.string_name = name
         self._default = default
 
     def get_kind(self):
+        """ """
         return Parameter.POSITIONAL_ONLY
 
     def to_string(self):
+        """ """
         string = self.string_name
         if self._default:
             string += '=' + self._default
         return string
 
     def infer(self):
+        """ """
         return NO_VALUES
 
 
 class CompiledValueName(ValueNameMixin, AbstractNameDefinition):
+    """ """
     def __init__(self, value, name):
         self.string_name = name
         self._value = value
@@ -424,26 +588,45 @@
 
 
 class EmptyCompiledName(AbstractNameDefinition):
-    """
-    Accessing some names will raise an exception. To avoid not having any
+    """Accessing some names will raise an exception. To avoid not having any
     completions, just give Jedi the option to return this object. It infers to
     nothing.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, inference_state, name):
         self.parent_context = inference_state.builtins_module
         self.string_name = name
 
     def infer(self):
+        """ """
         return NO_VALUES
 
 
 class CompiledValueFilter(AbstractFilter):
+    """ """
     def __init__(self, inference_state, compiled_value, is_instance=False):
         self._inference_state = inference_state
         self.compiled_value = compiled_value
         self.is_instance = is_instance
 
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         access_handle = self.compiled_value.access_handle
         return self._get(
             name,
@@ -453,8 +636,22 @@
         )
 
     def _get(self, name, allowed_getattr_callback, in_dir_callback, check_has_attribute=False):
-        """
-        To remove quite a few access calls we introduced the callback here.
+        """To remove quite a few access calls we introduced the callback here.
+
+        Parameters
+        ----------
+        name :
+            
+        allowed_getattr_callback :
+            
+        in_dir_callback :
+            
+        check_has_attribute :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         # Always use unicode objects in Python 2 from here.
         name = force_unicode(name)
@@ -479,12 +676,26 @@
 
     @memoize_method
     def _get_cached_name(self, name, is_empty=False):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        is_empty :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if is_empty:
             return EmptyCompiledName(self._inference_state, name)
         else:
             return self._create_name(name)
 
     def values(self):
+        """ """
         from jedi.inference.compiled import builtin_from_name
         names = []
         needs_type_completions, dir_infos = self.compiled_value.access_handle.get_dir_infos()
@@ -507,6 +718,17 @@
         return names
 
     def _create_name(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return CompiledName(
             self._inference_state,
             self.compiled_value,
@@ -527,12 +749,20 @@
 
 
 def _parse_function_doc(doc):
-    """
-    Takes a function and returns the params and return value as a tuple.
+    """Takes a function and returns the params and return value as a tuple.
     This is nothing more than a docstring parser.
-
+    
     TODO docstrings like utime(path, (atime, mtime)) and a(b [, b]) -> None
     TODO docstrings like 'tuple of integers'
+
+    Parameters
+    ----------
+    doc :
+        
+
+    Returns
+    -------
+
     """
     doc = force_unicode(doc)
     # parse round parentheses: def func(a, (b,c))
@@ -557,6 +787,17 @@
     else:
         # remove square brackets, that show an optional param ( = None)
         def change_options(m):
+            """
+
+            Parameters
+            ----------
+            m :
+                
+
+            Returns
+            -------
+
+            """
             args = m.group(1).split(',')
             for i, a in enumerate(args):
                 if a and '=' not in a:
@@ -588,6 +829,21 @@
 
 
 def create_from_name(inference_state, compiled_value, name):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    compiled_value :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     access_paths = compiled_value.access_handle.getattr_paths(name, default=None)
 
     value = None
@@ -601,13 +857,51 @@
 
 
 def _normalize_create_args(func):
-    """The cache doesn't care about keyword vs. normal args."""
+    """The cache doesn't care about keyword vs. normal args.
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(inference_state, obj, parent_context=None):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+        obj :
+            
+        parent_context :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return func(inference_state, obj, parent_context)
     return wrapper
 
 
 def create_from_access_path(inference_state, access_path):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    access_path :
+        
+
+    Returns
+    -------
+
+    """
     value = None
     for name, access in access_path.accesses:
         value = create_cached_compiled_value(
@@ -621,6 +915,21 @@
 @_normalize_create_args
 @inference_state_function_cache()
 def create_cached_compiled_value(inference_state, access_handle, parent_context):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    access_handle :
+        
+    parent_context :
+        
+
+    Returns
+    -------
+
+    """
     assert not isinstance(parent_context, CompiledValue)
     if parent_context is None:
         cls = CompiledModule
