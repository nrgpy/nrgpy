# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_einsum.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_einsum.py
@@ -13,7 +13,9 @@
 
 
 class TestEinsum:
+    """ """
     def test_einsum_errors(self):
+        """ """
         for do_opt in [True, False]:
             # Need enough arguments
             assert_raises(ValueError, np.einsum, optimize=do_opt)
@@ -95,6 +97,7 @@
                 np.einsum('aabcb,abc', a, b)
 
     def test_einsum_views(self):
+        """ """
         # pass-through
         for do_opt in [True, False]:
             a = np.arange(6)
@@ -234,6 +237,19 @@
             assert_equal(b, a.swapaxes(0, 1))
 
     def check_einsum_sums(self, dtype, do_opt=False):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        do_opt :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         # Check various sums.  Does many sizes to exercise unrolled loops.
 
         # sum(a, axis=-1)
@@ -529,55 +545,71 @@
                            [2.])  # contig_stride0_outstride0_two
 
     def test_einsum_sums_int8(self):
+        """ """
         self.check_einsum_sums('i1')
 
     def test_einsum_sums_uint8(self):
+        """ """
         self.check_einsum_sums('u1')
 
     def test_einsum_sums_int16(self):
+        """ """
         self.check_einsum_sums('i2')
 
     def test_einsum_sums_uint16(self):
+        """ """
         self.check_einsum_sums('u2')
 
     def test_einsum_sums_int32(self):
+        """ """
         self.check_einsum_sums('i4')
         self.check_einsum_sums('i4', True)
 
     def test_einsum_sums_uint32(self):
+        """ """
         self.check_einsum_sums('u4')
         self.check_einsum_sums('u4', True)
 
     def test_einsum_sums_int64(self):
+        """ """
         self.check_einsum_sums('i8')
 
     def test_einsum_sums_uint64(self):
+        """ """
         self.check_einsum_sums('u8')
 
     def test_einsum_sums_float16(self):
+        """ """
         self.check_einsum_sums('f2')
 
     def test_einsum_sums_float32(self):
+        """ """
         self.check_einsum_sums('f4')
 
     def test_einsum_sums_float64(self):
+        """ """
         self.check_einsum_sums('f8')
         self.check_einsum_sums('f8', True)
 
     def test_einsum_sums_longdouble(self):
+        """ """
         self.check_einsum_sums(np.longdouble)
 
     def test_einsum_sums_cfloat64(self):
+        """ """
         self.check_einsum_sums('c8')
         self.check_einsum_sums('c8', True)
 
     def test_einsum_sums_cfloat128(self):
+        """ """
         self.check_einsum_sums('c16')
 
     def test_einsum_sums_clongdouble(self):
+        """ """
         self.check_einsum_sums(np.clongdouble)
 
     def test_einsum_misc(self):
+        """ """
         # This call used to crash because of a bug in
         # PyArray_AssignZero
         a = np.ones((1, 2))
@@ -617,6 +649,7 @@
         assert_equal(np.einsum('i,j', [1], [2], out=None), [[2]])
 
     def test_subscript_range(self):
+        """ """
         # Issue #7741, make sure that all letters of Latin alphabet (both uppercase & lowercase) can be used
         # when creating a subscript from arrays
         a = np.ones((2, 3))
@@ -628,6 +661,7 @@
         assert_raises(ValueError, lambda: np.einsum(a, [-1, 5], b, [5, 2], [-1, 2], optimize=False))
 
     def test_einsum_broadcast(self):
+        """ """
         # Issue #2455 change in handling ellipsis
         # remove the 'middle broadcast' error
         # only use the 'RIGHT' iteration in prepare_op_axes
@@ -670,6 +704,7 @@
                                    optimize=opt), ref)  # used to raise error
 
     def test_einsum_fixedstridebug(self):
+        """ """
         # Issue #4485 obscure einsum bug
         # This case revealed a bug in nditer where it reported a stride
         # as 'fixed' (0) when it was in fact not fixed during processing
@@ -700,6 +735,7 @@
         assert_equal(es, tp)
 
     def test_einsum_fixed_collapsingbug(self):
+        """ """
         # Issue #5147.
         # The bug only occurred when output argument of einssum was used.
         x = np.random.normal(0, 1, (5, 5, 5, 5))
@@ -710,6 +746,7 @@
         assert_equal(y1, y2)
 
     def test_einsum_failed_on_p9_and_s390x(self):
+        """ """
         # Issues gh-14692 and gh-12689
         # Bug with signed vs unsigned char errored on power9 and s390x Linux
         tensor = np.random.random_sample((10, 10, 10, 10))
@@ -718,6 +755,7 @@
         assert_allclose(x, y)
 
     def test_einsum_all_contig_non_contig_output(self):
+        """ """
         # Issue gh-5907, tests that the all contiguous special case
         # actually checks the contiguity of the output
         x = np.ones((5, 5))
@@ -741,6 +779,7 @@
         assert_array_equal(out.base, correct_base)
 
     def test_small_boolean_arrays(self):
+        """ """
         # See gh-5946.
         # Use array of True embedded in False.
         a = np.zeros((16, 1, 1), dtype=np.bool_)[:2]
@@ -751,11 +790,25 @@
         assert_equal(res, tgt)
 
     def test_out_is_res(self):
+        """ """
         a = np.arange(9).reshape(3, 3)
         res = np.einsum('...ij,...jk->...ik', a, a, out=a)
         assert res is a
 
     def optimize_compare(self, subscripts, operands=None):
+        """
+
+        Parameters
+        ----------
+        subscripts :
+            
+        operands :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Tests all paths of the optimization function against
         # conventional einsum
         if operands is None:
@@ -774,17 +827,20 @@
         assert_almost_equal(opt, noopt)
 
     def test_hadamard_like_products(self):
+        """ """
         # Hadamard outer products
         self.optimize_compare('a,ab,abc->abc')
         self.optimize_compare('a,b,ab->ab')
 
     def test_index_transformations(self):
+        """ """
         # Simple index transformation cases
         self.optimize_compare('ea,fb,gc,hd,abcd->efgh')
         self.optimize_compare('ea,fb,abcd,gc,hd->efgh')
         self.optimize_compare('abcd,ea,fb,gc,hd->efgh')
 
     def test_complex(self):
+        """ """
         # Long test cases
         self.optimize_compare('acdf,jbje,gihb,hfac,gfac,gifabc,hfac')
         self.optimize_compare('acdf,jbje,gihb,hfac,gfac,gifabc,hfac')
@@ -796,6 +852,7 @@
         self.optimize_compare('bdhe,acad,hiab,agac,hibd')
 
     def test_collapse(self):
+        """ """
         # Inner products
         self.optimize_compare('ab,ab,c->')
         self.optimize_compare('ab,ab,c->c')
@@ -805,6 +862,7 @@
         self.optimize_compare('ab,ab,cd,cd,ef,ef->')
 
     def test_expand(self):
+        """ """
         # Outer products
         self.optimize_compare('ab,cd,ef->abcdef')
         self.optimize_compare('ab,cd,ef->acdf')
@@ -814,6 +872,7 @@
         self.optimize_compare('ab,bcd,cd->abd')
 
     def test_edge_cases(self):
+        """ """
         # Difficult edge cases for optimization
         self.optimize_compare('eb,cb,fb->cef')
         self.optimize_compare('dd,fb,be,cdb->cef')
@@ -829,6 +888,7 @@
         self.optimize_compare('ba,ac,da->bcd')
 
     def test_inner_product(self):
+        """ """
         # Inner products
         self.optimize_compare('ab,ab')
         self.optimize_compare('ab,ba')
@@ -837,6 +897,7 @@
         self.optimize_compare('abc,cba')
 
     def test_random_cases(self):
+        """ """
         # Randomly built test cases
         self.optimize_compare('aab,fa,df,ecc->bde')
         self.optimize_compare('ecb,fef,bad,ed->ac')
@@ -851,12 +912,14 @@
         self.optimize_compare('aef,fbc,dca->bde')
 
     def test_combined_views_mapping(self):
+        """ """
         # gh-10792
         a = np.arange(9).reshape(1, 1, 3, 1, 3)
         b = np.einsum('bbcdc->d', a)
         assert_equal(b, [12])
 
     def test_broadcasting_dot_cases(self):
+        """ """
         # Ensures broadcasting cases are not mistaken for GEMM
 
         a = np.random.rand(1, 5, 4)
@@ -878,7 +941,21 @@
 
 
 class TestEinsumPath:
+    """ """
     def build_operands(self, string, size_dict=global_size_dict):
+        """
+
+        Parameters
+        ----------
+        string :
+            
+        size_dict :
+             (Default value = global_size_dict)
+
+        Returns
+        -------
+
+        """
 
         # Builds views based off initial operands
         operands = [string]
@@ -890,6 +967,19 @@
         return operands
 
     def assert_path_equal(self, comp, benchmark):
+        """
+
+        Parameters
+        ----------
+        comp :
+            
+        benchmark :
+            
+
+        Returns
+        -------
+
+        """
         # Checks if list of tuples are equivalent
         ret = (len(comp) == len(benchmark))
         assert_(ret)
@@ -899,6 +989,7 @@
         assert_(ret)
 
     def test_memory_contraints(self):
+        """ """
         # Ensure memory constraints are satisfied
 
         outer_test = self.build_operands('a,b,c->abc')
@@ -917,6 +1008,7 @@
         self.assert_path_equal(path, ['einsum_path', (0, 1, 2, 3)])
 
     def test_long_paths(self):
+        """ """
         # Long complex cases
 
         # Long test 1
@@ -942,6 +1034,7 @@
                                       (0, 5), (1, 4), (3, 4), (1, 3), (1, 2), (0, 1)])
 
     def test_edge_paths(self):
+        """ """
         # Difficult edge cases
 
         # Edge test1
@@ -986,6 +1079,7 @@
         self.assert_path_equal(path, ['einsum_path', (0, 1), (0, 1, 2, 3, 4, 5)])
 
     def test_path_type_input(self):
+        """ """
         # Test explicit path handeling
         path_test = self.build_operands('dcc,fce,ea,dbf->ab')
 
@@ -1005,6 +1099,7 @@
         assert_almost_equal(noopt, opt)
 
     def test_spaces(self):
+        """ """
         #gh-10794
         arr = np.array([[1]])
         for sp in itertools.product(['', ' '], repeat=4):
@@ -1012,6 +1107,7 @@
             np.einsum('{}...a{}->{}...a{}'.format(*sp), arr)
 
 def test_overlap():
+    """ """
     a = np.arange(9, dtype=int).reshape(3, 3)
     b = np.arange(9, dtype=int).reshape(3, 3)
     d = np.dot(a, b)
