# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/numeric.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/numeric.py
@@ -39,10 +39,16 @@
 
 
 class NumericIndex(Index):
-    """
-    Provide numeric type operations.
-
+    """Provide numeric type operations.
+    
     This is an abstract class.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     _is_numeric_dtype = True
@@ -80,6 +86,17 @@
 
     @classmethod
     def _validate_dtype(cls, dtype: Dtype) -> None:
+        """
+
+        Parameters
+        ----------
+        dtype: Dtype :
+            
+
+        Returns
+        -------
+
+        """
         if dtype is None:
             return
         validation_metadata = {
@@ -97,6 +114,21 @@
 
     @doc(Index._maybe_cast_slice_bound)
     def _maybe_cast_slice_bound(self, label, side, kind):
+        """
+
+        Parameters
+        ----------
+        label :
+            
+        side :
+            
+        kind :
+            
+
+        Returns
+        -------
+
+        """
         assert kind in ["loc", "getitem", None]
 
         # we will try to coerce to integers
@@ -104,6 +136,19 @@
 
     @doc(Index._shallow_copy)
     def _shallow_copy(self, values=None, name: Label = lib.no_default):
+        """
+
+        Parameters
+        ----------
+        values :
+             (Default value = None)
+        name: Label :
+             (Default value = lib.no_default)
+
+        Returns
+        -------
+
+        """
         if values is not None and not self._can_hold_na and values.dtype.kind == "f":
             name = self.name if name is lib.no_default else name
             # Ensure we are not returning an Int64Index with float data:
@@ -111,8 +156,16 @@
         return super()._shallow_copy(values=values, name=name)
 
     def _convert_for_op(self, value):
-        """
-        Convert value to be insertable to ndarray.
+        """Convert value to be insertable to ndarray.
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
         """
         if is_bool(value) or is_bool_dtype(value):
             # force conversion to object
@@ -122,6 +175,19 @@
         return value
 
     def _convert_tolerance(self, tolerance, target):
+        """
+
+        Parameters
+        ----------
+        tolerance :
+            
+        target :
+            
+
+        Returns
+        -------
+
+        """
         tolerance = np.asarray(tolerance)
         if target.size != tolerance.size and tolerance.size > 1:
             raise ValueError("list-like tolerance size must match target index size")
@@ -140,28 +206,62 @@
 
     @classmethod
     def _assert_safe_casting(cls, data, subarr):
-        """
-        Subclasses need to override this only if the process of casting data
+        """Subclasses need to override this only if the process of casting data
         from some accepted dtype to the internal dtype(s) bears the risk of
         truncation (e.g. float to int).
+
+        Parameters
+        ----------
+        data :
+            
+        subarr :
+            
+
+        Returns
+        -------
+
         """
         pass
 
     @property
     def is_all_dates(self) -> bool:
-        """
-        Checks that all the labels are datetime objects.
-        """
+        """Checks that all the labels are datetime objects."""
         return False
 
     @doc(Index.insert)
     def insert(self, loc: int, item):
+        """
+
+        Parameters
+        ----------
+        loc: int :
+            
+        item :
+            
+
+        Returns
+        -------
+
+        """
         # treat NA values as nans:
         if is_scalar(item) and isna(item):
             item = self._na_value
         return super().insert(loc, item)
 
     def _union(self, other, sort):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        sort :
+            
+
+        Returns
+        -------
+
+        """
         # Right now, we treat union(int, float) a bit special.
         # See https://github.com/pandas-dev/pandas/issues/26778 for discussion
         # We may change union(int, float) to go to object.
@@ -216,9 +316,7 @@
 
 
 class IntegerIndex(NumericIndex):
-    """
-    This is an abstract class for Int64Index, UInt64Index.
-    """
+    """This is an abstract class for Int64Index, UInt64Index."""
 
     _default_dtype: np.dtype
 
@@ -236,18 +334,18 @@
 
     @property
     def inferred_type(self) -> str:
-        """
-        Always 'integer' for ``Int64Index`` and ``UInt64Index``
-        """
+        """Always 'integer' for ``Int64Index`` and ``UInt64Index``"""
         return "integer"
 
     @property
     def asi8(self) -> np.ndarray:
+        """ """
         # do not cache or you'll create a memory leak
         return self._values.view(self._default_dtype)
 
 
 class Int64Index(IntegerIndex):
+    """ """
     __doc__ = _num_index_shared_docs["class_descr"] % _int64_descr_args
 
     _typ = "int64index"
@@ -256,19 +354,53 @@
     _default_dtype = np.dtype(np.int64)
 
     def _wrap_joined_index(self, joined, other):
+        """
+
+        Parameters
+        ----------
+        joined :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         name = get_op_result_name(self, other)
         return Int64Index(joined, name=name)
 
     @classmethod
     def _assert_safe_casting(cls, data, subarr):
-        """
-        Ensure incoming data can be represented as ints.
+        """Ensure incoming data can be represented as ints.
+
+        Parameters
+        ----------
+        data :
+            
+        subarr :
+            
+
+        Returns
+        -------
+
         """
         if not issubclass(data.dtype.type, np.signedinteger):
             if not np.array_equal(data, subarr):
                 raise TypeError("Unsafe NumPy casting, you must explicitly cast")
 
     def _is_compatible_with_other(self, other) -> bool:
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         return super()._is_compatible_with_other(other) or all(
             isinstance(obj, (ABCInt64Index, ABCFloat64Index, ABCRangeIndex))
             for obj in [self, other]
@@ -284,6 +416,7 @@
 
 
 class UInt64Index(IntegerIndex):
+    """ """
     __doc__ = _num_index_shared_docs["class_descr"] % _uint64_descr_args
 
     _typ = "uint64index"
@@ -293,6 +426,17 @@
 
     @doc(Index._convert_arr_indexer)
     def _convert_arr_indexer(self, keyarr):
+        """
+
+        Parameters
+        ----------
+        keyarr :
+            
+
+        Returns
+        -------
+
+        """
         # Cast the indexer to uint64 if possible so that the values returned
         # from indexing are also uint64.
         dtype = None
@@ -305,6 +449,17 @@
 
     @doc(Index._convert_index_indexer)
     def _convert_index_indexer(self, keyarr):
+        """
+
+        Parameters
+        ----------
+        keyarr :
+            
+
+        Returns
+        -------
+
+        """
         # Cast the indexer to uint64 if possible so
         # that the values returned from indexing are
         # also uint64.
@@ -313,19 +468,53 @@
         return keyarr
 
     def _wrap_joined_index(self, joined, other):
+        """
+
+        Parameters
+        ----------
+        joined :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         name = get_op_result_name(self, other)
         return UInt64Index(joined, name=name)
 
     @classmethod
     def _assert_safe_casting(cls, data, subarr):
-        """
-        Ensure incoming data can be represented as uints.
+        """Ensure incoming data can be represented as uints.
+
+        Parameters
+        ----------
+        data :
+            
+        subarr :
+            
+
+        Returns
+        -------
+
         """
         if not issubclass(data.dtype.type, np.unsignedinteger):
             if not np.array_equal(data, subarr):
                 raise TypeError("Unsafe NumPy casting, you must explicitly cast")
 
     def _is_compatible_with_other(self, other) -> bool:
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         return super()._is_compatible_with_other(other) or all(
             isinstance(obj, (ABCUInt64Index, ABCFloat64Index)) for obj in [self, other]
         )
@@ -340,6 +529,7 @@
 
 
 class Float64Index(NumericIndex):
+    """ """
     __doc__ = _num_index_shared_docs["class_descr"] % _float64_descr_args
 
     _typ = "float64index"
@@ -348,13 +538,24 @@
 
     @property
     def inferred_type(self) -> str:
-        """
-        Always 'floating' for ``Float64Index``
-        """
+        """Always 'floating' for ``Float64Index``"""
         return "floating"
 
     @doc(Index.astype)
     def astype(self, dtype, copy=True):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         dtype = pandas_dtype(dtype)
         if needs_i8_conversion(dtype):
             raise TypeError(
@@ -373,10 +574,24 @@
 
     @doc(Index._should_fallback_to_positional)
     def _should_fallback_to_positional(self) -> bool:
+        """ """
         return False
 
     @doc(Index._convert_slice_indexer)
     def _convert_slice_indexer(self, key: slice, kind: str):
+        """
+
+        Parameters
+        ----------
+        key: slice :
+            
+        kind: str :
+            
+
+        Returns
+        -------
+
+        """
         assert kind in ["loc", "getitem"]
 
         # We always treat __getitem__ slicing as label-based
@@ -388,6 +603,25 @@
     def _format_native_types(
         self, na_rep="", float_format=None, decimal=".", quoting=None, **kwargs
     ):
+        """
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "")
+        float_format :
+             (Default value = None)
+        decimal :
+             (Default value = ".")
+        quoting :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         from pandas.io.formats.format import FloatArrayFormatter
 
         formatter = FloatArrayFormatter(
@@ -409,6 +643,21 @@
 
     @doc(Index.get_loc)
     def get_loc(self, key, method=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        method :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if is_bool(key):
             # Catch this to avoid accidentally casting to 1.0
             raise KeyError(key)
@@ -425,15 +674,40 @@
 
     @cache_readonly
     def is_unique(self) -> bool:
+        """ """
         return super().is_unique and self._nan_idxs.size < 2
 
     @doc(Index.isin)
     def isin(self, values, level=None):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        level :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if level is not None:
             self._validate_index_level(level)
         return algorithms.isin(np.array(self), values)
 
     def _is_compatible_with_other(self, other) -> bool:
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         return super()._is_compatible_with_other(other) or all(
             isinstance(
                 obj, (ABCInt64Index, ABCFloat64Index, ABCUInt64Index, ABCRangeIndex),
