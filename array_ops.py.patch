# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/ops/array_ops.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/ops/array_ops.py
@@ -37,6 +37,21 @@
 
 
 def comp_method_OBJECT_ARRAY(op, x, y):
+    """
+
+    Parameters
+    ----------
+    op :
+        
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(y, list):
         y = construct_1d_object_array_from_listlike(y)
 
@@ -58,15 +73,22 @@
 
 
 def masked_arith_op(x: np.ndarray, y, op):
-    """
-    If the given arithmetic operation fails, attempt it again on
+    """If the given arithmetic operation fails, attempt it again on
     only the non-null elements of the input array(s).
 
     Parameters
     ----------
-    x : np.ndarray
-    y : np.ndarray, Series, Index
-    op : binary operator
+    x: np.ndarray :
+        
+    y :
+        
+    op :
+        
+
+    Returns
+    -------
+
+    
     """
     # For Series `x` is 1D so ravel() is a no-op; calling it anyway makes
     # the logic valid for both Series and DataFrame ops.
@@ -117,25 +139,29 @@
 
 
 def na_arithmetic_op(left, right, op, is_cmp: bool = False):
-    """
-    Return the result of evaluating op on the passed in values.
-
+    """Return the result of evaluating op on the passed in values.
+    
     If native types are not compatible, try coercion to object dtype.
 
     Parameters
     ----------
     left : np.ndarray
+        
     right : np.ndarray or scalar
+        
     is_cmp : bool, default False
         If this a comparison operation.
+    op :
+        
+    is_cmp: bool :
+         (Default value = False)
 
     Returns
     -------
     array-like
-
-    Raises
-    ------
-    TypeError : invalid operation
+        
+
+    
     """
     import pandas.core.computation.expressions as expressions
 
@@ -158,21 +184,25 @@
 
 
 def arithmetic_op(left: ArrayLike, right: Any, op):
-    """
-    Evaluate an arithmetic operation `+`, `-`, `*`, `/`, `//`, `%`, `**`, ...
+    """Evaluate an arithmetic operation `+`, `-`, `*`, `/`, `//`, `%`, `**`, ...
 
     Parameters
     ----------
     left : np.ndarray or ExtensionArray
+        
     right : object
         Cannot be a DataFrame or Index.  Series is *not* excluded.
     op : {operator.add, operator.sub, ...}
         Or one of the reversed variants from roperator.
-
-    Returns
-    -------
-    ndarray or ExtensionArray
-        Or a 2-tuple of these in the case of divmod or rdivmod.
+    left: ArrayLike :
+        
+    right: Any :
+        
+
+    Returns
+    -------
+
+    
     """
 
     # NB: We assume that extract_array has already been called
@@ -193,19 +223,25 @@
 
 
 def comparison_op(left: ArrayLike, right: Any, op) -> ArrayLike:
-    """
-    Evaluate a comparison operation `=`, `!=`, `>=`, `>`, `<=`, or `<`.
+    """Evaluate a comparison operation `=`, `!=`, `>=`, `>`, `<=`, or `<`.
 
     Parameters
     ----------
     left : np.ndarray or ExtensionArray
+        
     right : object
         Cannot be a DataFrame, Series, or Index.
     op : {operator.eq, operator.ne, operator.gt, operator.ge, operator.lt, operator.le}
-
-    Returns
-    -------
-    ndarray or ExtensionArray
+        
+    left: ArrayLike :
+        
+    right: Any :
+        
+
+    Returns
+    -------
+
+    
     """
     # NB: We assume extract_array has already been called on left and right
     lvalues = maybe_upcast_datetimelike_array(left)
@@ -254,6 +290,21 @@
 
 
 def na_logical_op(x: np.ndarray, y, op):
+    """
+
+    Parameters
+    ----------
+    x: np.ndarray :
+        
+    y :
+        
+    op :
+        
+
+    Returns
+    -------
+
+    """
     try:
         # For exposition, write:
         #  yarr = isinstance(y, np.ndarray)
@@ -295,24 +346,42 @@
 
 
 def logical_op(left: ArrayLike, right: Any, op) -> ArrayLike:
-    """
-    Evaluate a logical operation `|`, `&`, or `^`.
+    """Evaluate a logical operation `|`, `&`, or `^`.
 
     Parameters
     ----------
     left : np.ndarray or ExtensionArray
+        
     right : object
         Cannot be a DataFrame, Series, or Index.
     op : {operator.and_, operator.or_, operator.xor}
         Or one of the reversed variants from roperator.
-
-    Returns
-    -------
-    ndarray or ExtensionArray
+    left: ArrayLike :
+        
+    right: Any :
+        
+
+    Returns
+    -------
+
+    
     """
     fill_int = lambda x: x
 
     def fill_bool(x, left=None):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+        left :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # if `left` is specifically not-boolean, we do not cast to bool
         if x.dtype.kind in ["c", "f", "O"]:
             # dtypes that can hold NA
@@ -360,8 +429,7 @@
 
 
 def get_array_op(op):
-    """
-    Return a binary array operation corresponding to the given operator op.
+    """Return a binary array operation corresponding to the given operator op.
 
     Parameters
     ----------
@@ -370,7 +438,8 @@
 
     Returns
     -------
-    functools.partial
+
+    
     """
     if isinstance(op, partial):
         # We get here via dispatch_to_series in DataFrame case
@@ -402,16 +471,19 @@
 
 
 def maybe_upcast_datetimelike_array(obj: ArrayLike) -> ArrayLike:
-    """
-    If we have an ndarray that is either datetime64 or timedelta64, wrap in EA.
+    """If we have an ndarray that is either datetime64 or timedelta64, wrap in EA.
 
     Parameters
     ----------
     obj : ndarray or ExtensionArray
-
-    Returns
-    -------
-    ndarray or ExtensionArray
+        
+    obj: ArrayLike :
+        
+
+    Returns
+    -------
+
+    
     """
     if isinstance(obj, np.ndarray):
         if obj.dtype.kind == "m":
@@ -427,18 +499,24 @@
 
 
 def maybe_upcast_for_op(obj, shape: Tuple[int, ...]):
-    """
-    Cast non-pandas objects to pandas types to unify behavior of arithmetic
+    """Cast non-pandas objects to pandas types to unify behavior of arithmetic
     and comparison operations.
 
     Parameters
     ----------
-    obj: object
+    obj : object
+        
     shape : tuple[int]
+        
+    shape: Tuple[int :
+        
+    ...] :
+        
 
     Returns
     -------
     out : object
+        
 
     Notes
     -----
