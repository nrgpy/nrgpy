# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_umath.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_umath.py
@@ -16,7 +16,7 @@
     )
 
 def on_powerpc():
-    """ True if we are running on a Power PC platform."""
+    """True if we are running on a Power PC platform."""
     return platform.processor() == 'powerpc' or \
            platform.machine().startswith('ppc')
 
@@ -26,6 +26,13 @@
     complex256. Rather than dig through the actual problem skip the
     test. This should be fixed when we can move past glibc2.17
     which is the version in manylinux2014
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     x = 1.78e-10
     v1 = np.arcsinh(np.float128(x))
@@ -43,26 +50,35 @@
 
 
 class _FilterInvalids:
+    """ """
     def setup(self):
+        """ """
         self.olderr = np.seterr(invalid='ignore')
 
     def teardown(self):
+        """ """
         np.seterr(**self.olderr)
 
 
 class TestConstants:
+    """ """
     def test_pi(self):
+        """ """
         assert_allclose(ncu.pi, 3.141592653589793, 1e-15)
 
     def test_e(self):
+        """ """
         assert_allclose(ncu.e, 2.718281828459045, 1e-15)
 
     def test_euler_gamma(self):
+        """ """
         assert_allclose(ncu.euler_gamma, 0.5772156649015329, 1e-15)
 
 
 class TestOut:
+    """ """
     def test_out_subok(self):
+        """ """
         for subok in (True, False):
             a = np.array(0.5)
             o = np.empty(())
@@ -112,7 +128,9 @@
             assert_raises(ValueError, np.add, a, 2, out=(o,), subok=subok)
 
     def test_out_wrap_subok(self):
+        """ """
         class ArrayWrap(np.ndarray):
+            """ """
             __array_priority__ = 10
 
             def __new__(cls, arr):
@@ -188,7 +206,9 @@
 
 
 class TestComparisons:
+    """ """
     def test_ignore_object_identity_in_equal(self):
+        """ """
         # Check comparing identical objects whose comparison
         # is not a simple boolean, e.g., arrays that are compared elementwise.
         a = np.array([np.array([1, 2, 3]), None], dtype=object)
@@ -196,6 +216,7 @@
 
         # Check error raised when comparing identical non-comparable objects.
         class FunkyType:
+            """ """
             def __eq__(self, other):
                 raise TypeError("I won't compare")
 
@@ -207,6 +228,7 @@
         assert_equal(np.equal(a, a), [False])
 
     def test_ignore_object_identity_in_not_equal(self):
+        """ """
         # Check comparing identical objects whose comparison
         # is not a simple boolean, e.g., arrays that are compared elementwise.
         a = np.array([np.array([1, 2, 3]), None], dtype=object)
@@ -214,6 +236,7 @@
 
         # Check error raised when comparing identical non-comparable objects.
         class FunkyType:
+            """ """
             def __ne__(self, other):
                 raise TypeError("I won't compare")
 
@@ -226,7 +249,9 @@
 
 
 class TestAdd:
+    """ """
     def test_reduce_alignment(self):
+        """ """
         # gh-9876
         # make sure arrays with weird strides work with the optimizations in
         # pairwise_sum_@TYPE@. On x86, the 'b' field will count as aligned at a
@@ -237,7 +262,9 @@
 
 
 class TestDivision:
+    """ """
     def test_division_int(self):
+        """ """
         # int division should follow Python
         x = np.array([5, 10, 90, 100, -5, -10, -90, -100, -120])
         if 5 / 10 == 0.5:
@@ -249,6 +276,7 @@
         assert_equal(x % 100, [5, 10, 90, 0, 95, 90, 10, 0, 80])
 
     def test_division_complex(self):
+        """ """
         # check that implementation is correct
         msg = "Complex division implementation check"
         x = np.array([1. + 1.*1j, 1. + .5*1j, 1. + 2.*1j], dtype=np.complex128)
@@ -260,6 +288,7 @@
         assert_almost_equal(y/x, [1, 1], err_msg=msg)
 
     def test_zero_division_complex(self):
+        """ """
         with np.errstate(invalid="ignore", divide="ignore"):
             x = np.array([0.0], dtype=np.complex128)
             y = 1.0/x
@@ -274,6 +303,7 @@
             assert_(np.isnan(y)[0])
 
     def test_floor_division_complex(self):
+        """ """
         # check that implementation is correct
         msg = "Complex floor division implementation check"
         x = np.array([.9 + 1j, -.1 + 1j, .9 + .5*1j, .9 + 2.*1j], dtype=np.complex128)
@@ -286,6 +316,7 @@
         assert_equal(y, [1.e+110, 0], err_msg=msg)
 
     def test_floor_division_signed_zero(self):
+        """ """
         # Check that the sign bit is correctly set when dividing positive and
         # negative zero by one.
         x = np.zeros(10)
@@ -293,10 +324,34 @@
         assert_equal(np.signbit((-x)//1), 1)
 
 def floor_divide_and_remainder(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     return (np.floor_divide(x, y), np.remainder(x, y))
 
 
 def _signs(dt):
+    """
+
+    Parameters
+    ----------
+    dt :
+        
+
+    Returns
+    -------
+
+    """
     if dt in np.typecodes['UnsignedInteger']:
         return (+1,)
     else:
@@ -304,8 +359,10 @@
 
 
 class TestRemainder:
+    """ """
 
     def test_remainder_basic(self):
+        """ """
         dt = np.typecodes['AllInteger'] + np.typecodes['Float']
         for op in [floor_divide_and_remainder, np.divmod]:
             for dt1, dt2 in itertools.product(dt, dt):
@@ -322,6 +379,7 @@
                         assert_(b > rem >= 0, msg)
 
     def test_float_remainder_exact(self):
+        """ """
         # test that float results are exact for small integers. This also
         # holds for the same integers scaled by powers of two.
         nlst = list(range(-127, 0))
@@ -348,6 +406,7 @@
                 assert_equal(rem, tgtrem, err_msg=msg)
 
     def test_float_remainder_roundoff(self):
+        """ """
         # gh-6127
         dt = np.typecodes['Float']
         for op in [floor_divide_and_remainder, np.divmod]:
@@ -366,6 +425,7 @@
                         assert_(b > rem >= 0, msg)
 
     def test_float_remainder_corner_cases(self):
+        """ """
         # Check remainder magnitude.
         for dt in np.typecodes['Float']:
             b = np.array(1.0, dtype=dt)
@@ -395,10 +455,13 @@
 
 
 class TestCbrt:
+    """ """
     def test_cbrt_scalar(self):
+        """ """
         assert_almost_equal((np.cbrt(np.float32(-2.5)**3)), -2.5)
 
     def test_cbrt(self):
+        """ """
         x = np.array([1., 2., -3., np.inf, -np.inf])
         assert_almost_equal(np.cbrt(x**3), x)
 
@@ -408,7 +471,9 @@
 
 
 class TestPower:
+    """ """
     def test_power_float(self):
+        """ """
         x = np.array([1., 2., 3.])
         assert_equal(x**0, [1., 1., 1.])
         assert_equal(x**1, x)
@@ -436,6 +501,7 @@
             assert_equal(out, exp, err_msg=msg)
 
     def test_power_complex(self):
+        """ """
         x = np.array([1+2j, 2+3j, 3+4j])
         assert_equal(x**0, [1., 1., 1.])
         assert_equal(x**1, x)
@@ -455,6 +521,19 @@
 
         # Ticket #836
         def assert_complex_equal(x, y):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+            y :
+                
+
+            Returns
+            -------
+
+            """
             assert_array_equal(x.real, y.real)
             assert_array_equal(x.imag, y.imag)
 
@@ -466,6 +545,7 @@
                 assert_complex_equal(z**3, z*z*z)
 
     def test_power_zero(self):
+        """ """
         # ticket #1271
         zero = np.array([0j])
         one = np.array([1+0j])
@@ -474,6 +554,19 @@
         #cinf = np.array([complex(np.inf, 0)])
 
         def assert_complex_equal(x, y):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+            y :
+                
+
+            Returns
+            -------
+
+            """
             x, y = np.asarray(x), np.asarray(y)
             assert_array_equal(x.real, y.real)
             assert_array_equal(x.imag, y.imag)
@@ -493,6 +586,7 @@
             assert_complex_equal(np.power(zero, -1+0.2j), cnan)
 
     def test_fast_power(self):
+        """ """
         x = np.array([1, 2, 3], np.int16)
         res = x**2.0
         assert_((x**2.00001).dtype is res.dtype)
@@ -506,11 +600,13 @@
         assert_equal(res.shape, (1, 1, 3))
 
     def test_integer_power(self):
+        """ """
         a = np.array([15, 15], 'i8')
         b = np.power(a, a)
         assert_equal(b, [437893890380859375, 437893890380859375])
 
     def test_integer_power_with_integer_zero_exponent(self):
+        """ """
         dtypes = np.typecodes['Integer']
         for dt in dtypes:
             arr = np.arange(-10, 10, dtype=dt)
@@ -522,18 +618,21 @@
             assert_equal(np.power(arr, 0), np.ones_like(arr))
 
     def test_integer_power_of_1(self):
+        """ """
         dtypes = np.typecodes['AllInteger']
         for dt in dtypes:
             arr = np.arange(10, dtype=dt)
             assert_equal(np.power(1, arr), np.ones_like(arr))
 
     def test_integer_power_of_zero(self):
+        """ """
         dtypes = np.typecodes['AllInteger']
         for dt in dtypes:
             arr = np.arange(1, 10, dtype=dt)
             assert_equal(np.power(0, arr), np.zeros_like(arr))
 
     def test_integer_to_negative_power(self):
+        """ """
         dtypes = np.typecodes['Integer']
         for dt in dtypes:
             a = np.array([0, 1, 2, 3], dtype=dt)
@@ -547,7 +646,9 @@
 
 
 class TestFloat_power:
+    """ """
     def test_type_conversion(self):
+        """ """
         arg_type = '?bhilBHILefdgFDG'
         res_type = 'ddddddddddddgDDG'
         for dtin, dtout in zip(arg_type, res_type):
@@ -558,7 +659,9 @@
 
 
 class TestLog2:
+    """ """
     def test_log2_values(self):
+        """ """
         x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
         y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         for dt in ['f', 'd', 'g']:
@@ -567,6 +670,7 @@
             assert_almost_equal(np.log2(xf), yf)
 
     def test_log2_ints(self):
+        """ """
         # a good log2 implementation should provide this,
         # might fail on OS with bad libm
         for i in range(1, 65):
@@ -574,6 +678,7 @@
             assert_equal(v, float(i), err_msg='at exponent %d' % i)
 
     def test_log2_special(self):
+        """ """
         assert_equal(np.log2(1.), 0.)
         assert_equal(np.log2(np.inf), np.inf)
         assert_(np.isnan(np.log2(np.nan)))
@@ -589,7 +694,9 @@
 
 
 class TestExp2:
+    """ """
     def test_exp2_values(self):
+        """ """
         x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
         y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         for dt in ['f', 'd', 'g']:
@@ -599,8 +706,10 @@
 
 
 class TestLogAddExp2(_FilterInvalids):
+    """ """
     # Need test for intermediate precisions
     def test_logaddexp2_values(self):
+        """ """
         x = [1, 2, 3, 4, 5]
         y = [5, 4, 3, 2, 1]
         z = [6, 6, 6, 6, 6]
@@ -611,6 +720,7 @@
             assert_almost_equal(np.logaddexp2(xf, yf), zf, decimal=dec_)
 
     def test_logaddexp2_range(self):
+        """ """
         x = [1000000, -1000000, 1000200, -1000200]
         y = [1000200, -1000200, 1000000, -1000000]
         z = [1000200, -1000000, 1000200, -1000000]
@@ -621,6 +731,7 @@
             assert_almost_equal(np.logaddexp2(logxf, logyf), logzf)
 
     def test_inf(self):
+        """ """
         inf = np.inf
         x = [inf, -inf,  inf, -inf, inf, 1,  -inf,  1]
         y = [inf,  inf, -inf, -inf, 1,   inf, 1,   -inf]
@@ -633,6 +744,7 @@
                 assert_equal(np.logaddexp2(logxf, logyf), logzf)
 
     def test_nan(self):
+        """ """
         assert_(np.isnan(np.logaddexp2(np.nan, np.inf)))
         assert_(np.isnan(np.logaddexp2(np.inf, np.nan)))
         assert_(np.isnan(np.logaddexp2(np.nan, 0)))
@@ -640,6 +752,7 @@
         assert_(np.isnan(np.logaddexp2(np.nan, np.nan)))
 
     def test_reduce(self):
+        """ """
         assert_equal(np.logaddexp2.identity, -np.inf)
         assert_equal(np.logaddexp2.reduce([]), -np.inf)
         assert_equal(np.logaddexp2.reduce([-np.inf]), -np.inf)
@@ -647,7 +760,9 @@
 
 
 class TestLog:
+    """ """
     def test_log_values(self):
+        """ """
         x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
         y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         for dt in ['f', 'd', 'g']:
@@ -658,7 +773,9 @@
 
 
 class TestExp:
+    """ """
     def test_exp_values(self):
+        """ """
         x = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
         y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         for dt in ['f', 'd', 'g']:
@@ -668,6 +785,7 @@
             assert_almost_equal(np.exp(yf), xf)
 
     def test_exp_strides(self):
+        """ """
         np.random.seed(42)
         strides = np.array([-4,-3,-2,-1,1,2,3,4])
         sizes = np.arange(2,100)
@@ -678,7 +796,9 @@
                 assert_array_almost_equal_nulp(np.exp(x_f64[::jj]), y_true[::jj], nulp=2)
 
 class TestSpecialFloats:
+    """ """
     def test_exp_values(self):
+        """ """
         x = [np.nan,  np.nan, np.inf, 0.]
         y = [np.nan, -np.nan, np.inf, -np.inf]
         for dt in ['f', 'd', 'g']:
@@ -693,6 +813,7 @@
             assert_raises(FloatingPointError, np.exp, np.float64(1E19))
 
     def test_log_values(self):
+        """ """
         with np.errstate(all='ignore'):
             x = [np.nan,  np.nan, np.inf, np.nan, -np.inf, np.nan]
             y = [np.nan, -np.nan, np.inf, -np.inf, 0., -1.0]
@@ -709,6 +830,7 @@
             assert_raises(FloatingPointError, np.log, np.float32(-1.0))
 
     def test_sincos_values(self):
+        """ """
         with np.errstate(all='ignore'):
             x = [np.nan,  np.nan, np.nan, np.nan]
             y = [np.nan, -np.nan, np.inf, -np.inf]
@@ -725,6 +847,7 @@
             assert_raises(FloatingPointError, np.cos, np.float32(np.inf))
 
     def test_sqrt_values(self):
+        """ """
         with np.errstate(all='ignore'):
             x = [np.nan,  np.nan, np.inf, np.nan, 0.]
             y = [np.nan, -np.nan, np.inf, -np.inf, 0.]
@@ -738,6 +861,7 @@
         #        assert_raises(FloatingPointError, np.sqrt, np.array(-100., dtype=dt))
 
     def test_abs_values(self):
+        """ """
         x = [np.nan,  np.nan, np.inf, np.inf, 0., 0., 1.0, 1.0]
         y = [np.nan, -np.nan, np.inf, -np.inf, 0., -0., -1.0, 1.0]
         for dt in ['f', 'd', 'g']:
@@ -746,6 +870,7 @@
             assert_equal(np.abs(yf), xf)
 
     def test_square_values(self):
+        """ """
         x = [np.nan,  np.nan, np.inf, np.inf]
         y = [np.nan, -np.nan, np.inf, -np.inf]
         with np.errstate(all='ignore'):
@@ -759,6 +884,7 @@
             assert_raises(FloatingPointError, np.square, np.array(1E200, dtype='d'))
 
     def test_reciprocal_values(self):
+        """ """
         with np.errstate(all='ignore'):
             x = [np.nan,  np.nan, 0.0, -0.0, np.inf, -np.inf]
             y = [np.nan, -np.nan, np.inf, -np.inf, 0., -0.]
@@ -782,7 +908,9 @@
               'trunc'       :[0, -100., 100.]}
 
 class TestAVXUfuncs:
+    """ """
     def test_avx_based_ufunc(self):
+        """ """
         strides = np.array([-4,-3,-2,-1,1,2,3,4])
         np.random.seed(42)
         for func, prop in avx_ufuncs.items():
@@ -814,19 +942,23 @@
                         assert_equal(myfunc(x_f32[::jj]), y_true32[::jj])
 
 class TestAVXFloat32Transcendental:
+    """ """
     def test_exp_float32(self):
+        """ """
         np.random.seed(42)
         x_f32 = np.float32(np.random.uniform(low=0.0,high=88.1,size=1000000))
         x_f64 = np.float64(x_f32)
         assert_array_max_ulp(np.exp(x_f32), np.float32(np.exp(x_f64)), maxulp=3)
 
     def test_log_float32(self):
+        """ """
         np.random.seed(42)
         x_f32 = np.float32(np.random.uniform(low=0.0,high=1000,size=1000000))
         x_f64 = np.float64(x_f32)
         assert_array_max_ulp(np.log(x_f32), np.float32(np.log(x_f64)), maxulp=4)
 
     def test_sincos_float32(self):
+        """ """
         np.random.seed(42)
         N = 1000000
         M = np.int_(N/20)
@@ -839,6 +971,7 @@
         assert_array_max_ulp(np.cos(x_f32), np.float32(np.cos(x_f64)), maxulp=2)
 
     def test_strided_float32(self):
+        """ """
         np.random.seed(42)
         strides = np.array([-4,-3,-2,-1,1,2,3,4])
         sizes = np.arange(2,100)
@@ -857,7 +990,9 @@
                 assert_array_almost_equal_nulp(np.cos(x_f32_large[::jj]), cos_true[::jj], nulp=2)
 
 class TestLogAddExp(_FilterInvalids):
+    """ """
     def test_logaddexp_values(self):
+        """ """
         x = [1, 2, 3, 4, 5]
         y = [5, 4, 3, 2, 1]
         z = [6, 6, 6, 6, 6]
@@ -868,6 +1003,7 @@
             assert_almost_equal(np.logaddexp(xf, yf), zf, decimal=dec_)
 
     def test_logaddexp_range(self):
+        """ """
         x = [1000000, -1000000, 1000200, -1000200]
         y = [1000200, -1000200, 1000000, -1000000]
         z = [1000200, -1000000, 1000200, -1000000]
@@ -878,6 +1014,7 @@
             assert_almost_equal(np.logaddexp(logxf, logyf), logzf)
 
     def test_inf(self):
+        """ """
         inf = np.inf
         x = [inf, -inf,  inf, -inf, inf, 1,  -inf,  1]
         y = [inf,  inf, -inf, -inf, 1,   inf, 1,   -inf]
@@ -890,6 +1027,7 @@
                 assert_equal(np.logaddexp(logxf, logyf), logzf)
 
     def test_nan(self):
+        """ """
         assert_(np.isnan(np.logaddexp(np.nan, np.inf)))
         assert_(np.isnan(np.logaddexp(np.inf, np.nan)))
         assert_(np.isnan(np.logaddexp(np.nan, 0)))
@@ -897,16 +1035,20 @@
         assert_(np.isnan(np.logaddexp(np.nan, np.nan)))
 
     def test_reduce(self):
+        """ """
         assert_equal(np.logaddexp.identity, -np.inf)
         assert_equal(np.logaddexp.reduce([]), -np.inf)
 
 
 class TestLog1p:
+    """ """
     def test_log1p(self):
+        """ """
         assert_almost_equal(ncu.log1p(0.2), ncu.log(1.2))
         assert_almost_equal(ncu.log1p(1e-6), ncu.log(1+1e-6))
 
     def test_special(self):
+        """ """
         with np.errstate(invalid="ignore", divide="ignore"):
             assert_equal(ncu.log1p(np.nan), np.nan)
             assert_equal(ncu.log1p(np.inf), np.inf)
@@ -916,11 +1058,14 @@
 
 
 class TestExpm1:
+    """ """
     def test_expm1(self):
+        """ """
         assert_almost_equal(ncu.expm1(0.2), ncu.exp(0.2)-1)
         assert_almost_equal(ncu.expm1(1e-6), ncu.exp(1e-6)-1)
 
     def test_special(self):
+        """ """
         assert_equal(ncu.expm1(np.inf), np.inf)
         assert_equal(ncu.expm1(0.), 0.)
         assert_equal(ncu.expm1(-0.), -0.)
@@ -928,6 +1073,7 @@
         assert_equal(ncu.expm1(-np.inf), -1.)
 
     def test_complex(self):
+        """ """
         x = np.asarray(1e-12)
         assert_allclose(x, ncu.expm1(x))
         x = x.astype(np.complex128)
@@ -935,11 +1081,14 @@
 
 
 class TestHypot:
+    """ """
     def test_simple(self):
+        """ """
         assert_almost_equal(ncu.hypot(1, 1), ncu.sqrt(2))
         assert_almost_equal(ncu.hypot(0, 0), 0)
 
     def test_reduce(self):
+        """ """
         assert_almost_equal(ncu.hypot.reduce([3.0, 4.0]), 5.0)
         assert_almost_equal(ncu.hypot.reduce([3.0, 4.0, 0]), 5.0)
         assert_almost_equal(ncu.hypot.reduce([9.0, 12.0, 20.0]), 25.0)
@@ -947,23 +1096,52 @@
 
 
 def assert_hypot_isnan(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     with np.errstate(invalid='ignore'):
         assert_(np.isnan(ncu.hypot(x, y)),
                 "hypot(%s, %s) is %s, not nan" % (x, y, ncu.hypot(x, y)))
 
 
 def assert_hypot_isinf(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     with np.errstate(invalid='ignore'):
         assert_(np.isinf(ncu.hypot(x, y)),
                 "hypot(%s, %s) is %s, not inf" % (x, y, ncu.hypot(x, y)))
 
 
 class TestHypotSpecialValues:
+    """ """
     def test_nan_outputs(self):
+        """ """
         assert_hypot_isnan(np.nan, np.nan)
         assert_hypot_isnan(np.nan, 1)
 
     def test_nan_outputs2(self):
+        """ """
         assert_hypot_isinf(np.nan, np.inf)
         assert_hypot_isinf(np.inf, np.nan)
         assert_hypot_isinf(np.inf, 0)
@@ -972,92 +1150,172 @@
         assert_hypot_isinf(np.inf, 23.0)
 
     def test_no_fpe(self):
+        """ """
         assert_no_warnings(ncu.hypot, np.inf, 0)
 
 
 def assert_arctan2_isnan(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     assert_(np.isnan(ncu.arctan2(x, y)), "arctan(%s, %s) is %s, not nan" % (x, y, ncu.arctan2(x, y)))
 
 
 def assert_arctan2_ispinf(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     assert_((np.isinf(ncu.arctan2(x, y)) and ncu.arctan2(x, y) > 0), "arctan(%s, %s) is %s, not +inf" % (x, y, ncu.arctan2(x, y)))
 
 
 def assert_arctan2_isninf(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     assert_((np.isinf(ncu.arctan2(x, y)) and ncu.arctan2(x, y) < 0), "arctan(%s, %s) is %s, not -inf" % (x, y, ncu.arctan2(x, y)))
 
 
 def assert_arctan2_ispzero(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     assert_((ncu.arctan2(x, y) == 0 and not np.signbit(ncu.arctan2(x, y))), "arctan(%s, %s) is %s, not +0" % (x, y, ncu.arctan2(x, y)))
 
 
 def assert_arctan2_isnzero(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     assert_((ncu.arctan2(x, y) == 0 and np.signbit(ncu.arctan2(x, y))), "arctan(%s, %s) is %s, not -0" % (x, y, ncu.arctan2(x, y)))
 
 
 class TestArctan2SpecialValues:
+    """ """
     def test_one_one(self):
+        """ """
         # atan2(1, 1) returns pi/4.
         assert_almost_equal(ncu.arctan2(1, 1), 0.25 * np.pi)
         assert_almost_equal(ncu.arctan2(-1, 1), -0.25 * np.pi)
         assert_almost_equal(ncu.arctan2(1, -1), 0.75 * np.pi)
 
     def test_zero_nzero(self):
+        """ """
         # atan2(+-0, -0) returns +-pi.
         assert_almost_equal(ncu.arctan2(np.PZERO, np.NZERO), np.pi)
         assert_almost_equal(ncu.arctan2(np.NZERO, np.NZERO), -np.pi)
 
     def test_zero_pzero(self):
+        """ """
         # atan2(+-0, +0) returns +-0.
         assert_arctan2_ispzero(np.PZERO, np.PZERO)
         assert_arctan2_isnzero(np.NZERO, np.PZERO)
 
     def test_zero_negative(self):
+        """ """
         # atan2(+-0, x) returns +-pi for x < 0.
         assert_almost_equal(ncu.arctan2(np.PZERO, -1), np.pi)
         assert_almost_equal(ncu.arctan2(np.NZERO, -1), -np.pi)
 
     def test_zero_positive(self):
+        """ """
         # atan2(+-0, x) returns +-0 for x > 0.
         assert_arctan2_ispzero(np.PZERO, 1)
         assert_arctan2_isnzero(np.NZERO, 1)
 
     def test_positive_zero(self):
+        """ """
         # atan2(y, +-0) returns +pi/2 for y > 0.
         assert_almost_equal(ncu.arctan2(1, np.PZERO), 0.5 * np.pi)
         assert_almost_equal(ncu.arctan2(1, np.NZERO), 0.5 * np.pi)
 
     def test_negative_zero(self):
+        """ """
         # atan2(y, +-0) returns -pi/2 for y < 0.
         assert_almost_equal(ncu.arctan2(-1, np.PZERO), -0.5 * np.pi)
         assert_almost_equal(ncu.arctan2(-1, np.NZERO), -0.5 * np.pi)
 
     def test_any_ninf(self):
+        """ """
         # atan2(+-y, -infinity) returns +-pi for finite y > 0.
         assert_almost_equal(ncu.arctan2(1, np.NINF),  np.pi)
         assert_almost_equal(ncu.arctan2(-1, np.NINF), -np.pi)
 
     def test_any_pinf(self):
+        """ """
         # atan2(+-y, +infinity) returns +-0 for finite y > 0.
         assert_arctan2_ispzero(1, np.inf)
         assert_arctan2_isnzero(-1, np.inf)
 
     def test_inf_any(self):
+        """ """
         # atan2(+-infinity, x) returns +-pi/2 for finite x.
         assert_almost_equal(ncu.arctan2( np.inf, 1),  0.5 * np.pi)
         assert_almost_equal(ncu.arctan2(-np.inf, 1), -0.5 * np.pi)
 
     def test_inf_ninf(self):
+        """ """
         # atan2(+-infinity, -infinity) returns +-3*pi/4.
         assert_almost_equal(ncu.arctan2( np.inf, -np.inf),  0.75 * np.pi)
         assert_almost_equal(ncu.arctan2(-np.inf, -np.inf), -0.75 * np.pi)
 
     def test_inf_pinf(self):
+        """ """
         # atan2(+-infinity, +infinity) returns +-pi/4.
         assert_almost_equal(ncu.arctan2( np.inf, np.inf),  0.25 * np.pi)
         assert_almost_equal(ncu.arctan2(-np.inf, np.inf), -0.25 * np.pi)
 
     def test_nan_any(self):
+        """ """
         # atan2(nan, x) returns nan for any x, including inf
         assert_arctan2_isnan(np.nan, np.inf)
         assert_arctan2_isnan(np.inf, np.nan)
@@ -1065,7 +1323,19 @@
 
 
 class TestLdexp:
+    """ """
     def _check_ldexp(self, tp):
+        """
+
+        Parameters
+        ----------
+        tp :
+            
+
+        Returns
+        -------
+
+        """
         assert_almost_equal(ncu.ldexp(np.array(2., np.float32),
                                       np.array(3, tp)), 16.)
         assert_almost_equal(ncu.ldexp(np.array(2., np.float64),
@@ -1074,6 +1344,7 @@
                                       np.array(3, tp)), 16.)
 
     def test_ldexp(self):
+        """ """
         # The default Python int type should work
         assert_almost_equal(ncu.ldexp(2., 3),  16.)
         # The following int types should all be accepted
@@ -1084,6 +1355,7 @@
         self._check_ldexp('l')
 
     def test_ldexp_overflow(self):
+        """ """
         # silence warning emitted on overflow
         with np.errstate(over="ignore"):
             imax = np.iinfo(np.dtype('l')).max
@@ -1093,7 +1365,9 @@
 
 
 class TestMaximum(_FilterInvalids):
+    """ """
     def test_reduce(self):
+        """ """
         dflt = np.typecodes['AllFloat']
         dint = np.typecodes['AllInteger']
         seq1 = np.arange(11)
@@ -1115,10 +1389,12 @@
             assert_equal(func(tmp2), np.nan)
 
     def test_reduce_complex(self):
+        """ """
         assert_equal(np.maximum.reduce([1, 2j]), 1)
         assert_equal(np.maximum.reduce([1+3j, 2j]), 1+3j)
 
     def test_float_nans(self):
+        """ """
         nan = np.nan
         arg1 = np.array([0,   nan, nan])
         arg2 = np.array([nan, 0,   nan])
@@ -1126,6 +1402,7 @@
         assert_equal(np.maximum(arg1, arg2), out)
 
     def test_object_nans(self):
+        """ """
         # Multiple checks to give this a chance to
         # fail if cmp is used instead of rich compare.
         # Failure cannot be guaranteed.
@@ -1137,6 +1414,7 @@
             assert_(np.maximum(z, y) == 1.0)
 
     def test_complex_nans(self):
+        """ """
         nan = np.nan
         for cnan in [complex(nan, 0), complex(0, nan), complex(nan, nan)]:
             arg1 = np.array([0, cnan, cnan], dtype=complex)
@@ -1145,11 +1423,13 @@
             assert_equal(np.maximum(arg1, arg2), out)
 
     def test_object_array(self):
+        """ """
         arg1 = np.arange(5, dtype=object)
         arg2 = arg1 + 1
         assert_equal(np.maximum(arg1, arg2), arg2)
 
     def test_strided_array(self):
+        """ """
         arr1 = np.array([-4.0, 1.0, 10.0,  0.0, np.nan, -np.nan, np.inf, -np.inf])
         arr2 = np.array([-2.0,-1.0, np.nan, 1.0, 0.0,    np.nan, 1.0,    -3.0])
         maxtrue  = np.array([-2.0, 1.0, np.nan, 1.0, np.nan, np.nan, np.inf, -3.0])
@@ -1164,7 +1444,9 @@
 
 
 class TestMinimum(_FilterInvalids):
+    """ """
     def test_reduce(self):
+        """ """
         dflt = np.typecodes['AllFloat']
         dint = np.typecodes['AllInteger']
         seq1 = np.arange(11)
@@ -1186,10 +1468,12 @@
             assert_equal(func(tmp2), np.nan)
 
     def test_reduce_complex(self):
+        """ """
         assert_equal(np.minimum.reduce([1, 2j]), 2j)
         assert_equal(np.minimum.reduce([1+3j, 2j]), 2j)
 
     def test_float_nans(self):
+        """ """
         nan = np.nan
         arg1 = np.array([0,   nan, nan])
         arg2 = np.array([nan, 0,   nan])
@@ -1197,6 +1481,7 @@
         assert_equal(np.minimum(arg1, arg2), out)
 
     def test_object_nans(self):
+        """ """
         # Multiple checks to give this a chance to
         # fail if cmp is used instead of rich compare.
         # Failure cannot be guaranteed.
@@ -1208,6 +1493,7 @@
             assert_(np.minimum(z, y) == 1.0)
 
     def test_complex_nans(self):
+        """ """
         nan = np.nan
         for cnan in [complex(nan, 0), complex(0, nan), complex(nan, nan)]:
             arg1 = np.array([0, cnan, cnan], dtype=complex)
@@ -1216,11 +1502,13 @@
             assert_equal(np.minimum(arg1, arg2), out)
 
     def test_object_array(self):
+        """ """
         arg1 = np.arange(5, dtype=object)
         arg2 = arg1 + 1
         assert_equal(np.minimum(arg1, arg2), arg1)
 
     def test_strided_array(self):
+        """ """
         arr1 = np.array([-4.0, 1.0, 10.0,  0.0, np.nan, -np.nan, np.inf, -np.inf])
         arr2 = np.array([-2.0,-1.0, np.nan, 1.0, 0.0,    np.nan, 1.0,    -3.0])
         mintrue  = np.array([-4.0, -1.0, np.nan, 0.0, np.nan, np.nan, 1.0, -np.inf])
@@ -1234,7 +1522,9 @@
         assert_equal(out, out_mintrue)
 
 class TestFmax(_FilterInvalids):
+    """ """
     def test_reduce(self):
+        """ """
         dflt = np.typecodes['AllFloat']
         dint = np.typecodes['AllInteger']
         seq1 = np.arange(11)
@@ -1256,10 +1546,12 @@
             assert_equal(func(tmp2), 9)
 
     def test_reduce_complex(self):
+        """ """
         assert_equal(np.fmax.reduce([1, 2j]), 1)
         assert_equal(np.fmax.reduce([1+3j, 2j]), 1+3j)
 
     def test_float_nans(self):
+        """ """
         nan = np.nan
         arg1 = np.array([0,   nan, nan])
         arg2 = np.array([nan, 0,   nan])
@@ -1267,6 +1559,7 @@
         assert_equal(np.fmax(arg1, arg2), out)
 
     def test_complex_nans(self):
+        """ """
         nan = np.nan
         for cnan in [complex(nan, 0), complex(0, nan), complex(nan, nan)]:
             arg1 = np.array([0, cnan, cnan], dtype=complex)
@@ -1276,7 +1569,9 @@
 
 
 class TestFmin(_FilterInvalids):
+    """ """
     def test_reduce(self):
+        """ """
         dflt = np.typecodes['AllFloat']
         dint = np.typecodes['AllInteger']
         seq1 = np.arange(11)
@@ -1298,10 +1593,12 @@
             assert_equal(func(tmp2), 1)
 
     def test_reduce_complex(self):
+        """ """
         assert_equal(np.fmin.reduce([1, 2j]), 2j)
         assert_equal(np.fmin.reduce([1+3j, 2j]), 2j)
 
     def test_float_nans(self):
+        """ """
         nan = np.nan
         arg1 = np.array([0,   nan, nan])
         arg2 = np.array([nan, 0,   nan])
@@ -1309,6 +1606,7 @@
         assert_equal(np.fmin(arg1, arg2), out)
 
     def test_complex_nans(self):
+        """ """
         nan = np.nan
         for cnan in [complex(nan, 0), complex(0, nan), complex(nan, nan)]:
             arg1 = np.array([0, cnan, cnan], dtype=complex)
@@ -1318,13 +1616,16 @@
 
 
 class TestBool:
+    """ """
     def test_exceptions(self):
+        """ """
         a = np.ones(1, dtype=np.bool_)
         assert_raises(TypeError, np.negative, a)
         assert_raises(TypeError, np.positive, a)
         assert_raises(TypeError, np.subtract, a, a)
 
     def test_truth_table_logical(self):
+        """ """
         # 2, 3 and 4 serves as true values
         input1 = [0, 0, 3, 2]
         input2 = [0, 4, 0, 2]
@@ -1350,6 +1651,7 @@
                 assert_equal(func(arg1, arg2).astype(bool), out)
 
     def test_truth_table_bitwise(self):
+        """ """
         arg1 = [False, False, True, True]
         arg2 = [False, True, False, True]
 
@@ -1363,6 +1665,7 @@
         assert_equal(np.bitwise_xor(arg1, arg2), out)
 
     def test_reduce(self):
+        """ """
         none = np.array([0, 0, 0, 0], bool)
         some = np.array([1, 0, 1, 1], bool)
         every = np.array([1, 1, 1, 1], bool)
@@ -1381,10 +1684,12 @@
 
 
 class TestBitwiseUFuncs:
+    """ """
 
     bitwise_types = [np.dtype(c) for c in '?' + 'bBhHiIlLqQ' + 'O']
 
     def test_values(self):
+        """ """
         for dt in self.bitwise_types:
             zeros = np.array([0], dtype=dt)
             ones = np.array([-1], dtype=dt)
@@ -1409,6 +1714,7 @@
             assert_equal(np.bitwise_and(ones, ones), ones, err_msg=msg)
 
     def test_types(self):
+        """ """
         for dt in self.bitwise_types:
             zeros = np.array([0], dtype=dt)
             ones = np.array([-1], dtype=dt)
@@ -1420,11 +1726,13 @@
             assert_(np.bitwise_and(zeros, zeros).dtype == dt, msg)
 
     def test_identity(self):
+        """ """
         assert_(np.bitwise_or.identity == 0, 'bitwise_or')
         assert_(np.bitwise_xor.identity == 0, 'bitwise_xor')
         assert_(np.bitwise_and.identity == -1, 'bitwise_and')
 
     def test_reduction(self):
+        """ """
         binary_funcs = (np.bitwise_or, np.bitwise_xor, np.bitwise_and)
 
         for dt in self.bitwise_types:
@@ -1465,7 +1773,9 @@
 
 
 class TestInt:
+    """ """
     def test_logical_not(self):
+        """ """
         x = np.ones(10, dtype=np.int16)
         o = np.ones(10 * 2, dtype=bool)
         tgt = o.copy()
@@ -1476,24 +1786,32 @@
 
 
 class TestFloatingPoint:
+    """ """
     def test_floating_point(self):
+        """ """
         assert_equal(ncu.FLOATING_POINT_SUPPORT, 1)
 
 
 class TestDegrees:
+    """ """
     def test_degrees(self):
+        """ """
         assert_almost_equal(ncu.degrees(np.pi), 180.0)
         assert_almost_equal(ncu.degrees(-0.5*np.pi), -90.0)
 
 
 class TestRadians:
+    """ """
     def test_radians(self):
+        """ """
         assert_almost_equal(ncu.radians(180.0), np.pi)
         assert_almost_equal(ncu.radians(-90.0), -0.5*np.pi)
 
 
 class TestHeavside:
+    """ """
     def test_heaviside(self):
+        """ """
         x = np.array([[-30.0, -0.1, 0.0, 0.2], [7.5, np.nan, np.inf, -np.inf]])
         expectedhalf = np.array([[0.0, 0.0, 0.5, 1.0], [1.0, np.nan, 1.0, 0.0]])
         expected1 = expectedhalf.copy()
@@ -1515,7 +1833,9 @@
 
 
 class TestSign:
+    """ """
     def test_sign(self):
+        """ """
         a = np.array([np.inf, -np.inf, np.nan, 0.0, 3.0, -3.0])
         out = np.zeros(a.shape)
         tgt = np.array([1., -1., np.nan, 0.0, 1.0, -1.0])
@@ -1528,6 +1848,7 @@
             assert_equal(out, tgt)
 
     def test_sign_dtype_object(self):
+        """ """
         # In reference to github issue #6229
 
         foo = np.array([-.1, 0, .1])
@@ -1537,8 +1858,10 @@
         assert_array_equal(a, b)
 
     def test_sign_dtype_nan_object(self):
+        """ """
         # In reference to github issue #6229
         def test_nan():
+            """ """
             foo = np.array([np.nan])
             # FIXME: a not used
             a = np.sign(foo.astype(object))
@@ -1546,7 +1869,9 @@
         assert_raises(TypeError, test_nan)
 
 class TestMinMax:
+    """ """
     def test_minmax_blocked(self):
+        """ """
         # simd tests on max/min, test all alignments, slow but important
         # for 2 * vz + 2 * (vs - 1) + 1 (unrolled once)
         for dt, sz in [(np.float32, 15), (np.float64, 7)]:
@@ -1568,6 +1893,7 @@
                     assert_equal(inp.min(), -1e10, err_msg=msg)
 
     def test_lower_align(self):
+        """ """
         # check data that is not aligned to element size
         # i.e doubles are aligned to 4 bytes on i386
         d = np.zeros(23 * 8, dtype=np.int8)[4:-4].view(np.float64)
@@ -1575,6 +1901,7 @@
         assert_equal(d.min(), d[0])
 
     def test_reduce_reorder(self):
+        """ """
         # gh 10370, 11029 Some compilers reorder the call to npy_getfloatstatus
         # and put it before the call to an intrisic function that causes
         # invalid status to be set. Also make sure warnings are not emitted
@@ -1584,12 +1911,15 @@
                     assert_equal(np.min(r), np.nan)
 
     def test_minimize_no_warns(self):
+        """ """
         a = np.minimum(np.nan, 1)
         assert_equal(a, np.nan)
 
 
 class TestAbsoluteNegative:
+    """ """
     def test_abs_neg_blocked(self):
+        """ """
         # simd tests on abs, test all alignments for vz + 2 * (vs - 1) + 1
         for dt, sz in [(np.float32, 11), (np.float64, 5)]:
             for out, inp, msg in _gen_alignment_data(dtype=dt, type='unary',
@@ -1619,6 +1949,7 @@
                         assert_array_equal(out, d, err_msg=msg)
 
     def test_lower_align(self):
+        """ """
         # check data that is not aligned to element size
         # i.e doubles are aligned to 4 bytes on i386
         d = np.zeros(23 * 8, dtype=np.int8)[4:-4].view(np.float64)
@@ -1631,7 +1962,9 @@
 
 
 class TestPositive:
+    """ """
     def test_valid(self):
+        """ """
         valid_dtypes = [int, float, complex, object]
         for dtype in valid_dtypes:
             x = np.arange(5, dtype=dtype)
@@ -1639,6 +1972,7 @@
             assert_equal(x, result, err_msg=str(dtype))
 
     def test_invalid(self):
+        """ """
         with assert_raises(TypeError):
             np.positive(True)
         with assert_raises(TypeError):
@@ -1650,9 +1984,12 @@
 
 
 class TestSpecialMethods:
+    """ """
     def test_wrap(self):
+        """ """
 
         class with_wrap:
+            """ """
             def __array__(self):
                 return np.zeros(1)
 
@@ -1673,10 +2010,12 @@
         assert_equal(i, 0)
 
     def test_wrap_and_prepare_out(self):
+        """ """
         # Calling convention for out should not affect how special methods are
         # called
 
         class StoreArrayPrepareWrap(np.ndarray):
+            """ """
             _wrap_args = None
             _prepare_args = None
             def __new__(cls):
@@ -1689,6 +2028,7 @@
                 return obj
             @property
             def args(self):
+                """ """
                 # We need to ensure these are fetched at the same time, before
                 # any other ufuncs are called by the assertions
                 return (self._prepare_args, self._wrap_args)
@@ -1696,6 +2036,19 @@
                 return "a"  # for short test output
 
         def do_test(f_call, f_expected):
+            """
+
+            Parameters
+            ----------
+            f_call :
+                
+            f_expected :
+                
+
+            Returns
+            -------
+
+            """
             a = StoreArrayPrepareWrap()
             f_call(a)
             p, w = a.args
@@ -1724,9 +2077,11 @@
         do_test(lambda a: np.add(0, 0, out=(a,)),    lambda a: (0, 0, a))
 
     def test_wrap_with_iterable(self):
+        """ """
         # test fix for bug #1026:
 
         class with_wrap(np.ndarray):
+            """ """
             __array_priority__ = 10
 
             def __new__(cls):
@@ -1741,9 +2096,11 @@
         assert_array_equal(x, np.array((1, 2, 3)))
 
     def test_priority_with_scalar(self):
+        """ """
         # test fix for bug #826:
 
         class A(np.ndarray):
+            """ """
             __array_priority__ = 10
 
             def __new__(cls):
@@ -1755,8 +2112,10 @@
         assert_array_equal(x, np.array(1))
 
     def test_old_wrap(self):
+        """ """
 
         class with_wrap:
+            """ """
             def __array__(self):
                 return np.zeros(1)
 
@@ -1770,8 +2129,10 @@
         assert_equal(x.arr, np.zeros(1))
 
     def test_priority(self):
+        """ """
 
         class A:
+            """ """
             def __array__(self):
                 return np.zeros(1)
 
@@ -1782,9 +2143,11 @@
                 return r
 
         class B(A):
+            """ """
             __array_priority__ = 20.
 
         class C(A):
+            """ """
             __array_priority__ = 40.
 
         x = np.zeros(1)
@@ -1813,8 +2176,10 @@
         assert_(type(ncu.exp(c) is C))
 
     def test_failing_wrap(self):
+        """ """
 
         class A:
+            """ """
             def __array__(self):
                 return np.zeros(2)
 
@@ -1826,14 +2191,17 @@
         assert_raises(RuntimeError, ncu.maximum.reduce, a)
 
     def test_failing_out_wrap(self):
+        """ """
 
         singleton = np.array([1.0])
 
         class Ok(np.ndarray):
+            """ """
             def __array_wrap__(self, obj):
                 return singleton
 
         class Bad(np.ndarray):
+            """ """
             def __array_wrap__(self, obj):
                 raise RuntimeError
 
@@ -1844,9 +2212,11 @@
             assert_raises(RuntimeError, ncu.frexp, 1, ok, bad)
 
     def test_none_wrap(self):
+        """ """
         # Tests that issue #8507 is resolved. Previously, this would segfault
 
         class A:
+            """ """
             def __array__(self):
                 return np.zeros(1)
 
@@ -1857,8 +2227,10 @@
         assert_equal(ncu.maximum(a, a), None)
 
     def test_default_prepare(self):
+        """ """
 
         class with_wrap:
+            """ """
             __array_priority__ = 10
 
             def __array__(self):
@@ -1873,8 +2245,10 @@
         assert_equal(type(x), np.ndarray)
 
     def test_prepare(self):
+        """ """
 
         class with_prepare(np.ndarray):
+            """ """
             __array_priority__ = 10
 
             def __array_prepare__(self, arr, context):
@@ -1887,8 +2261,10 @@
         assert_equal(type(x), with_prepare)
 
     def test_prepare_out(self):
+        """ """
 
         class with_prepare(np.ndarray):
+            """ """
             __array_priority__ = 10
 
             def __array_prepare__(self, arr, context):
@@ -1903,8 +2279,10 @@
         assert_equal(type(x), with_prepare)
 
     def test_failing_prepare(self):
+        """ """
 
         class A:
+            """ """
             def __array__(self):
                 return np.zeros(1)
 
@@ -1915,8 +2293,10 @@
         assert_raises(RuntimeError, ncu.maximum, a, a)
 
     def test_array_too_many_args(self):
+        """ """
 
         class A(object):
+            """ """
             def __array__(self, dtype, context):
                 return np.zeros(1)
 
@@ -1924,12 +2304,15 @@
         assert_raises_regex(TypeError, '2 required positional', np.sum, a)
 
     def test_ufunc_override(self):
+        """ """
         # check override works even with instance with high priority.
         class A:
+            """ """
             def __array_ufunc__(self, func, method, *inputs, **kwargs):
                 return self, func, method, inputs, kwargs
 
         class MyNDArray(np.ndarray):
+            """ """
             __array_priority__ = 100
 
         a = A()
@@ -1950,12 +2333,45 @@
         assert_equal(res1[4], {'out': (a,)})
 
     def test_ufunc_override_mro(self):
+        """ """
 
         # Some multi arg functions for testing.
         def tres_mul(a, b, c):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+            c :
+                
+
+            Returns
+            -------
+
+            """
             return a * b * c
 
         def quatro_mul(a, b, c, d):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+            c :
+                
+            d :
+                
+
+            Returns
+            -------
+
+            """
             return a * b * c * d
 
         # Make these into ufuncs.
@@ -1963,18 +2379,22 @@
         four_mul_ufunc = np.frompyfunc(quatro_mul, 4, 1)
 
         class A:
+            """ """
             def __array_ufunc__(self, func, method, *inputs, **kwargs):
                 return "A"
 
         class ASub(A):
+            """ """
             def __array_ufunc__(self, func, method, *inputs, **kwargs):
                 return "ASub"
 
         class B:
+            """ """
             def __array_ufunc__(self, func, method, *inputs, **kwargs):
                 return "B"
 
         class C:
+            """ """
             def __init__(self):
                 self.count = 0
 
@@ -1983,6 +2403,7 @@
                 return NotImplemented
 
         class CSub(C):
+            """ """
             def __array_ufunc__(self, func, method, *inputs, **kwargs):
                 self.count += 1
                 return NotImplemented
@@ -2085,8 +2506,10 @@
         assert_equal(c2.count, 1)
 
     def test_ufunc_override_methods(self):
+        """ """
 
         class A:
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
                 return self, ufunc, method, inputs, kwargs
 
@@ -2254,12 +2677,15 @@
         assert_raises(TypeError, np.multiply.at, a, a, a, a)
 
     def test_ufunc_override_out(self):
+        """ """
 
         class A:
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
                 return kwargs
 
         class B:
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
                 return kwargs
 
@@ -2310,8 +2736,10 @@
         assert_raises(ValueError, np.modf, a, out=('one',))
 
     def test_ufunc_override_exception(self):
+        """ """
 
         class A:
+            """ """
             def __array_ufunc__(self, *a, **kwargs):
                 raise ValueError("oops")
 
@@ -2321,8 +2749,10 @@
         assert_raises(ValueError, np.divide, 1., a)
 
     def test_ufunc_override_not_implemented(self):
+        """ """
 
         class A:
+            """ """
             def __array_ufunc__(self, *args, **kwargs):
                 return NotImplemented
 
@@ -2338,8 +2768,10 @@
             np.add(A(), object(), out=1)
 
     def test_ufunc_override_disabled(self):
+        """ """
 
         class OptOut:
+            """ """
             __array_ufunc__ = None
 
         opt_out = OptOut()
@@ -2357,6 +2789,7 @@
         # __array_ufunc__ implementations
 
         class GreedyArray:
+            """ """
             def __array_ufunc__(self, *args, **kwargs):
                 return self
 
@@ -2368,9 +2801,11 @@
             np.add(greedy, 1, out=opt_out)
 
     def test_gufunc_override(self):
+        """ """
         # gufunc are just ufunc instances, but follow a different path,
         # so check __array_ufunc__ overrides them properly.
         class A:
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
                 return self, ufunc, method, inputs, kwargs
 
@@ -2398,9 +2833,11 @@
         assert_raises(ValueError, inner1d, a, a, out=())
 
     def test_ufunc_override_with_super(self):
+        """ """
         # NOTE: this class is given as an example in doc/subclassing.py;
         # if you make any changes here, do update it there too.
         class A(np.ndarray):
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, out=None, **kwargs):
                 args = []
                 in_no = []
@@ -2453,6 +2890,7 @@
                 return results[0] if len(results) == 1 else results
 
         class B:
+            """ """
             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
                 if any(isinstance(input_, A) for input_ in inputs):
                     return "A!"
@@ -2572,28 +3010,46 @@
 
 
 class TestChoose:
+    """ """
     def test_mixed(self):
+        """ """
         c = np.array([True, True])
         a = np.array([True, True])
         assert_equal(np.choose(c, (a, 1)), np.array([1, 1]))
 
 
 class TestRationalFunctions:
+    """ """
     def test_lcm(self):
+        """ """
         self._test_lcm_inner(np.int16)
         self._test_lcm_inner(np.uint16)
 
     def test_lcm_object(self):
+        """ """
         self._test_lcm_inner(np.object_)
 
     def test_gcd(self):
+        """ """
         self._test_gcd_inner(np.int16)
         self._test_lcm_inner(np.uint16)
 
     def test_gcd_object(self):
+        """ """
         self._test_gcd_inner(np.object_)
 
     def _test_lcm_inner(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # basic use
         a = np.array([12, 120], dtype=dtype)
         b = np.array([20, 200], dtype=dtype)
@@ -2615,6 +3071,17 @@
         assert_equal(np.lcm(a, b), [0, 20, 20, 60, 20, 20])
 
     def _test_gcd_inner(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # basic use
         a = np.array([12, 120], dtype=dtype)
         b = np.array([20, 200], dtype=dtype)
@@ -2636,6 +3103,7 @@
         assert_equal(np.gcd(a, b), [20,  1,  2,  1,  4,  5])
 
     def test_lcm_overflow(self):
+        """ """
         # verify that we don't overflow when a*b does overflow
         big = np.int32(np.iinfo(np.int32).max // 11)
         a = 2*big
@@ -2643,6 +3111,7 @@
         assert_equal(np.lcm(a, b), 10*big)
 
     def test_gcd_overflow(self):
+        """ """
         for dtype in (np.int32, np.int64):
             # verify that we don't overflow when taking abs(x)
             # not relevant for lcm, where the result is unrepresentable anyway
@@ -2652,6 +3121,7 @@
             assert_equal(np.gcd(a, -q*3), q)
 
     def test_decimal(self):
+        """ """
         from decimal import Decimal
         a = np.array([1,  1, -1, -1]) * Decimal('0.20')
         b = np.array([1, -1,  1, -1]) * Decimal('0.12')
@@ -2660,11 +3130,13 @@
         assert_equal(np.lcm(a, b), 4*[Decimal('0.60')])
 
     def test_float(self):
+        """ """
         # not well-defined on float due to rounding errors
         assert_raises(TypeError, np.gcd, 0.3, 0.4)
         assert_raises(TypeError, np.lcm, 0.3, 0.4)
 
     def test_builtin_long(self):
+        """ """
         # sanity check that array coercion is alright for builtin longs
         assert_equal(np.array(2**200).item(), 2**200)
 
@@ -2678,10 +3150,12 @@
 
 
 class TestRoundingFunctions:
+    """ """
 
     def test_object_direct(self):
-        """ test direct implementation of these magic methods """
+        """test direct implementation of these magic methods"""
         class C:
+            """ """
             def __floor__(self):
                 return 1
             def __ceil__(self):
@@ -2695,8 +3169,9 @@
         assert_equal(np.trunc(arr), [3, 3])
 
     def test_object_indirect(self):
-        """ test implementations via __float__ """
+        """test implementations via __float__"""
         class C:
+            """ """
             def __float__(self):
                 return -2.5
 
@@ -2707,6 +3182,7 @@
             np.trunc(arr)  # consistent with math.trunc
 
     def test_fraction(self):
+        """ """
         f = Fraction(-4, 3)
         assert_equal(np.floor(f), -2)
         assert_equal(np.ceil(f), -1)
@@ -2714,12 +3190,14 @@
 
 
 class TestComplexFunctions:
+    """ """
     funcs = [np.arcsin,  np.arccos,  np.arctan, np.arcsinh, np.arccosh,
              np.arctanh, np.sin,     np.cos,    np.tan,     np.exp,
              np.exp2,    np.log,     np.sqrt,   np.log10,   np.log2,
              np.log1p]
 
     def test_it(self):
+        """ """
         for f in self.funcs:
             if f is np.arccosh:
                 x = 1.5
@@ -2731,6 +3209,7 @@
             assert_almost_equal(fz.imag, 0., err_msg='imag part %s' % f)
 
     def test_precisions_consistent(self):
+        """ """
         z = 1 + 1j
         for f in self.funcs:
             fcf = f(np.csingle(z))
@@ -2740,6 +3219,7 @@
             assert_almost_equal(fcl, fcd, decimal=15, err_msg='fch-fcl %s' % f)
 
     def test_branch_cuts(self):
+        """ """
         # check branch cuts and continuity on them
         _check_branch_cut(np.log,   -0.5, 1j, 1, -1, True)
         _check_branch_cut(np.log2,  -0.5, 1j, 1, -1, True)
@@ -2765,6 +3245,7 @@
         _check_branch_cut(np.arctanh, [0-2j, 2j, 0], [1,  1,  1j], 1, 1)
 
     def test_branch_cuts_complex64(self):
+        """ """
         # check branch cuts and continuity on them
         _check_branch_cut(np.log,   -0.5, 1j, 1, -1, True, np.complex64)
         _check_branch_cut(np.log2,  -0.5, 1j, 1, -1, True, np.complex64)
@@ -2790,6 +3271,7 @@
         _check_branch_cut(np.arctanh, [0-2j, 2j, 0], [1,  1,  1j], 1, 1, False, np.complex64)
 
     def test_against_cmath(self):
+        """ """
         import cmath
 
         points = [-1-1j, -1+1j, +1-1j, +1+1j]
@@ -2810,7 +3292,17 @@
 
     @pytest.mark.parametrize('dtype', [np.complex64, np.complex_, np.longcomplex])
     def test_loss_of_precision(self, dtype):
-        """Check loss of precision in complex arc* functions"""
+        """Check loss of precision in complex arc* functions
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
 
         # Check against known-good functions
 
@@ -2819,6 +3311,19 @@
         eps = info.eps
 
         def check(x, rtol):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+            rtol :
+                
+
+            Returns
+            -------
+
+            """
             x = x.astype(real_dtype)
 
             z = x.astype(dtype)
@@ -2881,6 +3386,21 @@
         # Check continuity across switchover points
 
         def check(func, z0, d=1):
+            """
+
+            Parameters
+            ----------
+            func :
+                
+            z0 :
+                
+            d :
+                 (Default value = 1)
+
+            Returns
+            -------
+
+            """
             z0 = np.asarray(z0, dtype=dtype)
             zp = z0 + abs(z0) * d * eps * 2
             zm = z0 - abs(z0) * d * eps * 2
@@ -2899,7 +3419,9 @@
 
 
 class TestAttributes:
+    """ """
     def test_attributes(self):
+        """ """
         add = ncu.add
         assert_equal(add.__name__, 'add')
         assert_(add.ntypes >= 18)  # don't fail if types added
@@ -2909,6 +3431,7 @@
         assert_equal(add.identity, 0)
 
     def test_doc(self):
+        """ """
         # don't bother checking the long list of kwargs, which are likely to
         # change
         assert_(ncu.add.__doc__.startswith(
@@ -2918,10 +3441,13 @@
 
 
 class TestSubclass:
+    """ """
 
     def test_subclass_op(self):
+        """ """
 
         class simple(np.ndarray):
+            """ """
             def __new__(subtype, shape):
                 self = np.ndarray.__new__(subtype, shape, dtype=object)
                 self.fill(0)
@@ -2932,9 +3458,24 @@
 
 
 class TestFrompyfunc(object):
+    """ """
 
     def test_identity(self):
+        """ """
         def mul(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return a * b
 
         # with identity=value
@@ -2958,27 +3499,32 @@
 
 def _check_branch_cut(f, x0, dx, re_sign=1, im_sign=-1, sig_zero_ok=False,
                       dtype=complex):
-    """
-    Check for a branch cut in a function.
-
+    """Check for a branch cut in a function.
+    
     Assert that `x0` lies on a branch cut of function `f` and `f` is
     continuous from the direction `dx`.
 
     Parameters
     ----------
-    f : func
-        Function to check
-    x0 : array-like
-        Point on branch cut
-    dx : array-like
-        Direction to check continuity in
-    re_sign, im_sign : {1, -1}
-        Change of sign of the real or imaginary part expected
-    sig_zero_ok : bool
-        Whether to check if the branch cut respects signed zero (if applicable)
-    dtype : dtype
-        Dtype to check (should be complex)
-
+    f :
+        
+    x0 :
+        
+    dx :
+        
+    re_sign :
+         (Default value = 1)
+    im_sign :
+         (Default value = -1)
+    sig_zero_ok :
+         (Default value = False)
+    dtype :
+         (Default value = complex)
+
+    Returns
+    -------
+
+    
     """
     x0 = np.atleast_1d(x0).astype(dtype)
     dx = np.atleast_1d(dx).astype(dtype)
@@ -3018,6 +3564,7 @@
             assert_(np.all(np.absolute(y0[ji].imag - ym.imag*im_sign) < atol), (y0[ji], ym))
 
 def test_copysign():
+    """ """
     assert_(np.copysign(1, -1) == -1)
     with np.errstate(divide="ignore"):
         assert_(1 / np.copysign(0, -1) < 0)
@@ -3026,6 +3573,17 @@
     assert_(not np.signbit(np.copysign(np.nan, 1)))
 
 def _test_nextafter(t):
+    """
+
+    Parameters
+    ----------
+    t :
+        
+
+    Returns
+    -------
+
+    """
     one = t(1)
     two = t(2)
     zero = t(0)
@@ -3037,10 +3595,12 @@
     assert_(np.nextafter(one, one) == one)
 
 def test_nextafter():
+    """ """
     return _test_nextafter(np.float64)
 
 
 def test_nextafterf():
+    """ """
     return _test_nextafter(np.float32)
 
 
@@ -3049,16 +3609,29 @@
 @pytest.mark.xfail(condition=platform.machine().startswith("ppc64"),
                     reason="IBM double double")
 def test_nextafterl():
+    """ """
     return _test_nextafter(np.longdouble)
 
 
 def test_nextafter_0():
+    """ """
     for t, direction in itertools.product(np.sctypes['float'], (1, -1)):
         tiny = np.finfo(t).tiny
         assert_(0. < direction * np.nextafter(t(0), t(direction)) < tiny)
         assert_equal(np.nextafter(t(0), t(direction)) / t(2.1), direction * 0.0)
 
 def _test_spacing(t):
+    """
+
+    Parameters
+    ----------
+    t :
+        
+
+    Returns
+    -------
+
+    """
     one = t(1)
     eps = np.finfo(t).eps
     nan = t(np.nan)
@@ -3071,9 +3644,11 @@
         assert_(np.spacing(t(1e30)) != 0)
 
 def test_spacing():
+    """ """
     return _test_spacing(np.float64)
 
 def test_spacingf():
+    """ """
     return _test_spacing(np.float32)
 
 
@@ -3082,9 +3657,11 @@
 @pytest.mark.xfail(condition=platform.machine().startswith("ppc64"),
                     reason="IBM double double")
 def test_spacingl():
+    """ """
     return _test_spacing(np.longdouble)
 
 def test_spacing_gfortran():
+    """ """
     # Reference from this fortran file, built with gfortran 4.3.3 on linux
     # 32bits:
     #       PROGRAM test_spacing
@@ -3115,6 +3692,7 @@
         assert_array_almost_equal(np.spacing(x), ref[dt], decimal=dec_)
 
 def test_nextafter_vs_spacing():
+    """ """
     # XXX: spacing does not handle long double yet
     for t in [np.float32, np.float64]:
         for _f in [1, 1e-5, 1000]:
@@ -3171,6 +3749,7 @@
     assert_equal(result.shape, (5, 0))
 
 def test_complex_nan_comparisons():
+    """ """
     nans = [complex(np.nan, 0), complex(0, np.nan), complex(np.nan, np.nan)]
     fins = [complex(1, 0), complex(-1, 0), complex(0, 1), complex(0, -1),
             complex(1, 1), complex(-1, -1), complex(0, 0)]
@@ -3192,6 +3771,7 @@
 
 
 def test_rint_big_int():
+    """ """
     # np.rint bug for large integer values on Windows 32-bit and MKL
     # https://github.com/numpy/numpy/issues/6685
     val = 4607998452777363968
@@ -3202,6 +3782,17 @@
 
 @pytest.mark.parametrize('ftype', [np.float32, np.float64])
 def test_memoverlap_accumulate(ftype):
+    """
+
+    Parameters
+    ----------
+    ftype :
+        
+
+    Returns
+    -------
+
+    """
     # Reproduces bug https://github.com/numpy/numpy/issues/15597
     arr = np.array([0.61, 0.60, 0.77, 0.41, 0.19], dtype=ftype)
     out_max = np.array([0.61, 0.61, 0.77, 0.77, 0.77], dtype=ftype)
@@ -3210,6 +3801,7 @@
     assert_equal(np.minimum.accumulate(arr), out_min)
 
 def test_signaling_nan_exceptions():
+    """ """
     with assert_no_warnings():
         a = np.ndarray(shape=(), dtype='float32', buffer=b'\x00\xe0\xbf\xff')
         np.isnan(a)
@@ -3220,6 +3812,17 @@
     np.matrix([[0, 1], [2, 5]]),
     ])
 def test_outer_subclass_preserve(arr):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+
+    Returns
+    -------
+
+    """
     # for gh-8661
     class foo(np.ndarray): pass
     actual = np.multiply.outer(arr.view(foo), arr.view(foo))
