# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/gen.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/gen.py
@@ -22,8 +22,10 @@
 .. testcode::
 
     class GenAsyncHandler(RequestHandler):
+        """ """
         @gen.coroutine
         def get(self):
+            """ """
             http_client = AsyncHTTPClient()
             response = yield http_client.fetch("http://example.com")
             do_something_with_response(response)
@@ -43,6 +45,7 @@
 
     @gen.coroutine
     def get(self):
+        """ """
         http_client = AsyncHTTPClient()
         response1, response2 = yield [http_client.fetch(url1),
                                       http_client.fetch(url2)]
@@ -109,26 +112,44 @@
 
 
 class KeyReuseError(Exception):
+    """ """
     pass
 
 
 class UnknownKeyError(Exception):
+    """ """
     pass
 
 
 class LeakedCallbackError(Exception):
+    """ """
     pass
 
 
 class BadYieldError(Exception):
+    """ """
     pass
 
 
 class ReturnValueIgnoredError(Exception):
+    """ """
     pass
 
 
 def _value_from_stopiteration(e: Union[StopIteration, "Return"]) -> Any:
+    """
+
+    Parameters
+    ----------
+    e: Union[StopIteration :
+        
+    "Return"] :
+        
+
+    Returns
+    -------
+
+    """
     try:
         # StopIteration has a value attribute beginning in py33.
         # So does our Return class.
@@ -144,6 +165,7 @@
 
 
 def _create_future() -> Future:
+    """ """
     future = Future()  # type: Future
     # Fixup asyncio debug info by removing extraneous stack entries
     source_traceback = getattr(future, "_source_traceback", ())
@@ -159,6 +181,23 @@
 
 
 def _fake_ctx_run(f: Callable[..., _T], *args: Any, **kw: Any) -> _T:
+    """
+
+    Parameters
+    ----------
+    f: Callable[... :
+        
+    _T] :
+        
+    *args: Any :
+        
+    **kw: Any :
+        
+
+    Returns
+    -------
+
+    """
     return f(*args, **kw)
 
 
@@ -166,11 +205,41 @@
 def coroutine(
     func: Callable[..., "Generator[Any, Any, _T]"]
 ) -> Callable[..., "Future[_T]"]:
+    """
+
+    Parameters
+    ----------
+    func: Callable[... :
+        
+    "Generator[Any :
+        
+    Any :
+        
+    _T]"] :
+        
+
+    Returns
+    -------
+
+    """
     ...
 
 
 @overload
 def coroutine(func: Callable[..., _T]) -> Callable[..., "Future[_T]"]:
+    """
+
+    Parameters
+    ----------
+    func: Callable[... :
+        
+    _T] :
+        
+
+    Returns
+    -------
+
+    """
     ...
 
 
@@ -178,15 +247,15 @@
     func: Union[Callable[..., "Generator[Any, Any, _T]"], Callable[..., _T]]
 ) -> Callable[..., "Future[_T]"]:
     """Decorator for asynchronous generators.
-
+    
     For compatibility with older versions of Python, coroutines may
     also "return" by raising the special exception `Return(value)
     <Return>`.
-
+    
     Functions with this decorator return a `.Future`.
-
+    
     .. warning::
-
+    
        When exceptions occur inside a coroutine, the exception
        information will be stored in the `.Future` object. You must
        examine the result of the `.Future` object, or the exception
@@ -194,16 +263,47 @@
        if called from another coroutine, using something like
        `.IOLoop.run_sync` for top-level calls, or passing the `.Future`
        to `.IOLoop.add_future`.
-
+    
     .. versionchanged:: 6.0
-
+    
        The ``callback`` argument was removed. Use the returned
        awaitable object instead.
 
+    Parameters
+    ----------
+    func: Union[Callable[... :
+        
+    "Generator[Any :
+        
+    Any :
+        
+    _T]"] :
+        
+    Callable[... :
+        
+    _T]] :
+        
+
+    Returns
+    -------
+
     """
 
     @functools.wraps(func)
     def wrapper(*args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         # type: (*Any, **Any) -> Future[_T]
         # This function is type-annotated with a comment to work around
         # https://bitbucket.org/pypy/pypy/issues/2868/segfault-with-args-type-annotation-in
@@ -271,33 +371,57 @@
 
 
 def is_coroutine_function(func: Any) -> bool:
-    """Return whether *func* is a coroutine function, i.e. a function
-    wrapped with `~.gen.coroutine`.
-
-    .. versionadded:: 4.5
+    """
+
+    Parameters
+    ----------
+    func: Any :
+        
+
+    Returns
+    -------
+    type
+        wrapped with `~.gen.coroutine`.
+        
+        .. versionadded:: 4.5
+
     """
     return getattr(func, "__tornado_coroutine__", False)
 
 
 class Return(Exception):
     """Special exception to return a value from a `coroutine`.
-
+    
     If this exception is raised, its value argument is used as the
     result of the coroutine::
-
+    
         @gen.coroutine
         def fetch_json(url):
             response = yield AsyncHTTPClient().fetch(url)
-            raise gen.Return(json_decode(response.body))
-
-    In Python 3.3, this exception is no longer necessary: the ``return``
-    statement can be used directly to return a value (previously
-    ``yield`` and ``return`` with a value could not be combined in the
-    same function).
-
-    By analogy with the return statement, the value argument is optional,
-    but it is never necessary to ``raise gen.Return()``.  The ``return``
-    statement can be used with no arguments instead.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    In
+        Python 3
+    statement
+        can be used directly to return a value
+    yield
+        and
+    same
+        function
+    By
+        analogy with the return statement
+    but
+        it is never necessary to
+    statement
+        can be used with no arguments instead
+
     """
 
     def __init__(self, value: Any = None) -> None:
@@ -309,56 +433,71 @@
 
 class WaitIterator(object):
     """Provides an iterator to yield the results of awaitables as they finish.
-
+    
     Yielding a set of awaitables like this:
-
+    
     ``results = yield [awaitable1, awaitable2]``
-
+    
     pauses the coroutine until both ``awaitable1`` and ``awaitable2``
-    return, and then restarts the coroutine with the results of both
-    awaitables. If either awaitable raises an exception, the
-    expression will raise that exception and all the results will be
-    lost.
-
-    If you need to get the result of each awaitable as soon as possible,
-    or if you need the result of some awaitables even if others produce
-    errors, you can use ``WaitIterator``::
-
-      wait_iterator = gen.WaitIterator(awaitable1, awaitable2)
-      while not wait_iterator.done():
-          try:
-              result = yield wait_iterator.next()
-          except Exception as e:
-              print("Error {} from {}".format(e, wait_iterator.current_future))
-          else:
-              print("Result {} received from {} at {}".format(
-                  result, wait_iterator.current_future,
-                  wait_iterator.current_index))
-
-    Because results are returned as soon as they are available the
-    output from the iterator *will not be in the same order as the
-    input arguments*. If you need to know which future produced the
-    current result, you can use the attributes
-    ``WaitIterator.current_future``, or ``WaitIterator.current_index``
-    to get the index of the awaitable from the input list. (if keyword
-    arguments were used in the construction of the `WaitIterator`,
-    ``current_index`` will use the corresponding keyword).
-
-    On Python 3.5, `WaitIterator` implements the async iterator
-    protocol, so it can be used with the ``async for`` statement (note
-    that in this version the entire iteration is aborted if any value
-    raises an exception, while the previous example can continue past
-    individual errors)::
-
-      async for result in gen.WaitIterator(future1, future2):
-          print("Result {} received from {} at {}".format(
-              result, wait_iterator.current_future,
-              wait_iterator.current_index))
-
-    .. versionadded:: 4.1
-
-    .. versionchanged:: 4.3
-       Added ``async for`` support in Python 3.5.
+
+    Parameters
+    ----------
+    current_index :
+        will use the corresponding keyword
+    On :
+        Python 3
+    protocol :
+        so it can be used with the
+    that :
+        in this version the entire iteration is aborted if any value
+
+    Returns
+    -------
+    type
+        awaitables. If either awaitable raises an exception, the
+        expression will raise that exception and all the results will be
+        lost.
+        
+        If you need to get the result of each awaitable as soon as possible,
+        or if you need the result of some awaitables even if others produce
+        errors, you can use ``WaitIterator``::
+        
+        wait_iterator = gen.WaitIterator(awaitable1, awaitable2)
+        while not wait_iterator.done():
+        try:
+        result = yield wait_iterator.next()
+        except Exception as e:
+        print("Error {} from {}".format(e, wait_iterator.current_future))
+        else:
+        print("Result {} received from {} at {}".format(
+        result, wait_iterator.current_future,
+        wait_iterator.current_index))
+        
+        Because results are returned as soon as they are available the
+        output from the iterator *will not be in the same order as the
+        input arguments*. If you need to know which future produced the
+        current result, you can use the attributes
+        ``WaitIterator.current_future``, or ``WaitIterator.current_index``
+        to get the index of the awaitable from the input list. (if keyword
+
+    Raises
+    ------
+    individual
+        errors
+    async
+        for result in gen
+    print
+        Result
+    result
+        wait_iterator
+    wait_iterator
+        current_index
+    .
+        versionadded
+    .
+        versionchanged
+    Added
+        async for
 
     """
 
@@ -393,9 +532,16 @@
 
     def next(self) -> Future:
         """Returns a `.Future` that will yield the next available result.
-
+        
         Note that this `.Future` will not be the same object as any of
         the inputs.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self._running_future = Future()
 
@@ -405,6 +551,17 @@
         return self._running_future
 
     def _done_callback(self, done: Future) -> None:
+        """
+
+        Parameters
+        ----------
+        done: Future :
+            
+
+        Returns
+        -------
+
+        """
         if self._running_future and not self._running_future.done():
             self._return_result(done)
         else:
@@ -413,6 +570,15 @@
     def _return_result(self, done: Future) -> None:
         """Called set the returned future's state that of the future
         we yielded, and set the current future for the iterator.
+
+        Parameters
+        ----------
+        done: Future :
+            
+
+        Returns
+        -------
+
         """
         if self._running_future is None:
             raise Exception("no future is running")
@@ -436,47 +602,65 @@
     quiet_exceptions: "Union[Type[Exception], Tuple[Type[Exception], ...]]" = (),
 ) -> "Union[Future[List], Future[Dict]]":
     """Runs multiple asynchronous operations in parallel.
-
+    
     ``children`` may either be a list or a dict whose values are
     yieldable objects. ``multi()`` returns a new yieldable
     object that resolves to a parallel structure containing their
     results. If ``children`` is a list, the result is a list of
     results in the same order; if it is a dict, the result is a dict
     with the same keys.
-
+    
     That is, ``results = yield multi(list_of_futures)`` is equivalent
     to::
-
+    
         results = []
         for future in list_of_futures:
             results.append(yield future)
-
+    
     If any children raise exceptions, ``multi()`` will raise the first
     one. All others will be logged, unless they are of types
     contained in the ``quiet_exceptions`` argument.
-
+    
     In a ``yield``-based coroutine, it is not normally necessary to
     call this function directly, since the coroutine runner will
     do it automatically when a list or dict is yielded. However,
     it is necessary in ``await``-based coroutines, or to pass
     the ``quiet_exceptions`` argument.
-
+    
     This function is available under the names ``multi()`` and ``Multi()``
     for historical reasons.
-
+    
     Cancelling a `.Future` returned by ``multi()`` does not cancel its
     children. `asyncio.gather` is similar to ``multi()``, but it does
     cancel its children.
-
+    
     .. versionchanged:: 4.2
        If multiple yieldables fail, any exceptions after the first
        (which is raised) will be logged. Added the ``quiet_exceptions``
        argument to suppress this logging for selected exception types.
-
+    
     .. versionchanged:: 4.3
        Replaced the class ``Multi`` and the function ``multi_future``
        with a unified function ``multi``. Added support for yieldables
        other than ``YieldPoint`` and `.Future`.
+
+    Parameters
+    ----------
+    children: Union[List[_Yieldable] :
+        
+    Dict[Any :
+        
+    _Yieldable]] :
+        
+    quiet_exceptions: "Union[Type[Exception] :
+        
+    Tuple[Type[Exception] :
+        
+    ...]]" :
+         (Default value = ())
+
+    Returns
+    -------
 
     """
     return multi_future(children, quiet_exceptions=quiet_exceptions)
@@ -490,18 +674,41 @@
     quiet_exceptions: "Union[Type[Exception], Tuple[Type[Exception], ...]]" = (),
 ) -> "Union[Future[List], Future[Dict]]":
     """Wait for multiple asynchronous futures in parallel.
-
+    
     Since Tornado 6.0, this function is exactly the same as `multi`.
-
+    
     .. versionadded:: 4.0
-
+    
     .. versionchanged:: 4.2
        If multiple ``Futures`` fail, any exceptions after the first (which is
-       raised) will be logged. Added the ``quiet_exceptions``
-       argument to suppress this logging for selected exception types.
-
-    .. deprecated:: 4.3
-       Use `multi` instead.
+
+    Parameters
+    ----------
+    children: Union[List[_Yieldable] :
+        
+    Dict[Any :
+        
+    _Yieldable]] :
+        
+    quiet_exceptions: "Union[Type[Exception] :
+        
+    Tuple[Type[Exception] :
+        
+    ...]]" :
+         (Default value = ())
+
+    Returns
+    -------
+
+    Raises
+    ------
+    argument
+        to suppress this logging for selected exception types
+    .
+        deprecated
+    Use
+        multi
+
     """
     if isinstance(children, dict):
         keys = list(children.keys())  # type: Optional[List]
@@ -518,6 +725,17 @@
         future_set_result_unless_cancelled(future, {} if keys is not None else [])
 
     def callback(fut: Future) -> None:
+        """
+
+        Parameters
+        ----------
+        fut: Future :
+            
+
+        Returns
+        -------
+
+        """
         unfinished_children.remove(fut)
         if not unfinished_children:
             result_list = []
@@ -550,16 +768,25 @@
 
 def maybe_future(x: Any) -> Future:
     """Converts ``x`` into a `.Future`.
-
+    
     If ``x`` is already a `.Future`, it is simply returned; otherwise
     it is wrapped in a new `.Future`.  This is suitable for use as
     ``result = yield gen.maybe_future(f())`` when you don't know whether
     ``f()`` returns a `.Future` or not.
-
+    
     .. deprecated:: 4.3
        This function only handles ``Futures``, not other yieldable objects.
        Instead of `maybe_future`, check for the non-future result types
        you expect (often just ``None``), and ``yield`` anything unknown.
+
+    Parameters
+    ----------
+    x: Any :
+        
+
+    Returns
+    -------
+
     """
     if is_future(x):
         return x
@@ -575,32 +802,54 @@
     quiet_exceptions: "Union[Type[Exception], Tuple[Type[Exception], ...]]" = (),
 ) -> Future:
     """Wraps a `.Future` (or other yieldable object) in a timeout.
-
+    
     Raises `tornado.util.TimeoutError` if the input future does not
     complete before ``timeout``, which may be specified in any form
     allowed by `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or
     an absolute time relative to `.IOLoop.time`)
-
+    
     If the wrapped `.Future` fails after it has timed out, the exception
     will be logged unless it is either of a type contained in
     ``quiet_exceptions`` (which may be an exception type or a sequence of
     types), or an ``asyncio.CancelledError``.
-
+    
     The wrapped `.Future` is not canceled when the timeout expires,
     permitting it to be reused. `asyncio.wait_for` is similar to this
     function but it does cancel the wrapped `.Future` on timeout.
-
+    
     .. versionadded:: 4.0
-
+    
     .. versionchanged:: 4.1
        Added the ``quiet_exceptions`` argument and the logging of unhandled
-       exceptions.
-
-    .. versionchanged:: 4.4
-       Added support for yieldable objects other than `.Future`.
-
-    .. versionchanged:: 6.0.3
-       ``asyncio.CancelledError`` is now always considered "quiet".
+
+    Parameters
+    ----------
+    timeout: Union[float :
+        
+    datetime.timedelta] :
+        
+    future: _Yieldable :
+        
+    quiet_exceptions: "Union[Type[Exception] :
+        
+    Tuple[Type[Exception] :
+        
+    ...]]" :
+         (Default value = ())
+
+    Returns
+    -------
+
+    Raises
+    ------
+    .
+        versionchanged
+    Added
+        support for yieldable objects other than
+    .
+        versionchanged
+    asyncio.CancelledError
+        is now always considered
 
     """
     # It's tempting to optimize this by cancelling the input future on timeout
@@ -614,6 +863,17 @@
     io_loop = IOLoop.current()
 
     def error_callback(future: Future) -> None:
+        """
+
+        Parameters
+        ----------
+        future: Future :
+            
+
+        Returns
+        -------
+
+        """
         try:
             future.result()
         except asyncio.CancelledError:
@@ -625,6 +885,7 @@
                 )
 
     def timeout_callback() -> None:
+        """ """
         if not result.done():
             result.set_exception(TimeoutError("Timeout"))
         # In case the wrapped future goes on to fail, log it.
@@ -648,18 +909,27 @@
 
 
 def sleep(duration: float) -> "Future[None]":
-    """Return a `.Future` that resolves after the given number of seconds.
-
-    When used with ``yield`` in a coroutine, this is a non-blocking
-    analogue to `time.sleep` (which should not be used in coroutines
-    because it is blocking)::
-
+    """
+
+    Parameters
+    ----------
+    duration: float :
+        
+
+    Returns
+    -------
+    type
+        When used with ``yield`` in a coroutine, this is a non-blocking
+        analogue to `time.sleep` (which should not be used in coroutines
+        because it is blocking)::
+        
         yield gen.sleep(0.5)
-
-    Note that calling this function on its own does nothing; you must
-    wait on the `.Future` it returns (usually by yielding it).
-
-    .. versionadded:: 4.1
+        
+        Note that calling this function on its own does nothing; you must
+        wait on the `.Future` it returns (usually by yielding it).
+        
+        .. versionadded:: 4.1
+
     """
     f = _create_future()
     IOLoop.current().call_later(
@@ -670,21 +940,30 @@
 
 class _NullFuture(object):
     """_NullFuture resembles a Future that finished with a result of None.
-
+    
     It's not actually a `Future` to avoid depending on a particular event loop.
     Handled as a special case in the coroutine runner.
-
+    
     We lie and tell the type checker that a _NullFuture is a Future so
     we don't have to leak _NullFuture into lots of public APIs. But
     this means that the type checker can't warn us when we're passing
     a _NullFuture into a code path that doesn't understand what to do
     with it.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def result(self) -> None:
+        """ """
         return None
 
     def done(self) -> bool:
+        """ """
         return True
 
 
@@ -715,11 +994,18 @@
 
 class Runner(object):
     """Internal implementation of `tornado.gen.coroutine`.
-
+    
     Maintains information about pending callbacks and their results.
-
+    
     The results of the generator are stored in ``result_future`` (a
     `.Future`)
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -743,6 +1029,13 @@
     def run(self) -> None:
         """Starts or resumes the generator, running until it reaches a
         yield point that is not ready.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self.running or self.finished:
             return
@@ -795,6 +1088,17 @@
             self.running = False
 
     def handle_yield(self, yielded: _Yieldable) -> bool:
+        """
+
+        Parameters
+        ----------
+        yielded: _Yieldable :
+            
+
+        Returns
+        -------
+
+        """
         try:
             self.future = convert_yielded(yielded)
         except BadYieldError:
@@ -809,6 +1113,17 @@
         elif not self.future.done():
 
             def inner(f: Any) -> None:
+                """
+
+                Parameters
+                ----------
+                f: Any :
+                    
+
+                Returns
+                -------
+
+                """
                 # Break a reference cycle to speed GC.
                 f = None  # noqa: F841
                 self.ctx_run(self.run)
@@ -820,6 +1135,21 @@
     def handle_exception(
         self, typ: Type[Exception], value: Exception, tb: types.TracebackType
     ) -> bool:
+        """
+
+        Parameters
+        ----------
+        typ: Type[Exception] :
+            
+        value: Exception :
+            
+        tb: types.TracebackType :
+            
+
+        Returns
+        -------
+
+        """
         if not self.running and not self.finished:
             self.future = Future()
             future_set_exc_info(self.future, (typ, value, tb))
@@ -840,19 +1170,26 @@
 
 def convert_yielded(yielded: _Yieldable) -> Future:
     """Convert a yielded object into a `.Future`.
-
+    
     The default implementation accepts lists, dictionaries, and
     Futures. This has the side effect of starting any coroutines that
     did not start themselves, similar to `asyncio.ensure_future`.
-
+    
     If the `~functools.singledispatch` library is available, this function
     may be extended to support additional types. For example::
-
+    
         @convert_yielded.register(asyncio.Future)
         def _(asyncio_future):
-            return tornado.platform.asyncio.to_tornado_future(asyncio_future)
-
-    .. versionadded:: 4.1
+
+    Parameters
+    ----------
+    yielded: _Yieldable :
+        
+
+    Returns
+    -------
+    type
+        .. versionadded:: 4.1
 
     """
     if yielded is None or yielded is moment:
