# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/queues.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/queues.py
@@ -45,13 +45,13 @@
 
 
 class QueueEmpty(Exception):
-    """Raised by `.Queue.get_nowait` when the queue has no items."""
+    """ """
 
     pass
 
 
 class QueueFull(Exception):
-    """Raised by `.Queue.put_nowait` when a queue is at its maximum size."""
+    """ """
 
     pass
 
@@ -59,9 +59,27 @@
 def _set_timeout(
     future: Future, timeout: Union[None, float, datetime.timedelta]
 ) -> None:
+    """
+
+    Parameters
+    ----------
+    future: Future :
+        
+    timeout: Union[None :
+        
+    float :
+        
+    datetime.timedelta] :
+        
+
+    Returns
+    -------
+
+    """
     if timeout:
 
         def on_timeout() -> None:
+            """ """
             if not future.done():
                 future.set_exception(gen.TimeoutError())
 
@@ -71,6 +89,7 @@
 
 
 class _QueueIterator(Generic[_T]):
+    """ """
     def __init__(self, q: "Queue[_T]") -> None:
         self.q = q
 
@@ -80,17 +99,17 @@
 
 class Queue(Generic[_T]):
     """Coordinate producer and consumer coroutines.
-
+    
     If maxsize is 0 (the default) the queue size is unbounded.
-
+    
     .. testcode::
-
+    
         from tornado import gen
         from tornado.ioloop import IOLoop
         from tornado.queues import Queue
-
+    
         q = Queue(maxsize=2)
-
+    
         async def consumer():
             async for item in q:
                 try:
@@ -98,23 +117,23 @@
                     await gen.sleep(0.01)
                 finally:
                     q.task_done()
-
+    
         async def producer():
             for item in range(5):
                 await q.put(item)
                 print('Put %s' % item)
-
+    
         async def main():
             # Start consumer without waiting (since it never finishes).
             IOLoop.current().spawn_callback(consumer)
             await producer()     # Wait for producer to put all tasks.
             await q.join()       # Wait for consumer to finish all tasks.
             print('Done')
-
+    
         IOLoop.current().run_sync(main)
-
+    
     .. testoutput::
-
+    
         Put 0
         Put 1
         Doing work on 0
@@ -126,11 +145,11 @@
         Doing work on 3
         Doing work on 4
         Done
-
-
+    
+    
     In versions of Python without native coroutines (before 3.5),
     ``consumer()`` could be written as::
-
+    
         @gen.coroutine
         def consumer():
             while True:
@@ -140,9 +159,15 @@
                     yield gen.sleep(0.01)
                 finally:
                     q.task_done()
-
+    
     .. versionchanged:: 4.3
        Added ``async for`` support in Python 3.5.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -175,9 +200,11 @@
         return len(self._queue)
 
     def empty(self) -> bool:
+        """ """
         return not self._queue
 
     def full(self) -> bool:
+        """ """
         if self.maxsize == 0:
             return False
         else:
@@ -187,14 +214,27 @@
         self, item: _T, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> "Future[None]":
         """Put an item into the queue, perhaps waiting until there is room.
-
+        
         Returns a Future, which raises `tornado.util.TimeoutError` after a
         timeout.
-
+        
         ``timeout`` may be a number denoting a time (on the same
         scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a
         `datetime.timedelta` object for a deadline relative to the
         current time.
+
+        Parameters
+        ----------
+        item: _T :
+            
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         future = Future()  # type: Future[None]
         try:
@@ -208,8 +248,17 @@
 
     def put_nowait(self, item: _T) -> None:
         """Put an item into the queue without blocking.
-
+        
         If no free slot is immediately available, raise `QueueFull`.
+
+        Parameters
+        ----------
+        item: _T :
+            
+
+        Returns
+        -------
+
         """
         self._consume_expired()
         if self._getters:
@@ -226,23 +275,33 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[_T]:
         """Remove and return an item from the queue.
-
+        
         Returns an awaitable which resolves once an item is available, or raises
         `tornado.util.TimeoutError` after a timeout.
-
+        
         ``timeout`` may be a number denoting a time (on the same
         scale as `tornado.ioloop.IOLoop.time`, normally `time.time`), or a
         `datetime.timedelta` object for a deadline relative to the
         current time.
-
+        
         .. note::
-
+        
            The ``timeout`` argument of this method differs from that
            of the standard library's `queue.Queue.get`. That method
            interprets numeric values as relative timeouts; this one
            interprets them as absolute deadlines and requires
            ``timedelta`` objects for relative timeouts (consistent
            with other timeouts in Tornado).
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
 
         """
         future = Future()  # type: Future[_T]
@@ -256,8 +315,14 @@
     def get_nowait(self) -> _T:
         """Remove and return an item from the queue without blocking.
 
-        Return an item if one is immediately available, else raise
-        `QueueEmpty`.
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            `QueueEmpty`.
+
         """
         self._consume_expired()
         if self._putters:
@@ -273,15 +338,22 @@
 
     def task_done(self) -> None:
         """Indicate that a formerly enqueued task is complete.
-
+        
         Used by queue consumers. For each `.get` used to fetch a task, a
         subsequent call to `.task_done` tells the queue that the processing
         on the task is complete.
-
+        
         If a `.join` is blocking, it resumes when all items have been
         processed; that is, when every `.put` is matched by a `.task_done`.
-
+        
         Raises `ValueError` if called more times than `.put`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._unfinished_tasks <= 0:
             raise ValueError("task_done() called too many times")
@@ -293,9 +365,20 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[None]:
         """Block until all items in the queue are processed.
-
+        
         Returns an awaitable, which raises `tornado.util.TimeoutError` after a
         timeout.
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         return self._finished.wait(timeout)
 
@@ -304,12 +387,25 @@
 
     # These three are overridable in subclasses.
     def _init(self) -> None:
+        """ """
         self._queue = collections.deque()
 
     def _get(self) -> _T:
+        """ """
         return self._queue.popleft()
 
     def _put(self, item: _T) -> None:
+        """
+
+        Parameters
+        ----------
+        item: _T :
+            
+
+        Returns
+        -------
+
+        """
         self._queue.append(item)
 
     # End of the overridable methods.
@@ -320,6 +416,7 @@
         self._put(item)
 
     def _consume_expired(self) -> None:
+        """ """
         # Remove timed-out waiters.
         while self._putters and self._putters[0][1].done():
             self._putters.popleft()
@@ -334,6 +431,7 @@
         return "<%s %s>" % (type(self).__name__, self._format())
 
     def _format(self) -> str:
+        """ """
         result = "maxsize=%r" % (self.maxsize,)
         if getattr(self, "_queue", None):
             result += " queue=%r" % self._queue
@@ -348,67 +446,107 @@
 
 class PriorityQueue(Queue):
     """A `.Queue` that retrieves entries in priority order, lowest first.
-
+    
     Entries are typically tuples like ``(priority number, data)``.
-
+    
     .. testcode::
-
+    
         from tornado.queues import PriorityQueue
-
+    
         q = PriorityQueue()
         q.put((1, 'medium-priority item'))
         q.put((0, 'high-priority item'))
         q.put((10, 'low-priority item'))
-
+    
         print(q.get_nowait())
         print(q.get_nowait())
         print(q.get_nowait())
-
+    
     .. testoutput::
-
+    
         (0, 'high-priority item')
         (1, 'medium-priority item')
         (10, 'low-priority item')
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def _init(self) -> None:
+        """ """
         self._queue = []
 
     def _put(self, item: _T) -> None:
+        """
+
+        Parameters
+        ----------
+        item: _T :
+            
+
+        Returns
+        -------
+
+        """
         heapq.heappush(self._queue, item)
 
     def _get(self) -> _T:
+        """ """
         return heapq.heappop(self._queue)
 
 
 class LifoQueue(Queue):
     """A `.Queue` that retrieves the most recently put items first.
-
+    
     .. testcode::
-
+    
         from tornado.queues import LifoQueue
-
+    
         q = LifoQueue()
         q.put(3)
         q.put(2)
         q.put(1)
-
+    
         print(q.get_nowait())
         print(q.get_nowait())
         print(q.get_nowait())
-
+    
     .. testoutput::
-
+    
         1
         2
         3
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def _init(self) -> None:
+        """ """
         self._queue = []
 
     def _put(self, item: _T) -> None:
+        """
+
+        Parameters
+        ----------
+        item: _T :
+            
+
+        Returns
+        -------
+
+        """
         self._queue.append(item)
 
     def _get(self) -> _T:
+        """ """
         return self._queue.pop()
