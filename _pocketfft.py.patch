# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/fft/_pocketfft.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/fft/_pocketfft.py
@@ -47,6 +47,27 @@
 # divisions by zero (or alternatively additional checks) in the case of
 # zero-length axes during its computation.
 def _raw_fft(a, n, axis, is_real, is_forward, inv_norm):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    n :
+        
+    axis :
+        
+    is_real :
+        
+    is_forward :
+        
+    inv_norm :
+        
+
+    Returns
+    -------
+
+    """
     axis = normalize_axis_index(axis, a.ndim)
     if n is None:
         n = a.shape[axis]
@@ -80,6 +101,17 @@
 
 
 def _unitary(norm):
+    """
+
+    Parameters
+    ----------
+    norm :
+        
+
+    Returns
+    -------
+
+    """
     if norm is None:
         return False
     if norm=="ortho":
@@ -89,14 +121,30 @@
 
 
 def _fft_dispatcher(a, n=None, axis=None, norm=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    n :
+         (Default value = None)
+    axis :
+         (Default value = None)
+    norm :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_fft_dispatcher)
 def fft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the one-dimensional discrete Fourier Transform.
-
+    """Compute the one-dimensional discrete Fourier Transform.
+    
     This function computes the one-dimensional *n*-point discrete Fourier
     Transform (DFT) with the efficient Fast Fourier Transform (FFT)
     algorithm [CT].
@@ -109,13 +157,12 @@
         Length of the transformed axis of the output.
         If `n` is smaller than the length of the input, the input is cropped.
         If it is larger, the input is padded with zeros.  If `n` is not given,
-        the length of the input along the axis specified by `axis` is used.
+        the length of the input along the axis specified by `axis` is used. (Default value = None)
     axis : int, optional
         Axis over which to compute the FFT.  If not given, the last axis is
-        used.
+        used. (Default value = -1)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -137,35 +184,32 @@
     fftn : The *n*-dimensional FFT.
     rfftn : The *n*-dimensional FFT of real input.
     fftfreq : Frequency bins for given FFT parameters.
-
     Notes
     -----
     FFT (Fast Fourier Transform) refers to a way the discrete Fourier
     Transform (DFT) can be calculated efficiently, by using symmetries in the
     calculated terms.  The symmetry is highest when `n` is a power of 2, and
     the transform is therefore most efficient for these sizes.
-
+    
     The DFT is defined, with the conventions used in this implementation, in
     the documentation for the `numpy.fft` module.
-
     References
     ----------
     .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
             machine calculation of complex Fourier series," *Math. Comput.*
             19: 297-301.
-
     Examples
     --------
+    
+    In this example, real input has an FFT which is Hermitian, i.e., symmetric
+    in the real part and anti-symmetric in the imaginary part, as described in
+    the `numpy.fft` documentation:
     >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
     array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
             2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
            -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
             1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
-
-    In this example, real input has an FFT which is Hermitian, i.e., symmetric
-    in the real part and anti-symmetric in the imaginary part, as described in
-    the `numpy.fft` documentation:
-
+    
     >>> import matplotlib.pyplot as plt
     >>> t = np.arange(256)
     >>> sp = np.fft.fft(np.sin(t))
@@ -173,7 +217,6 @@
     >>> plt.plot(freq, sp.real, freq, sp.imag)
     [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
     >>> plt.show()
-
     """
 
     a = asarray(a)
@@ -188,23 +231,22 @@
 
 @array_function_dispatch(_fft_dispatcher)
 def ifft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the one-dimensional inverse discrete Fourier Transform.
-
+    """Compute the one-dimensional inverse discrete Fourier Transform.
+    
     This function computes the inverse of the one-dimensional *n*-point
     discrete Fourier transform computed by `fft`.  In other words,
     ``ifft(fft(a)) == a`` to within numerical accuracy.
     For a general description of the algorithm and definitions,
     see `numpy.fft`.
-
+    
     The input should be ordered in the same way as is returned by `fft`,
     i.e.,
-
+    
     * ``a[0]`` should contain the zero frequency term,
     * ``a[1:n//2]`` should contain the positive-frequency terms,
     * ``a[n//2 + 1:]`` should contain the negative-frequency terms, in
       increasing order starting from the most negative frequency.
-
+    
     For an even number of input points, ``A[n//2]`` represents the sum of
     the values at the positive and negative Nyquist frequencies, as the two
     are aliased together. See `numpy.fft` for details.
@@ -218,13 +260,12 @@
         If `n` is smaller than the length of the input, the input is cropped.
         If it is larger, the input is padded with zeros.  If `n` is not given,
         the length of the input along the axis specified by `axis` is used.
-        See notes about padding issues.
+        See notes about padding issues. (Default value = None)
     axis : int, optional
         Axis over which to compute the inverse DFT.  If not given, the last
-        axis is used.
+        axis is used. (Default value = -1)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -244,21 +285,19 @@
     fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
     ifft2 : The two-dimensional inverse FFT.
     ifftn : The n-dimensional inverse FFT.
-
     Notes
     -----
     If the input parameter `n` is larger than the size of the input, the input
     is padded by appending zeros at the end.  Even though this is the common
     approach, it might lead to surprising results.  If a different padding is
     desired, it must be performed before calling `ifft`.
-
     Examples
     --------
+    
+    Create and plot a band-limited signal with random phases:
     >>> np.fft.ifft([0, 4, 0, 0])
     array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary
-
-    Create and plot a band-limited signal with random phases:
-
+    
     >>> import matplotlib.pyplot as plt
     >>> t = np.arange(400)
     >>> n = np.zeros((400,), dtype=complex)
@@ -269,7 +308,6 @@
     >>> plt.legend(('real', 'imaginary'))
     <matplotlib.legend.Legend object at ...>
     >>> plt.show()
-
     """
     a = asarray(a)
     if n is None:
@@ -285,9 +323,8 @@
 
 @array_function_dispatch(_fft_dispatcher)
 def rfft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the one-dimensional discrete Fourier Transform for real input.
-
+    """Compute the one-dimensional discrete Fourier Transform for real input.
+    
     This function computes the one-dimensional *n*-point discrete Fourier
     Transform (DFT) of a real-valued array by means of an efficient algorithm
     called the Fast Fourier Transform (FFT).
@@ -300,13 +337,12 @@
         Number of points along transformation axis in the input to use.
         If `n` is smaller than the length of the input, the input is cropped.
         If it is larger, the input is padded with zeros. If `n` is not given,
-        the length of the input along the axis specified by `axis` is used.
+        the length of the input along the axis specified by `axis` is used. (Default value = None)
     axis : int, optional
         Axis over which to compute the FFT. If not given, the last axis is
-        used.
+        used. (Default value = -1)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -329,7 +365,6 @@
     fft : The one-dimensional FFT of general (complex) input.
     fftn : The *n*-dimensional FFT.
     rfftn : The *n*-dimensional FFT of real input.
-
     Notes
     -----
     When the DFT is computed for purely real input, the output is
@@ -338,29 +373,27 @@
     negative-frequency terms are therefore redundant.  This function does not
     compute the negative frequency terms, and the length of the transformed
     axis of the output is therefore ``n//2 + 1``.
-
+    
     When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
     the zero-frequency term 0*fs, which is real due to Hermitian symmetry.
-
+    
     If `n` is even, ``A[-1]`` contains the term representing both positive
     and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
     real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
     the largest positive frequency (fs/2*(n-1)/n), and is complex in the
     general case.
-
+    
     If the input `a` contains an imaginary part, it is silently discarded.
-
     Examples
     --------
+    
+    Notice how the final element of the `fft` output is the complex conjugate
+    of the second element, for real input. For `rfft`, this symmetry is
+    exploited to compute only the non-negative frequency terms.
     >>> np.fft.fft([0, 1, 0, 0])
     array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
     >>> np.fft.rfft([0, 1, 0, 0])
     array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary
-
-    Notice how the final element of the `fft` output is the complex conjugate
-    of the second element, for real input. For `rfft`, this symmetry is
-    exploited to compute only the non-negative frequency terms.
-
     """
     a = asarray(a)
     inv_norm = 1
@@ -374,14 +407,13 @@
 
 @array_function_dispatch(_fft_dispatcher)
 def irfft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the inverse of the n-point DFT for real input.
-
+    """Compute the inverse of the n-point DFT for real input.
+    
     This function computes the inverse of the one-dimensional *n*-point
     discrete Fourier Transform of real input computed by `rfft`.
     In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
     accuracy. (See Notes below for why ``len(a)`` is necessary here.)
-
+    
     The input is expected to be in the form returned by `rfft`, i.e. the
     real zero-frequency term followed by the complex positive frequency terms
     in order of increasing frequency.  Since the discrete Fourier Transform of
@@ -398,13 +430,12 @@
         input is longer than this, it is cropped.  If it is shorter than this,
         it is padded with zeros.  If `n` is not given, it is taken to be
         ``2*(m-1)`` where ``m`` is the length of the input along the axis
-        specified by `axis`.
+        specified by `axis`. (Default value = None)
     axis : int, optional
         Axis over which to compute the inverse FFT. If not given, the last
-        axis is used.
+        axis is used. (Default value = -1)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -428,19 +459,18 @@
     fft : The one-dimensional FFT.
     irfft2 : The inverse of the two-dimensional FFT of real input.
     irfftn : The inverse of the *n*-dimensional FFT of real input.
-
     Notes
     -----
     Returns the real valued `n`-point inverse discrete Fourier transform
     of `a`, where `a` contains the non-negative frequency terms of a
     Hermitian-symmetric sequence. `n` is the length of the result, not the
     input.
-
+    
     If you specify an `n` such that `a` must be zero-padded or truncated, the
     extra/removed values will be added/removed at high frequencies. One can
     thus resample a series to `m` points via Fourier interpolation by:
     ``a_resamp = irfft(rfft(a), m)``.
-
+    
     The correct interpretation of the hermitian input depends on the length of
     the original data, as given by `n`. This is because each input shape could
     correspond to either an odd or even length signal. By default, `irfft`
@@ -448,19 +478,17 @@
     frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
     the value is thus treated as purely real. To avoid losing information, the
     correct length of the real input **must** be given.
-
     Examples
     --------
+    
+    Notice how the last term in the input to the ordinary `ifft` is the
+    complex conjugate of the second term, and the output has zero imaginary
+    part everywhere.  When calling `irfft`, the negative frequencies are not
+    specified, and the output array is purely real.
     >>> np.fft.ifft([1, -1j, -1, 1j])
     array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
     >>> np.fft.irfft([1, -1j, -1])
     array([0.,  1.,  0.,  0.])
-
-    Notice how the last term in the input to the ordinary `ifft` is the
-    complex conjugate of the second term, and the output has zero imaginary
-    part everywhere.  When calling `irfft`, the negative frequencies are not
-    specified, and the output array is purely real.
-
     """
     a = asarray(a)
     if n is None:
@@ -474,8 +502,7 @@
 
 @array_function_dispatch(_fft_dispatcher)
 def hfft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
+    """Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
     spectrum.
 
     Parameters
@@ -488,13 +515,12 @@
         longer than this, it is cropped.  If it is shorter than this, it is
         padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``
         where ``m`` is the length of the input along the axis specified by
-        `axis`.
+        `axis`. (Default value = None)
     axis : int, optional
         Axis over which to compute the FFT. If not given, the last
-        axis is used.
+        axis is used. (Default value = -1)
     norm : {None, "ortho"}, optional
         Normalization mode (see `numpy.fft`). Default is None.
-
         .. versionadded:: 1.10.0
 
     Returns
@@ -516,17 +542,16 @@
     --------
     rfft : Compute the one-dimensional FFT for real input.
     ihfft : The inverse of `hfft`.
-
     Notes
     -----
     `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
     opposite case: here the signal has Hermitian symmetry in the time
     domain and is real in the frequency domain. So here it's `hfft` for
     which you must supply the length of the result if it is to be odd.
-
+    
     * even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
     * odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.
-
+    
     The correct interpretation of the hermitian input depends on the length of
     the original data, as given by `n`. This is because each input shape could
     correspond to either an odd or even length signal. By default, `hfft`
@@ -534,7 +559,6 @@
     frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
     the value is thus treated as purely real. To avoid losing information, the
     shape of the full signal **must** be given.
-
     Examples
     --------
     >>> signal = np.array([1, 2, 3, 4, 3, 2])
@@ -544,8 +568,7 @@
     array([15.,  -4.,   0.,  -1.,   0.,  -4.])
     >>> np.fft.hfft(signal, 6)  # Input entire signal and truncate
     array([15.,  -4.,   0.,  -1.,   0.,  -4.])
-
-
+    
     >>> signal = np.array([[1, 1.j], [-1.j, 2]])
     >>> np.conj(signal.T) - signal   # check Hermitian symmetry
     array([[ 0.-0.j,  -0.+0.j], # may vary
@@ -554,7 +577,6 @@
     >>> freq_spectrum
     array([[ 1.,  1.],
            [ 2., -2.]])
-
     """
     a = asarray(a)
     if n is None:
@@ -565,8 +587,7 @@
 
 @array_function_dispatch(_fft_dispatcher)
 def ihfft(a, n=None, axis=-1, norm=None):
-    """
-    Compute the inverse FFT of a signal that has Hermitian symmetry.
+    """Compute the inverse FFT of a signal that has Hermitian symmetry.
 
     Parameters
     ----------
@@ -577,13 +598,12 @@
         transformation axis in the input to use.  If `n` is smaller than
         the length of the input, the input is cropped.  If it is larger,
         the input is padded with zeros. If `n` is not given, the length of
-        the input along the axis specified by `axis` is used.
+        the input along the axis specified by `axis` is used. (Default value = None)
     axis : int, optional
         Axis over which to compute the inverse FFT. If not given, the last
-        axis is used.
+        axis is used. (Default value = -1)
     norm : {None, "ortho"}, optional
         Normalization mode (see `numpy.fft`). Default is None.
-
         .. versionadded:: 1.10.0
 
     Returns
@@ -596,17 +616,15 @@
     See also
     --------
     hfft, irfft
-
     Notes
     -----
     `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
     opposite case: here the signal has Hermitian symmetry in the time
     domain and is real in the frequency domain. So here it's `hfft` for
     which you must supply the length of the result if it is to be odd:
-
+    
     * even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
     * odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.
-
     Examples
     --------
     >>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])
@@ -614,7 +632,6 @@
     array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
     >>> np.fft.ihfft(spectrum)
     array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary
-
     """
     a = asarray(a)
     if n is None:
@@ -625,6 +642,23 @@
 
 
 def _cook_nd_args(a, s=None, axes=None, invreal=0):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    s :
+         (Default value = None)
+    axes :
+         (Default value = None)
+    invreal :
+         (Default value = 0)
+
+    Returns
+    -------
+
+    """
     if s is None:
         shapeless = 1
         if axes is None:
@@ -644,6 +678,25 @@
 
 
 def _raw_fftnd(a, s=None, axes=None, function=fft, norm=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    s :
+         (Default value = None)
+    axes :
+         (Default value = None)
+    function :
+         (Default value = fft)
+    norm :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     a = asarray(a)
     s, axes = _cook_nd_args(a, s, axes)
     itl = list(range(len(axes)))
@@ -654,14 +707,30 @@
 
 
 def _fftn_dispatcher(a, s=None, axes=None, norm=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    s :
+         (Default value = None)
+    axes :
+         (Default value = None)
+    norm :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_fftn_dispatcher)
 def fftn(a, s=None, axes=None, norm=None):
-    """
-    Compute the N-dimensional discrete Fourier Transform.
-
+    """Compute the N-dimensional discrete Fourier Transform.
+    
     This function computes the *N*-dimensional discrete Fourier Transform over
     any number of axes in an *M*-dimensional array by means of the Fast Fourier
     Transform (FFT).
@@ -677,15 +746,14 @@
         Along any axis, if the given shape is smaller than that of the input,
         the input is cropped.  If it is larger, the input is padded with zeros.
         if `s` is not given, the shape of the input along the axes specified
-        by `axes` is used.
+        by `axes` is used. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the FFT.  If not given, the last ``len(s)``
         axes are used, or all axes if `s` is also not specified.
         Repeated indices in `axes` means that the transform over that axis is
-        performed multiple times.
+        performed multiple times. (Default value = None)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -711,7 +779,6 @@
     rfftn : The *n*-dimensional FFT of real input.
     fft2 : The two-dimensional FFT.
     fftshift : Shifts zero-frequency terms to centre of array
-
     Notes
     -----
     The output, analogously to `fft`, contains the term for zero frequency in
@@ -719,9 +786,8 @@
     first half of all axes, the term for the Nyquist frequency in the middle
     of all axes and the negative frequency terms in the second half of all
     axes, in order of decreasingly negative frequency.
-
+    
     See `numpy.fft` for details, definitions and conventions used.
-
     Examples
     --------
     >>> a = np.mgrid[:3, :3, :3][0]
@@ -740,7 +806,7 @@
             [ 0.+0.j,  0.+0.j,  0.+0.j]],
            [[-2.+0.j, -2.+0.j, -2.+0.j],
             [ 0.+0.j,  0.+0.j,  0.+0.j]]])
-
+    
     >>> import matplotlib.pyplot as plt
     >>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
     ...                      2 * np.pi * np.arange(200) / 34)
@@ -749,7 +815,6 @@
     >>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
     <matplotlib.image.AxesImage object at 0x...>
     >>> plt.show()
-
     """
 
     return _raw_fftnd(a, s, axes, fft, norm)
@@ -757,15 +822,14 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def ifftn(a, s=None, axes=None, norm=None):
-    """
-    Compute the N-dimensional inverse discrete Fourier Transform.
-
+    """Compute the N-dimensional inverse discrete Fourier Transform.
+    
     This function computes the inverse of the N-dimensional discrete
     Fourier Transform over any number of axes in an M-dimensional array by
     means of the Fast Fourier Transform (FFT).  In other words,
     ``ifftn(fftn(a)) == a`` to within numerical accuracy.
     For a description of the definitions and conventions used, see `numpy.fft`.
-
+    
     The input, analogously to `ifft`, should be ordered in the same way as is
     returned by `fftn`, i.e. it should have the term for zero frequency
     in all axes in the low-order corner, the positive frequency terms in the
@@ -784,15 +848,14 @@
         Along any axis, if the given shape is smaller than that of the input,
         the input is cropped.  If it is larger, the input is padded with zeros.
         if `s` is not given, the shape of the input along the axes specified
-        by `axes` is used.  See notes for issue on `ifft` zero padding.
+        by `axes` is used.  See notes for issue on `ifft` zero padding. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the IFFT.  If not given, the last ``len(s)``
         axes are used, or all axes if `s` is also not specified.
         Repeated indices in `axes` means that the inverse transform over that
-        axis is performed multiple times.
+        axis is performed multiple times. (Default value = None)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -818,28 +881,26 @@
     ifft2 : The two-dimensional inverse FFT.
     ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
         of array.
-
     Notes
     -----
     See `numpy.fft` for definitions and conventions used.
-
+    
     Zero-padding, analogously with `ifft`, is performed by appending zeros to
     the input along the specified dimension.  Although this is the common
     approach, it might lead to surprising results.  If another form of zero
     padding is desired, it must be performed before `ifftn` is called.
-
     Examples
     --------
+    
+    
+    Create and plot an image with band-limited frequency content:
     >>> a = np.eye(4)
     >>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
     array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
            [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
            [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
            [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])
-
-
-    Create and plot an image with band-limited frequency content:
-
+    
     >>> import matplotlib.pyplot as plt
     >>> n = np.zeros((200,200), dtype=complex)
     >>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
@@ -847,7 +908,6 @@
     >>> plt.imshow(im)
     <matplotlib.image.AxesImage object at 0x...>
     >>> plt.show()
-
     """
 
     return _raw_fftnd(a, s, axes, ifft, norm)
@@ -855,9 +915,8 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def fft2(a, s=None, axes=(-2, -1), norm=None):
-    """
-    Compute the 2-dimensional discrete Fourier Transform
-
+    """Compute the 2-dimensional discrete Fourier Transform
+    
     This function computes the *n*-dimensional discrete Fourier Transform
     over any axes in an *M*-dimensional array by means of the
     Fast Fourier Transform (FFT).  By default, the transform is computed over
@@ -874,16 +933,17 @@
         Along each axis, if the given shape is smaller than that of the input,
         the input is cropped.  If it is larger, the input is padded with zeros.
         if `s` is not given, the shape of the input along the axes specified
-        by `axes` is used.
+        by `axes` is used. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the FFT.  If not given, the last two
         axes are used.  A repeated index in `axes` means the transform over
         that axis is performed multiple times.  A one-element sequence means
-        that a one-dimensional FFT is performed.
+        that a one-dimensional FFT is performed. (Default value = (-2)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
+    -1) :
+        
 
     Returns
     -------
@@ -909,21 +969,19 @@
     fftshift : Shifts zero-frequency terms to the center of the array.
         For two-dimensional input, swaps first and third quadrants, and second
         and fourth quadrants.
-
     Notes
     -----
     `fft2` is just `fftn` with a different default for `axes`.
-
+    
     The output, analogously to `fft`, contains the term for zero frequency in
     the low-order corner of the transformed axes, the positive frequency terms
     in the first half of these axes, the term for the Nyquist frequency in the
     middle of the axes and the negative frequency terms in the second half of
     the axes, in order of decreasingly negative frequency.
-
+    
     See `fftn` for details and a plotting example, and `numpy.fft` for
     definitions and conventions used.
-
-
+    
     Examples
     --------
     >>> a = np.mgrid[:5, :5][0]
@@ -938,7 +996,6 @@
               0.  +0.j        ,   0.  +0.j        ],
            [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
               0.  +0.j        ,   0.  +0.j        ]])
-
     """
 
     return _raw_fftnd(a, s, axes, fft, norm)
@@ -946,15 +1003,14 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def ifft2(a, s=None, axes=(-2, -1), norm=None):
-    """
-    Compute the 2-dimensional inverse discrete Fourier Transform.
-
+    """Compute the 2-dimensional inverse discrete Fourier Transform.
+    
     This function computes the inverse of the 2-dimensional discrete Fourier
     Transform over any number of axes in an M-dimensional array by means of
     the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
     to within numerical accuracy.  By default, the inverse transform is
     computed over the last two axes of the input array.
-
+    
     The input, analogously to `ifft`, should be ordered in the same way as is
     returned by `fft2`, i.e. it should have the term for zero frequency
     in the low-order corner of the two axes, the positive frequency terms in
@@ -972,16 +1028,17 @@
         Along each axis, if the given shape is smaller than that of the input,
         the input is cropped.  If it is larger, the input is padded with zeros.
         if `s` is not given, the shape of the input along the axes specified
-        by `axes` is used.  See notes for issue on `ifft` zero padding.
+        by `axes` is used.  See notes for issue on `ifft` zero padding. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the FFT.  If not given, the last two
         axes are used.  A repeated index in `axes` means the transform over
         that axis is performed multiple times.  A one-element sequence means
-        that a one-dimensional FFT is performed.
+        that a one-dimensional FFT is performed. (Default value = (-2)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
+    -1) :
+        
 
     Returns
     -------
@@ -1005,19 +1062,17 @@
     ifftn : The inverse of the *n*-dimensional FFT.
     fft : The one-dimensional FFT.
     ifft : The one-dimensional inverse FFT.
-
     Notes
     -----
     `ifft2` is just `ifftn` with a different default for `axes`.
-
+    
     See `ifftn` for details and a plotting example, and `numpy.fft` for
     definition and conventions used.
-
+    
     Zero-padding, analogously with `ifft`, is performed by appending zeros to
     the input along the specified dimension.  Although this is the common
     approach, it might lead to surprising results.  If another form of zero
     padding is desired, it must be performed before `ifft2` is called.
-
     Examples
     --------
     >>> a = 4 * np.eye(4)
@@ -1026,7 +1081,6 @@
            [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
            [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
            [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
-
     """
 
     return _raw_fftnd(a, s, axes, ifft, norm)
@@ -1034,9 +1088,8 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def rfftn(a, s=None, axes=None, norm=None):
-    """
-    Compute the N-dimensional discrete Fourier Transform for real input.
-
+    """Compute the N-dimensional discrete Fourier Transform for real input.
+    
     This function computes the N-dimensional discrete Fourier Transform over
     any number of axes in an M-dimensional real array by means of the Fast
     Fourier Transform (FFT).  By default, all axes are transformed, with the
@@ -1055,13 +1108,12 @@
         Along any axis, if the given shape is smaller than that of the input,
         the input is cropped.  If it is larger, the input is padded with zeros.
         if `s` is not given, the shape of the input along the axes specified
-        by `axes` is used.
+        by `axes` is used. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the FFT.  If not given, the last ``len(s)``
-        axes are used, or all axes if `s` is also not specified.
+        axes are used, or all axes if `s` is also not specified. (Default value = None)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -1089,7 +1141,6 @@
     rfft : The one-dimensional FFT of real input.
     fftn : The n-dimensional FFT.
     rfft2 : The two-dimensional FFT of real input.
-
     Notes
     -----
     The transform for real input is performed over the last transformation
@@ -1097,9 +1148,8 @@
     performed as by `fftn`.  The order of the output is as for `rfft` for the
     final transformation axis, and as for `fftn` for the remaining
     transformation axes.
-
+    
     See `fft` for details, definitions and conventions used.
-
     Examples
     --------
     >>> a = np.ones((2, 2, 2))
@@ -1108,13 +1158,12 @@
             [0.+0.j,  0.+0.j]],
            [[0.+0.j,  0.+0.j],
             [0.+0.j,  0.+0.j]]])
-
+    
     >>> np.fft.rfftn(a, axes=(2, 0))
     array([[[4.+0.j,  0.+0.j], # may vary
             [4.+0.j,  0.+0.j]],
            [[0.+0.j,  0.+0.j],
             [0.+0.j,  0.+0.j]]])
-
     """
     a = asarray(a)
     s, axes = _cook_nd_args(a, s, axes)
@@ -1126,21 +1175,21 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def rfft2(a, s=None, axes=(-2, -1), norm=None):
-    """
-    Compute the 2-dimensional FFT of a real array.
+    """Compute the 2-dimensional FFT of a real array.
 
     Parameters
     ----------
     a : array
         Input array, taken to be real.
     s : sequence of ints, optional
-        Shape of the FFT.
+        Shape of the FFT. (Default value = None)
     axes : sequence of ints, optional
-        Axes over which to compute the FFT.
+        Axes over which to compute the FFT. (Default value = (-2)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
+    -1) :
+        
 
     Returns
     -------
@@ -1151,12 +1200,10 @@
     --------
     rfftn : Compute the N-dimensional discrete Fourier Transform for real
             input.
-
     Notes
     -----
     This is really just `rfftn` with different default behavior.
     For more details see `rfftn`.
-
     """
 
     return rfftn(a, s, axes, norm)
@@ -1164,16 +1211,15 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def irfftn(a, s=None, axes=None, norm=None):
-    """
-    Compute the inverse of the N-dimensional FFT of real input.
-
+    """Compute the inverse of the N-dimensional FFT of real input.
+    
     This function computes the inverse of the N-dimensional discrete
     Fourier Transform for real input over any number of axes in an
     M-dimensional array by means of the Fast Fourier Transform (FFT).  In
     other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
     accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
     and for the same reason.)
-
+    
     The input should be ordered in the same way as is returned by `rfftn`,
     i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
     along all the other axes.
@@ -1191,15 +1237,14 @@
         the input, the input is cropped.  If it is larger, the input is padded
         with zeros. If `s` is not given, the shape of the input along the axes
         specified by axes is used. Except for the last axis which is taken to be
-        ``2*(m-1)`` where ``m`` is the length of the input along that axis.
+        ``2*(m-1)`` where ``m`` is the length of the input along that axis. (Default value = None)
     axes : sequence of ints, optional
         Axes over which to compute the inverse FFT. If not given, the last
         `len(s)` axes are used, or all axes if `s` is also not specified.
         Repeated indices in `axes` means that the inverse transform over that
-        axis is performed multiple times.
+        axis is performed multiple times. (Default value = None)
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
 
     Returns
@@ -1229,13 +1274,12 @@
     fft : The one-dimensional FFT, with definitions and conventions used.
     irfft : The inverse of the one-dimensional FFT of real input.
     irfft2 : The inverse of the two-dimensional FFT of real input.
-
     Notes
     -----
     See `fft` for definitions and conventions used.
-
+    
     See `rfft` for definitions and conventions used for real input.
-
+    
     The correct interpretation of the hermitian input depends on the shape of
     the original data, as given by `s`. This is because each input shape could
     correspond to either an odd or even length signal. By default, `irfftn`
@@ -1244,7 +1288,6 @@
     final complex to real transform, the last value is thus treated as purely
     real. To avoid losing information, the correct shape of the real input
     **must** be given.
-
     Examples
     --------
     >>> a = np.zeros((3, 2, 2))
@@ -1256,7 +1299,6 @@
             [1.,  1.]],
            [[1.,  1.],
             [1.,  1.]]])
-
     """
     a = asarray(a)
     s, axes = _cook_nd_args(a, s, axes, invreal=1)
@@ -1268,22 +1310,22 @@
 
 @array_function_dispatch(_fftn_dispatcher)
 def irfft2(a, s=None, axes=(-2, -1), norm=None):
-    """
-    Compute the 2-dimensional inverse FFT of a real array.
+    """Compute the 2-dimensional inverse FFT of a real array.
 
     Parameters
     ----------
     a : array_like
         The input array
     s : sequence of ints, optional
-        Shape of the real output to the inverse FFT.
+        Shape of the real output to the inverse FFT. (Default value = None)
     axes : sequence of ints, optional
         The axes over which to compute the inverse fft.
         Default is the last two axes.
     norm : {None, "ortho"}, optional
         .. versionadded:: 1.10.0
-
         Normalization mode (see `numpy.fft`). Default is None.
+    -1) :
+        
 
     Returns
     -------
@@ -1293,12 +1335,10 @@
     See Also
     --------
     irfftn : Compute the inverse of the N-dimensional FFT of real input.
-
     Notes
     -----
     This is really `irfftn` with different defaults.
     For more details see `irfftn`.
-
     """
 
     return irfftn(a, s, axes, norm)
