# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/range.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/range.py
@@ -37,13 +37,12 @@
 
 
 class RangeIndex(Int64Index):
-    """
-    Immutable Index implementing a monotonic integer range.
-
+    """Immutable Index implementing a monotonic integer range.
+    
     RangeIndex is a memory-saving special case of Int64Index limited to
     representing monotonic ranges. Using RangeIndex may in some instances
     improve computing speed.
-
+    
     This is the default index type used
     by DataFrame and Series when no explicit index is provided by the user.
 
@@ -52,22 +51,25 @@
     start : int (default: 0), or other RangeIndex instance
         If int and "stop" is not given, interpreted as "stop" instead.
     stop : int (default: 0)
+        
     step : int (default: 1)
+        
     name : object, optional
         Name to be stored in the index.
     copy : bool, default False
         Unused, accepted for homogeneity with other index types.
+
+    Returns
+    -------
 
     Attributes
     ----------
     start
     stop
     step
-
     Methods
     -------
     from_range
-
     See Also
     --------
     Index : The base pandas Index type.
@@ -115,12 +117,21 @@
 
     @classmethod
     def from_range(cls, data: range, name=None, dtype=None) -> "RangeIndex":
-        """
-        Create RangeIndex from a range object.
-
-        Returns
-        -------
-        RangeIndex
+        """Create RangeIndex from a range object.
+
+        Parameters
+        ----------
+        data: range :
+            
+        name :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if not isinstance(data, range):
             raise TypeError(
@@ -133,6 +144,19 @@
 
     @classmethod
     def _simple_new(cls, values: range, name: Label = None) -> "RangeIndex":
+        """
+
+        Parameters
+        ----------
+        values: range :
+            
+        name: Label :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = object.__new__(cls)
 
         assert isinstance(values, range)
@@ -147,17 +171,23 @@
 
     @cache_readonly
     def _constructor(self):
-        """ return the class to use for construction """
+        """ """
         return Int64Index
 
     @property
     def _data(self):
-        """
-        An int array that for performance reasons is created only when needed.
-
+        """An int array that for performance reasons is created only when needed.
+        
         The constructed array is saved in ``_cached_data``. This allows us to
         check if the array has been created without accessing ``_data`` and
         triggering the construction.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._cached_data is None:
             self._cached_data = np.arange(
@@ -167,10 +197,11 @@
 
     @cache_readonly
     def _int64index(self) -> Int64Index:
+        """ """
         return Int64Index._simple_new(self._data, name=self.name)
 
     def _get_data_as_items(self):
-        """ return a list of tuples of start, stop, step """
+        """ """
         rng = self._range
         return [("start", rng.start), ("stop", rng.stop), ("step", rng.step)]
 
@@ -183,19 +214,41 @@
     # Rendering Methods
 
     def _format_attrs(self):
-        """
-        Return a list of tuples of the (attr, formatted_value)
-        """
+        """ """
         attrs = self._get_data_as_items()
         if self.name is not None:
             attrs.append(("name", ibase.default_pprint(self.name)))
         return attrs
 
     def _format_data(self, name=None):
+        """
+
+        Parameters
+        ----------
+        name :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # we are formatting thru the attributes
         return None
 
     def _format_with_header(self, header: List[str], na_rep: str = "NaN") -> List[str]:
+        """
+
+        Parameters
+        ----------
+        header: List[str] :
+            
+        na_rep: str :
+             (Default value = "NaN")
+
+        Returns
+        -------
+
+        """
         if not len(self._range):
             return header
         first_val_str = str(self._range[0])
@@ -213,19 +266,23 @@
 
     @cache_readonly
     def start(self):
-        """
-        The value of the `start` parameter (``0`` if this was not supplied).
-        """
+        """The value of the `start` parameter (``0`` if this was not supplied)."""
         # GH 25710
         return self._range.start
 
     @property
     def _start(self):
-        """
-        The value of the `start` parameter (``0`` if this was not supplied).
-
+        """The value of the `start` parameter (``0`` if this was not supplied).
+        
          .. deprecated:: 0.25.0
             Use ``start`` instead.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         warnings.warn(
             self._deprecation_message.format("_start", "start"),
@@ -236,18 +293,22 @@
 
     @cache_readonly
     def stop(self):
-        """
-        The value of the `stop` parameter.
-        """
+        """The value of the `stop` parameter."""
         return self._range.stop
 
     @property
     def _stop(self):
-        """
-        The value of the `stop` parameter.
-
+        """The value of the `stop` parameter.
+        
          .. deprecated:: 0.25.0
             Use ``stop`` instead.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # GH 25710
         warnings.warn(
@@ -259,19 +320,23 @@
 
     @cache_readonly
     def step(self):
-        """
-        The value of the `step` parameter (``1`` if this was not supplied).
-        """
+        """The value of the `step` parameter (``1`` if this was not supplied)."""
         # GH 25710
         return self._range.step
 
     @property
     def _step(self):
-        """
-        The value of the `step` parameter (``1`` if this was not supplied).
-
+        """The value of the `step` parameter (``1`` if this was not supplied).
+        
          .. deprecated:: 0.25.0
             Use ``step`` instead.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # GH 25710
         warnings.warn(
@@ -283,9 +348,7 @@
 
     @cache_readonly
     def nbytes(self) -> int:
-        """
-        Return the number of bytes in the underlying data.
-        """
+        """ """
         rng = self._range
         return getsizeof(rng) + sum(
             getsizeof(getattr(rng, attr_name))
@@ -293,24 +356,25 @@
         )
 
     def memory_usage(self, deep: bool = False) -> int:
-        """
-        Memory usage of my values
+        """Memory usage of my values
 
         Parameters
         ----------
         deep : bool
             Introspect the data deeply, interrogate
             `object` dtypes for system-level memory consumption
+        deep: bool :
+             (Default value = False)
 
         Returns
         -------
         bytes used
+            
 
         Notes
         -----
         Memory usage does not include memory consumed by elements that
         are not components of the array if deep=False
-
         See Also
         --------
         numpy.ndarray.nbytes
@@ -319,23 +383,27 @@
 
     @property
     def dtype(self) -> np.dtype:
+        """ """
         return np.dtype(np.int64)
 
     @property
     def is_unique(self) -> bool:
-        """ return if the index has unique values """
+        """ """
         return True
 
     @cache_readonly
     def is_monotonic_increasing(self) -> bool:
+        """ """
         return self._range.step > 0 or len(self) <= 1
 
     @cache_readonly
     def is_monotonic_decreasing(self) -> bool:
+        """ """
         return self._range.step < 0 or len(self) <= 1
 
     @property
     def has_duplicates(self) -> bool:
+        """ """
         return False
 
     def __contains__(self, key: Any) -> bool:
@@ -348,6 +416,21 @@
 
     @doc(Int64Index.get_loc)
     def get_loc(self, key, method=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        method :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if method is None and tolerance is None:
             if is_integer(key) or (is_float(key) and key.is_integer()):
                 new_key = int(key)
@@ -360,6 +443,23 @@
 
     @Appender(_index_shared_docs["get_indexer"])
     def get_indexer(self, target, method=None, limit=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if com.any_not_none(method, tolerance, limit) or not is_list_like(target):
             return super().get_indexer(
                 target, method=method, tolerance=tolerance, limit=limit
@@ -388,10 +488,24 @@
         return ensure_platform_int(locs)
 
     def tolist(self):
+        """ """
         return list(self._range)
 
     @doc(Int64Index._shallow_copy)
     def _shallow_copy(self, values=None, name: Label = no_default):
+        """
+
+        Parameters
+        ----------
+        values :
+             (Default value = None)
+        name: Label :
+             (Default value = no_default)
+
+        Returns
+        -------
+
+        """
         name = self.name if name is no_default else name
 
         if values is None:
@@ -403,12 +517,40 @@
 
     @doc(Int64Index.copy)
     def copy(self, name=None, deep=False, dtype=None, **kwargs):
+        """
+
+        Parameters
+        ----------
+        name :
+             (Default value = None)
+        deep :
+             (Default value = False)
+        dtype :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         self._validate_dtype(dtype)
         if name is None:
             name = self.name
         return self.from_range(self._range, name=name)
 
     def _minmax(self, meth: str):
+        """
+
+        Parameters
+        ----------
+        meth: str :
+            
+
+        Returns
+        -------
+
+        """
         no_steps = len(self) - 1
         if no_steps == -1:
             return np.nan
@@ -418,25 +560,64 @@
         return self.start + self.step * no_steps
 
     def min(self, axis=None, skipna=True, *args, **kwargs) -> int:
-        """The minimum value of the RangeIndex"""
+        """The minimum value of the RangeIndex
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        skipna :
+             (Default value = True)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_minmax_axis(axis)
         nv.validate_min(args, kwargs)
         return self._minmax("min")
 
     def max(self, axis=None, skipna=True, *args, **kwargs) -> int:
-        """The maximum value of the RangeIndex"""
+        """The maximum value of the RangeIndex
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        skipna :
+             (Default value = True)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_minmax_axis(axis)
         nv.validate_max(args, kwargs)
         return self._minmax("max")
 
     def argsort(self, *args, **kwargs) -> np.ndarray:
-        """
-        Returns the indices that would sort the index and its
+        """Returns the indices that would sort the index and its
         underlying data.
 
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
         Returns
         -------
         argsorted : numpy array
+            
 
         See Also
         --------
@@ -450,33 +631,39 @@
             return np.arange(len(self) - 1, -1, -1)
 
     def equals(self, other) -> bool:
-        """
-        Determines if two Index objects contain the same elements.
+        """Determines if two Index objects contain the same elements.
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(other, RangeIndex):
             return self._range == other._range
         return super().equals(other)
 
     def intersection(self, other, sort=False):
-        """
-        Form the intersection of two Index objects.
+        """Form the intersection of two Index objects.
 
         Parameters
         ----------
         other : Index or array-like
+            
         sort : False or None, default False
             Sort the resulting index if possible
-
             .. versionadded:: 0.24.0
-
             .. versionchanged:: 0.24.1
-
-               Changed the default to ``False`` to match the behaviour
-               from before 0.24.0.
-
-        Returns
-        -------
-        intersection : Index
+            Changed the default to ``False`` to match the behaviour
+            from before 0.24.0.
+
+        Returns
+        -------
+
+        
         """
         self._validate_sort_keyword(sort)
 
@@ -528,21 +715,51 @@
         return new_index
 
     def _min_fitting_element(self, lower_limit: int) -> int:
-        """Returns the smallest element greater than or equal to the limit"""
+        """Returns the smallest element greater than or equal to the limit
+
+        Parameters
+        ----------
+        lower_limit: int :
+            
+
+        Returns
+        -------
+
+        """
         no_steps = -(-(lower_limit - self.start) // abs(self.step))
         return self.start + abs(self.step) * no_steps
 
     def _max_fitting_element(self, upper_limit: int) -> int:
-        """Returns the largest element smaller than or equal to the limit"""
+        """Returns the largest element smaller than or equal to the limit
+
+        Parameters
+        ----------
+        upper_limit: int :
+            
+
+        Returns
+        -------
+
+        """
         no_steps = (upper_limit - self.start) // abs(self.step)
         return self.start + abs(self.step) * no_steps
 
     def _extended_gcd(self, a, b):
-        """
-        Extended Euclidean algorithms to solve Bezout's identity:
+        """Extended Euclidean algorithms to solve Bezout's identity:
            a*x + b*y = gcd(x, y)
         Finds one particular solution for x, y: s, t
         Returns: gcd, s, t
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
         """
         s, old_s = 0, 1
         t, old_t = 1, 0
@@ -555,24 +772,23 @@
         return old_r, old_s, old_t
 
     def _union(self, other, sort):
-        """
-        Form the union of two Index objects and sorts if possible
+        """Form the union of two Index objects and sorts if possible
 
         Parameters
         ----------
         other : Index or array-like
-
+            
         sort : False or None, default None
             Whether to sort resulting index. ``sort=None`` returns a
             monotonically increasing ``RangeIndex`` if possible or a sorted
             ``Int64Index`` if not. ``sort=False`` always returns an
             unsorted ``Int64Index``
-
             .. versionadded:: 0.25.0
 
         Returns
         -------
-        union : Index
+
+        
         """
         if not len(other) or self.equals(other) or not len(self):
             return super()._union(other, sort=sort)
@@ -625,6 +841,25 @@
 
     @doc(Int64Index.join)
     def join(self, other, how="left", level=None, return_indexers=False, sort=False):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        how :
+             (Default value = "left")
+        level :
+             (Default value = None)
+        return_indexers :
+             (Default value = False)
+        sort :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if how == "outer" and self is not other:
             # note: could return RangeIndex in more circumstances
             return self._int64index.join(other, how, level, return_indexers, sort)
@@ -632,13 +867,23 @@
         return super().join(other, how, level, return_indexers, sort)
 
     def _concat(self, indexes, name):
-        """
-        Overriding parent method for the case of all RangeIndex instances.
-
+        """Overriding parent method for the case of all RangeIndex instances.
+        
         When all members of "indexes" are of type RangeIndex: result will be
         RangeIndex if possible, Int64Index otherwise. E.g.:
         indexes = [RangeIndex(3), RangeIndex(3, 6)] -> RangeIndex(6)
         indexes = [RangeIndex(3), RangeIndex(4, 6)] -> Int64Index([0,1,2,4,5])
+
+        Parameters
+        ----------
+        indexes :
+            
+        name :
+            
+
+        Returns
+        -------
+
         """
         if not all(isinstance(x, RangeIndex) for x in indexes):
             return super()._concat(indexes, name)
@@ -692,6 +937,7 @@
 
     @property
     def size(self) -> int:
+        """ """
         return len(self)
 
     def __getitem__(self, key):
@@ -736,28 +982,46 @@
         return self._int64index // other
 
     def all(self) -> bool:
+        """ """
         return 0 not in self._range
 
     def any(self) -> bool:
+        """ """
         return any(self._range)
 
     @classmethod
     def _add_numeric_methods_binary(cls):
-        """ add in numeric methods, specialized to RangeIndex """
+        """add in numeric methods, specialized to RangeIndex"""
 
         def _make_evaluate_binop(op, step=False):
             """
+
             Parameters
             ----------
-            op : callable that accepts 2 params
-                perform the binary op
-            step : callable, optional, default to False
-                op to apply to the step parm if not None
-                if False, use the existing step
+            op :
+                
+            step :
+                 (Default value = False)
+
+            Returns
+            -------
+
+            
             """
 
             @unpack_zerodim_and_defer(op.__name__)
             def _evaluate_numeric_binop(self, other):
+                """
+
+                Parameters
+                ----------
+                other :
+                    
+
+                Returns
+                -------
+
+                """
                 if isinstance(other, ABCTimedeltaIndex):
                     # Defer to TimedeltaIndex implementation
                     return NotImplemented
