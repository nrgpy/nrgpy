# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/ioloop_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/ioloop_test.py
@@ -26,7 +26,9 @@
 
 
 class TestIOLoop(AsyncTestCase):
+    """ """
     def test_add_callback_return_sequence(self):
+        """ """
         # A callback returning {} or [] shouldn't spin the CPU, see Issue #1803.
         self.calls = 0
 
@@ -35,6 +37,21 @@
         old_add_callback = loop.add_callback
 
         def add_callback(self, callback, *args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            callback :
+                
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             test.calls += 1
             old_add_callback(callback, *args, **kwargs)
 
@@ -47,13 +64,16 @@
 
     @skipOnTravis
     def test_add_callback_wakeup(self):
+        """ """
         # Make sure that add_callback from inside a running IOLoop
         # wakes up the IOLoop immediately instead of waiting for a timeout.
         def callback():
+            """ """
             self.called = True
             self.stop()
 
         def schedule_callback():
+            """ """
             self.called = False
             self.io_loop.add_callback(callback)
             # Store away the time so we can check if we woke up immediately
@@ -66,7 +86,9 @@
 
     @skipOnTravis
     def test_add_callback_wakeup_other_thread(self):
+        """ """
         def target():
+            """ """
             # sleep a bit to let the ioloop go into its poll loop
             time.sleep(0.01)
             self.stop_time = time.time()
@@ -80,10 +102,12 @@
         thread.join()
 
     def test_add_timeout_timedelta(self):
+        """ """
         self.io_loop.add_timeout(datetime.timedelta(microseconds=1), self.stop)
         self.wait()
 
     def test_multiple_add(self):
+        """ """
         sock, port = bind_unused_port()
         try:
             self.io_loop.add_handler(
@@ -103,6 +127,7 @@
             sock.close()
 
     def test_remove_without_add(self):
+        """ """
         # remove_handler should not throw an exception if called on an fd
         # was never added.
         sock, port = bind_unused_port()
@@ -112,12 +137,14 @@
             sock.close()
 
     def test_add_callback_from_signal(self):
+        """ """
         # cheat a little bit and just run this normally, since we can't
         # easily simulate the races that happen with real signal handlers
         self.io_loop.add_callback_from_signal(self.stop)
         self.wait()
 
     def test_add_callback_from_signal_other_thread(self):
+        """ """
         # Very crude test, just to make sure that we cover this case.
         # This also happens to be the first test where we run an IOLoop in
         # a non-main thread.
@@ -129,12 +156,14 @@
         other_ioloop.close()
 
     def test_add_callback_while_closing(self):
+        """ """
         # add_callback should not fail if it races with another thread
         # closing the IOLoop. The callbacks are dropped silently
         # without executing.
         closing = threading.Event()
 
         def target():
+            """ """
             other_ioloop.add_callback(other_ioloop.stop)
             other_ioloop.start()
             closing.set()
@@ -149,6 +178,7 @@
 
     @skipIfNonUnix  # just because socketpair is so convenient
     def test_read_while_writeable(self):
+        """ """
         # Ensure that write events don't come in while we're waiting for
         # a read and haven't asked for writeability. (the reverse is
         # difficult to test for)
@@ -156,6 +186,19 @@
         try:
 
             def handler(fd, events):
+                """
+
+                Parameters
+                ----------
+                fd :
+                    
+                events :
+                    
+
+                Returns
+                -------
+
+                """
                 self.assertEqual(events, IOLoop.READ)
                 self.stop()
 
@@ -170,12 +213,14 @@
             server.close()
 
     def test_remove_timeout_after_fire(self):
+        """ """
         # It is not an error to call remove_timeout after it has run.
         handle = self.io_loop.add_timeout(self.io_loop.time(), self.stop)
         self.wait()
         self.io_loop.remove_timeout(handle)
 
     def test_remove_timeout_cleanup(self):
+        """ """
         # Add and remove enough callbacks to trigger cleanup.
         # Not a very thorough test, but it ensures that the cleanup code
         # gets executed and doesn't blow up.  This test is only really useful
@@ -189,6 +234,7 @@
         self.wait()
 
     def test_remove_timeout_from_timeout(self):
+        """ """
         calls = [False, False]
 
         # Schedule several callbacks and wait for them all to come due at once.
@@ -197,12 +243,14 @@
         now = self.io_loop.time()
 
         def t1():
+            """ """
             calls[0] = True
             self.io_loop.remove_timeout(t2_handle)
 
         self.io_loop.add_timeout(now + 0.01, t1)
 
         def t2():
+            """ """
             calls[1] = True
 
         t2_handle = self.io_loop.add_timeout(now + 0.02, t2)
@@ -212,6 +260,7 @@
         self.assertEqual(calls, [True, False])
 
     def test_timeout_with_arguments(self):
+        """ """
         # This tests that all the timeout methods pass through *args correctly.
         results = []  # type: List[int]
         self.io_loop.add_timeout(self.io_loop.time(), results.append, 1)
@@ -225,6 +274,7 @@
         self.assertEqual(sorted(results), [1, 2, 3, 4])
 
     def test_add_timeout_return(self):
+        """ """
         # All the timeout methods return non-None handles that can be
         # passed to remove_timeout.
         handle = self.io_loop.add_timeout(self.io_loop.time(), lambda: None)
@@ -232,11 +282,13 @@
         self.io_loop.remove_timeout(handle)
 
     def test_call_at_return(self):
+        """ """
         handle = self.io_loop.call_at(self.io_loop.time(), lambda: None)
         self.assertFalse(handle is None)
         self.io_loop.remove_timeout(handle)
 
     def test_call_later_return(self):
+        """ """
         handle = self.io_loop.call_later(0, lambda: None)
         self.assertFalse(handle is None)
         self.io_loop.remove_timeout(handle)
@@ -245,19 +297,29 @@
         """When a file object is used instead of a numeric file descriptor,
         the object should be closed (by IOLoop.close(all_fds=True),
         not just the fd.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # Use a socket since they are supported by IOLoop on all platforms.
         # Unfortunately, sockets don't support the .closed attribute for
         # inspecting their close status, so we must use a wrapper.
         class SocketWrapper(object):
+            """ """
             def __init__(self, sockobj):
                 self.sockobj = sockobj
                 self.closed = False
 
             def fileno(self):
+                """ """
                 return self.sockobj.fileno()
 
             def close(self):
+                """ """
                 self.closed = True
                 self.sockobj.close()
 
@@ -274,6 +336,19 @@
         fds = []
 
         def handle_connection(fd, events):
+            """
+
+            Parameters
+            ----------
+            fd :
+                
+            events :
+                
+
+            Returns
+            -------
+
+            """
             fds.append(fd)
             conn, addr = server_sock.accept()
             conn.close()
@@ -294,9 +369,23 @@
         server_sock.close()
 
     def test_mixed_fd_fileobj(self):
+        """ """
         server_sock, port = bind_unused_port()
 
         def f(fd, events):
+            """
+
+            Parameters
+            ----------
+            fd :
+                
+            events :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         self.io_loop.add_handler(server_sock, f, IOLoop.READ)
@@ -313,6 +402,7 @@
         got_exception = [False]
 
         def callback():
+            """ """
             try:
                 self.io_loop.start()
                 returned_from_start[0] = True
@@ -337,6 +427,7 @@
 
         @gen.coroutine
         def callback():
+            """ """
             self.io_loop.add_callback(self.stop)
             1 / 0
 
@@ -358,6 +449,7 @@
             self.wait()
 
     def test_spawn_callback(self):
+        """ """
         # Both add_callback and spawn_callback run directly on the IOLoop,
         # so their errors are logged without stopping the test.
         self.io_loop.add_callback(lambda: 1 / 0)
@@ -373,6 +465,7 @@
 
     @skipIfNonUnix
     def test_remove_handler_from_handler(self):
+        """ """
         # Create two sockets with simultaneous read events.
         client, server = socket.socketpair()
         try:
@@ -383,6 +476,19 @@
             chunks = []
 
             def handle_read(fd, events):
+                """
+
+                Parameters
+                ----------
+                fd :
+                    
+                events :
+                    
+
+                Returns
+                -------
+
+                """
                 chunks.append(fd.recv(1024))
                 if fd is client:
                     self.io_loop.remove_handler(server)
@@ -403,12 +509,14 @@
     @skipIfNonUnix
     @gen_test
     def test_init_close_race(self):
+        """ """
         # Regression test for #2367
         #
         # Skipped on windows because of what looks like a bug in the
         # proactor event loop when started and stopped on non-main
         # threads.
         def f():
+            """ """
             for i in range(10):
                 loop = IOLoop()
                 loop.close()
@@ -419,15 +527,19 @@
 # Deliberately not a subclass of AsyncTestCase so the IOLoop isn't
 # automatically set as current.
 class TestIOLoopCurrent(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         self.io_loop = None  # type: typing.Optional[IOLoop]
         IOLoop.clear_current()
 
     def tearDown(self):
+        """ """
         if self.io_loop is not None:
             self.io_loop.close()
 
     def test_default_current(self):
+        """ """
         self.io_loop = IOLoop()
         # The first IOLoop with default arguments is made current.
         self.assertIs(self.io_loop, IOLoop.current())
@@ -437,6 +549,7 @@
         io_loop2.close()
 
     def test_non_current(self):
+        """ """
         self.io_loop = IOLoop(make_current=False)
         # The new IOLoop is not initially made current.
         self.assertIsNone(IOLoop.current(instance=False))
@@ -445,6 +558,7 @@
         for i in range(3):
 
             def f():
+                """ """
                 self.current_io_loop = IOLoop.current()
                 assert self.io_loop is not None
                 self.io_loop.stop()
@@ -456,6 +570,7 @@
             self.assertIsNone(IOLoop.current(instance=False))
 
     def test_force_current(self):
+        """ """
         self.io_loop = IOLoop(make_current=True)
         self.assertIs(self.io_loop, IOLoop.current())
         with self.assertRaises(RuntimeError):
@@ -466,8 +581,10 @@
 
 
 class TestIOLoopCurrentAsync(AsyncTestCase):
+    """ """
     @gen_test
     def test_clear_without_current(self):
+        """ """
         # If there is no current IOLoop, clear_current is a no-op (but
         # should not fail). Use a thread so we see the threading.Local
         # in a pristine state.
@@ -476,10 +593,13 @@
 
 
 class TestIOLoopFutures(AsyncTestCase):
+    """ """
     def test_add_future_threads(self):
+        """ """
         with futures.ThreadPoolExecutor(1) as pool:
 
             def dummy():
+                """ """
                 pass
 
             self.io_loop.add_future(
@@ -491,10 +611,24 @@
 
     @gen_test
     def test_run_in_executor_gen(self):
+        """ """
         event1 = threading.Event()
         event2 = threading.Event()
 
         def sync_func(self_event, other_event):
+            """
+
+            Parameters
+            ----------
+            self_event :
+                
+            other_event :
+                
+
+            Returns
+            -------
+
+            """
             self_event.set()
             other_event.wait()
             # Note that return value doesn't actually do anything,
@@ -513,10 +647,24 @@
 
     @gen_test
     def test_run_in_executor_native(self):
+        """ """
         event1 = threading.Event()
         event2 = threading.Event()
 
         def sync_func(self_event, other_event):
+            """
+
+            Parameters
+            ----------
+            self_event :
+                
+            other_event :
+                
+
+            Returns
+            -------
+
+            """
             self_event.set()
             other_event.wait()
             return self_event
@@ -535,16 +683,32 @@
 
     @gen_test
     def test_set_default_executor(self):
+        """ """
         count = [0]
 
         class MyExecutor(futures.ThreadPoolExecutor):
+            """ """
             def submit(self, func, *args):
+                """
+
+                Parameters
+                ----------
+                func :
+                    
+                *args :
+                    
+
+                Returns
+                -------
+
+                """
                 count[0] += 1
                 return super().submit(func, *args)
 
         event = threading.Event()
 
         def sync_func():
+            """ """
             event.set()
 
         executor = MyExecutor(1)
@@ -556,31 +720,40 @@
 
 
 class TestIOLoopRunSync(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         self.io_loop = IOLoop()
 
     def tearDown(self):
+        """ """
         self.io_loop.close()
 
     def test_sync_result(self):
+        """ """
         with self.assertRaises(gen.BadYieldError):
             self.io_loop.run_sync(lambda: 42)
 
     def test_sync_exception(self):
+        """ """
         with self.assertRaises(ZeroDivisionError):
             self.io_loop.run_sync(lambda: 1 / 0)
 
     def test_async_result(self):
+        """ """
         @gen.coroutine
         def f():
+            """ """
             yield gen.moment
             raise gen.Return(42)
 
         self.assertEqual(self.io_loop.run_sync(f), 42)
 
     def test_async_exception(self):
+        """ """
         @gen.coroutine
         def f():
+            """ """
             yield gen.moment
             1 / 0
 
@@ -588,21 +761,27 @@
             self.io_loop.run_sync(f)
 
     def test_current(self):
+        """ """
         def f():
+            """ """
             self.assertIs(IOLoop.current(), self.io_loop)
 
         self.io_loop.run_sync(f)
 
     def test_timeout(self):
+        """ """
         @gen.coroutine
         def f():
+            """ """
             yield gen.sleep(1)
 
         self.assertRaises(TimeoutError, self.io_loop.run_sync, f, timeout=0.01)
 
     def test_native_coroutine(self):
+        """ """
         @gen.coroutine
         def f1():
+            """ """
             yield gen.moment
 
         async def f2():
@@ -612,13 +791,25 @@
 
 
 class TestPeriodicCallbackMath(unittest.TestCase):
+    """ """
     def simulate_calls(self, pc, durations):
         """Simulate a series of calls to the PeriodicCallback.
-
+        
         Pass a list of call durations in seconds (negative values
         work to simulate clock adjustments during the call, or more or
         less equivalently, between calls). This method returns the
         times at which each call would be made.
+
+        Parameters
+        ----------
+        pc :
+            
+        durations :
+            
+
+        Returns
+        -------
+
         """
         calls = []
         now = 1000
@@ -630,15 +821,18 @@
         return calls
 
     def dummy(self):
+        """ """
         pass
 
     def test_basic(self):
+        """ """
         pc = PeriodicCallback(self.dummy, 10000)
         self.assertEqual(
             self.simulate_calls(pc, [0] * 5), [1010, 1020, 1030, 1040, 1050]
         )
 
     def test_overrun(self):
+        """ """
         # If a call runs for too long, we skip entire cycles to get
         # back on schedule.
         call_durations = [9, 9, 10, 11, 20, 20, 35, 35, 0, 0, 0]
@@ -660,6 +854,7 @@
         self.assertEqual(self.simulate_calls(pc, call_durations), expected)
 
     def test_clock_backwards(self):
+        """ """
         pc = PeriodicCallback(self.dummy, 10000)
         # Backwards jumps are ignored, potentially resulting in a
         # slightly slow schedule (although we assume that when
@@ -677,12 +872,14 @@
         self.assertEqual(self.simulate_calls(pc, [-100, 0, 0]), [1010, 1020, 1030])
 
     def test_jitter(self):
+        """ """
         random_times = [0.5, 1, 0, 0.75]
         expected = [1010, 1022.5, 1030, 1041.25]
         call_durations = [0] * len(random_times)
         pc = PeriodicCallback(self.dummy, 10000, jitter=0.5)
 
         def mock_random():
+            """ """
             return random_times.pop(0)
 
         with mock.patch("random.random", mock_random):
@@ -690,7 +887,19 @@
 
 
 class TestIOLoopConfiguration(unittest.TestCase):
+    """ """
     def run_python(self, *statements):
+        """
+
+        Parameters
+        ----------
+        *statements :
+            
+
+        Returns
+        -------
+
+        """
         stmt_list = [
             "from tornado.ioloop import IOLoop",
             "classname = lambda x: x.__class__.__name__",
@@ -699,6 +908,7 @@
         return native_str(subprocess.check_output(args)).strip()
 
     def test_default(self):
+        """ """
         # When asyncio is available, it is used by default.
         cls = self.run_python("print(classname(IOLoop.current()))")
         self.assertEqual(cls, "AsyncIOMainLoop")
@@ -706,6 +916,7 @@
         self.assertEqual(cls, "AsyncIOLoop")
 
     def test_asyncio(self):
+        """ """
         cls = self.run_python(
             'IOLoop.configure("tornado.platform.asyncio.AsyncIOLoop")',
             "print(classname(IOLoop.current()))",
@@ -713,6 +924,7 @@
         self.assertEqual(cls, "AsyncIOMainLoop")
 
     def test_asyncio_main(self):
+        """ """
         cls = self.run_python(
             "from tornado.platform.asyncio import AsyncIOMainLoop",
             "AsyncIOMainLoop().install()",
