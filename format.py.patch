# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/io/formats/format.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/io/formats/format.py
@@ -164,6 +164,7 @@
 
 
 class CategoricalFormatter:
+    """ """
     def __init__(
         self,
         categorical: "Categorical",
@@ -180,6 +181,7 @@
         self.quoting = QUOTE_NONNUMERIC
 
     def _get_footer(self) -> str:
+        """ """
         footer = ""
 
         if self.length:
@@ -197,6 +199,7 @@
         return str(footer)
 
     def _get_formatted_values(self) -> List[str]:
+        """ """
         return format_array(
             self.categorical._internal_get_values(),
             None,
@@ -206,6 +209,7 @@
         )
 
     def to_string(self) -> str:
+        """ """
         categorical = self.categorical
 
         if len(categorical) == 0:
@@ -228,6 +232,7 @@
 
 
 class SeriesFormatter:
+    """ """
     def __init__(
         self,
         series: "Series",
@@ -261,6 +266,7 @@
         self._chk_truncate()
 
     def _chk_truncate(self) -> None:
+        """ """
         from pandas.core.reshape.concat import concat
 
         self.tr_row_num: Optional[int]
@@ -290,6 +296,7 @@
         self.truncate_v = truncate_v
 
     def _get_footer(self) -> str:
+        """ """
         name = self.series.name
         footer = ""
 
@@ -329,6 +336,7 @@
         return str(footer)
 
     def _get_formatted_index(self) -> Tuple[List[str], bool]:
+        """ """
         index = self.tr_series.index
 
         if isinstance(index, MultiIndex):
@@ -340,6 +348,7 @@
         return fmt_index, have_header
 
     def _get_formatted_values(self) -> List[str]:
+        """ """
         return format_array(
             self.tr_series._values,
             None,
@@ -348,6 +357,7 @@
         )
 
     def to_string(self) -> str:
+        """ """
         series = self.tr_series
         footer = self._get_footer()
 
@@ -387,20 +397,63 @@
 
 
 class TextAdjustment:
+    """ """
     def __init__(self):
         self.encoding = get_option("display.encoding")
 
     def len(self, text: str) -> int:
+        """
+
+        Parameters
+        ----------
+        text: str :
+            
+
+        Returns
+        -------
+
+        """
         return len(text)
 
     def justify(self, texts: Any, max_len: int, mode: str = "right") -> List[str]:
+        """
+
+        Parameters
+        ----------
+        texts: Any :
+            
+        max_len: int :
+            
+        mode: str :
+             (Default value = "right")
+
+        Returns
+        -------
+
+        """
         return justify(texts, max_len, mode=mode)
 
     def adjoin(self, space: int, *lists, **kwargs) -> str:
+        """
+
+        Parameters
+        ----------
+        space: int :
+            
+        *lists :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return adjoin(space, *lists, strlen=self.len, justfunc=self.justify, **kwargs)
 
 
 class EastAsianTextAdjustment(TextAdjustment):
+    """ """
     def __init__(self):
         super().__init__()
         if get_option("display.unicode.ambiguous_as_wide"):
@@ -414,8 +467,16 @@
         self._EAW_MAP = {"Na": 1, "N": 1, "W": 2, "F": 2, "H": 1}
 
     def len(self, text: str) -> int:
-        """
-        Calculate display width considering unicode East Asian Width
+        """Calculate display width considering unicode East Asian Width
+
+        Parameters
+        ----------
+        text: str :
+            
+
+        Returns
+        -------
+
         """
         if not isinstance(text, str):
             return len(text)
@@ -427,8 +488,34 @@
     def justify(
         self, texts: Iterable[str], max_len: int, mode: str = "right"
     ) -> List[str]:
+        """
+
+        Parameters
+        ----------
+        texts: Iterable[str] :
+            
+        max_len: int :
+            
+        mode: str :
+             (Default value = "right")
+
+        Returns
+        -------
+
+        """
         # re-calculate padding space per str considering East Asian Width
         def _get_pad(t):
+            """
+
+            Parameters
+            ----------
+            t :
+                
+
+            Returns
+            -------
+
+            """
             return max_len - self.len(t) + len(t)
 
         if mode == "left":
@@ -440,6 +527,7 @@
 
 
 def _get_adjustment() -> TextAdjustment:
+    """ """
     use_east_asian_width = get_option("display.unicode.east_asian_width")
     if use_east_asian_width:
         return EastAsianTextAdjustment()
@@ -448,6 +536,7 @@
 
 
 class TableFormatter:
+    """ """
 
     show_dimensions: Union[bool, str]
     is_truncated: bool
@@ -456,11 +545,25 @@
 
     @property
     def should_show_dimensions(self) -> bool:
+        """ """
         return self.show_dimensions is True or (
             self.show_dimensions == "truncate" and self.is_truncated
         )
 
     def _get_formatter(self, i: Union[str, int]) -> Optional[Callable]:
+        """
+
+        Parameters
+        ----------
+        i: Union[str :
+            
+        int] :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(self.formatters, (list, tuple)):
             if is_integer(i):
                 i = cast(int, i)
@@ -476,9 +579,19 @@
     def get_buffer(
         self, buf: Optional[FilePathOrBuffer[str]], encoding: Optional[str] = None
     ):
-        """
-        Context manager to open, yield and close buffer for filenames or Path-like
+        """Context manager to open, yield and close buffer for filenames or Path-like
         objects, otherwise yield buf unchanged.
+
+        Parameters
+        ----------
+        buf: Optional[FilePathOrBuffer[str]] :
+            
+        encoding: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if buf is not None:
             buf = stringify_path(buf)
@@ -503,8 +616,16 @@
             raise TypeError("buf is not a file name and it has no write method")
 
     def write_result(self, buf: IO[str]) -> None:
-        """
-        Write the result of serialization to buf.
+        """Write the result of serialization to buf.
+
+        Parameters
+        ----------
+        buf: IO[str] :
+            
+
+        Returns
+        -------
+
         """
         raise AbstractMethodError(self)
 
@@ -513,8 +634,18 @@
         buf: Optional[FilePathOrBuffer[str]] = None,
         encoding: Optional[str] = None,
     ) -> Optional[str]:
-        """
-        Perform serialization. Write to buf or return as string if buf is None.
+        """Perform serialization. Write to buf or return as string if buf is None.
+
+        Parameters
+        ----------
+        buf: Optional[FilePathOrBuffer[str]] :
+             (Default value = None)
+        encoding: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         with self.get_buffer(buf, encoding=encoding) as f:
             self.write_result(buf=f)
@@ -524,12 +655,17 @@
 
 
 class DataFrameFormatter(TableFormatter):
-    """
-    Render a DataFrame
-
+    """Render a DataFrame
+    
     self.to_string() : console-friendly tabular output
     self.to_html()   : html table
     self.to_latex()   : LaTeX tabular environment table
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -631,9 +767,15 @@
         self.adj = _get_adjustment()
 
     def _chk_truncate(self) -> None:
-        """
-        Checks whether the frame should be truncated. If so, slices
+        """Checks whether the frame should be truncated. If so, slices
         the frame up.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         from pandas.core.reshape.concat import concat
 
@@ -724,9 +866,7 @@
         self.is_truncated = bool(self.truncate_h or self.truncate_v)
 
     def _to_str_columns(self) -> List[List[str]]:
-        """
-        Render a DataFrame to a list of columns (as lists of strings).
-        """
+        """Render a DataFrame to a list of columns (as lists of strings)."""
         # this method is not used by to_html where self.col_space
         # could be a string so safe to cast
         col_space = {k: cast(int, v) for k, v in self.col_space.items()}
@@ -815,8 +955,16 @@
         return strcols
 
     def write_result(self, buf: IO[str]) -> None:
-        """
-        Render a DataFrame to a console-friendly tabular output.
+        """Render a DataFrame to a console-friendly tabular output.
+
+        Parameters
+        ----------
+        buf: IO[str] :
+            
+
+        Returns
+        -------
+
         """
         from pandas import Series
 
@@ -875,6 +1023,17 @@
             buf.write(f"\n\n[{len(frame)} rows x {len(frame.columns)} columns]")
 
     def _join_multiline(self, *args) -> str:
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+
+        Returns
+        -------
+
+        """
         lwidth = self.line_width
         adjoin_width = 1
         strcols = list(args)
@@ -918,6 +1077,19 @@
         buf: Optional[FilePathOrBuffer[str]] = None,
         encoding: Optional[str] = None,
     ) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        buf: Optional[FilePathOrBuffer[str]] :
+             (Default value = None)
+        encoding: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self.get_result(buf=buf, encoding=encoding)
 
     def to_latex(
@@ -932,8 +1104,32 @@
         caption: Optional[str] = None,
         label: Optional[str] = None,
     ) -> Optional[str]:
-        """
-        Render a DataFrame to a LaTeX tabular/longtable environment output.
+        """Render a DataFrame to a LaTeX tabular/longtable environment output.
+
+        Parameters
+        ----------
+        buf: Optional[FilePathOrBuffer[str]] :
+             (Default value = None)
+        column_format: Optional[str] :
+             (Default value = None)
+        longtable: bool :
+             (Default value = False)
+        encoding: Optional[str] :
+             (Default value = None)
+        multicolumn: bool :
+             (Default value = False)
+        multicolumn_format: Optional[str] :
+             (Default value = None)
+        multirow: bool :
+             (Default value = False)
+        caption: Optional[str] :
+             (Default value = None)
+        label: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         from pandas.io.formats.latex import LatexFormatter
 
@@ -949,6 +1145,17 @@
         ).get_result(buf=buf, encoding=encoding)
 
     def _format_col(self, i: int) -> List[str]:
+        """
+
+        Parameters
+        ----------
+        i: int :
+            
+
+        Returns
+        -------
+
+        """
         frame = self.tr_frame
         formatter = self._get_formatter(i)
         return format_array(
@@ -968,19 +1175,29 @@
         notebook: bool = False,
         border: Optional[int] = None,
     ) -> Optional[str]:
-        """
-        Render a DataFrame to a html table.
+        """Render a DataFrame to a html table.
 
         Parameters
         ----------
-        classes : str or list-like
-            classes to include in the `class` attribute of the opening
-            ``<table>`` tag, in addition to the default "dataframe".
-        notebook : {True, False}, optional, default False
-            Whether the generated HTML is for IPython Notebook.
-        border : int
-            A ``border=border`` attribute is included in the opening
-            ``<table>`` tag. Default ``pd.options.display.html.border``.
+        buf: Optional[FilePathOrBuffer[str]] :
+             (Default value = None)
+        encoding: Optional[str] :
+             (Default value = None)
+        classes: Optional[Union[str :
+            
+        List :
+            
+        Tuple]] :
+             (Default value = None)
+        notebook: bool :
+             (Default value = False)
+        border: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         from pandas.io.formats.html import HTMLFormatter, NotebookFormatter
 
@@ -990,6 +1207,17 @@
         )
 
     def _get_formatted_column_labels(self, frame: "DataFrame") -> List[List[str]]:
+        """
+
+        Parameters
+        ----------
+        frame: "DataFrame" :
+            
+
+        Returns
+        -------
+
+        """
         from pandas.core.indexes.multi import _sparsify
 
         columns = frame.columns
@@ -1004,6 +1232,19 @@
             need_leadsp = dict(zip(fmt_columns, map(is_numeric_dtype, dtypes)))
 
             def space_format(x, y):
+                """
+
+                Parameters
+                ----------
+                x :
+                    
+                y :
+                    
+
+                Returns
+                -------
+
+                """
                 if (
                     y not in self.formatters
                     and need_leadsp[x]
@@ -1032,21 +1273,36 @@
 
     @property
     def has_index_names(self) -> bool:
+        """ """
         return _has_names(self.frame.index)
 
     @property
     def has_column_names(self) -> bool:
+        """ """
         return _has_names(self.frame.columns)
 
     @property
     def show_row_idx_names(self) -> bool:
+        """ """
         return all((self.has_index_names, self.index, self.show_index_names))
 
     @property
     def show_col_idx_names(self) -> bool:
+        """ """
         return all((self.has_column_names, self.show_index_names, self.header))
 
     def _get_formatted_index(self, frame: "DataFrame") -> List[str]:
+        """
+
+        Parameters
+        ----------
+        frame: "DataFrame" :
+            
+
+        Returns
+        -------
+
+        """
         # Note: this is only used by to_string() and to_latex(), not by
         # to_html(). so safe to cast col_space here.
         col_space = {k: cast(int, v) for k, v in self.col_space.items()}
@@ -1087,6 +1343,7 @@
             return adjoined
 
     def _get_column_name_list(self) -> List[str]:
+        """ """
         names: List[str] = []
         columns = self.frame.columns
         if isinstance(columns, MultiIndex):
@@ -1112,31 +1369,60 @@
     leading_space: Optional[bool] = None,
     quoting: Optional[int] = None,
 ) -> List[str]:
-    """
-    Format an array for printing.
+    """Format an array for printing.
 
     Parameters
     ----------
-    values
-    formatter
-    float_format
-    na_rep
-    digits
-    space
-    justify
-    decimal
+    values :
+        
+    formatter :
+        
+    float_format :
+        
+    na_rep :
+        
+    digits :
+        
+    space :
+        
+    justify :
+        
+    decimal :
+        
     leading_space : bool, optional
         Whether the array should be formatted with a leading space.
         When an array as a column of a Series or DataFrame, we do want
         the leading space to pad between columns.
-
         When formatting an Index subclass
         (e.g. IntervalIndex._format_native_types), we don't want the
         leading space since it should be left-aligned.
+    values: Any :
+        
+    formatter: Optional[Callable] :
+        
+    float_format: Optional[FloatFormatType] :
+         (Default value = None)
+    na_rep: str :
+         (Default value = "NaN")
+    digits: Optional[int] :
+         (Default value = None)
+    space: Optional[Union[str :
+        
+    int]] :
+         (Default value = None)
+    justify: str :
+         (Default value = "right")
+    decimal: str :
+         (Default value = ".")
+    leading_space: Optional[bool] :
+         (Default value = None)
+    quoting: Optional[int] :
+         (Default value = None)
 
     Returns
     -------
-    List[str]
+
+    
     """
     fmt_klass: Type[GenericArrayFormatter]
     if is_datetime64_dtype(values.dtype):
@@ -1180,6 +1466,7 @@
 
 
 class GenericArrayFormatter:
+    """ """
     def __init__(
         self,
         values: Any,
@@ -1207,10 +1494,12 @@
         self.leading_space = leading_space
 
     def get_result(self) -> List[str]:
+        """ """
         fmt_values = self._format_strings()
         return _make_fixed_width(fmt_values, self.justify)
 
     def _format_strings(self) -> List[str]:
+        """ """
         if self.float_format is None:
             float_format = get_option("display.float_format")
             if float_format is None:
@@ -1230,6 +1519,17 @@
             )
 
         def _format(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             if self.na_rep is not None and is_scalar(x) and isna(x):
                 try:
                     # try block for np.isnat specifically
@@ -1280,9 +1580,7 @@
 
 
 class FloatArrayFormatter(GenericArrayFormatter):
-    """
-
-    """
+    """ """
 
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
@@ -1301,7 +1599,21 @@
         float_format: Optional[FloatFormatType] = None,
         threshold: Optional[Union[float, int]] = None,
     ) -> Callable:
-        """Returns a function to be applied on each value to format it"""
+        """Returns a function to be applied on each value to format it
+
+        Parameters
+        ----------
+        float_format: Optional[FloatFormatType] :
+             (Default value = None)
+        threshold: Optional[Union[float :
+            
+        int]] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # the float_format parameter supersedes self.float_format
         if float_format is None:
             float_format = self.float_format
@@ -1315,16 +1627,49 @@
         if float_format:
 
             def base_formatter(v):
+                """
+
+                Parameters
+                ----------
+                v :
+                    
+
+                Returns
+                -------
+
+                """
                 return float_format(value=v) if notna(v) else self.na_rep
 
         else:
 
             def base_formatter(v):
+                """
+
+                Parameters
+                ----------
+                v :
+                    
+
+                Returns
+                -------
+
+                """
                 return str(v) if notna(v) else self.na_rep
 
         if self.decimal != ".":
 
             def decimal_formatter(v):
+                """
+
+                Parameters
+                ----------
+                v :
+                    
+
+                Returns
+                -------
+
+                """
                 return base_formatter(v).replace(".", self.decimal, 1)
 
         else:
@@ -1334,6 +1679,17 @@
             return decimal_formatter
 
         def formatter(value):
+            """
+
+            Parameters
+            ----------
+            value :
+                
+
+            Returns
+            -------
+
+            """
             if notna(value):
                 if abs(value) > threshold:
                     return decimal_formatter(value)
@@ -1345,9 +1701,15 @@
         return formatter
 
     def get_result_as_array(self) -> np.ndarray:
-        """
-        Returns the float values converted into strings using
+        """Returns the float values converted into strings using
         the parameters given at initialisation, as a numpy array
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self.formatter is not None:
             return np.array([self.formatter(x) for x in self.values])
@@ -1359,6 +1721,17 @@
 
         # if we have a fixed_width, we'll need to try different float_format
         def format_values_with(float_format):
+            """
+
+            Parameters
+            ----------
+            float_format :
+                
+
+            Returns
+            -------
+
+            """
             formatter = self._value_formatter(float_format, threshold)
 
             # default formatter leaves a space to the left when formatting
@@ -1433,6 +1806,7 @@
         return formatted_values
 
     def _format_strings(self) -> List[str]:
+        """ """
         # shortcut
         if self.formatter is not None:
             return [self.formatter(x) for x in self.values]
@@ -1441,13 +1815,16 @@
 
 
 class IntArrayFormatter(GenericArrayFormatter):
+    """ """
     def _format_strings(self) -> List[str]:
+        """ """
         formatter = self.formatter or (lambda x: f"{x: d}")
         fmt_values = [formatter(x) for x in self.values]
         return fmt_values
 
 
 class Datetime64Formatter(GenericArrayFormatter):
+    """ """
     def __init__(
         self,
         values: Union[np.ndarray, "Series", DatetimeIndex, DatetimeArray],
@@ -1460,7 +1837,7 @@
         self.date_format = date_format
 
     def _format_strings(self) -> List[str]:
-        """ we by definition have DO NOT have a TZ """
+        """we by definition have DO NOT have a TZ"""
         values = self.values
 
         if not isinstance(values, DatetimeIndex):
@@ -1478,7 +1855,9 @@
 
 
 class ExtensionArrayFormatter(GenericArrayFormatter):
+    """ """
     def _format_strings(self) -> List[str]:
+        """ """
         values = extract_array(self.values, extract_numpy=True)
 
         formatter = values._formatter(boxed=True)
@@ -1507,16 +1886,29 @@
         np.ndarray, List[Union[int, float]], List[float], List[Union[str, float]]
     ]
 ) -> List[str]:
-    """
-    Outputs rounded and formatted percentiles.
+    """Outputs rounded and formatted percentiles.
 
     Parameters
     ----------
     percentiles : list-like, containing floats from interval [0,1]
+        
+    percentiles: Union[np.ndarray :
+        
+    List[Union[int :
+        
+    float]] :
+        
+    List[float] :
+        
+    List[Union[str :
+        
+    float]]] :
+        
 
     Returns
     -------
     formatted : list of strings
+        
 
     Notes
     -----
@@ -1524,17 +1916,16 @@
     ``percentiles`` differ, they remain different after rounding
     (2) no entry is *rounded* to 0% or 100%.
     Any non-integer is always rounded to at least 1 decimal place.
-
     Examples
     --------
     Keeps all entries different after rounding:
-
+    
+    
+    No element is rounded to 0% or 100% (unless already equal to it).
+    Duplicates are allowed:
     >>> format_percentiles([0.01999, 0.02001, 0.5, 0.666666, 0.9999])
     ['1.999%', '2.001%', '50%', '66.667%', '99.99%']
-
-    No element is rounded to 0% or 100% (unless already equal to it).
-    Duplicates are allowed:
-
+    
     >>> format_percentiles([0, 0.5, 0.02001, 0.5, 0.666666, 0.9999])
     ['0%', '50%', '2.0%', '50%', '66.67%', '99.99%']
     """
@@ -1574,6 +1965,23 @@
 def _is_dates_only(
     values: Union[np.ndarray, DatetimeArray, Index, DatetimeIndex]
 ) -> bool:
+    """
+
+    Parameters
+    ----------
+    values: Union[np.ndarray :
+        
+    DatetimeArray :
+        
+    Index :
+        
+    DatetimeIndex] :
+        
+
+    Returns
+    -------
+
+    """
     # return a boolean if we are only dates (and don't have a timezone)
     values = values.ravel()
 
@@ -1595,6 +2003,23 @@
 def _format_datetime64(
     x: Union[NaTType, Timestamp], tz: Optional[tzinfo] = None, nat_rep: str = "NaT"
 ) -> str:
+    """
+
+    Parameters
+    ----------
+    x: Union[NaTType :
+        
+    Timestamp] :
+        
+    tz: Optional[tzinfo] :
+         (Default value = None)
+    nat_rep: str :
+         (Default value = "NaT")
+
+    Returns
+    -------
+
+    """
     if x is None or (is_scalar(x) and isna(x)):
         return nat_rep
 
@@ -1610,6 +2035,23 @@
 def _format_datetime64_dateonly(
     x: Union[NaTType, Timestamp], nat_rep: str = "NaT", date_format: None = None
 ) -> str:
+    """
+
+    Parameters
+    ----------
+    x: Union[NaTType :
+        
+    Timestamp] :
+        
+    nat_rep: str :
+         (Default value = "NaT")
+    date_format: None :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if x is None or (is_scalar(x) and isna(x)):
         return nat_rep
 
@@ -1625,6 +2067,21 @@
 def _get_format_datetime64(
     is_dates_only: bool, nat_rep: str = "NaT", date_format: None = None
 ) -> Callable:
+    """
+
+    Parameters
+    ----------
+    is_dates_only: bool :
+        
+    nat_rep: str :
+         (Default value = "NaT")
+    date_format: None :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
 
     if is_dates_only:
         return lambda x, tz=None: _format_datetime64_dateonly(
@@ -1637,7 +2094,23 @@
 def _get_format_datetime64_from_values(
     values: Union[np.ndarray, DatetimeArray, DatetimeIndex], date_format: Optional[str]
 ) -> Optional[str]:
-    """ given values and a date_format, return a string format """
+    """given values and a date_format, return a string format
+
+    Parameters
+    ----------
+    values: Union[np.ndarray :
+        
+    DatetimeArray :
+        
+    DatetimeIndex] :
+        
+    date_format: Optional[str] :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(values, np.ndarray) and values.ndim > 1:
         # We don't actually care about the order of values, and DatetimeIndex
         #  only accepts 1D values
@@ -1650,8 +2123,9 @@
 
 
 class Datetime64TZFormatter(Datetime64Formatter):
+    """ """
     def _format_strings(self) -> List[str]:
-        """ we by definition have a TZ """
+        """we by definition have a TZ"""
         values = self.values.astype(object)
         is_dates_only = _is_dates_only(values)
         formatter = self.formatter or _get_format_datetime64(
@@ -1663,6 +2137,7 @@
 
 
 class Timedelta64Formatter(GenericArrayFormatter):
+    """ """
     def __init__(
         self,
         values: Union[np.ndarray, TimedeltaIndex],
@@ -1675,6 +2150,7 @@
         self.box = box
 
     def _format_strings(self) -> List[str]:
+        """ """
         formatter = self.formatter or _get_format_timedelta64(
             self.values, nat_rep=self.nat_rep, box=self.box
         )
@@ -1687,10 +2163,27 @@
     box: bool = False,
 ) -> Callable:
     """
-    Return a formatter function for a range of timedeltas.
-    These will all have the same format argument
-
-    If box, then show the return in quotes
+
+    Parameters
+    ----------
+    values: Union[np.ndarray :
+        
+    TimedeltaIndex :
+        
+    TimedeltaArray] :
+        
+    nat_rep: str :
+         (Default value = "NaT")
+    box: bool :
+         (Default value = False)
+
+    Returns
+    -------
+    type
+        These will all have the same format argument
+        
+        If box, then show the return in quotes
+
     """
     values_int = values.astype(np.int64)
 
@@ -1707,6 +2200,17 @@
         format = "long"
 
     def _formatter(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if x is None or (is_scalar(x) and isna(x)):
             return nat_rep
 
@@ -1726,6 +2230,23 @@
     minimum: Optional[int] = None,
     adj: Optional[TextAdjustment] = None,
 ) -> List[str]:
+    """
+
+    Parameters
+    ----------
+    strings: List[str] :
+        
+    justify: str :
+         (Default value = "right")
+    minimum: Optional[int] :
+         (Default value = None)
+    adj: Optional[TextAdjustment] :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
 
     if len(strings) == 0 or justify == "all":
         return strings
@@ -1743,6 +2264,17 @@
         max_len = conf_max
 
     def just(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if conf_max is not None:
             if (conf_max > 3) & (adj.len(x) > max_len):
                 x = x[: max_len - 3] + "..."
@@ -1756,9 +2288,21 @@
 def _trim_zeros_complex(
     str_complexes: np.ndarray, decimal: str = ".", na_rep: str = "NaN"
 ) -> List[str]:
-    """
-    Separates the real and imaginary parts from the complex number, and
+    """Separates the real and imaginary parts from the complex number, and
     executes the _trim_zeros_float method on each of those.
+
+    Parameters
+    ----------
+    str_complexes: np.ndarray :
+        
+    decimal: str :
+         (Default value = ".")
+    na_rep: str :
+         (Default value = "NaN")
+
+    Returns
+    -------
+
     """
     return [
         "".join(_trim_zeros_float(re.split(r"([j+-])", x), decimal, na_rep))
@@ -1769,15 +2313,51 @@
 def _trim_zeros_float(
     str_floats: Union[np.ndarray, List[str]], decimal: str = ".", na_rep: str = "NaN"
 ) -> List[str]:
-    """
-    Trims zeros, leaving just one before the decimal points if need be.
+    """Trims zeros, leaving just one before the decimal points if need be.
+
+    Parameters
+    ----------
+    str_floats: Union[np.ndarray :
+        
+    List[str]] :
+        
+    decimal: str :
+         (Default value = ".")
+    na_rep: str :
+         (Default value = "NaN")
+
+    Returns
+    -------
+
     """
     trimmed = str_floats
 
     def _is_number(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         return x != na_rep and not x.endswith("inf")
 
     def _cond(values):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+
+        Returns
+        -------
+
+        """
         finite = [x for x in values if _is_number(x)]
         has_decimal = [decimal in x for x in finite]
 
@@ -1796,6 +2376,17 @@
 
 
 def _has_names(index: Index) -> bool:
+    """
+
+    Parameters
+    ----------
+    index: Index :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(index, MultiIndex):
         return com.any_not_none(*index.names)
     else:
@@ -1803,10 +2394,16 @@
 
 
 class EngFormatter:
-    """
-    Formats float values according to engineering format.
-
+    """Formats float values according to engineering format.
+    
     Based on matplotlib.ticker.EngFormatter
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # The SI engineering prefixes
@@ -1900,18 +2497,41 @@
 
 
 def set_eng_float_format(accuracy: int = 3, use_eng_prefix: bool = False) -> None:
-    """
-    Alter default behavior on how float is formatted in DataFrame.
+    """Alter default behavior on how float is formatted in DataFrame.
     Format float in engineering format. By accuracy, we mean the number of
     decimal digits after the floating point.
-
+    
     See also EngFormatter.
+
+    Parameters
+    ----------
+    accuracy: int :
+         (Default value = 3)
+    use_eng_prefix: bool :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     set_option("display.float_format", EngFormatter(accuracy, use_eng_prefix))
     set_option("display.column_space", max(12, accuracy + 9))
 
 
 def _binify(cols: List[int], line_width: int) -> List[int]:
+    """
+
+    Parameters
+    ----------
+    cols: List[int] :
+        
+    line_width: int :
+        
+
+    Returns
+    -------
+
+    """
     adjoin_width = 1
     bins = []
     curr_width = 0
@@ -1934,8 +2554,7 @@
 def get_level_lengths(
     levels: Any, sentinel: Union[bool, object, str] = ""
 ) -> List[Dict[int, int]]:
-    """
-    For each index in each level the function returns lengths of indexes.
+    """For each index in each level the function returns lengths of indexes.
 
     Parameters
     ----------
@@ -1943,11 +2562,19 @@
         List of values on for level.
     sentinel : string, optional
         Value which states that no new index starts on there.
+    levels: Any :
+        
+    sentinel: Union[bool :
+        
+    object :
+        
+    str] :
+         (Default value = "")
 
     Returns
     -------
-    Returns list of maps. For each level returns map of indexes (key is index
-    in row and value is length of index).
+
+    
     """
     if len(levels) == 0:
         return []
@@ -1975,15 +2602,19 @@
 
 
 def buffer_put_lines(buf: IO[str], lines: List[str]) -> None:
-    """
-    Appends lines to a buffer.
+    """Appends lines to a buffer.
 
     Parameters
     ----------
-    buf
-        The buffer to write to
-    lines
-        The lines to append.
+    buf: IO[str] :
+        
+    lines: List[str] :
+        
+
+    Returns
+    -------
+
+    
     """
     if any(isinstance(x, str) for x in lines):
         lines = [str(x) for x in lines]
