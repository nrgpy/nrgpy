# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/numerictypes.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/numerictypes.py
@@ -135,8 +135,7 @@
 
 @set_module('numpy')
 def maximum_sctype(t):
-    """
-    Return the scalar type of highest precision of the same kind as the input.
+    """Return the scalar type of highest precision of the same kind as the input.
 
     Parameters
     ----------
@@ -153,7 +152,6 @@
     --------
     obj2sctype, mintypecode, sctype2char
     dtype
-
     Examples
     --------
     >>> np.maximum_sctype(int)
@@ -162,15 +160,14 @@
     <class 'numpy.uint64'>
     >>> np.maximum_sctype(complex)
     <class 'numpy.complex256'> # may vary
-
+    
     >>> np.maximum_sctype(str)
     <class 'numpy.str_'>
-
+    
     >>> np.maximum_sctype('i2')
     <class 'numpy.int64'>
     >>> np.maximum_sctype('f4')
     <class 'numpy.float128'> # may vary
-
     """
     g = obj2sctype(t)
     if g is None:
@@ -185,8 +182,7 @@
 
 @set_module('numpy')
 def issctype(rep):
-    """
-    Determines whether the given object represents a scalar data-type.
+    """Determines whether the given object represents a scalar data-type.
 
     Parameters
     ----------
@@ -202,21 +198,19 @@
     See Also
     --------
     issubsctype, issubdtype, obj2sctype, sctype2char
-
-    Examples
-    --------
+    Examples
+    --------
+    
+    Strings are also a scalar type:
     >>> np.issctype(np.int32)
     True
     >>> np.issctype(list)
     False
     >>> np.issctype(1.1)
     False
-
-    Strings are also a scalar type:
-
+    
     >>> np.issctype(np.dtype('str'))
     True
-
     """
     if not isinstance(rep, (type, dtype)):
         return False
@@ -231,8 +225,7 @@
 
 @set_module('numpy')
 def obj2sctype(rep, default=None):
-    """
-    Return the scalar dtype or NumPy equivalent of Python type of an object.
+    """Return the scalar dtype or NumPy equivalent of Python type of an object.
 
     Parameters
     ----------
@@ -240,7 +233,7 @@
         The object of which the type is returned.
     default : any, optional
         If given, this is returned for objects whose types can not be
-        determined. If not given, None is returned for those objects.
+        determined. If not given, None is returned for those objects. (Default value = None)
 
     Returns
     -------
@@ -250,7 +243,6 @@
     See Also
     --------
     sctype2char, issctype, issubsctype, issubdtype, maximum_sctype
-
     Examples
     --------
     >>> np.obj2sctype(np.int32)
@@ -259,14 +251,13 @@
     <class 'numpy.float64'>
     >>> np.obj2sctype(np.array([1.j]))
     <class 'numpy.complex128'>
-
+    
     >>> np.obj2sctype(dict)
     <class 'numpy.object_'>
     >>> np.obj2sctype('string')
-
+    
     >>> np.obj2sctype(1, default=list)
     <class 'list'>
-
     """
     # prevent abstract classes being upcast
     if isinstance(rep, type) and issubclass(rep, generic):
@@ -285,9 +276,8 @@
 
 @set_module('numpy')
 def issubclass_(arg1, arg2):
-    """
-    Determine if a class is a subclass of a second class.
-
+    """Determine if a class is a subclass of a second class.
+    
     `issubclass_` is equivalent to the Python built-in ``issubclass``,
     except that it returns False instead of raising a TypeError if one
     of the arguments is not a class.
@@ -308,7 +298,6 @@
     See Also
     --------
     issubsctype, issubdtype, issctype
-
     Examples
     --------
     >>> np.issubclass_(np.int32, int)
@@ -317,7 +306,6 @@
     False
     >>> np.issubclass_(np.float64, float)
     True
-
     """
     try:
         return issubclass(arg1, arg2)
@@ -327,13 +315,16 @@
 
 @set_module('numpy')
 def issubsctype(arg1, arg2):
-    """
-    Determine if the first argument is a subclass of the second argument.
+    """Determine if the first argument is a subclass of the second argument.
 
     Parameters
     ----------
     arg1, arg2 : dtype or dtype specifier
         Data-types.
+    arg1 :
+        
+    arg2 :
+        
 
     Returns
     -------
@@ -343,7 +334,6 @@
     See Also
     --------
     issctype, issubdtype, obj2sctype
-
     Examples
     --------
     >>> np.issubsctype('S8', str)
@@ -352,37 +342,38 @@
     True
     >>> np.issubsctype(np.array([1]), float)
     False
-
     """
     return issubclass(obj2sctype(arg1), obj2sctype(arg2))
 
 
 @set_module('numpy')
 def issubdtype(arg1, arg2):
-    """
-    Returns True if first argument is a typecode lower/equal in type hierarchy.
+    """Returns True if first argument is a typecode lower/equal in type hierarchy.
 
     Parameters
     ----------
     arg1, arg2 : dtype_like
         dtype or string representing a typecode.
+    arg1 :
+        
+    arg2 :
+        
 
     Returns
     -------
     out : bool
+        
 
     See Also
     --------
     issubsctype, issubclass_
     numpy.core.numerictypes : Overview of numpy type hierarchy.
-
     Examples
     --------
     >>> np.issubdtype('S1', np.string_)
     True
     >>> np.issubdtype(np.float64, np.float32)
     False
-
     """
     if not issubclass_(arg1, generic):
         arg1 = dtype(arg1).type
@@ -394,11 +385,16 @@
 
 # This dictionary allows look up based on any alias for an array data-type
 class _typedict(dict):
-    """
-    Base object for a dictionary for look-up with any alias for an array dtype.
-
+    """Base object for a dictionary for look-up with any alias for an array dtype.
+    
     Instances of `_typedict` can not be used as dictionaries directly,
     first they have to be populated.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -410,6 +406,7 @@
 _maxvals = _typedict()
 _minvals = _typedict()
 def _construct_lookups():
+    """ """
     for name, info in _concrete_typeinfo.items():
         obj = info.type
         nbytes[obj] = info.bits // 8
@@ -426,8 +423,7 @@
 
 @set_module('numpy')
 def sctype2char(sctype):
-    """
-    Return the string representation of a scalar dtype.
+    """Return the string representation of a scalar dtype.
 
     Parameters
     ----------
@@ -449,7 +445,6 @@
     See Also
     --------
     obj2sctype, issctype, issubsctype, mintypecode
-
     Examples
     --------
     >>> for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:
@@ -459,13 +454,12 @@
     D
     S
     O
-
+    
     >>> x = np.array([1., 2-1.j])
     >>> np.sctype2char(x)
     'D'
     >>> np.sctype2char(list)
     'O'
-
     """
     sctype = obj2sctype(sctype)
     if sctype is None:
@@ -533,6 +527,19 @@
 # Keep incrementing until a common type both can be coerced to
 #  is found.  Otherwise, return None
 def _find_common_coerce(a, b):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     if a > b:
         return a
     try:
@@ -543,6 +550,19 @@
 
 # Find a data-type that all data-types in a list can be coerced to
 def _can_coerce_all(dtypelist, start=0):
+    """
+
+    Parameters
+    ----------
+    dtypelist :
+        
+    start :
+         (Default value = 0)
+
+    Returns
+    -------
+
+    """
     N = len(dtypelist)
     if N == 0:
         return None
@@ -558,6 +578,7 @@
     return None
 
 def _register_types():
+    """ """
     numbers.Integral.register(integer)
     numbers.Complex.register(inexact)
     numbers.Real.register(floating)
@@ -568,8 +589,7 @@
 
 @set_module('numpy')
 def find_common_type(array_types, scalar_types):
-    """
-    Determine common type following standard coercion rules.
+    """Determine common type following standard coercion rules.
 
     Parameters
     ----------
@@ -589,34 +609,34 @@
     See Also
     --------
     dtype, common_type, can_cast, mintypecode
-
-    Examples
-    --------
+    Examples
+    --------
+    
+    The standard casting rules ensure that a scalar cannot up-cast an
+    array unless the scalar is of a fundamentally different kind of data
+    (i.e. under a different hierarchy in the data type hierarchy) then
+    the array:
+    
+    
+    Complex is of a different type, so it up-casts the float in the
+    `array_types` argument:
+    
+    
+    Type specifier strings are convertible to dtypes and can therefore
+    be used instead of dtypes:
     >>> np.find_common_type([], [np.int64, np.float32, complex])
     dtype('complex128')
     >>> np.find_common_type([np.int64, np.float32], [])
     dtype('float64')
-
-    The standard casting rules ensure that a scalar cannot up-cast an
-    array unless the scalar is of a fundamentally different kind of data
-    (i.e. under a different hierarchy in the data type hierarchy) then
-    the array:
-
+    
     >>> np.find_common_type([np.float32], [np.int64, np.float64])
     dtype('float32')
-
-    Complex is of a different type, so it up-casts the float in the
-    `array_types` argument:
-
+    
     >>> np.find_common_type([np.float32], [complex])
     dtype('complex128')
-
-    Type specifier strings are convertible to dtypes and can therefore
-    be used instead of dtypes:
-
+    
     >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
     dtype('complex128')
-
     """
     array_types = [dtype(x) for x in array_types]
     scalar_types = [dtype(x) for x in scalar_types]
