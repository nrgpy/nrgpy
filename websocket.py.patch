# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/websocket.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/websocket.py
@@ -60,34 +60,120 @@
     # The zlib compressor types aren't actually exposed anywhere
     # publicly, so declare protocols for the portions we use.
     class _Compressor(Protocol):
+        """ """
         def compress(self, data: bytes) -> bytes:
+            """
+
+            Parameters
+            ----------
+            data: bytes :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def flush(self, mode: int) -> bytes:
+            """
+
+            Parameters
+            ----------
+            mode: int :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
     class _Decompressor(Protocol):
+        """ """
         unconsumed_tail = b""  # type: bytes
 
         def decompress(self, data: bytes, max_length: int) -> bytes:
+            """
+
+            Parameters
+            ----------
+            data: bytes :
+                
+            max_length: int :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
     class _WebSocketDelegate(Protocol):
+        """ """
         # The common base interface implemented by WebSocketHandler on
         # the server side and WebSocketClientConnection on the client
         # side.
         def on_ws_connection_close(
             self, close_code: Optional[int] = None, close_reason: Optional[str] = None
         ) -> None:
+            """
+
+            Parameters
+            ----------
+            close_code: Optional[int] :
+                 (Default value = None)
+            close_reason: Optional[str] :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             pass
 
         def on_message(self, message: Union[str, bytes]) -> Optional["Awaitable[None]"]:
+            """
+
+            Parameters
+            ----------
+            message: Union[str :
+                
+            bytes] :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def on_ping(self, data: bytes) -> None:
+            """
+
+            Parameters
+            ----------
+            data: bytes :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def on_pong(self, data: bytes) -> None:
+            """
+
+            Parameters
+            ----------
+            data: bytes :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def log_exception(
@@ -96,6 +182,21 @@
             value: Optional[BaseException],
             tb: Optional[TracebackType],
         ) -> None:
+            """
+
+            Parameters
+            ----------
+            typ: Optional[Type[BaseException]] :
+                
+            value: Optional[BaseException] :
+                
+            tb: Optional[TracebackType] :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
 
@@ -103,23 +204,36 @@
 
 
 class WebSocketError(Exception):
+    """ """
     pass
 
 
 class WebSocketClosedError(WebSocketError):
-    """Raised by operations on a closed connection.
-
-    .. versionadded:: 3.2
     """
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    .
+        versionadded
+
+    """
+
     pass
 
 
 class _DecompressTooLargeError(Exception):
+    """ """
     pass
 
 
 class _WebSocketParams(object):
+    """ """
     def __init__(
         self,
         ping_interval: Optional[float] = None,
@@ -135,38 +249,38 @@
 
 class WebSocketHandler(tornado.web.RequestHandler):
     """Subclass this class to create a basic WebSocket handler.
-
+    
     Override `on_message` to handle incoming messages, and use
     `write_message` to send messages to the client. You can also
     override `open` and `on_close` to handle opened and closed
     connections.
-
+    
     Custom upgrade response headers can be sent by overriding
     `~tornado.web.RequestHandler.set_default_headers` or
     `~tornado.web.RequestHandler.prepare`.
-
+    
     See http://dev.w3.org/html5/websockets/ for details on the
     JavaScript interface.  The protocol is specified at
     http://tools.ietf.org/html/rfc6455.
-
+    
     Here is an example WebSocket handler that echos back all received messages
     back to the client:
-
+    
     .. testcode::
-
+    
       class EchoWebSocket(tornado.websocket.WebSocketHandler):
           def open(self):
               print("WebSocket opened")
-
+    
           def on_message(self, message):
               self.write_message(u"You said: " + message)
-
+    
           def on_close(self):
               print("WebSocket closed")
-
+    
     .. testoutput::
        :hide:
-
+    
     WebSockets are not standard HTTP connections. The "handshake" is
     HTTP, but after the handshake, the protocol is
     message-based. Consequently, most of the Tornado HTTP facilities
@@ -174,10 +288,10 @@
     methods available to you are `write_message()`, `ping()`, and
     `close()`. Likewise, your request handler class should implement
     `open()` method rather than ``get()`` or ``post()``.
-
+    
     If you map the handler above to ``/websocket`` in your application, you can
     invoke it in JavaScript with::
-
+    
       var ws = new WebSocket("ws://localhost:8888/websocket");
       ws.onopen = function() {
          ws.send("Hello, world");
@@ -185,9 +299,9 @@
       ws.onmessage = function (evt) {
          alert(evt.data);
       };
-
+    
     This script pops up an alert box that says "You said: Hello, world".
-
+    
     Web browsers allow any site to open a websocket connection to any other,
     instead of using the same-origin policy that governs other network
     access from JavaScript.  This can be surprising and is a potential
@@ -196,23 +310,30 @@
     by overriding the `~WebSocketHandler.check_origin` method (see that
     method's docs for details).  Failure to do so is the most likely
     cause of 403 errors when making a websocket connection.
-
+    
     When using a secure websocket connection (``wss://``) with a self-signed
     certificate, the connection from a browser may fail because it wants
     to show the "accept this certificate" dialog but has nowhere to show it.
     You must first visit a regular HTML page using the same certificate
     to accept it before the websocket connection will succeed.
-
+    
     If the application setting ``websocket_ping_interval`` has a non-zero
     value, a ping will be sent periodically, and the connection will be
     closed if a response is not received before the ``websocket_ping_timeout``.
-
+    
     Messages larger than the ``websocket_max_message_size`` application setting
     (default 10MiB) will not be accepted.
-
+    
     .. versionchanged:: 4.5
        Added ``websocket_ping_interval``, ``websocket_ping_timeout``, and
        ``websocket_max_message_size``.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -283,8 +404,15 @@
     @property
     def ping_interval(self) -> Optional[float]:
         """The interval for websocket keep-alive pings.
-
+        
         Set websocket_ping_interval = 0 to disable pings.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.settings.get("websocket_ping_interval", None)
 
@@ -293,17 +421,31 @@
         """If no ping is received in this many seconds,
         close the websocket connection (VPNs, etc. can fail to cleanly close ws connections).
         Default is max of 3 pings or 30 seconds.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.settings.get("websocket_ping_timeout", None)
 
     @property
     def max_message_size(self) -> int:
         """Maximum allowed message size.
-
+        
         If the remote peer sends a message larger than this, the connection
         will be closed.
-
+        
         Default is 10MiB.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.settings.get(
             "websocket_max_message_size", _default_max_message_size
@@ -313,25 +455,42 @@
         self, message: Union[bytes, str, Dict[str, Any]], binary: bool = False
     ) -> "Future[None]":
         """Sends the given message to the client of this Web Socket.
-
+        
         The message may be either a string or a dict (which will be
         encoded as json).  If the ``binary`` argument is false, the
         message will be sent as utf8; in binary mode any byte string
         is allowed.
-
+        
         If the connection is already closed, raises `WebSocketClosedError`.
         Returns a `.Future` which can be used for flow control.
-
+        
         .. versionchanged:: 3.2
            `WebSocketClosedError` was added (previously a closed connection
            would raise an `AttributeError`)
-
+        
         .. versionchanged:: 4.3
            Returns a `.Future` which can be used for flow control.
-
+        
         .. versionchanged:: 5.0
            Consistently raises `WebSocketClosedError`. Previously could
            sometimes raise `.StreamClosedError`.
+
+        Parameters
+        ----------
+        message: Union[bytes :
+            
+        str :
+            
+        Dict[str :
+            
+        Any]] :
+            
+        binary: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         if self.ws_connection is None or self.ws_connection.is_closing():
             raise WebSocketClosedError()
@@ -341,103 +500,158 @@
 
     def select_subprotocol(self, subprotocols: List[str]) -> Optional[str]:
         """Override to implement subprotocol negotiation.
-
+        
         ``subprotocols`` is a list of strings identifying the
         subprotocols proposed by the client.  This method may be
         overridden to return one of those strings to select it, or
         ``None`` to not select a subprotocol.
-
+        
         Failure to select a subprotocol does not automatically abort
         the connection, although clients may close the connection if
         none of their proposed subprotocols was selected.
-
+        
         The list may be empty, in which case this method must return
         None. This method is always called exactly once even if no
         subprotocols were proposed so that the handler can be advised
         of this fact.
-
+        
         .. versionchanged:: 5.1
-
+        
            Previously, this method was called with a list containing
            an empty string instead of an empty list if no subprotocols
            were proposed by the client.
+
+        Parameters
+        ----------
+        subprotocols: List[str] :
+            
+
+        Returns
+        -------
+
         """
         return None
 
     @property
     def selected_subprotocol(self) -> Optional[str]:
         """The subprotocol returned by `select_subprotocol`.
-
+        
         .. versionadded:: 5.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         assert self.ws_connection is not None
         return self.ws_connection.selected_subprotocol
 
     def get_compression_options(self) -> Optional[Dict[str, Any]]:
         """Override to return compression options for the connection.
-
+        
         If this method returns None (the default), compression will
         be disabled.  If it returns a dict (even an empty one), it
         will be enabled.  The contents of the dict may be used to
         control the following compression options:
-
+        
         ``compression_level`` specifies the compression level.
-
+        
         ``mem_level`` specifies the amount of memory used for the internal compression state.
-
+        
          These parameters are documented in details here:
          https://docs.python.org/3.6/library/zlib.html#zlib.compressobj
-
+        
         .. versionadded:: 4.1
-
+        
         .. versionchanged:: 4.5
-
+        
            Added ``compression_level`` and ``mem_level``.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # TODO: Add wbits option.
         return None
 
     def open(self, *args: str, **kwargs: str) -> Optional[Awaitable[None]]:
         """Invoked when a new WebSocket is opened.
-
+        
         The arguments to `open` are extracted from the `tornado.web.URLSpec`
         regular expression, just like the arguments to
         `tornado.web.RequestHandler.get`.
-
+        
         `open` may be a coroutine. `on_message` will not be called until
         `open` has returned.
-
+        
         .. versionchanged:: 5.1
-
+        
            ``open`` may be a coroutine.
+
+        Parameters
+        ----------
+        *args: str :
+            
+        **kwargs: str :
+            
+
+        Returns
+        -------
+
         """
         pass
 
     def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:
         """Handle incoming messages on the WebSocket
-
+        
         This method must be overridden.
-
+        
         .. versionchanged:: 4.5
-
+        
            ``on_message`` can be a coroutine.
+
+        Parameters
+        ----------
+        message: Union[str :
+            
+        bytes] :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError
 
     def ping(self, data: Union[str, bytes] = b"") -> None:
         """Send ping frame to the remote end.
-
+        
         The data argument allows a small amount of data (up to 125
         bytes) to be sent as a part of the ping message. Note that not
         all websocket implementations expose this data to
         applications.
-
+        
         Consider using the ``websocket_ping_interval`` application
         setting instead of sending pings manually.
-
+        
         .. versionchanged:: 5.1
-
+        
            The data argument is now optional.
+
+        Parameters
+        ----------
+        data: Union[str :
+            
+        bytes] :
+             (Default value = b"")
+
+        Returns
+        -------
 
         """
         data = utf8(data)
@@ -446,41 +660,79 @@
         self.ws_connection.write_ping(data)
 
     def on_pong(self, data: bytes) -> None:
-        """Invoked when the response to a ping frame is received."""
+        """Invoked when the response to a ping frame is received.
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def on_ping(self, data: bytes) -> None:
-        """Invoked when the a ping frame is received."""
+        """Invoked when the a ping frame is received.
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def on_close(self) -> None:
         """Invoked when the WebSocket is closed.
-
+        
         If the connection was closed cleanly and a status code or reason
         phrase was supplied, these values will be available as the attributes
         ``self.close_code`` and ``self.close_reason``.
-
+        
         .. versionchanged:: 4.0
-
+        
            Added ``close_code`` and ``close_reason`` attributes.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
     def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:
         """Closes this Web Socket.
-
+        
         Once the close handshake is successful the socket will be closed.
-
+        
         ``code`` may be a numeric status code, taken from the values
         defined in `RFC 6455 section 7.4.1
         <https://tools.ietf.org/html/rfc6455#section-7.4.1>`_.
         ``reason`` may be a textual message about why the connection is
         closing.  These values are made available to the client, but are
         not otherwise interpreted by the websocket protocol.
-
+        
         .. versionchanged:: 4.0
-
+        
            Added the ``code`` and ``reason`` arguments.
+
+        Parameters
+        ----------
+        code: Optional[int] :
+             (Default value = None)
+        reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if self.ws_connection:
             self.ws_connection.close(code, reason)
@@ -488,24 +740,24 @@
 
     def check_origin(self, origin: str) -> bool:
         """Override to enable support for allowing alternate origins.
-
+        
         The ``origin`` argument is the value of the ``Origin`` HTTP
         header, the url responsible for initiating this request.  This
         method is not called for clients that do not send this header;
         such requests are always allowed (because all browsers that
         implement WebSockets support this header, and non-browser
         clients do not have the same cross-site security concerns).
-
+        
         Should return ``True`` to accept the request or ``False`` to
         reject it. By default, rejects all requests with an origin on
         a host other than this one.
-
+        
         This is a security protection against cross site scripting attacks on
         browsers, since WebSockets are allowed to bypass the usual same-origin
         policies and don't use CORS headers.
-
+        
         .. warning::
-
+        
            This is an important security measure; don't disable it
            without understanding the security implications. In
            particular, if your authentication is cookie-based, you
@@ -516,21 +768,28 @@
            `articles
            <https://devcenter.heroku.com/articles/websocket-security>`_
            for more.
-
+        
         To accept all cross-origin traffic (which was the default prior to
         Tornado 4.0), simply override this method to always return ``True``::
-
+        
             def check_origin(self, origin):
                 return True
-
+        
         To allow connections from any subdomain of your site, you might
         do something like::
-
+        
             def check_origin(self, origin):
                 parsed_origin = urllib.parse.urlparse(origin)
-                return parsed_origin.netloc.endswith(".mydomain.com")
-
-        .. versionadded:: 4.0
+
+        Parameters
+        ----------
+        origin: str :
+            
+
+        Returns
+        -------
+        type
+            .. versionadded:: 4.0
 
         """
         parsed_origin = urlparse(origin)
@@ -544,22 +803,32 @@
 
     def set_nodelay(self, value: bool) -> None:
         """Set the no-delay flag for this stream.
-
+        
         By default, small messages may be delayed and/or combined to minimize
         the number of packets sent.  This can sometimes cause 200-500ms delays
         due to the interaction between Nagle's algorithm and TCP delayed
         ACKs.  To reduce this delay (at the expense of possibly increasing
         bandwidth usage), call ``self.set_nodelay(True)`` once the websocket
         connection is established.
-
+        
         See `.BaseIOStream.set_nodelay` for additional details.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        value: bool :
+            
+
+        Returns
+        -------
+
         """
         assert self.ws_connection is not None
         self.ws_connection.set_nodelay(value)
 
     def on_connection_close(self) -> None:
+        """ """
         if self.ws_connection:
             self.ws_connection.on_connection_close()
             self.ws_connection = None
@@ -571,11 +840,25 @@
     def on_ws_connection_close(
         self, close_code: Optional[int] = None, close_reason: Optional[str] = None
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        close_code: Optional[int] :
+             (Default value = None)
+        close_reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self.close_code = close_code
         self.close_reason = close_reason
         self.on_connection_close()
 
     def _break_cycles(self) -> None:
+        """ """
         # WebSocketHandlers call finish() early, but we don't want to
         # break up reference cycles (which makes it impossible to call
         # self.render_string) until after we've really closed the
@@ -585,6 +868,19 @@
             super()._break_cycles()
 
     def send_error(self, *args: Any, **kwargs: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         if self.stream is None:
             super().send_error(*args, **kwargs)
         else:
@@ -595,6 +891,7 @@
             self.stream.close()
 
     def get_websocket_protocol(self) -> Optional["WebSocketProtocol"]:
+        """ """
         websocket_version = self.request.headers.get("Sec-WebSocket-Version")
         if websocket_version in ("7", "8", "13"):
             params = _WebSocketParams(
@@ -607,6 +904,7 @@
         return None
 
     def _detach_stream(self) -> IOStream:
+        """ """
         # disable non-WS methods
         for method in [
             "write",
@@ -622,12 +920,24 @@
 
 
 def _raise_not_supported_for_websockets(*args: Any, **kwargs: Any) -> None:
+    """
+
+    Parameters
+    ----------
+    *args: Any :
+        
+    **kwargs: Any :
+        
+
+    Returns
+    -------
+
+    """
     raise RuntimeError("Method not supported for Web Sockets")
 
 
 class WebSocketProtocol(abc.ABC):
-    """Base class for WebSocket protocol versions.
-    """
+    """Base class for WebSocket protocol versions."""
 
     def __init__(self, handler: "_WebSocketDelegate") -> None:
         self.handler = handler
@@ -639,9 +949,22 @@
         self, callback: Callable, *args: Any, **kwargs: Any
     ) -> "Optional[Future[Any]]":
         """Runs the given callback with exception handling.
-
+        
         If the callback is a coroutine, returns its Future. On error, aborts the
         websocket connection and returns None.
+
+        Parameters
+        ----------
+        callback: Callable :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         try:
             result = callback(*args, **kwargs)
@@ -657,6 +980,7 @@
             return result
 
     def on_connection_close(self) -> None:
+        """ """
         self._abort()
 
     def _abort(self) -> None:
@@ -669,10 +993,24 @@
 
     @abc.abstractmethod
     def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:
+        """
+
+        Parameters
+        ----------
+        code: Optional[int] :
+             (Default value = None)
+        reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     @abc.abstractmethod
     def is_closing(self) -> bool:
+        """ """
         raise NotImplementedError()
 
     @abc.abstractmethod
@@ -683,15 +1021,42 @@
     def write_message(
         self, message: Union[str, bytes], binary: bool = False
     ) -> "Future[None]":
+        """
+
+        Parameters
+        ----------
+        message: Union[str :
+            
+        bytes] :
+            
+        binary: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     @property
     @abc.abstractmethod
     def selected_subprotocol(self) -> Optional[str]:
+        """ """
         raise NotImplementedError()
 
     @abc.abstractmethod
     def write_ping(self, data: bytes) -> None:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     # The entry points below are used by WebSocketClientConnection,
@@ -702,10 +1067,26 @@
     def _process_server_headers(
         self, key: Union[str, bytes], headers: httputil.HTTPHeaders
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        key: Union[str :
+            
+        bytes] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     @abc.abstractmethod
     def start_pinging(self) -> None:
+        """ """
         raise NotImplementedError()
 
     @abc.abstractmethod
@@ -714,10 +1095,22 @@
 
     @abc.abstractmethod
     def set_nodelay(self, x: bool) -> None:
+        """
+
+        Parameters
+        ----------
+        x: bool :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
 
 class _PerMessageDeflateCompressor(object):
+    """ """
     def __init__(
         self,
         persistent: bool,
@@ -754,11 +1147,23 @@
             self._compressor = None
 
     def _create_compressor(self) -> "_Compressor":
+        """ """
         return zlib.compressobj(
             self._compression_level, zlib.DEFLATED, -self._max_wbits, self._mem_level
         )
 
     def compress(self, data: bytes) -> bytes:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         compressor = self._compressor or self._create_compressor()
         data = compressor.compress(data) + compressor.flush(zlib.Z_SYNC_FLUSH)
         assert data.endswith(b"\x00\x00\xff\xff")
@@ -766,6 +1171,7 @@
 
 
 class _PerMessageDeflateDecompressor(object):
+    """ """
     def __init__(
         self,
         persistent: bool,
@@ -791,9 +1197,21 @@
             self._decompressor = None
 
     def _create_decompressor(self) -> "_Decompressor":
+        """ """
         return zlib.decompressobj(-self._max_wbits)
 
     def decompress(self, data: bytes) -> bytes:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         decompressor = self._decompressor or self._create_decompressor()
         result = decompressor.decompress(
             data + b"\x00\x00\xff\xff", self._max_message_size
@@ -805,9 +1223,16 @@
 
 class WebSocketProtocol13(WebSocketProtocol):
     """Implementation of the WebSocket protocol from RFC 6455.
-
+    
     This class supports versions 7 and 8 of the protocol in addition to the
     final version 13.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # Bit masks for the first byte of a frame.
@@ -859,10 +1284,22 @@
     # Use a property for this to satisfy the abc.
     @property
     def selected_subprotocol(self) -> Optional[str]:
+        """ """
         return self._selected_subprotocol
 
     @selected_subprotocol.setter
     def selected_subprotocol(self, value: Optional[str]) -> None:
+        """
+
+        Parameters
+        ----------
+        value: Optional[str] :
+            
+
+        Returns
+        -------
+
+        """
         self._selected_subprotocol = value
 
     async def accept_connection(self, handler: WebSocketHandler) -> None:
@@ -887,9 +1324,17 @@
 
     def _handle_websocket_headers(self, handler: WebSocketHandler) -> None:
         """Verifies all invariant- and required headers
-
+        
         If a header is missing or have an incorrect value ValueError will be
-        raised
+
+        Parameters
+        ----------
+        handler: WebSocketHandler :
+            
+
+        Returns
+        -------
+
         """
         fields = ("Host", "Sec-Websocket-Key", "Sec-Websocket-Version")
         if not all(map(lambda f: handler.request.headers.get(f), fields)):
@@ -899,6 +1344,17 @@
     def compute_accept_value(key: Union[str, bytes]) -> str:
         """Computes the value for the Sec-WebSocket-Accept header,
         given the value for Sec-WebSocket-Key.
+
+        Parameters
+        ----------
+        key: Union[str :
+            
+        bytes] :
+            
+
+        Returns
+        -------
+
         """
         sha1 = hashlib.sha1()
         sha1.update(utf8(key))
@@ -906,6 +1362,17 @@
         return native_str(base64.b64encode(sha1.digest()))
 
     def _challenge_response(self, handler: WebSocketHandler) -> str:
+        """
+
+        Parameters
+        ----------
+        handler: WebSocketHandler :
+            
+
+        Returns
+        -------
+
+        """
         return WebSocketProtocol13.compute_accept_value(
             cast(str, handler.request.headers.get("Sec-Websocket-Key"))
         )
@@ -964,6 +1431,17 @@
     def _parse_extensions_header(
         self, headers: httputil.HTTPHeaders
     ) -> List[Tuple[str, Dict[str, str]]]:
+        """
+
+        Parameters
+        ----------
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         extensions = headers.get("Sec-WebSocket-Extensions", "")
         if extensions:
             return [httputil._parse_header(e.strip()) for e in extensions.split(",")]
@@ -973,8 +1451,21 @@
         self, key: Union[str, bytes], headers: httputil.HTTPHeaders
     ) -> None:
         """Process the headers sent by the server to this client connection.
-
+        
         'key' is the websocket handshake challenge/response key.
+
+        Parameters
+        ----------
+        key: Union[str :
+            
+        bytes] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
         """
         assert headers["Upgrade"].lower() == "websocket"
         assert headers["Connection"].lower() == "upgrade"
@@ -998,6 +1489,23 @@
     ) -> Dict[str, Any]:
         """Converts a websocket agreed_parameters set to keyword arguments
         for our compressor objects.
+
+        Parameters
+        ----------
+        side: str :
+            
+        agreed_parameters: Dict[str :
+            
+        Any] :
+            
+        compression_options: Optional[Dict[str :
+            
+        Any]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         options = dict(
             persistent=(side + "_no_context_takeover") not in agreed_parameters
@@ -1016,6 +1524,25 @@
         agreed_parameters: Dict[str, Any],
         compression_options: Optional[Dict[str, Any]] = None,
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        side: str :
+            
+        agreed_parameters: Dict[str :
+            
+        Any] :
+            
+        compression_options: Optional[Dict[str :
+            
+        Any]] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # TODO: handle invalid parameters gracefully
         allowed_keys = set(
             [
@@ -1042,6 +1569,23 @@
     def _write_frame(
         self, fin: bool, opcode: int, data: bytes, flags: int = 0
     ) -> "Future[None]":
+        """
+
+        Parameters
+        ----------
+        fin: bool :
+            
+        opcode: int :
+            
+        data: bytes :
+            
+        flags: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         data_len = len(data)
         if opcode & 0x8:
             # All control frames MUST have a payload length of 125
@@ -1075,7 +1619,21 @@
     def write_message(
         self, message: Union[str, bytes], binary: bool = False
     ) -> "Future[None]":
-        """Sends the given message to the client of this Web Socket."""
+        """Sends the given message to the client of this Web Socket.
+
+        Parameters
+        ----------
+        message: Union[str :
+            
+        bytes] :
+            
+        binary: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if binary:
             opcode = 0x2
         else:
@@ -1106,7 +1664,17 @@
         return asyncio.ensure_future(wrapper())
 
     def write_ping(self, data: bytes) -> None:
-        """Send ping frame."""
+        """Send ping frame.
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(data, bytes)
         self._write_frame(True, 0x9, data)
 
@@ -1207,7 +1775,19 @@
                 await handled_future
 
     def _handle_message(self, opcode: int, data: bytes) -> "Optional[Future[None]]":
-        """Execute on_message, returning its Future if it is a coroutine."""
+        """Execute on_message, returning its Future if it is a coroutine.
+
+        Parameters
+        ----------
+        opcode: int :
+            
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         if self.client_terminated:
             return None
 
@@ -1258,7 +1838,19 @@
         return None
 
     def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:
-        """Closes the WebSocket connection."""
+        """Closes the WebSocket connection.
+
+        Parameters
+        ----------
+        code: Optional[int] :
+             (Default value = None)
+        reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if not self.server_terminated:
             if not self.stream.closed():
                 if code is None and reason is not None:
@@ -1290,16 +1882,24 @@
             self.ping_callback = None
 
     def is_closing(self) -> bool:
-        """Return ``True`` if this connection is closing.
-
-        The connection is considered closing if either side has
-        initiated its closing handshake or if the stream has been
-        shut down uncleanly.
+        """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            The connection is considered closing if either side has
+            initiated its closing handshake or if the stream has been
+            shut down uncleanly.
+
         """
         return self.stream.closed() or self.client_terminated or self.server_terminated
 
     @property
     def ping_interval(self) -> Optional[float]:
+        """ """
         interval = self.params.ping_interval
         if interval is not None:
             return interval
@@ -1307,6 +1907,7 @@
 
     @property
     def ping_timeout(self) -> Optional[float]:
+        """ """
         timeout = self.params.ping_timeout
         if timeout is not None:
             return timeout
@@ -1325,8 +1926,15 @@
 
     def periodic_ping(self) -> None:
         """Send a ping to keep the websocket alive
-
+        
         Called periodically if the websocket_ping_interval is set and non-zero.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self.is_closing() and self.ping_callback is not None:
             self.ping_callback.stop()
@@ -1351,14 +1959,32 @@
         self.last_ping = now
 
     def set_nodelay(self, x: bool) -> None:
+        """
+
+        Parameters
+        ----------
+        x: bool :
+            
+
+        Returns
+        -------
+
+        """
         self.stream.set_nodelay(x)
 
 
 class WebSocketClientConnection(simple_httpclient._HTTPConnection):
     """WebSocket client connection.
-
+    
     This class should not be instantiated directly; use the
     `websocket_connect` function instead.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     protocol = None  # type: WebSocketProtocol
@@ -1426,21 +2052,33 @@
 
     def close(self, code: Optional[int] = None, reason: Optional[str] = None) -> None:
         """Closes the websocket connection.
-
+        
         ``code`` and ``reason`` are documented under
         `WebSocketHandler.close`.
-
+        
         .. versionadded:: 3.2
-
+        
         .. versionchanged:: 4.0
-
+        
            Added the ``code`` and ``reason`` arguments.
+
+        Parameters
+        ----------
+        code: Optional[int] :
+             (Default value = None)
+        reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if self.protocol is not None:
             self.protocol.close(code, reason)
             self.protocol = None  # type: ignore
 
     def on_connection_close(self) -> None:
+        """ """
         if not self.connect_future.done():
             self.connect_future.set_exception(StreamClosedError())
         self._on_message(None)
@@ -1450,11 +2088,35 @@
     def on_ws_connection_close(
         self, close_code: Optional[int] = None, close_reason: Optional[str] = None
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        close_code: Optional[int] :
+             (Default value = None)
+        close_reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self.close_code = close_code
         self.close_reason = close_reason
         self.on_connection_close()
 
     def _on_http_response(self, response: httpclient.HTTPResponse) -> None:
+        """
+
+        Parameters
+        ----------
+        response: httpclient.HTTPResponse :
+            
+
+        Returns
+        -------
+
+        """
         if not self.connect_future.done():
             if response.error:
                 self.connect_future.set_exception(response.error)
@@ -1497,13 +2159,28 @@
         self, message: Union[str, bytes], binary: bool = False
     ) -> "Future[None]":
         """Sends a message to the WebSocket server.
-
+        
         If the stream is closed, raises `WebSocketClosedError`.
-        Returns a `.Future` which can be used for flow control.
-
-        .. versionchanged:: 5.0
-           Exception raised on a closed stream changed from `.StreamClosedError`
-           to `WebSocketClosedError`.
+
+        Parameters
+        ----------
+        message: Union[str :
+            
+        bytes] :
+            
+        binary: bool :
+             (Default value = False)
+
+        Returns
+        -------
+        type
+            .. versionchanged:: 5.0
+
+        Raises
+        ------
+        to
+            WebSocketClosedError
+
         """
         return self.protocol.write_message(message, binary=binary)
 
@@ -1512,14 +2189,29 @@
         callback: Optional[Callable[["Future[Union[None, str, bytes]]"], None]] = None,
     ) -> Awaitable[Union[None, str, bytes]]:
         """Reads a message from the WebSocket server.
-
+        
         If on_message_callback was specified at WebSocket
         initialization, this function will never return messages
-
+        
         Returns a future whose result is the message, or None
         if the connection is closed.  If a callback argument
         is given it will be called with the future when it is
         ready.
+
+        Parameters
+        ----------
+        callback: Optional[Callable[["Future[Union[None :
+            
+        str :
+            
+        bytes]]"] :
+            
+        None]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
 
         awaitable = self.read_queue.get()
@@ -1528,11 +2220,39 @@
         return awaitable
 
     def on_message(self, message: Union[str, bytes]) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        message: Union[str :
+            
+        bytes] :
+            
+
+        Returns
+        -------
+
+        """
         return self._on_message(message)
 
     def _on_message(
         self, message: Union[None, str, bytes]
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        message: Union[None :
+            
+        str :
+            
+        bytes] :
+            
+
+        Returns
+        -------
+
+        """
         if self._on_message_callback:
             self._on_message_callback(message)
             return None
@@ -1541,16 +2261,24 @@
 
     def ping(self, data: bytes = b"") -> None:
         """Send ping frame to the remote end.
-
+        
         The data argument allows a small amount of data (up to 125
         bytes) to be sent as a part of the ping message. Note that not
         all websocket implementations expose this data to
         applications.
-
+        
         Consider using the ``ping_interval`` argument to
         `websocket_connect` instead of sending pings manually.
-
+        
         .. versionadded:: 5.1
+
+        Parameters
+        ----------
+        data: bytes :
+             (Default value = b"")
+
+        Returns
+        -------
 
         """
         data = utf8(data)
@@ -1559,19 +2287,49 @@
         self.protocol.write_ping(data)
 
     def on_pong(self, data: bytes) -> None:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def on_ping(self, data: bytes) -> None:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def get_websocket_protocol(self) -> WebSocketProtocol:
+        """ """
         return WebSocketProtocol13(self, mask_outgoing=True, params=self.params)
 
     @property
     def selected_subprotocol(self) -> Optional[str]:
         """The subprotocol selected by the server.
-
+        
         .. versionadded:: 5.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.protocol.selected_subprotocol
 
@@ -1581,6 +2339,21 @@
         value: Optional[BaseException],
         tb: Optional[TracebackType],
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        typ: "Optional[Type[BaseException]]" :
+            
+        value: Optional[BaseException] :
+            
+        tb: Optional[TracebackType] :
+            
+
+        Returns
+        -------
+
+        """
         assert typ is not None
         assert value is not None
         app_log.error("Uncaught exception %s", value, exc_info=(typ, value, tb))
@@ -1598,47 +2371,82 @@
     subprotocols: Optional[List[str]] = None,
 ) -> "Awaitable[WebSocketClientConnection]":
     """Client-side websocket support.
-
+    
     Takes a url and returns a Future whose result is a
     `WebSocketClientConnection`.
-
+    
     ``compression_options`` is interpreted in the same way as the
-    return value of `.WebSocketHandler.get_compression_options`.
-
-    The connection supports two styles of operation. In the coroutine
-    style, the application typically calls
-    `~.WebSocketClientConnection.read_message` in a loop::
-
+
+    Parameters
+    ----------
+    versionchanged :
+        
+    The :
+        io_loop
+    versionchanged :
+        
+    Added :
+        the
+    url: Union[str :
+        
+    httpclient.HTTPRequest] :
+        
+    callback: Optional[Callable[["Future[WebSocketClientConnection]"] :
+        
+    None]] :
+         (Default value = None)
+    connect_timeout: Optional[float] :
+         (Default value = None)
+    on_message_callback: Optional[Callable[[Union[None :
+        
+    str :
+        
+    bytes]] :
+        
+    compression_options: Optional[Dict[str :
+        
+    Any]] :
+         (Default value = None)
+    ping_interval: Optional[float] :
+         (Default value = None)
+    ping_timeout: Optional[float] :
+         (Default value = None)
+    max_message_size: int :
+         (Default value = _default_max_message_size)
+    subprotocols: Optional[List[str]] :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        The connection supports two styles of operation. In the coroutine
+        style, the application typically calls
+        `~.WebSocketClientConnection.read_message` in a loop::
+        
         conn = yield websocket_connect(url)
         while True:
-            msg = yield conn.read_message()
-            if msg is None: break
-            # Do something with msg
-
-    In the callback style, pass an ``on_message_callback`` to
-    ``websocket_connect``. In both styles, a message of ``None``
-    indicates that the connection has been closed.
-
-    ``subprotocols`` may be a list of strings specifying proposed
-    subprotocols. The selected protocol may be found on the
-    ``selected_subprotocol`` attribute of the connection object
-    when the connection is complete.
-
-    .. versionchanged:: 3.2
-       Also accepts ``HTTPRequest`` objects in place of urls.
-
-    .. versionchanged:: 4.1
-       Added ``compression_options`` and ``on_message_callback``.
-
-    .. versionchanged:: 4.5
-       Added the ``ping_interval``, ``ping_timeout``, and ``max_message_size``
-       arguments, which have the same meaning as in `WebSocketHandler`.
-
-    .. versionchanged:: 5.0
-       The ``io_loop`` argument (deprecated since version 4.1) has been removed.
-
-    .. versionchanged:: 5.1
-       Added the ``subprotocols`` argument.
+        msg = yield conn.read_message()
+        if msg is None: break
+        # Do something with msg
+        
+        In the callback style, pass an ``on_message_callback`` to
+        ``websocket_connect``. In both styles, a message of ``None``
+        indicates that the connection has been closed.
+        
+        ``subprotocols`` may be a list of strings specifying proposed
+        subprotocols. The selected protocol may be found on the
+        ``selected_subprotocol`` attribute of the connection object
+        when the connection is complete.
+        
+        .. versionchanged:: 3.2
+        Also accepts ``HTTPRequest`` objects in place of urls.
+        
+        .. versionchanged:: 4.1
+        Added ``compression_options`` and ``on_message_callback``.
+        
+        .. versionchanged:: 4.5
+        Added the ``ping_interval``, ``ping_timeout``, and ``max_message_size``
+
     """
     if isinstance(url, httpclient.HTTPRequest):
         assert connect_timeout is None
