# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/bleach/_vendor/html5lib/html5parser.py
+++ b/..//venv/lib/python3.8/site-packages/bleach/_vendor/html5lib/html5parser.py
@@ -25,21 +25,34 @@
 
 def parse(doc, treebuilder="etree", namespaceHTMLElements=True, **kwargs):
     """Parse an HTML document as a string or file-like object into a tree
-
+    
     :arg doc: the document to parse as a string or file-like object
-
+    
     :arg treebuilder: the treebuilder to use when parsing
-
+    
     :arg namespaceHTMLElements: whether or not to namespace HTML elements
 
-    :returns: parsed tree
-
-    Example:
+    Parameters
+    ----------
+    doc :
+        
+    treebuilder :
+         (Default value = "etree")
+    namespaceHTMLElements :
+         (Default value = True)
+    **kwargs :
+        
+
+    Returns
+    -------
+    type
+        parsed tree
+        
+        Example:
 
     >>> from html5lib.html5parser import parse
     >>> parse('<html><body><p>This is a doc</p></body></html>')
     <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>
-
     """
     tb = treebuilders.getTreeBuilder(treebuilder)
     p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
@@ -48,23 +61,38 @@
 
 def parseFragment(doc, container="div", treebuilder="etree", namespaceHTMLElements=True, **kwargs):
     """Parse an HTML fragment as a string or file-like object into a tree
-
+    
     :arg doc: the fragment to parse as a string or file-like object
-
+    
     :arg container: the container context to parse the fragment in
-
+    
     :arg treebuilder: the treebuilder to use when parsing
-
+    
     :arg namespaceHTMLElements: whether or not to namespace HTML elements
 
-    :returns: parsed tree
-
-    Example:
+    Parameters
+    ----------
+    doc :
+        
+    container :
+         (Default value = "div")
+    treebuilder :
+         (Default value = "etree")
+    namespaceHTMLElements :
+         (Default value = True)
+    **kwargs :
+        
+
+    Returns
+    -------
+    type
+        parsed tree
+        
+        Example:
 
     >>> from html5lib.html5libparser import parseFragment
     >>> parseFragment('<b>this is a fragment</b>')
     <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>
-
     """
     tb = treebuilders.getTreeBuilder(treebuilder)
     p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
@@ -72,7 +100,19 @@
 
 
 def method_decorator_metaclass(function):
+    """
+
+    Parameters
+    ----------
+    function :
+        
+
+    Returns
+    -------
+
+    """
     class Decorated(type):
+        """ """
         def __new__(meta, classname, bases, classDict):
             for attributeName, attribute in classDict.items():
                 if isinstance(attribute, types.FunctionType):
@@ -85,8 +125,14 @@
 
 class HTMLParser(object):
     """HTML parser
-
+    
     Generates a tree structure from a stream of (possibly malformed) HTML.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -122,6 +168,25 @@
                        getPhases(debug).items()}
 
     def _parse(self, stream, innerHTML=False, container="div", scripting=False, **kwargs):
+        """
+
+        Parameters
+        ----------
+        stream :
+            
+        innerHTML :
+             (Default value = False)
+        container :
+             (Default value = "div")
+        scripting :
+             (Default value = False)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         self.innerHTMLMode = innerHTML
         self.container = container
@@ -136,6 +201,7 @@
             self.mainLoop()
 
     def reset(self):
+        """ """
         self.tree.reset()
         self.firstStartTag = False
         self.errors = []
@@ -174,12 +240,29 @@
         """Name of the character encoding that was used to decode the input stream, or
         :obj:`None` if that is not determined yet
 
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not hasattr(self, 'tokenizer'):
             return None
         return self.tokenizer.stream.charEncoding[0].name
 
     def isHTMLIntegrationPoint(self, element):
+        """
+
+        Parameters
+        ----------
+        element :
+            
+
+        Returns
+        -------
+
+        """
         if (element.name == "annotation-xml" and
                 element.namespace == namespaces["mathml"]):
             return ("encoding" in element.attributes and
@@ -190,9 +273,21 @@
             return (element.namespace, element.name) in htmlIntegrationPointElements
 
     def isMathMLTextIntegrationPoint(self, element):
+        """
+
+        Parameters
+        ----------
+        element :
+            
+
+        Returns
+        -------
+
+        """
         return (element.namespace, element.name) in mathmlTextIntegrationPointElements
 
     def mainLoop(self):
+        """ """
         CharactersToken = tokenTypes["Characters"]
         SpaceCharactersToken = tokenTypes["SpaceCharacters"]
         StartTagToken = tokenTypes["StartTag"]
@@ -261,58 +356,93 @@
 
     def parse(self, stream, *args, **kwargs):
         """Parse a HTML document into a well-formed tree
-
+        
         :arg stream: a file-like object or string containing the HTML to be parsed
-
+        
             The optional encoding parameter must be a string that indicates
             the encoding.  If specified, that encoding will be used,
             regardless of any BOM or later declaration (such as in a meta
             element).
-
+        
         :arg scripting: treat noscript elements as if JavaScript was turned on
 
-        :returns: parsed tree
-
-        Example:
+        Parameters
+        ----------
+        stream :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+        type
+            parsed tree
+            
+            Example:
 
         >>> from html5lib.html5parser import HTMLParser
         >>> parser = HTMLParser()
         >>> parser.parse('<html><body><p>This is a doc</p></body></html>')
         <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>
-
         """
         self._parse(stream, False, None, *args, **kwargs)
         return self.tree.getDocument()
 
     def parseFragment(self, stream, *args, **kwargs):
         """Parse a HTML fragment into a well-formed tree fragment
-
+        
         :arg container: name of the element we're setting the innerHTML
             property if set to None, default to 'div'
-
+        
         :arg stream: a file-like object or string containing the HTML to be parsed
-
+        
             The optional encoding parameter must be a string that indicates
             the encoding.  If specified, that encoding will be used,
             regardless of any BOM or later declaration (such as in a meta
             element)
-
+        
         :arg scripting: treat noscript elements as if JavaScript was turned on
 
-        :returns: parsed tree
-
-        Example:
+        Parameters
+        ----------
+        stream :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+        type
+            parsed tree
+            
+            Example:
 
         >>> from html5lib.html5libparser import HTMLParser
         >>> parser = HTMLParser()
         >>> parser.parseFragment('<b>this is a fragment</b>')
         <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>
-
         """
         self._parse(stream, True, *args, **kwargs)
         return self.tree.getFragment()
 
     def parseError(self, errorcode="XXX-undefined-error", datavars=None):
+        """
+
+        Parameters
+        ----------
+        errorcode :
+             (Default value = "XXX-undefined-error")
+        datavars :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # XXX The idea is to make errorcode mandatory.
         if datavars is None:
             datavars = {}
@@ -321,19 +451,64 @@
             raise ParseError(E[errorcode] % datavars)
 
     def adjustMathMLAttributes(self, token):
+        """
+
+        Parameters
+        ----------
+        token :
+            
+
+        Returns
+        -------
+
+        """
         adjust_attributes(token, adjustMathMLAttributes)
 
     def adjustSVGAttributes(self, token):
+        """
+
+        Parameters
+        ----------
+        token :
+            
+
+        Returns
+        -------
+
+        """
         adjust_attributes(token, adjustSVGAttributes)
 
     def adjustForeignAttributes(self, token):
+        """
+
+        Parameters
+        ----------
+        token :
+            
+
+        Returns
+        -------
+
+        """
         adjust_attributes(token, adjustForeignAttributesMap)
 
     def reparseTokenNormal(self, token):
+        """
+
+        Parameters
+        ----------
+        token :
+            
+
+        Returns
+        -------
+
+        """
         # pylint:disable=unused-argument
         self.parser.phase()
 
     def resetInsertionMode(self):
+        """ """
         # The name of this method is mostly historical. (It's also used in the
         # specification.)
         last = False
@@ -378,6 +553,19 @@
         self.phase = new_phase
 
     def parseRCDataRawtext(self, token, contentType):
+        """
+
+        Parameters
+        ----------
+        token :
+            
+        contentType :
+            
+
+        Returns
+        -------
+
+        """
         # Generic RCDATA/RAWTEXT Parsing algorithm
         assert contentType in ("RAWTEXT", "RCDATA")
 
@@ -395,11 +583,45 @@
 
 @_utils.memoize
 def getPhases(debug):
+    """
+
+    Parameters
+    ----------
+    debug :
+        
+
+    Returns
+    -------
+
+    """
     def log(function):
-        """Logger that records which phase processes each token"""
+        """Logger that records which phase processes each token
+
+        Parameters
+        ----------
+        function :
+            
+
+        Returns
+        -------
+
+        """
         type_names = {value: key for key, value in tokenTypes.items()}
 
         def wrapped(self, *args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             if function.__name__.startswith("process") and len(args) > 0:
                 token = args[0]
                 info = {"type": type_names[token['type']]}
@@ -417,6 +639,19 @@
         return wrapped
 
     def getMetaclass(use_metaclass, metaclass_func):
+        """
+
+        Parameters
+        ----------
+        use_metaclass :
+            
+        metaclass_func :
+            
+
+        Returns
+        -------
+
+        """
         if use_metaclass:
             return method_decorator_metaclass(metaclass_func)
         else:
@@ -424,8 +659,7 @@
 
     # pylint:disable=unused-argument
     class Phase(with_metaclass(getMetaclass(debug, log))):
-        """Base class for helper object that implements each phase of processing
-        """
+        """Base class for helper object that implements each phase of processing"""
         __slots__ = ("parser", "tree", "__startTagCache", "__endTagCache")
 
         def __init__(self, parser, tree):
@@ -435,23 +669,79 @@
             self.__endTagCache = {}
 
         def processEOF(self):
+            """ """
             raise NotImplementedError
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # For most phases the following is correct. Where it's not it will be
             # overridden.
             self.tree.insertComment(token, self.tree.openElements[-1])
 
         def processDoctype(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-doctype")
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertText(token["data"])
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertText(token["data"])
 
         def processStartTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # Note the caching is done here rather than BoundMethodDispatcher as doing it there
             # requires a circular reference to the Phase, and this ends up with a significant
             # (CPython 2.7, 3.8) GC cost when parsing many short inputs
@@ -469,6 +759,17 @@
             return func(token)
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if not self.parser.firstStartTag and token["name"] == "html":
                 self.parser.parseError("non-html-root")
             # XXX Need a check here to see if the first start tag token emitted is
@@ -479,6 +780,17 @@
             self.parser.firstStartTag = False
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # Note the caching is done here rather than BoundMethodDispatcher as doing it there
             # requires a circular reference to the Phase, and this ends up with a significant
             # (CPython 2.7, 3.8) GC cost when parsing many short inputs
@@ -496,15 +808,49 @@
             return func(token)
 
     class InitialPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertComment(token, self.tree.document)
 
         def processDoctype(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             name = token["name"]
             publicId = token["publicId"]
             systemId = token["systemId"]
@@ -600,61 +946,154 @@
             self.parser.phase = self.parser.phases["beforeHtml"]
 
         def anythingElse(self):
+            """ """
             self.parser.compatMode = "quirks"
             self.parser.phase = self.parser.phases["beforeHtml"]
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-doctype-but-got-chars")
             self.anythingElse()
             return token
 
         def processStartTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-doctype-but-got-start-tag",
                                    {"name": token["name"]})
             self.anythingElse()
             return token
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-doctype-but-got-end-tag",
                                    {"name": token["name"]})
             self.anythingElse()
             return token
 
         def processEOF(self):
+            """ """
             self.parser.parseError("expected-doctype-but-got-eof")
             self.anythingElse()
             return True
 
     class BeforeHtmlPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         # helper methods
         def insertHtmlElement(self):
+            """ """
             self.tree.insertRoot(impliedTagToken("html", "StartTag"))
             self.parser.phase = self.parser.phases["beforeHead"]
 
         # other
         def processEOF(self):
+            """ """
             self.insertHtmlElement()
             return True
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertComment(token, self.tree.document)
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.insertHtmlElement()
             return token
 
         def processStartTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["name"] == "html":
                 self.parser.firstStartTag = True
             self.insertHtmlElement()
             return token
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["name"] not in ("head", "body", "html", "br"):
                 self.parser.parseError("unexpected-end-tag-before-html",
                                        {"name": token["name"]})
@@ -663,36 +1102,115 @@
                 return token
 
     class BeforeHeadPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             self.startTagHead(impliedTagToken("head", "StartTag"))
             return True
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.startTagHead(impliedTagToken("head", "StartTag"))
             return token
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.headPointer = self.tree.openElements[-1]
             self.parser.phase = self.parser.phases["inHead"]
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.startTagHead(impliedTagToken("head", "StartTag"))
             return token
 
         def endTagImplyHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.startTagHead(impliedTagToken("head", "StartTag"))
             return token
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("end-tag-after-implied-root",
                                    {"name": token["name"]})
 
@@ -708,29 +1226,86 @@
         endTagHandler.default = endTagOther
 
     class InHeadPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         # the real thing
         def processEOF(self):
+            """ """
             self.anythingElse()
             return True
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("two-heads-are-not-better-than-one")
 
         def startTagBaseLinkCommand(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.openElements.pop()
             token["selfClosingAcknowledged"] = True
 
         def startTagMeta(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.openElements.pop()
             token["selfClosingAcknowledged"] = True
@@ -752,13 +1327,46 @@
                     self.parser.tokenizer.stream.changeEncoding(codec)
 
         def startTagTitle(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseRCDataRawtext(token, "RCDATA")
 
         def startTagNoFramesStyle(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # Need to decide whether to implement the scripting-disabled case
             self.parser.parseRCDataRawtext(token, "RAWTEXT")
 
         def startTagNoscript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.parser.scripting:
                 self.parser.parseRCDataRawtext(token, "RAWTEXT")
             else:
@@ -766,28 +1374,84 @@
                 self.parser.phase = self.parser.phases["inHeadNoscript"]
 
         def startTagScript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.parser.tokenizer.state = self.parser.tokenizer.scriptDataState
             self.parser.originalPhase = self.parser.phase
             self.parser.phase = self.parser.phases["text"]
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def endTagHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             node = self.parser.tree.openElements.pop()
             assert node.name == "head", "Expected head got %s" % node.name
             self.parser.phase = self.parser.phases["afterHead"]
 
         def endTagHtmlBodyBr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def anythingElse(self):
+            """ """
             self.endTagHead(impliedTagToken("head"))
 
         startTagHandler = _utils.MethodDispatcher([
@@ -810,52 +1474,165 @@
         endTagHandler.default = endTagOther
 
     class InHeadNoscriptPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             self.parser.parseError("eof-in-head-noscript")
             self.anythingElse()
             return True
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processComment(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("char-in-head-noscript")
             self.anythingElse()
             return token
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processSpaceCharacters(token)
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagBaseLinkCommand(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagHeadNoscript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag", {"name": token["name"]})
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-inhead-noscript-tag", {"name": token["name"]})
             self.anythingElse()
             return token
 
         def endTagNoscript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             node = self.parser.tree.openElements.pop()
             assert node.name == "noscript", "Expected noscript got %s" % node.name
             self.parser.phase = self.parser.phases["inHead"]
 
         def endTagBr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-inhead-noscript-tag", {"name": token["name"]})
             self.anythingElse()
             return token
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def anythingElse(self):
+            """ """
             # Caller must raise parse error first!
             self.endTagNoscript(impliedTagToken("noscript"))
 
@@ -873,29 +1650,86 @@
         endTagHandler.default = endTagOther
 
     class AfterHeadPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             self.anythingElse()
             return True
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagBody(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.framesetOK = False
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inBody"]
 
         def startTagFrameset(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inFrameset"]
 
         def startTagFromHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-out-of-my-head",
                                    {"name": token["name"]})
             self.tree.openElements.append(self.tree.headPointer)
@@ -906,20 +1740,65 @@
                     break
 
         def startTagHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag", {"name": token["name"]})
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def endTagHtmlBodyBr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.anythingElse()
             return token
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def anythingElse(self):
+            """ """
             self.tree.insertElement(impliedTagToken("body", "StartTag"))
             self.parser.phase = self.parser.phases["inBody"]
             self.parser.framesetOK = True
@@ -939,6 +1818,7 @@
         endTagHandler.default = endTagOther
 
     class InBodyPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
         # the really-really-really-very crazy mode
         __slots__ = ("processSpaceCharacters",)
@@ -949,12 +1829,36 @@
             self.processSpaceCharacters = self.processSpaceCharactersNonPre
 
         def isMatchingFormattingElement(self, node1, node2):
+            """
+
+            Parameters
+            ----------
+            node1 :
+                
+            node2 :
+                
+
+            Returns
+            -------
+
+            """
             return (node1.name == node2.name and
                     node1.namespace == node2.namespace and
                     node1.attributes == node2.attributes)
 
         # helper
         def addFormattingElement(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             element = self.tree.openElements[-1]
 
@@ -972,6 +1876,7 @@
 
         # the real deal
         def processEOF(self):
+            """ """
             allowed_elements = frozenset(("dd", "dt", "li", "p", "tbody", "td",
                                           "tfoot", "th", "thead", "tr", "body",
                                           "html"))
@@ -982,6 +1887,17 @@
             # Stop parsing
 
         def processSpaceCharactersDropNewline(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # Sometimes (start of <pre>, <listing>, and <textarea> blocks) we
             # want to drop leading newlines
             data = token["data"]
@@ -995,6 +1911,17 @@
                 self.tree.insertText(data)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["data"] == "\u0000":
                 # The tokenizer should always emit null on its own
                 return
@@ -1007,13 +1934,46 @@
                 self.parser.framesetOK = False
 
         def processSpaceCharactersNonPre(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.tree.insertText(token["data"])
 
         def startTagProcessInHead(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagBody(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag", {"name": "body"})
             if (len(self.tree.openElements) == 1 or
                     self.tree.openElements[1].name != "body"):
@@ -1025,6 +1985,17 @@
                         self.tree.openElements[1].attributes[attr] = value
 
         def startTagFrameset(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag", {"name": "frameset"})
             if (len(self.tree.openElements) == 1 or self.tree.openElements[1].name != "body"):
                 assert self.parser.innerHTML
@@ -1039,11 +2010,33 @@
                 self.parser.phase = self.parser.phases["inFrameset"]
 
         def startTagCloseP(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             self.tree.insertElement(token)
 
         def startTagPreListing(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             self.tree.insertElement(token)
@@ -1051,6 +2044,17 @@
             self.processSpaceCharacters = self.processSpaceCharactersDropNewline
 
         def startTagForm(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.formPointer:
                 self.parser.parseError("unexpected-start-tag", {"name": "form"})
             else:
@@ -1060,6 +2064,17 @@
                 self.tree.formPointer = self.tree.openElements[-1]
 
         def startTagListItem(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.framesetOK = False
 
             stopNamesMap = {"li": ["li"],
@@ -1082,12 +2097,34 @@
             self.tree.insertElement(token)
 
         def startTagPlaintext(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             self.tree.insertElement(token)
             self.parser.tokenizer.state = self.parser.tokenizer.plaintextState
 
         def startTagHeading(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             if self.tree.openElements[-1].name in headingElements:
@@ -1096,6 +2133,17 @@
             self.tree.insertElement(token)
 
         def startTagA(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             afeAElement = self.tree.elementInActiveFormattingElements("a")
             if afeAElement:
                 self.parser.parseError("unexpected-start-tag-implies-end-tag",
@@ -1109,10 +2157,32 @@
             self.addFormattingElement(token)
 
         def startTagFormatting(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.addFormattingElement(token)
 
         def startTagNobr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             if self.tree.elementInScope("nobr"):
                 self.parser.parseError("unexpected-start-tag-implies-end-tag",
@@ -1123,6 +2193,17 @@
             self.addFormattingElement(token)
 
         def startTagButton(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("button"):
                 self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                        {"startName": "button", "endName": "button"})
@@ -1134,12 +2215,34 @@
                 self.parser.framesetOK = False
 
         def startTagAppletMarqueeObject(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.tree.insertElement(token)
             self.tree.activeFormattingElements.append(Marker)
             self.parser.framesetOK = False
 
         def startTagXmp(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             self.tree.reconstructActiveFormattingElements()
@@ -1147,6 +2250,17 @@
             self.parser.parseRCDataRawtext(token, "RAWTEXT")
 
         def startTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.parser.compatMode != "quirks":
                 if self.tree.elementInScope("p", variant="button"):
                     self.processEndTag(impliedTagToken("p"))
@@ -1155,6 +2269,17 @@
             self.parser.phase = self.parser.phases["inTable"]
 
         def startTagVoidFormatting(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.tree.insertElement(token)
             self.tree.openElements.pop()
@@ -1162,6 +2287,17 @@
             self.parser.framesetOK = False
 
         def startTagInput(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             framesetOK = self.parser.framesetOK
             self.startTagVoidFormatting(token)
             if ("type" in token["data"] and
@@ -1170,11 +2306,33 @@
                 self.parser.framesetOK = framesetOK
 
         def startTagParamSource(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.openElements.pop()
             token["selfClosingAcknowledged"] = True
 
         def startTagHr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("p", variant="button"):
                 self.endTagP(impliedTagToken("p"))
             self.tree.insertElement(token)
@@ -1183,6 +2341,17 @@
             self.parser.framesetOK = False
 
         def startTagImage(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # No really...
             self.parser.parseError("unexpected-start-tag-treated-as",
                                    {"originalName": "image", "newName": "img"})
@@ -1191,6 +2360,17 @@
                                                  selfClosing=token["selfClosing"]))
 
         def startTagIsIndex(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("deprecated-tag", {"name": "isindex"})
             if self.tree.formPointer:
                 return
@@ -1222,32 +2402,97 @@
             self.processEndTag(impliedTagToken("form"))
 
         def startTagTextarea(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.parser.tokenizer.state = self.parser.tokenizer.rcdataState
             self.processSpaceCharacters = self.processSpaceCharactersDropNewline
             self.parser.framesetOK = False
 
         def startTagIFrame(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.framesetOK = False
             self.startTagRawtext(token)
 
         def startTagNoscript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.parser.scripting:
                 self.startTagRawtext(token)
             else:
                 self.startTagOther(token)
 
         def startTagRawtext(self, token):
-            """iframe, noembed noframes, noscript(if scripting enabled)"""
+            """iframe, noembed noframes, noscript(if scripting enabled)
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseRCDataRawtext(token, "RAWTEXT")
 
         def startTagOpt(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.openElements[-1].name == "option":
                 self.parser.phase.processEndTag(impliedTagToken("option"))
             self.tree.reconstructActiveFormattingElements()
             self.parser.tree.insertElement(token)
 
         def startTagSelect(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.tree.insertElement(token)
             self.parser.framesetOK = False
@@ -1262,6 +2507,17 @@
                 self.parser.phase = self.parser.phases["inSelect"]
 
         def startTagRpRt(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("ruby"):
                 self.tree.generateImpliedEndTags()
                 if self.tree.openElements[-1].name != "ruby":
@@ -1269,6 +2525,17 @@
             self.tree.insertElement(token)
 
         def startTagMath(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.parser.adjustMathMLAttributes(token)
             self.parser.adjustForeignAttributes(token)
@@ -1281,6 +2548,17 @@
                 token["selfClosingAcknowledged"] = True
 
         def startTagSvg(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.parser.adjustSVGAttributes(token)
             self.parser.adjustForeignAttributes(token)
@@ -1293,19 +2571,50 @@
                 token["selfClosingAcknowledged"] = True
 
         def startTagMisplaced(self, token):
-            """ Elements that should be children of other elements that have a
+            """Elements that should be children of other elements that have a
             different insertion mode; here they are ignored
             "caption", "col", "colgroup", "frame", "frameset", "head",
             "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
             "tr", "noscript"
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
             """
             self.parser.parseError("unexpected-start-tag-ignored", {"name": token["name"]})
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.reconstructActiveFormattingElements()
             self.tree.insertElement(token)
 
         def endTagP(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if not self.tree.elementInScope("p", variant="button"):
                 self.startTagCloseP(impliedTagToken("p", "StartTag"))
                 self.parser.parseError("unexpected-end-tag", {"name": "p"})
@@ -1319,6 +2628,17 @@
                     node = self.tree.openElements.pop()
 
         def endTagBody(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if not self.tree.elementInScope("body"):
                 self.parser.parseError()
                 return
@@ -1337,12 +2657,34 @@
             self.parser.phase = self.parser.phases["afterBody"]
 
         def endTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # We repeat the test for the body end tag token being ignored here
             if self.tree.elementInScope("body"):
                 self.endTagBody(impliedTagToken("body"))
                 return token
 
         def endTagBlock(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # Put us back in the right whitespace handling mode
             if token["name"] == "pre":
                 self.processSpaceCharacters = self.processSpaceCharactersNonPre
@@ -1357,6 +2699,17 @@
                     node = self.tree.openElements.pop()
 
         def endTagForm(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             node = self.tree.formPointer
             self.tree.formPointer = None
             if node is None or not self.tree.elementInScope(node):
@@ -1370,6 +2723,17 @@
                 self.tree.openElements.remove(node)
 
         def endTagListItem(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["name"] == "li":
                 variant = "list"
             else:
@@ -1387,6 +2751,17 @@
                     node = self.tree.openElements.pop()
 
         def endTagHeading(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             for item in headingElements:
                 if self.tree.elementInScope(item):
                     self.tree.generateImpliedEndTags()
@@ -1402,7 +2777,17 @@
                     break
 
         def endTagFormatting(self, token):
-            """The much-feared adoption agency algorithm"""
+            """The much-feared adoption agency algorithm
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # http://svn.whatwg.org/webapps/complete.html#adoptionAgency revision 7867
             # XXX Better parseError messages appreciated.
 
@@ -1565,6 +2950,17 @@
                     self.tree.openElements.index(furthestBlock) + 1, clone)
 
         def endTagAppletMarqueeObject(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope(token["name"]):
                 self.tree.generateImpliedEndTags()
             if self.tree.openElements[-1].name != token["name"]:
@@ -1577,6 +2973,17 @@
                 self.tree.clearActiveFormattingElements()
 
         def endTagBr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-treated-as",
                                    {"originalName": "br", "newName": "br element"})
             self.tree.reconstructActiveFormattingElements()
@@ -1584,6 +2991,17 @@
             self.tree.openElements.pop()
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             for node in self.tree.openElements[::-1]:
                 if node.name == token["name"]:
                     self.tree.generateImpliedEndTags(exclude=token["name"])
@@ -1663,12 +3081,25 @@
         endTagHandler.default = endTagOther
 
     class TextPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertText(token["data"])
 
         def processEOF(self):
+            """ """
             self.parser.parseError("expected-named-closing-tag-but-got-eof",
                                    {"name": self.tree.openElements[-1].name})
             self.tree.openElements.pop()
@@ -1676,9 +3107,31 @@
             return True
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             assert False, "Tried to process start tag %s in RCDATA/RAWTEXT mode" % token['name']
 
         def endTagScript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             node = self.tree.openElements.pop()
             assert node.name == "script"
             self.parser.phase = self.parser.originalPhase
@@ -1686,6 +3139,17 @@
             # document.write works
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.openElements.pop()
             self.parser.phase = self.parser.originalPhase
 
@@ -1696,11 +3160,13 @@
         endTagHandler.default = endTagOther
 
     class InTablePhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-table
         __slots__ = tuple()
 
         # helper methods
         def clearStackToTableContext(self):
+            """ """
             # "clear the stack back to a table context"
             while self.tree.openElements[-1].name not in ("table", "html"):
                 # self.parser.parseError("unexpected-implied-end-tag-in-table",
@@ -1710,6 +3176,7 @@
 
         # processing methods
         def processEOF(self):
+            """ """
             if self.tree.openElements[-1].name != "html":
                 self.parser.parseError("eof-in-table")
             else:
@@ -1717,18 +3184,51 @@
             # Stop parsing
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             originalPhase = self.parser.phase
             self.parser.phase = self.parser.phases["inTableText"]
             self.parser.phase.originalPhase = originalPhase
             self.parser.phase.processSpaceCharacters(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             originalPhase = self.parser.phase
             self.parser.phase = self.parser.phases["inTableText"]
             self.parser.phase.originalPhase = originalPhase
             self.parser.phase.processCharacters(token)
 
         def insertText(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # If we get here there must be at least one non-whitespace character
             # Do the table magic!
             self.tree.insertFromTable = True
@@ -1736,30 +3236,96 @@
             self.tree.insertFromTable = False
 
         def startTagCaption(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.clearStackToTableContext()
             self.tree.activeFormattingElements.append(Marker)
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inCaption"]
 
         def startTagColgroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.clearStackToTableContext()
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inColumnGroup"]
 
         def startTagCol(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.startTagColgroup(impliedTagToken("colgroup", "StartTag"))
             return token
 
         def startTagRowGroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.clearStackToTableContext()
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inTableBody"]
 
         def startTagImplyTbody(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.startTagRowGroup(impliedTagToken("tbody", "StartTag"))
             return token
 
         def startTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                    {"startName": "table", "endName": "table"})
             self.parser.phase.processEndTag(impliedTagToken("table"))
@@ -1767,9 +3333,31 @@
                 return token
 
         def startTagStyleScript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagInput(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if ("type" in token["data"] and
                     token["data"]["type"].translate(asciiUpper2Lower) == "hidden"):
                 self.parser.parseError("unexpected-hidden-input-in-table")
@@ -1780,6 +3368,17 @@
                 self.startTagOther(token)
 
         def startTagForm(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-form-in-table")
             if self.tree.formPointer is None:
                 self.tree.insertElement(token)
@@ -1787,6 +3386,17 @@
                 self.tree.openElements.pop()
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-implies-table-voodoo", {"name": token["name"]})
             # Do the table magic!
             self.tree.insertFromTable = True
@@ -1794,6 +3404,17 @@
             self.tree.insertFromTable = False
 
         def endTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("table", variant="table"):
                 self.tree.generateImpliedEndTags()
                 if self.tree.openElements[-1].name != "table":
@@ -1810,9 +3431,31 @@
                 self.parser.parseError()
 
         def endTagIgnore(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-implies-table-voodoo", {"name": token["name"]})
             # Do the table magic!
             self.tree.insertFromTable = True
@@ -1841,6 +3484,7 @@
         endTagHandler.default = endTagOther
 
     class InTableTextPhase(Phase):
+        """ """
         __slots__ = ("originalPhase", "characterTokens")
 
         def __init__(self, *args, **kwargs):
@@ -1849,6 +3493,7 @@
             self.characterTokens = []
 
         def flushCharacters(self):
+            """ """
             data = "".join([item["data"] for item in self.characterTokens])
             if any([item not in spaceCharacters for item in data]):
                 token = {"type": tokenTypes["Characters"], "data": data}
@@ -1858,49 +3503,130 @@
             self.characterTokens = []
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.flushCharacters()
             self.parser.phase = self.originalPhase
             return token
 
         def processEOF(self):
+            """ """
             self.flushCharacters()
             self.parser.phase = self.originalPhase
             return True
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["data"] == "\u0000":
                 return
             self.characterTokens.append(token)
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # pretty sure we should never reach here
             self.characterTokens.append(token)
     #        assert False
 
         def processStartTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.flushCharacters()
             self.parser.phase = self.originalPhase
             return token
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.flushCharacters()
             self.parser.phase = self.originalPhase
             return token
 
     class InCaptionPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-caption
         __slots__ = tuple()
 
         def ignoreEndTagCaption(self):
+            """ """
             return not self.tree.elementInScope("caption", variant="table")
 
         def processEOF(self):
+            """ """
             self.parser.phases["inBody"].processEOF()
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processCharacters(token)
 
         def startTagTableElement(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError()
             # XXX Have to duplicate logic here to find out if the tag is ignored
             ignoreEndTag = self.ignoreEndTagCaption()
@@ -1909,9 +3635,31 @@
                 return token
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def endTagCaption(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if not self.ignoreEndTagCaption():
                 # AT this code is quite similar to endTagTable in "InTable"
                 self.tree.generateImpliedEndTags()
@@ -1930,6 +3678,17 @@
                 self.parser.parseError()
 
         def endTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError()
             ignoreEndTag = self.ignoreEndTagCaption()
             self.parser.phase.processEndTag(impliedTagToken("caption"))
@@ -1937,9 +3696,31 @@
                 return token
 
         def endTagIgnore(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processEndTag(token)
 
         startTagHandler = _utils.MethodDispatcher([
@@ -1958,13 +3739,16 @@
         endTagHandler.default = endTagOther
 
     class InColumnGroupPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-column
         __slots__ = tuple()
 
         def ignoreEndTagColgroup(self):
+            """ """
             return self.tree.openElements[-1].name == "html"
 
         def processEOF(self):
+            """ """
             if self.tree.openElements[-1].name == "html":
                 assert self.parser.innerHTML
                 return
@@ -1975,23 +3759,67 @@
                     return True
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             ignoreEndTag = self.ignoreEndTagColgroup()
             self.endTagColgroup(impliedTagToken("colgroup"))
             if not ignoreEndTag:
                 return token
 
         def startTagCol(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.openElements.pop()
             token["selfClosingAcknowledged"] = True
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             ignoreEndTag = self.ignoreEndTagColgroup()
             self.endTagColgroup(impliedTagToken("colgroup"))
             if not ignoreEndTag:
                 return token
 
         def endTagColgroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.ignoreEndTagColgroup():
                 # innerHTML case
                 assert self.parser.innerHTML
@@ -2001,9 +3829,31 @@
                 self.parser.phase = self.parser.phases["inTable"]
 
         def endTagCol(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("no-end-tag", {"name": "col"})
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             ignoreEndTag = self.ignoreEndTagColgroup()
             self.endTagColgroup(impliedTagToken("colgroup"))
             if not ignoreEndTag:
@@ -2022,11 +3872,13 @@
         endTagHandler.default = endTagOther
 
     class InTableBodyPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-table0
         __slots__ = tuple()
 
         # helper methods
         def clearStackToTableBodyContext(self):
+            """ """
             while self.tree.openElements[-1].name not in ("tbody", "tfoot",
                                                           "thead", "html"):
                 # self.parser.parseError("unexpected-implied-end-tag-in-table",
@@ -2037,26 +3889,82 @@
 
         # the rest
         def processEOF(self):
+            """ """
             self.parser.phases["inTable"].processEOF()
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processSpaceCharacters(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processCharacters(token)
 
         def startTagTr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.clearStackToTableBodyContext()
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inRow"]
 
         def startTagTableCell(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-cell-in-table-body",
                                    {"name": token["name"]})
             self.startTagTr(impliedTagToken("tr", "StartTag"))
             return token
 
         def startTagTableOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # XXX AT Any ideas on how to share this with endTagTable?
             if (self.tree.elementInScope("tbody", variant="table") or
                 self.tree.elementInScope("thead", variant="table") or
@@ -2071,9 +3979,31 @@
                 self.parser.parseError()
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processStartTag(token)
 
         def endTagTableRowGroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope(token["name"], variant="table"):
                 self.clearStackToTableBodyContext()
                 self.tree.openElements.pop()
@@ -2083,6 +4013,17 @@
                                        {"name": token["name"]})
 
         def endTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if (self.tree.elementInScope("tbody", variant="table") or
                 self.tree.elementInScope("thead", variant="table") or
                     self.tree.elementInScope("tfoot", variant="table")):
@@ -2096,10 +4037,32 @@
                 self.parser.parseError()
 
         def endTagIgnore(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-in-table-body",
                                    {"name": token["name"]})
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processEndTag(token)
 
         startTagHandler = _utils.MethodDispatcher([
@@ -2120,36 +4083,84 @@
         endTagHandler.default = endTagOther
 
     class InRowPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-row
         __slots__ = tuple()
 
         # helper methods (XXX unify this with other table helper methods)
         def clearStackToTableRowContext(self):
+            """ """
             while self.tree.openElements[-1].name not in ("tr", "html"):
                 self.parser.parseError("unexpected-implied-end-tag-in-table-row",
                                        {"name": self.tree.openElements[-1].name})
                 self.tree.openElements.pop()
 
         def ignoreEndTagTr(self):
+            """ """
             return not self.tree.elementInScope("tr", variant="table")
 
         # the rest
         def processEOF(self):
+            """ """
             self.parser.phases["inTable"].processEOF()
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processSpaceCharacters(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processCharacters(token)
 
         def startTagTableCell(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.clearStackToTableRowContext()
             self.tree.insertElement(token)
             self.parser.phase = self.parser.phases["inCell"]
             self.tree.activeFormattingElements.append(Marker)
 
         def startTagTableOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             ignoreEndTag = self.ignoreEndTagTr()
             self.endTagTr(impliedTagToken("tr"))
             # XXX how are we sure it's always ignored in the innerHTML case?
@@ -2157,9 +4168,31 @@
                 return token
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processStartTag(token)
 
         def endTagTr(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if not self.ignoreEndTagTr():
                 self.clearStackToTableRowContext()
                 self.tree.openElements.pop()
@@ -2170,6 +4203,17 @@
                 self.parser.parseError()
 
         def endTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             ignoreEndTag = self.ignoreEndTagTr()
             self.endTagTr(impliedTagToken("tr"))
             # Reprocess the current tag if the tr end tag was not ignored
@@ -2178,6 +4222,17 @@
                 return token
 
         def endTagTableRowGroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope(token["name"], variant="table"):
                 self.endTagTr(impliedTagToken("tr"))
                 return token
@@ -2185,10 +4240,32 @@
                 self.parser.parseError()
 
         def endTagIgnore(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-in-table-row",
                                    {"name": token["name"]})
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inTable"].processEndTag(token)
 
         startTagHandler = _utils.MethodDispatcher([
@@ -2209,11 +4286,13 @@
         endTagHandler.default = endTagOther
 
     class InCellPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-cell
         __slots__ = tuple()
 
         # helper
         def closeCell(self):
+            """ """
             if self.tree.elementInScope("td", variant="table"):
                 self.endTagTableCell(impliedTagToken("td"))
             elif self.tree.elementInScope("th", variant="table"):
@@ -2221,12 +4300,35 @@
 
         # the rest
         def processEOF(self):
+            """ """
             self.parser.phases["inBody"].processEOF()
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processCharacters(token)
 
         def startTagTableOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if (self.tree.elementInScope("td", variant="table") or
                     self.tree.elementInScope("th", variant="table")):
                 self.closeCell()
@@ -2237,9 +4339,31 @@
                 self.parser.parseError()
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def endTagTableCell(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope(token["name"], variant="table"):
                 self.tree.generateImpliedEndTags(token["name"])
                 if self.tree.openElements[-1].name != token["name"]:
@@ -2257,9 +4381,31 @@
                 self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def endTagIgnore(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
 
         def endTagImply(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope(token["name"], variant="table"):
                 self.closeCell()
                 return token
@@ -2268,6 +4414,17 @@
                 self.parser.parseError()
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processEndTag(token)
 
         startTagHandler = _utils.MethodDispatcher([
@@ -2285,27 +4442,62 @@
         endTagHandler.default = endTagOther
 
     class InSelectPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         # http://www.whatwg.org/specs/web-apps/current-work/#in-select
         def processEOF(self):
+            """ """
             if self.tree.openElements[-1].name != "html":
                 self.parser.parseError("eof-in-select")
             else:
                 assert self.parser.innerHTML
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["data"] == "\u0000":
                 return
             self.tree.insertText(token["data"])
 
         def startTagOption(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # We need to imply </option> if <option> is the current node.
             if self.tree.openElements[-1].name == "option":
                 self.tree.openElements.pop()
             self.tree.insertElement(token)
 
         def startTagOptgroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.openElements[-1].name == "option":
                 self.tree.openElements.pop()
             if self.tree.openElements[-1].name == "optgroup":
@@ -2313,10 +4505,32 @@
             self.tree.insertElement(token)
 
         def startTagSelect(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-select-in-select")
             self.endTagSelect(impliedTagToken("select"))
 
         def startTagInput(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-input-in-select")
             if self.tree.elementInScope("select", variant="select"):
                 self.endTagSelect(impliedTagToken("select"))
@@ -2325,13 +4539,46 @@
                 assert self.parser.innerHTML
 
         def startTagScript(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-in-select",
                                    {"name": token["name"]})
 
         def endTagOption(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.openElements[-1].name == "option":
                 self.tree.openElements.pop()
             else:
@@ -2339,6 +4586,17 @@
                                        {"name": "option"})
 
         def endTagOptgroup(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # </optgroup> implicitly closes <option>
             if (self.tree.openElements[-1].name == "option" and
                     self.tree.openElements[-2].name == "optgroup"):
@@ -2352,6 +4610,17 @@
                                        {"name": "optgroup"})
 
         def endTagSelect(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.elementInScope("select", variant="select"):
                 node = self.tree.openElements.pop()
                 while node.name != "select":
@@ -2363,6 +4632,17 @@
                 self.parser.parseError()
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-in-select",
                                    {"name": token["name"]})
 
@@ -2384,29 +4664,86 @@
         endTagHandler.default = endTagOther
 
     class InSelectInTablePhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             self.parser.phases["inSelect"].processEOF()
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inSelect"].processCharacters(token)
 
         def startTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-table-element-start-tag-in-select-in-table", {"name": token["name"]})
             self.endTagOther(impliedTagToken("select"))
             return token
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inSelect"].processStartTag(token)
 
         def endTagTable(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-table-element-end-tag-in-select-in-table", {"name": token["name"]})
             if self.tree.elementInScope(token["name"], variant="table"):
                 self.endTagOther(impliedTagToken("select"))
                 return token
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inSelect"].processEndTag(token)
 
         startTagHandler = _utils.MethodDispatcher([
@@ -2422,6 +4759,7 @@
         endTagHandler.default = endTagOther
 
     class InForeignContentPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         breakoutElements = frozenset(["b", "big", "blockquote", "body", "br",
@@ -2434,6 +4772,17 @@
                                       "table", "tt", "u", "ul", "var"])
 
         def adjustSVGTagNames(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             replacements = {"altglyph": "altGlyph",
                             "altglyphdef": "altGlyphDef",
                             "altglyphitem": "altGlyphItem",
@@ -2475,6 +4824,17 @@
                 token["name"] = replacements[token["name"]]
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if token["data"] == "\u0000":
                 token["data"] = "\uFFFD"
             elif (self.parser.framesetOK and
@@ -2483,6 +4843,17 @@
             Phase.processCharacters(self, token)
 
         def processStartTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             currentNode = self.tree.openElements[-1]
             if (token["name"] in self.breakoutElements or
                 (token["name"] == "font" and
@@ -2510,6 +4881,17 @@
                     token["selfClosingAcknowledged"] = True
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             nodeIndex = len(self.tree.openElements) - 1
             node = self.tree.openElements[-1]
             if node.name.translate(asciiUpper2Lower) != token["name"]:
@@ -2536,38 +4918,106 @@
             return new_token
 
     class AfterBodyPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             # Stop parsing
             pass
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             # This is needed because data is to be appended to the <html> element
             # here and not to whatever is currently open.
             self.tree.insertComment(token, self.tree.openElements[0])
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-char-after-body")
             self.parser.phase = self.parser.phases["inBody"]
             return token
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-after-body",
                                    {"name": token["name"]})
             self.parser.phase = self.parser.phases["inBody"]
             return token
 
         def endTagHtml(self, name):
+            """
+
+            Parameters
+            ----------
+            name :
+                
+
+            Returns
+            -------
+
+            """
             if self.parser.innerHTML:
                 self.parser.parseError("unexpected-end-tag-after-body-innerhtml")
             else:
                 self.parser.phase = self.parser.phases["afterAfterBody"]
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-after-body",
                                    {"name": token["name"]})
             self.parser.phase = self.parser.phases["inBody"]
@@ -2582,33 +5032,101 @@
         endTagHandler.default = endTagOther
 
     class InFramesetPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#in-frameset
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             if self.tree.openElements[-1].name != "html":
                 self.parser.parseError("eof-in-frameset")
             else:
                 assert self.parser.innerHTML
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-char-in-frameset")
 
         def startTagFrameset(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
 
         def startTagFrame(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertElement(token)
             self.tree.openElements.pop()
 
         def startTagNoframes(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-in-frameset",
                                    {"name": token["name"]})
 
         def endTagFrameset(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             if self.tree.openElements[-1].name == "html":
                 # innerHTML case
                 self.parser.parseError("unexpected-frameset-in-frameset-innerhtml")
@@ -2621,6 +5139,17 @@
                 self.parser.phase = self.parser.phases["afterFrameset"]
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-in-frameset",
                                    {"name": token["name"]})
 
@@ -2638,27 +5167,84 @@
         endTagHandler.default = endTagOther
 
     class AfterFramesetPhase(Phase):
+        """ """
         # http://www.whatwg.org/specs/web-apps/current-work/#after3
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             # Stop parsing
             pass
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-char-after-frameset")
 
         def startTagNoframes(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-start-tag-after-frameset",
                                    {"name": token["name"]})
 
         def endTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.phase = self.parser.phases["afterAfterFrameset"]
 
         def endTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("unexpected-end-tag-after-frameset",
                                    {"name": token["name"]})
 
@@ -2674,32 +5260,100 @@
         endTagHandler.default = endTagOther
 
     class AfterAfterBodyPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             pass
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertComment(token, self.tree.document)
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processSpaceCharacters(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-char")
             self.parser.phase = self.parser.phases["inBody"]
             return token
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-start-tag",
                                    {"name": token["name"]})
             self.parser.phase = self.parser.phases["inBody"]
             return token
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-end-tag",
                                    {"name": token["name"]})
             self.parser.phase = self.parser.phases["inBody"]
@@ -2711,31 +5365,110 @@
         startTagHandler.default = startTagOther
 
     class AfterAfterFramesetPhase(Phase):
+        """ """
         __slots__ = tuple()
 
         def processEOF(self):
+            """ """
             pass
 
         def processComment(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.tree.insertComment(token, self.tree.document)
 
         def processSpaceCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processSpaceCharacters(token)
 
         def processCharacters(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-char")
 
         def startTagHtml(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inBody"].processStartTag(token)
 
         def startTagNoFrames(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             return self.parser.phases["inHead"].processStartTag(token)
 
         def startTagOther(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-start-tag",
                                    {"name": token["name"]})
 
         def processEndTag(self, token):
+            """
+
+            Parameters
+            ----------
+            token :
+                
+
+            Returns
+            -------
+
+            """
             self.parser.parseError("expected-eof-but-got-end-tag",
                                    {"name": token["name"]})
 
@@ -2776,6 +5509,19 @@
 
 
 def adjust_attributes(token, replacements):
+    """
+
+    Parameters
+    ----------
+    token :
+        
+    replacements :
+        
+
+    Returns
+    -------
+
+    """
     needs_adjustment = viewkeys(token['data']) & viewkeys(replacements)
     if needs_adjustment:
         token['data'] = type(token['data'])((replacements.get(k, k), v)
@@ -2784,6 +5530,23 @@
 
 def impliedTagToken(name, type="EndTag", attributes=None,
                     selfClosing=False):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+    type :
+         (Default value = "EndTag")
+    attributes :
+         (Default value = None)
+    selfClosing :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     if attributes is None:
         attributes = {}
     return {"type": tokenTypes[type], "name": name, "data": attributes,
