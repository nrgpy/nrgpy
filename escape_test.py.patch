# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/escape_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/escape_test.py
@@ -210,12 +210,15 @@
 
 
 class EscapeTestCase(unittest.TestCase):
+    """ """
     def test_linkify(self):
+        """ """
         for text, kwargs, html in linkify_tests:
             linked = tornado.escape.linkify(text, **kwargs)
             self.assertEqual(linked, html)
 
     def test_xhtml_escape(self):
+        """ """
         tests = [
             ("<foo>", "&lt;foo&gt;"),
             (u"<foo>", u"&lt;foo&gt;"),
@@ -230,6 +233,7 @@
             self.assertEqual(utf8(unescaped), utf8(xhtml_unescape(escaped)))
 
     def test_xhtml_unescape_numeric(self):
+        """ """
         tests = [
             ("foo&#32;bar", "foo bar"),
             ("foo&#x20;bar", "foo bar"),
@@ -243,6 +247,7 @@
             self.assertEqual(unescaped, xhtml_unescape(escaped))
 
     def test_url_escape_unicode(self):
+        """ """
         tests = [
             # byte strings are passed through as-is
             (u"\u00e9".encode("utf8"), "%C3%A9"),
@@ -254,6 +259,7 @@
             self.assertEqual(url_escape(unescaped), escaped)
 
     def test_url_unescape_unicode(self):
+        """ """
         tests = [
             ("%C3%A9", u"\u00e9", "utf8"),
             ("%C3%A9", u"\u00c3\u00a9", "latin1"),
@@ -267,6 +273,7 @@
             self.assertEqual(url_unescape(utf8(escaped), encoding), unescaped)
 
     def test_url_escape_quote_plus(self):
+        """ """
         unescaped = "+ #%"
         plus_escaped = "%2B+%23%25"
         escaped = "%2B%20%23%25"
@@ -280,12 +287,14 @@
         )
 
     def test_escape_return_types(self):
+        """ """
         # On python2 the escape methods should generally return the same
         # type as their argument
         self.assertEqual(type(xhtml_escape("foo")), str)
         self.assertEqual(type(xhtml_escape(u"foo")), unicode_type)
 
     def test_json_decode(self):
+        """ """
         # json_decode accepts both bytes and unicode, but strings it returns
         # are always unicode.
         self.assertEqual(json_decode(b'"foo"'), u"foo")
@@ -295,6 +304,7 @@
         self.assertEqual(json_decode(utf8(u'"\u00e9"')), u"\u00e9")
 
     def test_json_encode(self):
+        """ """
         # json deals with strings, not bytes.  On python 2 byte strings will
         # convert automatically if they are utf8; on python 3 byte strings
         # are not allowed.
@@ -304,12 +314,14 @@
             self.assertRaises(UnicodeDecodeError, json_encode, b"\xe9")
 
     def test_squeeze(self):
+        """ """
         self.assertEqual(
             squeeze(u"sequences     of    whitespace   chars"),
             u"sequences of whitespace chars",
         )
 
     def test_recursive_unicode(self):
+        """ """
         tests = {
             "dict": {b"foo": b"bar"},
             "list": [b"foo", b"bar"],
