# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/tools/test_to_datetime.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/tools/test_to_datetime.py
@@ -36,8 +36,20 @@
 
 
 class TestTimeConversionFormats:
+    """ """
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         values = ["1/1/2000", "1/2/2000", "1/3/2000"]
 
         results1 = [Timestamp("20000101"), Timestamp("20000201"), Timestamp("20000301")]
@@ -63,6 +75,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format_YYYYMMDD(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         s = Series([19801222, 19801222] + [19810105] * 5)
         expected = Series([Timestamp(x) for x in s.apply(str)])
 
@@ -118,6 +141,17 @@
         ],
     )
     def test_to_datetime_format_YYYYMMDD_with_none(self, input_s):
+        """
+
+        Parameters
+        ----------
+        input_s :
+            
+
+        Returns
+        -------
+
+        """
         # GH 30011
         # format='%Y%m%d'
         # with None
@@ -151,6 +185,19 @@
         ],
     )
     def test_to_datetime_format_YYYYMMDD_overflow(self, input_s, expected):
+        """
+
+        Parameters
+        ----------
+        input_s :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 25512
         # format='%Y%m%d', errors='coerce'
         result = pd.to_datetime(input_s, format="%Y%m%d", errors="coerce")
@@ -158,6 +205,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format_integer(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 10178
         s = Series([2000, 2001, 2002])
         expected = Series([Timestamp(x) for x in s.apply(str)])
@@ -189,12 +247,36 @@
         ],
     )
     def test_int_to_datetime_format_YYYYMMDD_typeerror(self, int_date, expected):
+        """
+
+        Parameters
+        ----------
+        int_date :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 26583
         result = to_datetime(int_date, format="%Y%m%d", errors="ignore")
         assert result == expected
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format_microsecond(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # these are locale dependent
         lang, _ = locale.getlocale()
@@ -208,6 +290,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format_time(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         data = [
             ["01/10/2010 15:20", "%m/%d/%Y %H:%M", Timestamp("2010-01-10 15:20")],
             ["01/10/2010 05:43", "%m/%d/%Y %I:%M", Timestamp("2010-01-10 05:43")],
@@ -229,6 +322,17 @@
     @td.skip_if_has_locale
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_with_non_exact(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 10834
         # 8904
         # exact kw
@@ -243,6 +347,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_parse_nanoseconds_with_formula(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH8989
         # truncating the nanoseconds when a format was provided
@@ -259,6 +374,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_format_weeks(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         data = [
             ["2009324", "%Y%W%w", Timestamp("2009-08-13")],
             ["2013020", "%Y%U%w", Timestamp("2013-01-13")],
@@ -318,12 +444,28 @@
         ],
     )
     def test_to_datetime_parse_tzname_or_tzoffset(self, fmt, dates, expected_dates):
+        """
+
+        Parameters
+        ----------
+        fmt :
+            
+        dates :
+            
+        expected_dates :
+            
+
+        Returns
+        -------
+
+        """
         # GH 13486
         result = pd.to_datetime(dates, format=fmt)
         expected = pd.Index(expected_dates)
         tm.assert_equal(result, expected)
 
     def test_to_datetime_parse_tzname_or_tzoffset_different_tz_to_utc(self):
+        """ """
         # GH 32792
         dates = [
             "2010-01-01 12:00:00 +0100",
@@ -347,12 +489,24 @@
         "offset", ["+0", "-1foo", "UTCbar", ":10", "+01:000:01", ""]
     )
     def test_to_datetime_parse_timezone_malformed(self, offset):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+
+        Returns
+        -------
+
+        """
         fmt = "%Y-%m-%d %H:%M:%S %z"
         date = "2010-01-01 12:00:00 " + offset
         with pytest.raises(ValueError):
             pd.to_datetime([date], format=fmt)
 
     def test_to_datetime_parse_timezone_keeps_name(self):
+        """ """
         # GH 21697
         fmt = "%Y-%m-%d %H:%M:%S %z"
         arg = pd.Index(["2010-01-01 12:00:00 Z"], name="foo")
@@ -362,6 +516,7 @@
 
 
 class TestToDatetime:
+    """ """
     @pytest.mark.parametrize(
         "s, _format, dt",
         [
@@ -371,6 +526,21 @@
         ],
     )
     def test_to_datetime_iso_week_year_format(self, s, _format, dt):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        _format :
+            
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         # See GH#16607
         assert to_datetime(s, format=_format) == dt
 
@@ -458,6 +628,21 @@
         ],
     )
     def test_error_iso_week_year(self, msg, s, _format):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+        s :
+            
+        _format :
+            
+
+        Returns
+        -------
+
+        """
         # See GH#16607
         # This test checks for errors thrown when giving the wrong format
         # However, as discussed on PR#25541, overriding the locale
@@ -474,6 +659,17 @@
 
     @pytest.mark.parametrize("tz", [None, "US/Central"])
     def test_to_datetime_dtarr(self, tz):
+        """
+
+        Parameters
+        ----------
+        tz :
+            
+
+        Returns
+        -------
+
+        """
         # DatetimeArray
         dti = date_range("1965-04-03", periods=19, freq="2W", tz=tz)
         arr = DatetimeArray(dti)
@@ -485,20 +681,24 @@
         assert result is arr
 
     def test_to_datetime_pydatetime(self):
+        """ """
         actual = pd.to_datetime(datetime(2008, 1, 15))
         assert actual == datetime(2008, 1, 15)
 
     def test_to_datetime_YYYYMMDD(self):
+        """ """
         actual = pd.to_datetime("20080115")
         assert actual == datetime(2008, 1, 15)
 
     def test_to_datetime_unparseable_ignore(self):
+        """ """
         # unparseable
         s = "Month 1, 1999"
         assert pd.to_datetime(s, errors="ignore") == s
 
     @td.skip_if_windows  # `tm.set_timezone` does not work in windows
     def test_to_datetime_now(self):
+        """ """
         # See GH#18666
         with tm.set_timezone("US/Eastern"):
             npnow = np.datetime64("now").astype("datetime64[ns]")
@@ -515,6 +715,7 @@
 
     @td.skip_if_windows  # `tm.set_timezone` does not work in windows
     def test_to_datetime_today(self):
+        """ """
         # See GH#18666
         # Test with one timezone far ahead of UTC and another far behind, so
         # one of these will _almost_ always be in a different day from UTC.
@@ -553,11 +754,23 @@
             assert pdtoday2.tzinfo is None
 
     def test_to_datetime_today_now_unicode_bytes(self):
+        """ """
         to_datetime(["now"])
         to_datetime(["today"])
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_dt64s(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         in_bound_dts = [np.datetime64("2000-01-01"), np.datetime64("2000-01-02")]
 
         for dt in in_bound_dts:
@@ -568,6 +781,19 @@
     )
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_dt64s_out_of_bounds(self, cache, dt):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         msg = f"Out of bounds nanosecond timestamp: {dt}"
         with pytest.raises(OutOfBoundsDatetime, match=msg):
             pd.to_datetime(dt, errors="raise")
@@ -578,6 +804,19 @@
     @pytest.mark.parametrize("cache", [True, False])
     @pytest.mark.parametrize("unit", ["s", "D"])
     def test_to_datetime_array_of_dt64s(self, cache, unit):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        unit :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/31491
         # Need at least 50 to ensure cache is used.
         dts = [
@@ -616,6 +855,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_tz(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # xref 8260
         # uniform returns a DatetimeIndex
@@ -643,6 +893,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_different_offsets(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # inspired by asv timeseries.ToDatetimeNONISO8601 benchmark
         # see GH-26097 for more
         ts_string_1 = "March 1, 2018 12:00:00+0400"
@@ -654,6 +915,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_tz_pytz(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-8260
         us_eastern = pytz.timezone("US/Eastern")
         arr = np.array(
@@ -688,6 +960,23 @@
     def test_to_datetime_utc_true(
         self, cache, init_constructor, end_constructor, test_method
     ):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        init_constructor :
+            
+        end_constructor :
+            
+        test_method :
+            
+
+        Returns
+        -------
+
+        """
         # See gh-11934 & gh-6415
         data = ["20100102 121314", "20100102 121315"]
         expected_data = [
@@ -710,6 +999,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_utc_true_with_series_single_value(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 15760 UTC=True with Series
         ts = 1.5e18
         result = pd.to_datetime(pd.Series([ts]), utc=True, cache=cache)
@@ -718,6 +1018,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_utc_true_with_series_tzaware_string(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         ts = "2013-01-01 00:00:00-01:00"
         expected_ts = "2013-01-01 01:00:00"
         data = pd.Series([ts] * 3)
@@ -734,6 +1045,21 @@
         ],
     )
     def test_to_datetime_utc_true_with_series_datetime_ns(self, cache, date, dtype):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        date :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         expected = pd.Series([pd.Timestamp("2013-01-01 01:00:00", tz="UTC")])
         result = pd.to_datetime(pd.Series([date], dtype=dtype), utc=True, cache=cache)
         tm.assert_series_equal(result, expected)
@@ -741,6 +1067,17 @@
     @pytest.mark.parametrize("cache", [True, False])
     @td.skip_if_no("psycopg2")
     def test_to_datetime_tz_psycopg2(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # xref 8260
         import psycopg2
@@ -783,6 +1120,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_datetime_bool(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH13176
         with pytest.raises(TypeError):
             to_datetime(False)
@@ -804,6 +1152,7 @@
         )
 
     def test_datetime_invalid_datatype(self):
+        """ """
         # GH13176
 
         with pytest.raises(TypeError):
@@ -815,6 +1164,21 @@
     @pytest.mark.parametrize("infer", [True, False])
     @pytest.mark.parametrize("format", [None, "H%:M%:S%"])
     def test_datetime_invalid_scalar(self, value, format, infer):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        format :
+            
+        infer :
+            
+
+        Returns
+        -------
+
+        """
         # GH24763
         res = pd.to_datetime(
             value, errors="ignore", format=format, infer_datetime_format=infer
@@ -835,6 +1199,21 @@
     @pytest.mark.parametrize("infer", [True, False])
     @pytest.mark.parametrize("format", [None, "H%:M%:S%"])
     def test_datetime_outofbounds_scalar(self, value, format, infer):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        format :
+            
+        infer :
+            
+
+        Returns
+        -------
+
+        """
         # GH24763
         res = pd.to_datetime(
             value, errors="ignore", format=format, infer_datetime_format=infer
@@ -861,6 +1240,21 @@
     @pytest.mark.parametrize("infer", [True, False])
     @pytest.mark.parametrize("format", [None, "H%:M%:S%"])
     def test_datetime_invalid_index(self, values, format, infer):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        format :
+            
+        infer :
+            
+
+        Returns
+        -------
+
+        """
         # GH24763
         res = pd.to_datetime(
             values, errors="ignore", format=format, infer_datetime_format=infer
@@ -881,6 +1275,21 @@
     @pytest.mark.parametrize("format", ["%Y%m%d %H:%M:%S", None])
     @pytest.mark.parametrize("constructor", [list, tuple, np.array, pd.Index, deque])
     def test_to_datetime_cache(self, utc, format, constructor):
+        """
+
+        Parameters
+        ----------
+        utc :
+            
+        format :
+            
+        constructor :
+            
+
+        Returns
+        -------
+
+        """
         date = "20130101 00:00:00"
         test_dates = [date] * 10 ** 5
         data = constructor(test_dates)
@@ -899,10 +1308,22 @@
         ],
     )
     def test_no_slicing_errors_in_should_cache(self, listlike):
+        """
+
+        Parameters
+        ----------
+        listlike :
+            
+
+        Returns
+        -------
+
+        """
         # GH 29403
         assert tools.should_cache(listlike) is True
 
     def test_to_datetime_from_deque(self):
+        """ """
         # GH 29403
         result = pd.to_datetime(deque([pd.Timestamp("2010-06-02 09:30:00")] * 51))
         expected = pd.to_datetime([pd.Timestamp("2010-06-02 09:30:00")] * 51)
@@ -911,6 +1332,19 @@
     @pytest.mark.parametrize("utc", [True, None])
     @pytest.mark.parametrize("format", ["%Y%m%d %H:%M:%S", None])
     def test_to_datetime_cache_series(self, utc, format):
+        """
+
+        Parameters
+        ----------
+        utc :
+            
+        format :
+            
+
+        Returns
+        -------
+
+        """
         date = "20130101 00:00:00"
         test_dates = [date] * 10 ** 5
         data = pd.Series(test_dates)
@@ -919,6 +1353,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_to_datetime_cache_scalar(self):
+        """ """
         date = "20130101 00:00:00"
         result = pd.to_datetime(date, cache=True)
         expected = pd.Timestamp("20130101 00:00:00")
@@ -936,6 +1371,19 @@
         ],
     )
     def test_week_without_day_and_calendar_year(self, date, format):
+        """
+
+        Parameters
+        ----------
+        date :
+            
+        format :
+            
+
+        Returns
+        -------
+
+        """
         # GH16774
 
         msg = "Cannot use '%W' or '%U' without day and year"
@@ -943,6 +1391,7 @@
             pd.to_datetime(date, format=format)
 
     def test_to_datetime_coerce(self):
+        """ """
         # GH 26122
         ts_strings = [
             "March 1, 2018 12:00:00+0400",
@@ -960,6 +1409,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_to_datetime_coerce_malformed(self):
+        """ """
         # GH 28299
         ts_strings = ["200622-12-31", "111111-24-11"]
         result = to_datetime(ts_strings, errors="coerce")
@@ -967,6 +1417,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_iso_8601_strings_with_same_offset(self):
+        """ """
         # GH 17697, 11736
         ts_str = "2015-11-18 15:30:00+05:30"
         result = to_datetime(ts_str)
@@ -981,6 +1432,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_iso_8601_strings_with_different_offsets(self):
+        """ """
         # GH 17697, 11736
         ts_strings = ["2015-11-18 15:30:00+05:30", "2015-11-18 16:30:00+06:30", NaT]
         result = to_datetime(ts_strings)
@@ -1003,6 +1455,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_iso8601_strings_mixed_offsets_with_naive(self):
+        """ """
         # GH 24992
         result = pd.to_datetime(
             [
@@ -1032,6 +1485,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_mixed_offsets_with_native_datetime_raises(self):
+        """ """
         # GH 25978
         s = pd.Series(
             [
@@ -1046,6 +1500,7 @@
             pd.to_datetime(s)
 
     def test_non_iso_strings_with_tz_offset(self):
+        """ """
         result = to_datetime(["March 1, 2018 12:00:00+0400"] * 2)
         expected = DatetimeIndex(
             [datetime(2018, 3, 1, 12, tzinfo=pytz.FixedOffset(240))] * 2
@@ -1063,23 +1518,49 @@
         ],
     )
     def test_timestamp_utc_true(self, ts, expected):
+        """
+
+        Parameters
+        ----------
+        ts :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 24415
         result = to_datetime(ts, utc=True)
         assert result == expected
 
     @pytest.mark.parametrize("dt_str", ["00010101", "13000101", "30000101", "99990101"])
     def test_to_datetime_with_format_out_of_bounds(self, dt_str):
+        """
+
+        Parameters
+        ----------
+        dt_str :
+            
+
+        Returns
+        -------
+
+        """
         # GH 9107
         with pytest.raises(OutOfBoundsDatetime):
             pd.to_datetime(dt_str, format="%Y%m%d")
 
     def test_to_datetime_utc(self):
+        """ """
         arr = np.array([parse("2012-06-13T01:39:00Z")], dtype=object)
 
         result = to_datetime(arr, utc=True)
         assert result.tz is pytz.utc
 
     def test_to_datetime_fixed_offset(self):
+        """ """
         from pandas.tests.indexes.datetimes.test_timezones import fixed_off
 
         dates = [
@@ -1092,8 +1573,20 @@
 
 
 class TestToDatetimeUnit:
+    """ """
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 11758
         # test proper behavior with errors
 
@@ -1151,6 +1644,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit_consistency(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # consistency of conversions
         expected = Timestamp("1970-05-09 14:25:11")
@@ -1168,6 +1672,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit_with_numeric(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH 13180
         # coercions from floats/ints are ok
@@ -1197,6 +1712,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit_mixed(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # mixed integers/datetimes
         expected = DatetimeIndex(["2013-01-01", "NaT", "NaT"])
@@ -1217,6 +1743,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit_rounding(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 14156: argument will incur floating point errors but no
         # premature rounding
         result = pd.to_datetime(1434743731.8770001, unit="s", cache=cache)
@@ -1225,6 +1762,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_unit_ignore_keeps_name(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 21697
         expected = pd.Index([15e9] * 2, name="name")
         result = pd.to_datetime(expected, errors="ignore", unit="s", cache=cache)
@@ -1232,6 +1780,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_dataframe(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         df = DataFrame(
             {
@@ -1371,6 +1930,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_dataframe_dtypes(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # #13451
         df = DataFrame({"year": [2015, 2016], "month": [2, 3], "day": [4, 5]})
 
@@ -1396,6 +1966,7 @@
             to_datetime(df, cache=cache)
 
     def test_dataframe_utc_true(self):
+        """ """
         # GH 23760
         df = pd.DataFrame({"year": [2015, 2016], "month": [2, 3], "day": [4, 5]})
         result = pd.to_datetime(df, utc=True)
@@ -1405,6 +1976,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_to_datetime_errors_ignore_utc_true(self):
+        """ """
         # GH 23758
         result = pd.to_datetime([1], unit="s", utc=True, errors="ignore")
         expected = DatetimeIndex(["1970-01-01 00:00:01"], tz="UTC")
@@ -1412,6 +1984,7 @@
 
     # TODO: this is moved from tests.series.test_timeseries, may be redundant
     def test_to_datetime_unit(self):
+        """ """
 
         epoch = 1370745748
         s = Series([epoch + t for t in range(20)])
@@ -1492,7 +2065,9 @@
 
 
 class TestToDatetimeMisc:
+    """ """
     def test_to_datetime_barely_out_of_bounds(self):
+        """ """
         # GH#19529
         # GH#19382 close enough to bounds that dropping nanos would result
         # in an in-bounds datetime
@@ -1503,6 +2078,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_iso8601(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         result = to_datetime(["2012-01-01 00:00:00"], cache=cache)
         exp = Timestamp("2012-01-01 00:00:00")
         assert result[0] == exp
@@ -1513,6 +2099,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_default(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         rs = to_datetime("2001", cache=cache)
         xp = datetime(2001, 1, 1)
         assert rs == xp
@@ -1525,6 +2122,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_on_datetime64_series(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # #2699
         s = Series(date_range("1/1/2000", periods=10))
 
@@ -1533,6 +2141,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_with_space_in_series(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 6428
         s = Series(["10/18/2006", "10/18/2008", " "])
         msg = r"(\(')?String does not contain a date(:', ' '\))?"
@@ -1547,6 +2166,17 @@
     @td.skip_if_has_locale
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_with_apply(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # this is only locale tested with US/None locales
         # GH 5195
         # with a format and coerce a single item to_datetime fails
@@ -1570,6 +2200,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_types(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # empty string
         result = to_datetime("", cache=cache)
@@ -1601,6 +2242,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_unprocessable_input(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 4928
         # GH 21864
         result = to_datetime([1, "1"], errors="ignore", cache=cache)
@@ -1612,6 +2264,7 @@
             to_datetime([1, "1"], errors="raise", cache=cache)
 
     def test_to_datetime_other_datetime64_units(self):
+        """ """
         # 5/25/2012
         scalar = np.int64(1337904000000000).view("M8[us]")
         as_obj = scalar.astype("O")
@@ -1623,6 +2276,7 @@
         assert value == as_obj
 
     def test_to_datetime_list_of_integers(self):
+        """ """
         rng = date_range("1/1/2000", periods=20)
         rng = DatetimeIndex(rng.values)
 
@@ -1633,6 +2287,7 @@
         tm.assert_index_equal(rng, result)
 
     def test_to_datetime_overflow(self):
+        """ """
         # gh-17637
         # we are overflowing Timedelta range here
 
@@ -1641,6 +2296,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_string_na_nat_conversion(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH #999, #858
 
         strings = np.array(
@@ -1722,6 +2388,19 @@
     )
     @pytest.mark.parametrize("cache", [True, False])
     def test_dti_constructor_numpy_timeunits(self, cache, dtype):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # GH 9114
         base = pd.to_datetime(
             ["2000-01-01T00:00", "2000-01-02T00:00", "NaT"], cache=cache
@@ -1734,6 +2413,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_dayfirst(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 5917
         arr = ["10/02/2014", "11/02/2014", "12/02/2014"]
         expected = DatetimeIndex(
@@ -1754,6 +2444,17 @@
 
     @pytest.mark.parametrize("klass", [DatetimeIndex, DatetimeArray])
     def test_to_datetime_dta_tz(self, klass):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
+        """
         # GH#27733
         dti = date_range("2015-04-05", periods=3).rename("foo")
         expected = dti.tz_localize("UTC")
@@ -1766,8 +2467,10 @@
 
 
 class TestGuessDatetimeFormat:
+    """ """
     @td.skip_if_not_us_locale
     def test_guess_datetime_format_for_array(self):
+        """ """
         expected_format = "%Y-%m-%d %H:%M:%S.%f"
         dt_string = datetime(2011, 12, 30, 0, 0, 0).strftime(expected_format)
 
@@ -1787,8 +2490,20 @@
 
 
 class TestToDatetimeInferFormat:
+    """ """
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_infer_datetime_format_consistent_format(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(pd.date_range("20000101", periods=50, freq="H"))
 
         test_formats = ["%m-%d-%Y", "%m/%d/%Y %H:%M:%S.%f", "%Y-%m-%dT%H:%M:%S.%f"]
@@ -1813,6 +2528,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_infer_datetime_format_inconsistent_format(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(
             np.array(
                 ["01/01/2011 00:00:00", "01-02-2011 00:00:00", "2011-01-03T00:00:00"]
@@ -1835,6 +2561,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_infer_datetime_format_series_with_nans(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(
             np.array(["01/01/2011 00:00:00", np.nan, "01/03/2011 00:00:00", np.nan])
         )
@@ -1845,6 +2582,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_infer_datetime_format_series_start_with_nans(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(
             np.array(
                 [
@@ -1866,6 +2614,19 @@
         "tz_name, offset", [("UTC", 0), ("UTC-3", 180), ("UTC+3", -180)]
     )
     def test_infer_datetime_format_tz_name(self, tz_name, offset):
+        """
+
+        Parameters
+        ----------
+        tz_name :
+            
+        offset :
+            
+
+        Returns
+        -------
+
+        """
         # GH 33133
         s = pd.Series([f"2019-02-02 08:07:13 {tz_name}"])
         result = to_datetime(s, infer_datetime_format=True)
@@ -1876,6 +2637,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_to_datetime_iso8601_noleading_0s(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # GH 11871
         s = pd.Series(["2014-1-1", "2014-2-2", "2015-3-3"])
         expected = pd.Series(
@@ -1892,10 +2664,22 @@
 
 
 class TestDaysInMonth:
+    """ """
     # tests for issue #10154
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_day_not_in_month_coerce(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         assert isna(to_datetime("2015-02-29", errors="coerce", cache=cache))
         assert isna(
             to_datetime("2015-02-29", format="%Y-%m-%d", errors="coerce", cache=cache)
@@ -1909,6 +2693,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_day_not_in_month_raise(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         msg = "day is out of range for month"
         with pytest.raises(ValueError, match=msg):
             to_datetime("2015-02-29", errors="raise", cache=cache)
@@ -1927,6 +2722,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_day_not_in_month_ignore(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         assert to_datetime("2015-02-29", errors="ignore", cache=cache) == "2015-02-29"
         assert (
             to_datetime("2015-02-29", errors="ignore", format="%Y-%m-%d", cache=cache)
@@ -1943,6 +2749,7 @@
 
 
 class TestDatetimeParsingWrappers:
+    """ """
     @pytest.mark.parametrize(
         "date_str,expected",
         list(
@@ -1997,6 +2804,21 @@
     )
     @pytest.mark.parametrize("cache", [True, False])
     def test_parsers(self, date_str, expected, cache):
+        """
+
+        Parameters
+        ----------
+        date_str :
+            
+        expected :
+            
+        cache :
+            
+
+        Returns
+        -------
+
+        """
 
         # dateutil >= 2.5.0 defaults to yearfirst=True
         # https://github.com/dateutil/dateutil/issues/217
@@ -2031,12 +2853,28 @@
     def test_na_values_with_cache(
         self, cache, unique_nulls_fixture, unique_nulls_fixture2
     ):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        unique_nulls_fixture :
+            
+        unique_nulls_fixture2 :
+            
+
+        Returns
+        -------
+
+        """
         # GH22305
         expected = Index([NaT, NaT], dtype="datetime64[ns]")
         result = to_datetime([unique_nulls_fixture, unique_nulls_fixture2], cache=cache)
         tm.assert_index_equal(result, expected)
 
     def test_parsers_nat(self):
+        """ """
         # Test that each of several string-accepting methods return pd.NaT
         result1, _ = parsing.parse_time_string("NaT")
         result2 = to_datetime("NaT")
@@ -2049,6 +2887,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_parsers_dayfirst_yearfirst(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # OK
         # 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00
         # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2012-10-11 00:00:00
@@ -2137,6 +2986,17 @@
 
     @pytest.mark.parametrize("cache", [True, False])
     def test_parsers_timestring(self, cache):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+
+        Returns
+        -------
+
+        """
         # must be the same as dateutil result
         cases = {
             "10:15": (parse("10:15"), datetime(1, 1, 1, 10, 15)),
@@ -2177,6 +3037,23 @@
     def test_parsers_timezone_minute_offsets_roundtrip(
         self, cache, dt_string, tz, dt_string_repr
     ):
+        """
+
+        Parameters
+        ----------
+        cache :
+            
+        dt_string :
+            
+        tz :
+            
+        dt_string_repr :
+            
+
+        Returns
+        -------
+
+        """
         # GH11708
         base = to_datetime("2013-01-01 00:00:00", cache=cache)
         base = base.tz_localize("UTC").tz_convert(tz)
@@ -2188,12 +3065,21 @@
 @pytest.fixture(params=["D", "s", "ms", "us", "ns"])
 def units(request):
     """Day and some time units.
-
+    
     * D
     * s
     * ms
     * us
     * ns
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
     """
     return request.param
 
@@ -2206,17 +3092,29 @@
 
 @pytest.fixture
 def units_from_epochs():
+    """ """
     return list(range(5))
 
 
 @pytest.fixture(params=["timestamp", "pydatetime", "datetime64", "str_1960"])
 def epochs(epoch_1960, request):
     """Timestamp at 1960-01-01 in various forms.
-
+    
     * pd.Timestamp
     * datetime.datetime
     * numpy.datetime64
     * str
+
+    Parameters
+    ----------
+    epoch_1960 :
+        
+    request :
+        
+
+    Returns
+    -------
+
     """
     assert request.param in {"timestamp", "pydatetime", "datetime64", "str_1960"}
     if request.param == "timestamp":
@@ -2231,11 +3129,24 @@
 
 @pytest.fixture
 def julian_dates():
+    """ """
     return pd.date_range("2014-1-1", periods=10).to_julian_date().values
 
 
 class TestOrigin:
+    """ """
     def test_to_basic(self, julian_dates):
+        """
+
+        Parameters
+        ----------
+        julian_dates :
+            
+
+        Returns
+        -------
+
+        """
         # gh-11276, gh-11745
         # for origin as julian
 
@@ -2259,6 +3170,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_julian_round_trip(self):
+        """ """
         result = pd.to_datetime(2456658, origin="julian", unit="D")
         assert result.to_julian_date() == 2456658
 
@@ -2267,6 +3179,19 @@
             pd.to_datetime(1, origin="julian", unit="D")
 
     def test_invalid_unit(self, units, julian_dates):
+        """
+
+        Parameters
+        ----------
+        units :
+            
+        julian_dates :
+            
+
+        Returns
+        -------
+
+        """
 
         # checking for invalid combination of origin='julian' and unit != D
         if units != "D":
@@ -2274,6 +3199,7 @@
                 pd.to_datetime(julian_dates, unit=units, origin="julian")
 
     def test_invalid_origin(self):
+        """ """
 
         # need to have a numeric specified
         with pytest.raises(ValueError):
@@ -2283,6 +3209,23 @@
             pd.to_datetime("2005-01-01", origin="1960-01-01", unit="D")
 
     def test_epoch(self, units, epochs, epoch_1960, units_from_epochs):
+        """
+
+        Parameters
+        ----------
+        units :
+            
+        epochs :
+            
+        epoch_1960 :
+            
+        units_from_epochs :
+            
+
+        Returns
+        -------
+
+        """
 
         expected = Series(
             [pd.Timedelta(x, unit=units) + epoch_1960 for x in units_from_epochs]
@@ -2301,23 +3244,53 @@
         ],
     )
     def test_invalid_origins(self, origin, exc, units, units_from_epochs):
+        """
+
+        Parameters
+        ----------
+        origin :
+            
+        exc :
+            
+        units :
+            
+        units_from_epochs :
+            
+
+        Returns
+        -------
+
+        """
 
         with pytest.raises(exc):
             pd.to_datetime(units_from_epochs, unit=units, origin=origin)
 
     def test_invalid_origins_tzinfo(self):
+        """ """
         # GH16842
         with pytest.raises(ValueError):
             pd.to_datetime(1, unit="D", origin=datetime(2000, 1, 1, tzinfo=pytz.utc))
 
     @pytest.mark.parametrize("format", [None, "%Y-%m-%d %H:%M:%S"])
     def test_to_datetime_out_of_bounds_with_format_arg(self, format):
+        """
+
+        Parameters
+        ----------
+        format :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-23830
         msg = "Out of bounds nanosecond timestamp"
         with pytest.raises(OutOfBoundsDatetime, match=msg):
             to_datetime("2417-10-27 00:00:00", format=format)
 
     def test_processing_order(self):
+        """ """
         # make sure we handle out-of-bounds *before*
         # constructing the dates
 
@@ -2343,6 +3316,21 @@
         ],
     )
     def test_arg_tz_ns_unit(self, offset, utc, exp):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        utc :
+            
+        exp :
+            
+
+        Returns
+        -------
+
+        """
         # GH 25546
         arg = "2019-01-01T00:00:00.000" + offset
         result = to_datetime([arg], unit="ns", utc=utc)
@@ -2355,6 +3343,19 @@
     [([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], False), ([1, 1, 1, 1, 4, 5, 6, 7, 8, 9], True)],
 )
 def test_should_cache(listlike, do_caching):
+    """
+
+    Parameters
+    ----------
+    listlike :
+        
+    do_caching :
+        
+
+    Returns
+    -------
+
+    """
     assert (
         tools.should_cache(listlike, check_count=len(listlike), unique_share=0.7)
         == do_caching
@@ -2369,6 +3370,21 @@
     ],
 )
 def test_should_cache_errors(unique_share, check_count, err_message):
+    """
+
+    Parameters
+    ----------
+    unique_share :
+        
+    check_count :
+        
+    err_message :
+        
+
+    Returns
+    -------
+
+    """
     arg = [5] * 10
 
     with pytest.raises(AssertionError, match=err_message):
@@ -2376,6 +3392,7 @@
 
 
 def test_nullable_integer_to_datetime():
+    """ """
     # Test for #30050
     ser = pd.Series([1, 2, None, 2 ** 61, None])
     ser = ser.astype("Int64")
@@ -2399,6 +3416,19 @@
 
 @pytest.mark.parametrize("klass", [np.array, list])
 def test_na_to_datetime(nulls_fixture, klass):
+    """
+
+    Parameters
+    ----------
+    nulls_fixture :
+        
+    klass :
+        
+
+    Returns
+    -------
+
+    """
     result = pd.to_datetime(klass([nulls_fixture]))
 
     assert result[0] is pd.NaT
