# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/httpclient_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/httpclient_test.py
@@ -34,14 +34,18 @@
 
 
 class HelloWorldHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         name = self.get_argument("name", "world")
         self.set_header("Content-Type", "text/plain")
         self.finish("Hello %s!" % name)
 
 
 class PostHandler(RequestHandler):
+    """ """
     def post(self):
+        """ """
         self.finish(
             "Post arg1: %s, arg2: %s"
             % (self.get_argument("arg1"), self.get_argument("arg2"))
@@ -49,13 +53,17 @@
 
 
 class PutHandler(RequestHandler):
+    """ """
     def put(self):
+        """ """
         self.write("Put body: ")
         self.write(self.request.body)
 
 
 class RedirectHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         self.write("redirects can have bodies too")
         self.redirect(
             self.get_argument("url"), status=int(self.get_argument("status", "302"))
@@ -63,15 +71,19 @@
 
 
 class RedirectWithoutLocationHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         # For testing error handling of a redirect with no location header.
         self.set_status(301)
         self.finish()
 
 
 class ChunkHandler(RequestHandler):
+    """ """
     @gen.coroutine
     def get(self):
+        """ """
         self.write("asdf")
         self.flush()
         # Wait a bit to ensure the chunks are sent and received separately.
@@ -80,12 +92,26 @@
 
 
 class AuthHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.finish(self.request.headers["Authorization"])
 
 
 class CountdownHandler(RequestHandler):
+    """ """
     def get(self, count):
+        """
+
+        Parameters
+        ----------
+        count :
+            
+
+        Returns
+        -------
+
+        """
         count = int(count)
         if count > 0:
             self.redirect(self.reverse_url("countdown", count - 1))
@@ -94,36 +120,47 @@
 
 
 class EchoPostHandler(RequestHandler):
+    """ """
     def post(self):
+        """ """
         self.write(self.request.body)
 
 
 class UserAgentHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.write(self.request.headers.get("User-Agent", "User agent not set"))
 
 
 class ContentLength304Handler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.set_status(304)
         self.set_header("Content-Length", 42)
 
     def _clear_representation_headers(self):
+        """ """
         # Tornado strips content-length from 304 responses, but here we
         # want to simulate servers that include the headers anyway.
         pass
 
 
 class PatchHandler(RequestHandler):
+    """ """
     def patch(self):
+        """ """
         "Return the request payload - so we can check it is being kept"
         self.write(self.request.body)
 
 
 class AllMethodsHandler(RequestHandler):
+    """ """
     SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ("OTHER",)  # type: ignore
 
     def method(self):
+        """ """
         assert self.request.method is not None
         self.write(self.request.method)
 
@@ -131,7 +168,9 @@
 
 
 class SetHeaderHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         # Use get_arguments for keys to get strings, but
         # request.arguments for values to get bytes.
         for k, v in zip(self.get_arguments("k"), self.request.arguments["v"]):
@@ -139,7 +178,9 @@
 
 
 class InvalidGzipHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         # set Content-Encoding manually to avoid automatic gzip encoding
         self.set_header("Content-Type", "text/plain")
         self.set_header("Content-Encoding", "gzip")
@@ -157,7 +198,9 @@
 
 
 class HTTPClientCommonTestCase(AsyncHTTPTestCase):
+    """ """
     def get_app(self):
+        """ """
         return Application(
             [
                 url("/hello", HelloWorldHandler),
@@ -180,6 +223,7 @@
         )
 
     def test_patch_receives_payload(self):
+        """ """
         body = b"some patch data"
         response = self.fetch("/patch", method="PATCH", body=body)
         self.assertEqual(response.code, 200)
@@ -187,6 +231,7 @@
 
     @skipOnTravis
     def test_hello_world(self):
+        """ """
         response = self.fetch("/hello")
         self.assertEqual(response.code, 200)
         self.assertEqual(response.headers["Content-Type"], "text/plain")
@@ -198,6 +243,7 @@
         self.assertEqual(response.body, b"Hello Ben!")
 
     def test_streaming_callback(self):
+        """ """
         # streaming_callback is also tested in test_chunked
         chunks = []  # type: typing.List[bytes]
         response = self.fetch("/hello", streaming_callback=chunks.append)
@@ -206,11 +252,13 @@
         self.assertFalse(response.body)
 
     def test_post(self):
+        """ """
         response = self.fetch("/post", method="POST", body="arg1=foo&arg2=bar")
         self.assertEqual(response.code, 200)
         self.assertEqual(response.body, b"Post arg1: foo, arg2: bar")
 
     def test_chunked(self):
+        """ """
         response = self.fetch("/chunk")
         self.assertEqual(response.body, b"asdfqwer")
 
@@ -220,6 +268,7 @@
         self.assertFalse(response.body)
 
     def test_chunked_close(self):
+        """ """
         # test case in which chunks spread read-callback processing
         # over several ioloop iterations, but the connection is already closed.
         sock, port = bind_unused_port()
@@ -227,6 +276,19 @@
 
             @gen.coroutine
             def accept_callback(conn, address):
+                """
+
+                Parameters
+                ----------
+                conn :
+                    
+                address :
+                    
+
+                Returns
+                -------
+
+                """
                 # fake an HTTP server using chunked encoding where the final chunks
                 # and connection close all happen at once
                 stream = IOStream(conn)
@@ -257,6 +319,7 @@
             self.io_loop.remove_handler(sock.fileno())
 
     def test_basic_auth(self):
+        """ """
         # This test data appears in section 2 of RFC 7617.
         self.assertEqual(
             self.fetch(
@@ -266,6 +329,7 @@
         )
 
     def test_basic_auth_explicit_mode(self):
+        """ """
         self.assertEqual(
             self.fetch(
                 "/auth",
@@ -277,6 +341,7 @@
         )
 
     def test_basic_auth_unicode(self):
+        """ """
         # This test data appears in section 2.1 of RFC 7617.
         self.assertEqual(
             self.fetch("/auth", auth_username="test", auth_password="123Â£").body,
@@ -292,6 +357,7 @@
         )
 
     def test_unsupported_auth_mode(self):
+        """ """
         # curl and simple clients handle errors a bit differently; the
         # important thing is that they don't fall back to basic auth
         # on an unknown mode.
@@ -306,6 +372,7 @@
                 )
 
     def test_follow_redirect(self):
+        """ """
         response = self.fetch("/countdown/2", follow_redirects=False)
         self.assertEqual(302, response.code)
         self.assertTrue(response.headers["Location"].endswith("/countdown/1"))
@@ -316,6 +383,7 @@
         self.assertEqual(b"Zero", response.body)
 
     def test_redirect_without_location(self):
+        """ """
         response = self.fetch("/redirect_without_location", follow_redirects=True)
         # If there is no location header, the redirect response should
         # just be returned as-is. (This should arguably raise an
@@ -324,12 +392,14 @@
         self.assertEqual(301, response.code)
 
     def test_redirect_put_with_body(self):
+        """ """
         response = self.fetch(
             "/redirect?url=/put&status=307", method="PUT", body="hello"
         )
         self.assertEqual(response.body, b"Put body: hello")
 
     def test_redirect_put_without_body(self):
+        """ """
         # This "without body" edge case is similar to what happens with body_producer.
         response = self.fetch(
             "/redirect?url=/put&status=307",
@@ -339,6 +409,7 @@
         self.assertEqual(response.body, b"Put body: ")
 
     def test_method_after_redirect(self):
+        """ """
         # Legacy redirect codes (301, 302) convert POST requests to GET.
         for status in [301, 302, 303]:
             url = "/redirect?url=/all_methods&status=%d" % status
@@ -369,11 +440,13 @@
             self.assertEqual(b"", resp.body)
 
     def test_credentials_in_url(self):
+        """ """
         url = self.get_url("/auth").replace("http://", "http://me:secret@")
         response = self.fetch(url)
         self.assertEqual(b"Basic " + base64.b64encode(b"me:secret"), response.body)
 
     def test_body_encoding(self):
+        """ """
         unicode_body = u"\xe9"
         byte_body = binascii.a2b_hex(b"e9")
 
@@ -410,6 +483,7 @@
         self.assertEqual(response.body, byte_body)
 
     def test_types(self):
+        """ """
         response = self.fetch("/hello")
         self.assertEqual(type(response.body), bytes)
         self.assertEqual(type(response.headers["Content-Type"]), str)
@@ -417,6 +491,7 @@
         self.assertEqual(type(response.effective_url), str)
 
     def test_gzip(self):
+        """ """
         # All the tests in this file should be using gzip, but this test
         # ensures that it is in fact getting compressed, and also tests
         # the httpclient's decompress=False option.
@@ -434,6 +509,7 @@
         self.assertEqual(f.read(), b"asdfqwer")
 
     def test_invalid_gzip(self):
+        """ """
         # test if client hangs on tricky invalid gzip
         # curl/simple httpclient have different behavior (exception, logging)
         with ExpectLog(
@@ -447,11 +523,23 @@
                 pass  # acceptable
 
     def test_header_callback(self):
+        """ """
         first_line = []
         headers = {}
         chunks = []
 
         def header_callback(header_line):
+            """
+
+            Parameters
+            ----------
+            header_line :
+                
+
+            Returns
+            -------
+
+            """
             if header_line.startswith("HTTP/1.1 101"):
                 # Upgrading to HTTP/2
                 pass
@@ -462,6 +550,17 @@
                 headers[k.lower()] = v.strip()
 
         def streaming_callback(chunk):
+            """
+
+            Parameters
+            ----------
+            chunk :
+                
+
+            Returns
+            -------
+
+            """
             # All header callbacks are run before any streaming callbacks,
             # so the header data is available to process the data as it
             # comes in.
@@ -479,6 +578,7 @@
 
     @gen_test
     def test_configure_defaults(self):
+        """ """
         defaults = dict(user_agent="TestDefaultUserAgent", allow_ipv6=False)
         # Construct a new instance of the configured client class
         client = self.http_client.__class__(force_instance=True, defaults=defaults)
@@ -489,6 +589,7 @@
             client.close()
 
     def test_header_types(self):
+        """ """
         # Header values may be passed as character or utf8 byte strings,
         # in a plain dictionary or an HTTPHeaders object.
         # Keys must always be the native str type.
@@ -506,6 +607,7 @@
                 )
 
     def test_multi_line_headers(self):
+        """ """
         # Multi-line http headers are rare but rfc-allowed
         # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
         sock, port = bind_unused_port()
@@ -513,6 +615,19 @@
 
             @gen.coroutine
             def accept_callback(conn, address):
+                """
+
+                Parameters
+                ----------
+                conn :
+                    
+                address :
+                    
+
+                Returns
+                -------
+
+                """
                 stream = IOStream(conn)
                 request_data = yield stream.read_until(b"\r\n\r\n")
                 if b"HTTP/1." not in request_data:
@@ -538,6 +653,7 @@
                 self.io_loop.remove_handler(sock.fileno())
 
     def test_304_with_content_length(self):
+        """ """
         # According to the spec 304 responses SHOULD NOT include
         # Content-Length or other entity headers, but some servers do it
         # anyway.
@@ -548,11 +664,13 @@
 
     @gen_test
     def test_future_interface(self):
+        """ """
         response = yield self.http_client.fetch(self.get_url("/hello"))
         self.assertEqual(response.body, b"Hello world!")
 
     @gen_test
     def test_future_http_error(self):
+        """ """
         with self.assertRaises(HTTPError) as context:
             yield self.http_client.fetch(self.get_url("/notfound"))
         assert context.exception is not None
@@ -562,6 +680,7 @@
 
     @gen_test
     def test_future_http_error_no_raise(self):
+        """ """
         response = yield self.http_client.fetch(
             self.get_url("/notfound"), raise_error=False
         )
@@ -569,6 +688,7 @@
 
     @gen_test
     def test_reuse_request_from_response(self):
+        """ """
         # The response.request attribute should be an HTTPRequest, not
         # a _RequestProxy.
         # This test uses self.http_client.fetch because self.fetch calls
@@ -582,6 +702,7 @@
 
     @gen_test
     def test_bind_source_ip(self):
+        """ """
         url = self.get_url("/hello")
         request = HTTPRequest(url, network_interface="127.0.0.1")
         response = yield self.http_client.fetch(request)
@@ -593,6 +714,7 @@
         self.assertIn("not-interface-or-ip", str(context.exception))
 
     def test_all_methods(self):
+        """ """
         for method in ["GET", "DELETE", "OPTIONS"]:
             response = self.fetch("/all_methods", method=method)
             self.assertEqual(response.body, utf8(method))
@@ -607,6 +729,7 @@
         self.assertEqual(response.body, b"OTHER")
 
     def test_body_sanity_checks(self):
+        """ """
         # These methods require a body.
         for method in ("POST", "PUT", "PATCH"):
             with self.assertRaises(ValueError) as context:
@@ -655,6 +778,7 @@
     #    self.assertEqual(response.body, b"Post arg1: foo, arg2: bar")
 
     def test_put_307(self):
+        """ """
         response = self.fetch(
             "/redirect?status=307&url=/put", method="PUT", body=b"hello"
         )
@@ -662,12 +786,14 @@
         self.assertEqual(response.body, b"Put body: hello")
 
     def test_non_ascii_header(self):
+        """ """
         # Non-ascii headers are sent as latin1.
         response = self.fetch("/set_header?k=foo&v=%E9")
         response.rethrow()
         self.assertEqual(response.headers["Foo"], native_str(u"\u00e9"))
 
     def test_response_times(self):
+        """ """
         # A few simple sanity checks of the response time fields to
         # make sure they're using the right basis (between the
         # wall-time and monotonic clocks).
@@ -685,6 +811,7 @@
             self.assertTrue(0 <= v < 1.0, "time_info[%s] out of bounds: %s" % (k, v))
 
     def test_zero_timeout(self):
+        """ """
         response = self.fetch("/hello", connect_timeout=0)
         self.assertEqual(response.code, 200)
 
@@ -696,6 +823,7 @@
 
     @gen_test
     def test_error_after_cancel(self):
+        """ """
         fut = self.http_client.fetch(self.get_url("/404"))
         self.assertTrue(fut.cancel())
         with ExpectLog(app_log, "Exception after Future was cancelled") as el:
@@ -710,40 +838,49 @@
 
 
 class RequestProxyTest(unittest.TestCase):
+    """ """
     def test_request_set(self):
+        """ """
         proxy = _RequestProxy(
             HTTPRequest("http://example.com/", user_agent="foo"), dict()
         )
         self.assertEqual(proxy.user_agent, "foo")
 
     def test_default_set(self):
+        """ """
         proxy = _RequestProxy(
             HTTPRequest("http://example.com/"), dict(network_interface="foo")
         )
         self.assertEqual(proxy.network_interface, "foo")
 
     def test_both_set(self):
+        """ """
         proxy = _RequestProxy(
             HTTPRequest("http://example.com/", proxy_host="foo"), dict(proxy_host="bar")
         )
         self.assertEqual(proxy.proxy_host, "foo")
 
     def test_neither_set(self):
+        """ """
         proxy = _RequestProxy(HTTPRequest("http://example.com/"), dict())
         self.assertIs(proxy.auth_username, None)
 
     def test_bad_attribute(self):
+        """ """
         proxy = _RequestProxy(HTTPRequest("http://example.com/"), dict())
         with self.assertRaises(AttributeError):
             proxy.foo
 
     def test_defaults_none(self):
+        """ """
         proxy = _RequestProxy(HTTPRequest("http://example.com/"), None)
         self.assertIs(proxy.auth_username, None)
 
 
 class HTTPResponseTestCase(unittest.TestCase):
+    """ """
     def test_str(self):
+        """ """
         response = HTTPResponse(  # type: ignore
             HTTPRequest("http://example.com"), 200, buffer=BytesIO()
         )
@@ -753,12 +890,15 @@
 
 
 class SyncHTTPClientTest(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         self.server_ioloop = IOLoop()
         event = threading.Event()
 
         @gen.coroutine
         def init_server():
+            """ """
             sock, self.port = bind_unused_port()
             app = Application([("/", HelloWorldHandler)])
             self.server = HTTPServer(app)
@@ -766,6 +906,7 @@
             event.set()
 
         def start():
+            """ """
             self.server_ioloop.run_sync(init_server)
             self.server_ioloop.start()
 
@@ -776,7 +917,9 @@
         self.http_client = HTTPClient()
 
     def tearDown(self):
+        """ """
         def stop_server():
+            """ """
             self.server.stop()
             # Delay the shutdown of the IOLoop by several iterations because
             # the server may still have some cleanup work left when
@@ -786,6 +929,7 @@
 
             @gen.coroutine
             def slow_stop():
+                """ """
                 yield self.server.close_all_connections()
                 # The number of iterations is difficult to predict. Typically,
                 # one is sufficient, although sometimes it needs more.
@@ -801,13 +945,26 @@
         self.server_ioloop.close(all_fds=True)
 
     def get_url(self, path):
+        """
+
+        Parameters
+        ----------
+        path :
+            
+
+        Returns
+        -------
+
+        """
         return "http://127.0.0.1:%d%s" % (self.port, path)
 
     def test_sync_client(self):
+        """ """
         response = self.http_client.fetch(self.get_url("/"))
         self.assertEqual(b"Hello world!", response.body)
 
     def test_sync_client_error(self):
+        """ """
         # Synchronous HTTPClient raises errors directly; no need for
         # response.rethrow()
         with self.assertRaises(HTTPError) as assertion:
@@ -816,7 +973,9 @@
 
 
 class SyncHTTPClientSubprocessTest(unittest.TestCase):
+    """ """
     def test_destructor_log(self):
+        """ """
         # Regression test for
         # https://github.com/tornadoweb/tornado/issues/2539
         #
@@ -846,30 +1005,37 @@
 
 
 class HTTPRequestTestCase(unittest.TestCase):
+    """ """
     def test_headers(self):
+        """ """
         request = HTTPRequest("http://example.com", headers={"foo": "bar"})
         self.assertEqual(request.headers, {"foo": "bar"})
 
     def test_headers_setter(self):
+        """ """
         request = HTTPRequest("http://example.com")
         request.headers = {"bar": "baz"}  # type: ignore
         self.assertEqual(request.headers, {"bar": "baz"})
 
     def test_null_headers_setter(self):
+        """ """
         request = HTTPRequest("http://example.com")
         request.headers = None  # type: ignore
         self.assertEqual(request.headers, {})
 
     def test_body(self):
+        """ """
         request = HTTPRequest("http://example.com", body="foo")
         self.assertEqual(request.body, utf8("foo"))
 
     def test_body_setter(self):
+        """ """
         request = HTTPRequest("http://example.com")
         request.body = "foo"  # type: ignore
         self.assertEqual(request.body, utf8("foo"))
 
     def test_if_modified_since(self):
+        """ """
         http_date = datetime.datetime.utcnow()
         request = HTTPRequest("http://example.com", if_modified_since=http_date)
         self.assertEqual(
@@ -878,18 +1044,22 @@
 
 
 class HTTPErrorTestCase(unittest.TestCase):
+    """ """
     def test_copy(self):
+        """ """
         e = HTTPError(403)
         e2 = copy.copy(e)
         self.assertIsNot(e, e2)
         self.assertEqual(e.code, e2.code)
 
     def test_plain_error(self):
+        """ """
         e = HTTPError(403)
         self.assertEqual(str(e), "HTTP 403: Forbidden")
         self.assertEqual(repr(e), "HTTP 403: Forbidden")
 
     def test_error_with_response(self):
+        """ """
         resp = HTTPResponse(HTTPRequest("http://example.com/"), 403)
         with self.assertRaises(HTTPError) as cm:
             resp.rethrow()
