# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/arrays/sparse/test_array.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/arrays/sparse/test_array.py
@@ -16,16 +16,40 @@
 
 @pytest.fixture(params=["integer", "block"])
 def kind(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 class TestSparseArray:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.arr_data = np.array([np.nan, np.nan, 1, 2, 3, np.nan, 4, 5, np.nan, 6])
         self.arr = SparseArray(self.arr_data)
         self.zarr = SparseArray([0, 0, 1, 2, 3, 0, 4, 5, 0, 6], fill_value=0)
 
     def test_constructor_dtype(self):
+        """ """
         arr = SparseArray([np.nan, 1, 2, np.nan])
         assert arr.dtype == SparseDtype(np.float64, np.nan)
         assert arr.dtype.subtype == np.float64
@@ -56,23 +80,27 @@
         assert arr.fill_value == 0
 
     def test_constructor_dtype_str(self):
+        """ """
         result = SparseArray([1, 2, 3], dtype="int")
         expected = SparseArray([1, 2, 3], dtype=int)
         tm.assert_sp_array_equal(result, expected)
 
     def test_constructor_sparse_dtype(self):
+        """ """
         result = SparseArray([1, 0, 0, 1], dtype=SparseDtype("int64", -1))
         expected = SparseArray([1, 0, 0, 1], fill_value=-1, dtype=np.int64)
         tm.assert_sp_array_equal(result, expected)
         assert result.sp_values.dtype == np.dtype("int64")
 
     def test_constructor_sparse_dtype_str(self):
+        """ """
         result = SparseArray([1, 0, 0, 1], dtype="Sparse[int32]")
         expected = SparseArray([1, 0, 0, 1], dtype=np.int32)
         tm.assert_sp_array_equal(result, expected)
         assert result.sp_values.dtype == np.dtype("int32")
 
     def test_constructor_object_dtype(self):
+        """ """
         # GH 11856
         arr = SparseArray(["A", "A", np.nan, "B"], dtype=object)
         assert arr.dtype == SparseDtype(object)
@@ -93,10 +121,22 @@
 
     @pytest.mark.parametrize("dtype", [SparseDtype(int, 0), int])
     def test_constructor_na_dtype(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError, match="Cannot convert"):
             SparseArray([0, 1, np.nan], dtype=dtype)
 
     def test_constructor_warns_when_losing_timezone(self):
+        """ """
         # GH#32501 warn when losing timezone inforamtion
         dti = pd.date_range("2016-01-01", periods=3, tz="US/Pacific")
 
@@ -113,6 +153,7 @@
         tm.assert_sp_array_equal(result, expected)
 
     def test_constructor_spindex_dtype(self):
+        """ """
         arr = SparseArray(data=[1, 2], sparse_index=IntIndex(4, [1, 2]))
         # XXX: Behavior change: specifying SparseIndex no longer changes the
         # fill_value
@@ -153,6 +194,17 @@
 
     @pytest.mark.parametrize("sparse_index", [None, IntIndex(1, [0])])
     def test_constructor_spindex_dtype_scalar(self, sparse_index):
+        """
+
+        Parameters
+        ----------
+        sparse_index :
+            
+
+        Returns
+        -------
+
+        """
         # scalar input
         arr = SparseArray(data=1, sparse_index=sparse_index, dtype=None)
         exp = SparseArray([1], dtype=None)
@@ -167,6 +219,7 @@
         assert arr.fill_value == 0
 
     def test_constructor_spindex_dtype_scalar_broadcasts(self):
+        """ """
         arr = SparseArray(
             data=[1, 2], sparse_index=IntIndex(4, [1, 2]), fill_value=0, dtype=None
         )
@@ -185,6 +238,19 @@
         ],
     )
     def test_constructor_inferred_fill_value(self, data, fill_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         result = SparseArray(data).fill_value
 
         if pd.isna(fill_value):
@@ -199,6 +265,19 @@
     )
     @td.skip_if_no_scipy
     def test_from_spmatrix(self, size, format):
+        """
+
+        Parameters
+        ----------
+        size :
+            
+        format :
+            
+
+        Returns
+        -------
+
+        """
         import scipy.sparse
 
         mat = scipy.sparse.random(size, 1, density=0.5, format=format)
@@ -211,6 +290,17 @@
     @pytest.mark.parametrize("format", ["coo", "csc", "csr"])
     @td.skip_if_no_scipy
     def test_from_spmatrix_including_explicit_zero(self, format):
+        """
+
+        Parameters
+        ----------
+        format :
+            
+
+        Returns
+        -------
+
+        """
         import scipy.sparse
 
         mat = scipy.sparse.random(10, 1, density=0.5, format=format)
@@ -223,6 +313,7 @@
 
     @td.skip_if_no_scipy
     def test_from_spmatrix_raises(self):
+        """ """
         import scipy.sparse
 
         mat = scipy.sparse.eye(5, 4, format="csc")
@@ -240,6 +331,19 @@
         ],
     )
     def test_scalar_with_index_infer_dtype(self, scalar, dtype):
+        """
+
+        Parameters
+        ----------
+        scalar :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # GH 19163
         arr = SparseArray(scalar, index=[1, 2, 3], fill_value=scalar)
         exp = SparseArray([scalar, scalar, scalar], fill_value=scalar)
@@ -250,6 +354,7 @@
         assert exp.dtype == dtype
 
     def test_get_item(self):
+        """ """
 
         assert np.isnan(self.arr[1])
         assert self.arr[2] == 1
@@ -270,11 +375,13 @@
         assert self.arr[-1] == self.arr[len(self.arr) - 1]
 
     def test_take_scalar_raises(self):
+        """ """
         msg = "'indices' must be an array, not a scalar '2'."
         with pytest.raises(ValueError, match=msg):
             self.arr.take(2)
 
     def test_take(self):
+        """ """
         exp = SparseArray(np.take(self.arr_data, [2, 3]))
         tm.assert_sp_array_equal(self.arr.take([2, 3]), exp)
 
@@ -282,11 +389,13 @@
         tm.assert_sp_array_equal(self.arr.take([0, 1, 2]), exp)
 
     def test_take_all_empty(self):
+        """ """
         a = pd.array([0, 0], dtype=pd.SparseDtype("int64"))
         result = a.take([0, 1], allow_fill=True, fill_value=np.nan)
         tm.assert_sp_array_equal(a, result)
 
     def test_take_fill_value(self):
+        """ """
         data = np.array([1, np.nan, 0, 3, 0])
         sparse = SparseArray(data, fill_value=0)
 
@@ -297,6 +406,7 @@
         tm.assert_sp_array_equal(sparse.take([1, 3, 4]), exp)
 
     def test_take_negative(self):
+        """ """
         exp = SparseArray(np.take(self.arr_data, [-1]))
         tm.assert_sp_array_equal(self.arr.take([-1]), exp)
 
@@ -305,6 +415,17 @@
 
     @pytest.mark.parametrize("fill_value", [0, None, np.nan])
     def test_shift_fill_value(self, fill_value):
+        """
+
+        Parameters
+        ----------
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         # GH #24128
         sparse = SparseArray(np.array([1, 0, 0, 3, 0]), fill_value=8.0)
         res = sparse.shift(1, fill_value=fill_value)
@@ -314,10 +435,12 @@
         tm.assert_sp_array_equal(res, exp)
 
     def test_bad_take(self):
+        """ """
         with pytest.raises(IndexError, match="bounds"):
             self.arr.take([11])
 
     def test_take_filling(self):
+        """ """
         # similar tests as GH 12631
         sparse = SparseArray([np.nan, np.nan, 1, np.nan, 4])
         result = sparse.take(np.array([1, 0, -1]))
@@ -350,6 +473,7 @@
             sparse.take(np.array([1, 5]), allow_fill=True)
 
     def test_take_filling_fill_value(self):
+        """ """
         # same tests as GH 12631
         sparse = SparseArray([np.nan, 0, 1, 0, 4], fill_value=0)
         result = sparse.take(np.array([1, 0, -1]))
@@ -384,6 +508,7 @@
             sparse.take(np.array([1, 5]), fill_value=True)
 
     def test_take_filling_all_nan(self):
+        """ """
         sparse = SparseArray([np.nan, np.nan, np.nan, np.nan, np.nan])
         # XXX: did the default kind from take change?
         result = sparse.take(np.array([1, 0, -1]))
@@ -403,10 +528,13 @@
             sparse.take(np.array([1, 5]), fill_value=True)
 
     def test_set_item(self):
+        """ """
         def setitem():
+            """ """
             self.arr[5] = 3
 
         def setslice():
+            """ """
             self.arr[1:5] = 2
 
         with pytest.raises(TypeError, match="assignment via setitem"):
@@ -416,15 +544,18 @@
             setslice()
 
     def test_constructor_from_too_large_array(self):
+        """ """
         with pytest.raises(TypeError, match="expected dimension <= 1 data"):
             SparseArray(np.arange(10).reshape((2, 5)))
 
     def test_constructor_from_sparse(self):
+        """ """
         res = SparseArray(self.zarr)
         assert res.fill_value == 0
         tm.assert_almost_equal(res.sp_values, self.zarr.sp_values)
 
     def test_constructor_copy(self):
+        """ """
         cp = SparseArray(self.arr, copy=True)
         cp.sp_values[:3] = 0
         assert not (self.arr.sp_values[:3] == 0).any()
@@ -434,6 +565,7 @@
         assert (self.arr.sp_values[:3] == 0).all()
 
     def test_constructor_bool(self):
+        """ """
         # GH 10648
         data = np.array([False, False, True, True, False, False])
         arr = SparseArray(data, fill_value=False, dtype=bool)
@@ -449,6 +581,7 @@
         tm.assert_numpy_array_equal(dense, data)
 
     def test_constructor_bool_fill_value(self):
+        """ """
         arr = SparseArray([True, False, True], dtype=None)
         assert arr.dtype == SparseDtype(np.bool_)
         assert not arr.fill_value
@@ -462,6 +595,7 @@
         assert arr.fill_value
 
     def test_constructor_float32(self):
+        """ """
         # GH 10648
         data = np.array([1.0, np.nan, 3], dtype=np.float32)
         arr = SparseArray(data, dtype=np.float32)
@@ -479,6 +613,7 @@
         tm.assert_numpy_array_equal(dense, data)
 
     def test_astype(self):
+        """ """
         # float -> float
         arr = SparseArray([None, None, 0, 2])
         result = arr.astype("Sparse[float32]")
@@ -504,6 +639,7 @@
             arr.astype("Sparse[i8]")
 
     def test_astype_bool(self):
+        """ """
         a = SparseArray([1, 0, 0, 1], dtype=SparseDtype(int, 0))
         result = a.astype(bool)
         expected = SparseArray([True, 0, 0, True], dtype=SparseDtype(bool, 0))
@@ -517,6 +653,17 @@
         tm.assert_sp_array_equal(result, expected)
 
     def test_astype_all(self, any_real_dtype):
+        """
+
+        Parameters
+        ----------
+        any_real_dtype :
+            
+
+        Returns
+        -------
+
+        """
         vals = np.array([1, 2, 3])
         arr = SparseArray(vals, fill_value=1)
         typ = np.dtype(any_real_dtype)
@@ -563,15 +710,32 @@
         ],
     )
     def test_astype_more(self, array, dtype, expected):
+        """
+
+        Parameters
+        ----------
+        array :
+            
+        dtype :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         result = array.astype(dtype)
         tm.assert_sp_array_equal(result, expected)
 
     def test_astype_nan_raises(self):
+        """ """
         arr = SparseArray([1.0, np.nan])
         with pytest.raises(ValueError, match="Cannot convert non-finite"):
             arr.astype(int)
 
     def test_set_fill_value(self):
+        """ """
         arr = SparseArray([1.0, np.nan, 2.0], fill_value=np.nan)
         arr.fill_value = 2
         assert arr.fill_value == 2
@@ -610,6 +774,17 @@
 
     @pytest.mark.parametrize("val", [[1, 2, 3], np.array([1, 2]), (1, 2, 3)])
     def test_set_fill_invalid_non_scalar(self, val):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+
+        Returns
+        -------
+
+        """
         arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool_)
         msg = "fill_value must be a scalar"
 
@@ -617,11 +792,13 @@
             arr.fill_value = val
 
     def test_copy(self):
+        """ """
         arr2 = self.arr.copy()
         assert arr2.sp_values is not self.arr.sp_values
         assert arr2.sp_index is self.arr.sp_index
 
     def test_values_asarray(self):
+        """ """
         tm.assert_almost_equal(self.arr.to_dense(), self.arr_data)
 
     @pytest.mark.parametrize(
@@ -634,6 +811,21 @@
         ],
     )
     def test_shape(self, data, shape, dtype):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        shape :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # GH 21126
         out = SparseArray(data, dtype=dtype)
         assert out.shape == shape
@@ -648,6 +840,19 @@
     )
     @pytest.mark.parametrize("fill_value", [None, 0])
     def test_dense_repr(self, vals, fill_value):
+        """
+
+        Parameters
+        ----------
+        vals :
+            
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         vals = np.array(vals)
         arr = SparseArray(vals, fill_value=fill_value)
 
@@ -659,7 +864,19 @@
         tm.assert_numpy_array_equal(res2, vals)
 
     def test_getitem(self):
+        """ """
         def _checkit(i):
+            """
+
+            Parameters
+            ----------
+            i :
+                
+
+            Returns
+            -------
+
+            """
             tm.assert_almost_equal(self.arr[i], self.arr.to_dense()[i])
 
         for i in range(len(self.arr)):
@@ -667,12 +884,14 @@
             _checkit(-i)
 
     def test_getitem_arraylike_mask(self):
+        """ """
         arr = SparseArray([0, 1, 2])
         result = arr[[True, False, True]]
         expected = SparseArray([0, 2])
         tm.assert_sp_array_equal(result, expected)
 
     def test_getslice(self):
+        """ """
         result = self.arr[:-3]
         exp = SparseArray(self.arr.to_dense()[:-3])
         tm.assert_sp_array_equal(result, exp)
@@ -691,6 +910,7 @@
         tm.assert_sp_array_equal(result, exp)
 
     def test_getslice_tuple(self):
+        """ """
         dense = np.array([np.nan, 0, 3, 4, 0, 5, np.nan, np.nan, 0])
 
         sparse = SparseArray(dense)
@@ -716,12 +936,24 @@
             dense[4:, :]
 
     def test_boolean_slice_empty(self):
+        """ """
         arr = SparseArray([0, 1, 2])
         res = arr[[False, False, False]]
         assert res.dtype == arr.dtype
 
     @pytest.mark.parametrize("op", ["add", "sub", "mul", "truediv", "floordiv", "pow"])
     def test_binary_operators(self, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         op = getattr(operator, op)
         data1 = np.random.randn(20)
         data2 = np.random.randn(20)
@@ -738,6 +970,21 @@
         farr2 = SparseArray(data2, fill_value=3)
 
         def _check_op(op, first, second):
+            """
+
+            Parameters
+            ----------
+            op :
+                
+            first :
+                
+            second :
+                
+
+            Returns
+            -------
+
+            """
             res = op(first, second)
             exp = SparseArray(
                 op(first.to_dense(), second.to_dense()), fill_value=first.fill_value
@@ -771,7 +1018,19 @@
                 _check_op(op, first_arr, second_arr)
 
     def test_pickle(self):
+        """ """
         def _check_roundtrip(obj):
+            """
+
+            Parameters
+            ----------
+            obj :
+                
+
+            Returns
+            -------
+
+            """
             unpickled = tm.round_trip_pickle(obj)
             tm.assert_sp_array_equal(unpickled, obj)
 
@@ -779,6 +1038,7 @@
         _check_roundtrip(self.zarr)
 
     def test_generator_warnings(self):
+        """ """
         sp_arr = SparseArray([1, 2, 3])
         with warnings.catch_warnings(record=True) as w:
             warnings.filterwarnings(action="always", category=DeprecationWarning)
@@ -788,6 +1048,7 @@
             assert len(w) == 0
 
     def test_fillna(self):
+        """ """
         s = SparseArray([1, np.nan, np.nan, 3, np.nan])
         res = s.fillna(-1)
         exp = SparseArray([1, -1, -1, 3, -1], fill_value=-1, dtype=np.float64)
@@ -848,6 +1109,7 @@
         tm.assert_sp_array_equal(res, exp)
 
     def test_fillna_overlap(self):
+        """ """
         s = SparseArray([1, np.nan, np.nan, 3, np.nan])
         # filling with existing value doesn't replace existing value with
         # fill_value, i.e. existing 3 remains in sp_values
@@ -861,6 +1123,7 @@
         tm.assert_sp_array_equal(res, exp)
 
     def test_nonzero(self):
+        """ """
         # Tests regression #21172.
         sa = SparseArray([float("nan"), float("nan"), 1, 0, 0, 2, 0, 0, 0, 3, 0, 0])
         expected = np.array([2, 5, 9], dtype=np.int32)
@@ -873,6 +1136,7 @@
 
 
 class TestSparseArrayAnalytics:
+    """ """
     @pytest.mark.parametrize(
         "data,pos,neg",
         [
@@ -882,6 +1146,21 @@
         ],
     )
     def test_all(self, data, pos, neg):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        pos :
+            
+        neg :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17570
         out = SparseArray(data).all()
         assert out
@@ -906,6 +1185,21 @@
     )
     @td.skip_if_np_lt("1.15")  # prior didn't dispatch
     def test_numpy_all(self, data, pos, neg):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        pos :
+            
+        neg :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17570
         out = np.all(SparseArray(data))
         assert out
@@ -934,6 +1228,21 @@
         ],
     )
     def test_any(self, data, pos, neg):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        pos :
+            
+        neg :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17570
         out = SparseArray(data).any()
         assert out
@@ -958,6 +1267,21 @@
     )
     @td.skip_if_np_lt("1.15")  # prior didn't dispatch
     def test_numpy_any(self, data, pos, neg):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        pos :
+            
+        neg :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17570
         out = np.any(SparseArray(data))
         assert out
@@ -977,6 +1301,7 @@
             np.any(SparseArray(data), out=out)
 
     def test_sum(self):
+        """ """
         data = np.arange(10).astype(float)
         out = SparseArray(data).sum()
         assert out == 45.0
@@ -999,6 +1324,23 @@
     @pytest.mark.parametrize("fill_value", [0, 1, np.nan, True, False])
     @pytest.mark.parametrize("min_count, expected", [(3, 2), (4, np.nan)])
     def test_sum_min_count(self, arr, fill_value, min_count, expected):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+        fill_value :
+            
+        min_count :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/25777
         sparray = SparseArray(arr, fill_value=fill_value)
         result = sparray.sum(min_count=min_count)
@@ -1008,6 +1350,7 @@
             assert result == expected
 
     def test_numpy_sum(self):
+        """ """
         data = np.arange(10).astype(float)
         out = np.sum(SparseArray(data))
         assert out == 45.0
@@ -1042,6 +1385,21 @@
     )
     @pytest.mark.parametrize("numpy", [True, False])
     def test_cumsum(self, data, expected, numpy):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        expected :
+            
+        numpy :
+            
+
+        Returns
+        -------
+
+        """
         cumsum = np.cumsum if numpy else lambda s: s.cumsum()
 
         out = cumsum(SparseArray(data))
@@ -1068,6 +1426,7 @@
                 SparseArray(data).cumsum(axis=axis)
 
     def test_mean(self):
+        """ """
         data = np.arange(10).astype(float)
         out = SparseArray(data).mean()
         assert out == 4.5
@@ -1077,6 +1436,7 @@
         assert out == 40.0 / 9
 
     def test_numpy_mean(self):
+        """ """
         data = np.arange(10).astype(float)
         out = np.mean(SparseArray(data))
         assert out == 4.5
@@ -1094,6 +1454,7 @@
             np.mean(SparseArray(data), out=out)
 
     def test_ufunc(self):
+        """ """
         # GH 13853 make sure ufunc is applied to fill_value
         sparse = SparseArray([1, np.nan, 2, np.nan, -2])
         result = SparseArray([1, np.nan, 2, np.nan, 2])
@@ -1123,6 +1484,7 @@
         tm.assert_sp_array_equal(np.sin(sparse), result)
 
     def test_ufunc_args(self):
+        """ """
         # GH 13853 make sure ufunc is applied to fill_value, including its arg
         sparse = SparseArray([1, np.nan, 2, np.nan, -2])
         result = SparseArray([2, np.nan, 3, np.nan, -1])
@@ -1138,6 +1500,17 @@
 
     @pytest.mark.parametrize("fill_value", [0.0, np.nan])
     def test_modf(self, fill_value):
+        """
+
+        Parameters
+        ----------
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/26946
         sparse = SparseArray([fill_value] * 10 + [1.1, 2.2], fill_value=fill_value)
         r1, r2 = np.modf(sparse)
@@ -1146,12 +1519,14 @@
         tm.assert_sp_array_equal(r2, SparseArray(e2, fill_value=fill_value))
 
     def test_nbytes_integer(self):
+        """ """
         arr = SparseArray([1, 0, 0, 0, 2], kind="integer")
         result = arr.nbytes
         # (2 * 8) + 2 * 4
         assert result == 24
 
     def test_nbytes_block(self):
+        """ """
         arr = SparseArray([1, 2, 0, 0, 0], kind="block")
         result = arr.nbytes
         # (2 * 8) + 4 + 4
@@ -1159,21 +1534,36 @@
         assert result == 24
 
     def test_asarray_datetime64(self):
+        """ """
         s = SparseArray(pd.to_datetime(["2012", None, None, "2013"]))
         np.asarray(s)
 
     def test_density(self):
+        """ """
         arr = SparseArray([0, 1])
         assert arr.density == 0.5
 
     def test_npoints(self):
+        """ """
         arr = SparseArray([0, 1])
         assert arr.npoints == 1
 
 
 class TestAccessor:
+    """ """
     @pytest.mark.parametrize("attr", ["npoints", "density", "fill_value", "sp_values"])
     def test_get_attributes(self, attr):
+        """
+
+        Parameters
+        ----------
+        attr :
+            
+
+        Returns
+        -------
+
+        """
         arr = SparseArray([0, 1])
         ser = pd.Series(arr)
 
@@ -1183,6 +1573,7 @@
 
     @td.skip_if_no_scipy
     def test_from_coo(self):
+        """ """
         import scipy.sparse
 
         row = [0, 3, 1, 0]
@@ -1197,6 +1588,7 @@
 
     @td.skip_if_no_scipy
     def test_to_coo(self):
+        """ """
         import scipy.sparse
 
         ser = pd.Series(
@@ -1208,12 +1600,14 @@
         assert isinstance(A, scipy.sparse.coo.coo_matrix)
 
     def test_non_sparse_raises(self):
+        """ """
         ser = pd.Series([1, 2, 3])
         with pytest.raises(AttributeError, match=".sparse"):
             ser.sparse.density
 
 
 def test_setting_fill_value_fillna_still_works():
+    """ """
     # This is why letting users update fill_value / dtype is bad
     # astype has the same problem.
     arr = SparseArray([1.0, np.nan, 1.0], fill_value=0.0)
@@ -1228,6 +1622,7 @@
 
 
 def test_setting_fill_value_updates():
+    """ """
     arr = SparseArray([0.0, np.nan], fill_value=0)
     arr.fill_value = np.nan
     # use private constructor to get the index right
@@ -1252,6 +1647,19 @@
     ],
 )
 def test_first_fill_value_loc(arr, loc):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    loc :
+        
+
+    Returns
+    -------
+
+    """
     result = SparseArray(arr)._first_fill_value_loc()
     assert result == loc
 
@@ -1261,6 +1669,19 @@
 )
 @pytest.mark.parametrize("fill_value", [np.nan, 0, 1])
 def test_unique_na_fill(arr, fill_value):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    fill_value :
+        
+
+    Returns
+    -------
+
+    """
     a = SparseArray(arr, fill_value=fill_value).unique()
     b = pd.Series(arr).unique()
     assert isinstance(a, SparseArray)
@@ -1269,6 +1690,7 @@
 
 
 def test_unique_all_sparse():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/23168
     arr = SparseArray([0, 0])
     result = arr.unique()
@@ -1277,6 +1699,7 @@
 
 
 def test_map():
+    """ """
     arr = SparseArray([0, 1, 2])
     expected = SparseArray([10, 11, 12], fill_value=10)
 
@@ -1295,6 +1718,7 @@
 
 
 def test_map_missing():
+    """ """
     arr = SparseArray([0, 1, 2])
     expected = SparseArray([10, 11, None], fill_value=10)
 
@@ -1304,6 +1728,17 @@
 
 @pytest.mark.parametrize("fill_value", [np.nan, 1])
 def test_dropna(fill_value):
+    """
+
+    Parameters
+    ----------
+    fill_value :
+        
+
+    Returns
+    -------
+
+    """
     # GH-28287
     arr = SparseArray([np.nan, 1], fill_value=fill_value)
     exp = SparseArray([1.0], fill_value=fill_value)
