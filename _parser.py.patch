# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/dateutil/parser/_parser.py
+++ b/..//venv/lib/python3.8/site-packages/dateutil/parser/_parser.py
@@ -56,6 +56,7 @@
 # making public and/or figuring out if there is something we can
 # take off their plate.
 class _timelex(object):
+    """ """
     # Fractional seconds are sometimes split by a comma
     _split_decimal = re.compile("([.,])")
 
@@ -81,18 +82,24 @@
         self.eof = False
 
     def get_token(self):
-        """
-        This function breaks the time string into lexical units (tokens), which
+        """This function breaks the time string into lexical units (tokens), which
         can be parsed by the parser. Lexical units are demarcated by changes in
         the character set, so any continuous string of letters is considered
         one unit, any continuous string of numbers is considered one unit.
-
+        
         The main complication arises from the fact that dots ('.') can be used
         both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
         "4:30:21.447"). As such, it is necessary to read the full context of
         any dot-separated strings before breaking it into tokens; as such, this
         function maintains a "token stack", for when the ambiguous context
         demands that multiple tokens be parsed at once.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self.tokenstack:
             return self.tokenstack.pop(0)
@@ -200,35 +207,89 @@
         return token
 
     def next(self):
+        """ """
         return self.__next__()  # Python 2.x support
 
     @classmethod
     def split(cls, s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return list(cls(s))
 
     @classmethod
     def isword(cls, nextchar):
-        """ Whether or not the next character is part of a word """
+        """Whether or not the next character is part of a word
+
+        Parameters
+        ----------
+        nextchar :
+            
+
+        Returns
+        -------
+
+        """
         return nextchar.isalpha()
 
     @classmethod
     def isnum(cls, nextchar):
-        """ Whether the next character is part of a number """
+        """Whether the next character is part of a number
+
+        Parameters
+        ----------
+        nextchar :
+            
+
+        Returns
+        -------
+
+        """
         return nextchar.isdigit()
 
     @classmethod
     def isspace(cls, nextchar):
-        """ Whether the next character is whitespace """
+        """Whether the next character is whitespace
+
+        Parameters
+        ----------
+        nextchar :
+            
+
+        Returns
+        -------
+
+        """
         return nextchar.isspace()
 
 
 class _resultbase(object):
+    """ """
 
     def __init__(self):
         for attr in self.__slots__:
             setattr(self, attr, None)
 
     def _repr(self, classname):
+        """
+
+        Parameters
+        ----------
+        classname :
+            
+
+        Returns
+        -------
+
+        """
         l = []
         for attr in self.__slots__:
             value = getattr(self, attr)
@@ -245,21 +306,25 @@
 
 
 class parserinfo(object):
-    """
-    Class which handles what inputs are accepted. Subclass this to customize
+    """Class which handles what inputs are accepted. Subclass this to customize
     the language and acceptable values for each parameter.
 
-    :param dayfirst:
+    Parameters
+    ----------
+    dayfirst :
         Whether to interpret the first value in an ambiguous 3-integer date
         (e.g. 01/05/09) as the day (``True``) or month (``False``). If
         ``yearfirst`` is set to ``True``, this distinguishes between YDM
         and YMD. Default is ``False``.
-
-    :param yearfirst:
+    yearfirst :
         Whether to interpret the first value in an ambiguous 3-integer date
         (e.g. 01/05/09) as the year. If ``True``, the first number is taken
         to be the year, otherwise the last number is taken to be the year.
         Default is ``False``.
+
+    Returns
+    -------
+
     """
 
     # m from a.m/p.m, t from ISO T separator
@@ -313,6 +378,17 @@
         self._century = self._year // 100 * 100
 
     def _convert(self, lst):
+        """
+
+        Parameters
+        ----------
+        lst :
+            
+
+        Returns
+        -------
+
+        """
         dct = {}
         for i, v in enumerate(lst):
             if isinstance(v, tuple):
@@ -323,9 +399,31 @@
         return dct
 
     def jump(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return name.lower() in self._jump
 
     def weekday(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._weekdays[name.lower()]
         except KeyError:
@@ -333,6 +431,17 @@
         return None
 
     def month(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._months[name.lower()] + 1
         except KeyError:
@@ -340,33 +449,98 @@
         return None
 
     def hms(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._hms[name.lower()]
         except KeyError:
             return None
 
     def ampm(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._ampm[name.lower()]
         except KeyError:
             return None
 
     def pertain(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return name.lower() in self._pertain
 
     def utczone(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return name.lower() in self._utczone
 
     def tzoffset(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         if name in self._utczone:
             return 0
 
         return self.TZOFFSET.get(name)
 
     def convertyear(self, year, century_specified=False):
-        """
-        Converts two-digit years to year within [-50, 49]
+        """Converts two-digit years to year within [-50, 49]
         range of self._year (current local time)
+
+        Parameters
+        ----------
+        year :
+            
+        century_specified :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
 
         # Function contract is that the year is always positive
@@ -384,6 +558,17 @@
         return year
 
     def validate(self, res):
+        """
+
+        Parameters
+        ----------
+        res :
+            
+
+        Returns
+        -------
+
+        """
         # move to info
         if res.year is not None:
             res.year = self.convertyear(res.year, res.century_specified)
@@ -398,6 +583,7 @@
 
 
 class _ymd(list):
+    """ """
     def __init__(self, *args, **kwargs):
         super(self.__class__, self).__init__(*args, **kwargs)
         self.century_specified = False
@@ -407,17 +593,31 @@
 
     @property
     def has_year(self):
+        """ """
         return self.ystridx is not None
 
     @property
     def has_month(self):
+        """ """
         return self.mstridx is not None
 
     @property
     def has_day(self):
+        """ """
         return self.dstridx is not None
 
     def could_be_day(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         if self.has_day:
             return False
         elif not self.has_month:
@@ -432,6 +632,19 @@
             return 1 <= value <= monthrange(year, month)[1]
 
     def append(self, val, label=None):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+        label :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if hasattr(val, '__len__'):
             if val.isdigit() and len(val) > 2:
                 self.century_specified = True
@@ -460,9 +673,17 @@
             self.ystridx = len(self) - 1
 
     def _resolve_from_stridxs(self, strids):
-        """
-        Try to resolve the identities of year/month/day elements using
+        """Try to resolve the identities of year/month/day elements using
         ystridx, mstridx, and dstridx, if enough of these are specified.
+
+        Parameters
+        ----------
+        strids :
+            
+
+        Returns
+        -------
+
         """
         if len(self) == 3 and len(strids) == 2:
             # we can back out the remaining stridx value
@@ -478,6 +699,19 @@
         return (out.get('y'), out.get('m'), out.get('d'))
 
     def resolve_ymd(self, yearfirst, dayfirst):
+        """
+
+        Parameters
+        ----------
+        yearfirst :
+            
+        dayfirst :
+            
+
+        Returns
+        -------
+
+        """
         len_ymd = len(self)
         year, month, day = (None, None, None)
 
@@ -572,41 +806,65 @@
 
 
 class parser(object):
+    """ """
     def __init__(self, info=None):
         self.info = info or parserinfo()
 
     def parse(self, timestr, default=None,
               ignoretz=False, tzinfos=None, **kwargs):
-        """
-        Parse the date/time string into a :class:`datetime.datetime` object.
-
-        :param timestr:
+        """Parse the date/time string into a :class:`datetime.datetime` object.
+
+        Parameters
+        ----------
+        timestr :
             Any date/time string using the supported formats.
-
-        :param default:
+        default :
             The default datetime object, if this is a datetime object and not
             ``None``, elements specified in ``timestr`` replace elements in the
             default object.
-
-        :param ignoretz:
+        ignoretz :
             If set ``True``, time zones in parsed strings are ignored and a
-            naive :class:`datetime.datetime` object is returned.
-
-        :param tzinfos:
+            naive :class:`datetime.datetime` object is returned. (Default value = False)
+        tzinfos :
             Additional time zone names / aliases which may be present in the
             string. This argument maps time zone names (and optionally offsets
             from those time zones) to time zones. This parameter can be a
             dictionary with timezone aliases mapping time zone names to time
             zones or a function taking two parameters (``tzname`` and
             ``tzoffset``) and returning a time zone.
-
+            
             The timezones to which the names are mapped can be an integer
             offset from UTC in seconds or a :class:`tzinfo` object.
-
+            
             .. doctest::
-               :options: +NORMALIZE_WHITESPACE
-
-                >>> from dateutil.parser import parse
+            :options: +NORMALIZE_WHITESPACE
+            
+            
+            This parameter is ignored if ``ignoretz`` is set. (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+        type
+            Returns a :class:`datetime.datetime` object or, if the
+            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+            first element being a :class:`datetime.datetime` object, the second
+            a tuple containing the fuzzy tokens.
+
+        Raises
+        ------
+        ParserError
+            Raised for invalid or unknown string format, if the provided
+            :class:`tzinfo` is not in a valid format, or if an invalid date
+            would be created.
+        TypeError
+            Raised for non-string or character stream input.
+        OverflowError
+            Raised if the parsed date exceeds the largest valid C integer on
+            your system.
+
+        >>> from dateutil.parser import parse
                 >>> from dateutil.tz import gettz
                 >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
                 >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
@@ -614,29 +872,6 @@
                 >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
                 datetime.datetime(2012, 1, 19, 17, 21,
                                   tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
-
-            This parameter is ignored if ``ignoretz`` is set.
-
-        :param \\*\\*kwargs:
-            Keyword arguments as passed to ``_parse()``.
-
-        :return:
-            Returns a :class:`datetime.datetime` object or, if the
-            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
-            first element being a :class:`datetime.datetime` object, the second
-            a tuple containing the fuzzy tokens.
-
-        :raises ParserError:
-            Raised for invalid or unknown string format, if the provided
-            :class:`tzinfo` is not in a valid format, or if an invalid date
-            would be created.
-
-        :raises TypeError:
-            Raised for non-string or character stream input.
-
-        :raises OverflowError:
-            Raised if the parsed date exceeds the largest valid C integer on
-            your system.
         """
 
         if default is None:
@@ -665,50 +900,50 @@
             return ret
 
     class _result(_resultbase):
+        """ """
         __slots__ = ["year", "month", "day", "weekday",
                      "hour", "minute", "second", "microsecond",
                      "tzname", "tzoffset", "ampm","any_unused_tokens"]
 
     def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
                fuzzy_with_tokens=False):
-        """
-        Private method which performs the heavy lifting of parsing, called from
+        """Private method which performs the heavy lifting of parsing, called from
         ``parse()``, which passes on its ``kwargs`` to this function.
 
-        :param timestr:
+        Parameters
+        ----------
+        timestr :
             The string to parse.
-
-        :param dayfirst:
+        dayfirst :
             Whether to interpret the first value in an ambiguous 3-integer date
             (e.g. 01/05/09) as the day (``True``) or month (``False``). If
             ``yearfirst`` is set to ``True``, this distinguishes between YDM
             and YMD. If set to ``None``, this value is retrieved from the
             current :class:`parserinfo` object (which itself defaults to
             ``False``).
-
-        :param yearfirst:
+        yearfirst :
             Whether to interpret the first value in an ambiguous 3-integer date
             (e.g. 01/05/09) as the year. If ``True``, the first number is taken
             to be the year, otherwise the last number is taken to be the year.
             If this is set to ``None``, the value is retrieved from the current
             :class:`parserinfo` object (which itself defaults to ``False``).
-
-        :param fuzzy:
+        fuzzy :
             Whether to allow fuzzy parsing, allowing for string like "Today is
-            January 1, 2047 at 8:21:00AM".
-
-        :param fuzzy_with_tokens:
+            January 1, 2047 at 8:21:00AM". (Default value = False)
+        fuzzy_with_tokens :
             If ``True``, ``fuzzy`` is automatically set to True, and the parser
             will return a tuple where the first element is the parsed
             :class:`datetime.datetime` datetimestamp and the second element is
             a tuple containing the portions of the string which were ignored:
-
-            .. doctest::
-
-                >>> from dateutil.parser import parse
+            
+            .. doctest:: (Default value = False)
+
+        Returns
+        -------
+
+        >>> from dateutil.parser import parse
                 >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
                 (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
-
         """
         if fuzzy_with_tokens:
             fuzzy = True
@@ -879,6 +1114,27 @@
             return res, None
 
     def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
+        """
+
+        Parameters
+        ----------
+        tokens :
+            
+        idx :
+            
+        info :
+            
+        ymd :
+            
+        res :
+            
+        fuzzy :
+            
+
+        Returns
+        -------
+
+        """
         # Token is a number
         value_repr = tokens[idx]
         try:
@@ -1010,6 +1266,23 @@
         return idx
 
     def _find_hms_idx(self, idx, tokens, info, allow_jump):
+        """
+
+        Parameters
+        ----------
+        idx :
+            
+        tokens :
+            
+        info :
+            
+        allow_jump :
+            
+
+        Returns
+        -------
+
+        """
         len_l = len(tokens)
 
         if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
@@ -1044,6 +1317,21 @@
         return hms_idx
 
     def _assign_hms(self, res, value_repr, hms):
+        """
+
+        Parameters
+        ----------
+        res :
+            
+        value_repr :
+            
+        hms :
+            
+
+        Returns
+        -------
+
+        """
         # See GH issue #427, fixing float rounding
         value = self._to_decimal(value_repr)
 
@@ -1060,6 +1348,23 @@
             (res.second, res.microsecond) = self._parsems(value_repr)
 
     def _could_be_tzname(self, hour, tzname, tzoffset, token):
+        """
+
+        Parameters
+        ----------
+        hour :
+            
+        tzname :
+            
+        tzoffset :
+            
+        token :
+            
+
+        Returns
+        -------
+
+        """
         return (hour is not None and
                 tzname is None and
                 tzoffset is None and
@@ -1068,10 +1373,22 @@
                  or token in self.info.UTCZONE))
 
     def _ampm_valid(self, hour, ampm, fuzzy):
-        """
-        For fuzzy parsing, 'a' or 'am' (both valid English words)
+        """For fuzzy parsing, 'a' or 'am' (both valid English words)
         may erroneously trigger the AM/PM flag. Deal with that
         here.
+
+        Parameters
+        ----------
+        hour :
+            
+        ampm :
+            
+        fuzzy :
+            
+
+        Returns
+        -------
+
         """
         val_is_ampm = True
 
@@ -1096,6 +1413,19 @@
         return val_is_ampm
 
     def _adjust_ampm(self, hour, ampm):
+        """
+
+        Parameters
+        ----------
+        hour :
+            
+        ampm :
+            
+
+        Returns
+        -------
+
+        """
         if hour < 12 and ampm == 1:
             hour += 12
         elif hour == 12 and ampm == 0:
@@ -1103,6 +1433,17 @@
         return hour
 
     def _parse_min_sec(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: Every usage of this function sets res.second to the return
         # value. Are there any cases where second will be returned as None and
         # we *don't* want to set res.second = None?
@@ -1115,6 +1456,23 @@
         return (minute, second)
 
     def _parse_hms(self, idx, tokens, info, hms_idx):
+        """
+
+        Parameters
+        ----------
+        idx :
+            
+        tokens :
+            
+        info :
+            
+        hms_idx :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: Is this going to admit a lot of false-positives for when we
         # just happen to have digits and "h", "m" or "s" characters in non-date
         # text?  I guess hex hashes won't have that problem, but there's plenty
@@ -1137,7 +1495,17 @@
     #  of functions for the sake of customizability via subclassing.
 
     def _parsems(self, value):
-        """Parse a I[.F] seconds value into (seconds, microseconds)."""
+        """Parse a I[.F] seconds value into (seconds, microseconds).
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         if "." not in value:
             return int(value), 0
         else:
@@ -1145,6 +1513,17 @@
             return int(i), int(f.ljust(6, "0")[:6])
 
     def _to_decimal(self, val):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+
+        Returns
+        -------
+
+        """
         try:
             decimal_value = Decimal(val)
             # See GH 662, edge case, infinite value should not be converted
@@ -1163,6 +1542,21 @@
     #  subclassing.
 
     def _build_tzinfo(self, tzinfos, tzname, tzoffset):
+        """
+
+        Parameters
+        ----------
+        tzinfos :
+            
+        tzname :
+            
+        tzoffset :
+            
+
+        Returns
+        -------
+
+        """
         if callable(tzinfos):
             tzdata = tzinfos(tzname, tzoffset)
         else:
@@ -1181,6 +1575,21 @@
         return tzinfo
 
     def _build_tzaware(self, naive, res, tzinfos):
+        """
+
+        Parameters
+        ----------
+        naive :
+            
+        res :
+            
+        tzinfos :
+            
+
+        Returns
+        -------
+
+        """
         if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
             tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
             aware = naive.replace(tzinfo=tzinfo)
@@ -1221,6 +1630,19 @@
         return aware
 
     def _build_naive(self, res, default):
+        """
+
+        Parameters
+        ----------
+        res :
+            
+        default :
+            
+
+        Returns
+        -------
+
+        """
         repl = {}
         for attr in ("year", "month", "day", "hour",
                      "minute", "second", "microsecond"):
@@ -1246,6 +1668,19 @@
         return naive
 
     def _assign_tzname(self, dt, tzname):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+        tzname :
+            
+
+        Returns
+        -------
+
+        """
         if dt.tzname() != tzname:
             new_dt = tz.enfold(dt, fold=1)
             if new_dt.tzname() == tzname:
@@ -1255,6 +1690,17 @@
 
     def _recombine_skipped(self, tokens, skipped_idxs):
         """
+
+        Parameters
+        ----------
+        tokens :
+            
+        skipped_idxs :
+            
+
+        Returns
+        -------
+
         >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
         >>> skipped_idxs = [0, 1, 2, 5]
         >>> _recombine_skipped(tokens, skipped_idxs)
@@ -1274,45 +1720,86 @@
 
 
 def parse(timestr, parserinfo=None, **kwargs):
-    """
-
-    Parse a string in one of the supported formats, using the
+    """Parse a string in one of the supported formats, using the
     ``parserinfo`` parameters.
 
-    :param timestr:
+    Parameters
+    ----------
+    timestr :
         A string containing a date/time stamp.
-
-    :param parserinfo:
+    parserinfo :
         A :class:`parserinfo` object containing parameters for the parser.
         If ``None``, the default arguments to the :class:`parserinfo`
         constructor are used.
-
-    The ``**kwargs`` parameter takes the following keyword arguments:
-
-    :param default:
+        
+        The ``**kwargs`` parameter takes the following keyword arguments:
+    default :
         The default datetime object, if this is a datetime object and not
         ``None``, elements specified in ``timestr`` replace elements in the
         default object.
-
-    :param ignoretz:
+    ignoretz :
         If set ``True``, time zones in parsed strings are ignored and a naive
         :class:`datetime` object is returned.
-
-    :param tzinfos:
+    tzinfos :
         Additional time zone names / aliases which may be present in the
         string. This argument maps time zone names (and optionally offsets
         from those time zones) to time zones. This parameter can be a
         dictionary with timezone aliases mapping time zone names to time
         zones or a function taking two parameters (``tzname`` and
         ``tzoffset``) and returning a time zone.
-
+        
         The timezones to which the names are mapped can be an integer
         offset from UTC in seconds or a :class:`tzinfo` object.
-
+        
         .. doctest::
-           :options: +NORMALIZE_WHITESPACE
-
-            >>> from dateutil.parser import parse
+        :options: +NORMALIZE_WHITESPACE
+        
+        
+        This parameter is ignored if ``ignoretz`` is set.
+    dayfirst :
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
+        YMD. If set to ``None``, this value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+    yearfirst :
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
+        be the year, otherwise the last number is taken to be the year. If
+        this is set to ``None``, the value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+    fuzzy :
+        Whether to allow fuzzy parsing, allowing for string like "Today is
+        January 1, 2047 at 8:21:00AM".
+    fuzzy_with_tokens :
+        If ``True``, ``fuzzy`` is automatically set to True, and the parser
+        will return a tuple where the first element is the parsed
+        :class:`datetime.datetime` datetimestamp and the second element is
+        a tuple containing the portions of the string which were ignored:
+        
+        .. doctest::
+    **kwargs :
+        
+
+    Returns
+    -------
+    type
+        Returns a :class:`datetime.datetime` object or, if the
+        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+        first element being a :class:`datetime.datetime` object, the second
+        a tuple containing the fuzzy tokens.
+
+    Raises
+    ------
+    ValueError
+        Raised for invalid or unknown string format, if the provided
+        :class:`tzinfo` is not in a valid format, or if an invalid date
+        would be created.
+    OverflowError
+        Raised if the parsed date exceeds the largest valid C integer on
+        your system.
+
+    >>> from dateutil.parser import parse
             >>> from dateutil.tz import gettz
             >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
             >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
@@ -1320,53 +1807,10 @@
             >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
             datetime.datetime(2012, 1, 19, 17, 21,
                               tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
-
-        This parameter is ignored if ``ignoretz`` is set.
-
-    :param dayfirst:
-        Whether to interpret the first value in an ambiguous 3-integer date
-        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
-        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
-        YMD. If set to ``None``, this value is retrieved from the current
-        :class:`parserinfo` object (which itself defaults to ``False``).
-
-    :param yearfirst:
-        Whether to interpret the first value in an ambiguous 3-integer date
-        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
-        be the year, otherwise the last number is taken to be the year. If
-        this is set to ``None``, the value is retrieved from the current
-        :class:`parserinfo` object (which itself defaults to ``False``).
-
-    :param fuzzy:
-        Whether to allow fuzzy parsing, allowing for string like "Today is
-        January 1, 2047 at 8:21:00AM".
-
-    :param fuzzy_with_tokens:
-        If ``True``, ``fuzzy`` is automatically set to True, and the parser
-        will return a tuple where the first element is the parsed
-        :class:`datetime.datetime` datetimestamp and the second element is
-        a tuple containing the portions of the string which were ignored:
-
-        .. doctest::
-
+    
             >>> from dateutil.parser import parse
             >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
             (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
-
-    :return:
-        Returns a :class:`datetime.datetime` object or, if the
-        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
-        first element being a :class:`datetime.datetime` object, the second
-        a tuple containing the fuzzy tokens.
-
-    :raises ValueError:
-        Raised for invalid or unknown string format, if the provided
-        :class:`tzinfo` is not in a valid format, or if an invalid date
-        would be created.
-
-    :raises OverflowError:
-        Raised if the parsed date exceeds the largest valid C integer on
-        your system.
     """
     if parserinfo:
         return parser(parserinfo).parse(timestr, **kwargs)
@@ -1375,13 +1819,16 @@
 
 
 class _tzparser(object):
+    """ """
 
     class _result(_resultbase):
+        """ """
 
         __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
                      "start", "end"]
 
         class _attr(_resultbase):
+            """ """
             __slots__ = ["month", "week", "weekday",
                          "yday", "jyday", "day", "time"]
 
@@ -1394,6 +1841,17 @@
             self.end = self._attr()
 
     def parse(self, tzstr):
+        """
+
+        Parameters
+        ----------
+        tzstr :
+            
+
+        Returns
+        -------
+
+        """
         res = self._result()
         l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
         used_idxs = list()
@@ -1589,6 +2047,17 @@
 
 
 def _parsetz(tzstr):
+    """
+
+    Parameters
+    ----------
+    tzstr :
+        
+
+    Returns
+    -------
+
+    """
     return DEFAULTTZPARSER.parse(tzstr)
 
 
@@ -1605,5 +2074,5 @@
 
 
 class UnknownTimezoneWarning(RuntimeWarning):
-    """Raised when the parser finds a timezone it cannot parse into a tzinfo"""
+    """ """
 # vim:ts=4:sw=4:et
