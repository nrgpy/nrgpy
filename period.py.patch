# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/period.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/period.py
@@ -50,6 +50,17 @@
 
 
 def _new_PeriodIndex(cls, **d):
+    """
+
+    Parameters
+    ----------
+    **d :
+        
+
+    Returns
+    -------
+
+    """
     # GH13277 for unpickling
     values = d.pop("data")
     if values.dtype == "int64":
@@ -67,9 +78,8 @@
 )
 @inherit_names(["is_leap_year", "_format_native_types"], PeriodArray)
 class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
-    """
-    Immutable ndarray holding ordinal values indicating regular periods in time.
-
+    """Immutable ndarray holding ordinal values indicating regular periods in time.
+    
     Index keys are boxed to Period objects which carries the metadata (eg,
     frequency information).
 
@@ -82,15 +92,26 @@
     freq : str or period object, optional
         One of pandas period strings or corresponding objects.
     year : int, array, or Series, default None
+        
     month : int, array, or Series, default None
+        
     quarter : int, array, or Series, default None
+        
     day : int, array, or Series, default None
+        
     hour : int, array, or Series, default None
+        
     minute : int, array, or Series, default None
+        
     second : int, array, or Series, default None
+        
     tz : object, default None
         Timezone for converting datetime64 data to Periods.
     dtype : str or PeriodDtype, default None
+        
+
+    Returns
+    -------
 
     Attributes
     ----------
@@ -114,13 +135,11 @@
     weekday
     weekofyear
     year
-
     Methods
     -------
     asfreq
     strftime
     to_timestamp
-
     See Also
     --------
     Index : The base pandas Index type.
@@ -128,7 +147,6 @@
     DatetimeIndex : Index with datetime64 data.
     TimedeltaIndex : Index of timedelta64 data.
     period_range : Create a fixed-frequency PeriodIndex.
-
     Examples
     --------
     >>> idx = pd.PeriodIndex(year=[2000, 2002], quarter=[1, 3])
@@ -153,6 +171,19 @@
 
     @doc(PeriodArray.asfreq)
     def asfreq(self, freq=None, how: str = "E") -> "PeriodIndex":
+        """
+
+        Parameters
+        ----------
+        freq :
+             (Default value = None)
+        how: str :
+             (Default value = "E")
+
+        Returns
+        -------
+
+        """
         arr = self._data.asfreq(freq, how)
         return type(self)._simple_new(arr, name=self.name)
 
@@ -221,14 +252,19 @@
 
     @classmethod
     def _simple_new(cls, values: PeriodArray, name: Label = None):
-        """
-        Create a new PeriodIndex.
-
-        Parameters
-        ----------
-        values : PeriodArray
-            Values that can be converted to a PeriodArray without inference
-            or coercion.
+        """Create a new PeriodIndex.
+
+        Parameters
+        ----------
+        values: PeriodArray :
+            
+        name: Label :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         assert isinstance(values, PeriodArray), type(values)
 
@@ -246,14 +282,29 @@
 
     @property
     def values(self):
+        """ """
         return np.asarray(self)
 
     @property
     def _has_complex_internals(self):
+        """ """
         # used to avoid libreduction code paths, which raise or require conversion
         return True
 
     def _shallow_copy(self, values=None, name: Label = no_default):
+        """
+
+        Parameters
+        ----------
+        values :
+             (Default value = None)
+        name: Label :
+             (Default value = no_default)
+
+        Returns
+        -------
+
+        """
         name = name if name is not no_default else self.name
         cache = self._cache.copy() if values is None else {}
         if values is None:
@@ -264,21 +315,19 @@
         return result
 
     def _maybe_convert_timedelta(self, other):
-        """
-        Convert timedelta-like input to an integer multiple of self.freq
+        """Convert timedelta-like input to an integer multiple of self.freq
 
         Parameters
         ----------
         other : timedelta, np.timedelta64, DateOffset, int, np.ndarray
+            
 
         Returns
         -------
         converted : int, np.ndarray[int64]
-
-        Raises
-        ------
-        IncompatibleFrequency : if the input cannot be written as a multiple
-            of self.freq.  Note IncompatibleFrequency subclasses ValueError.
+            
+
+        
         """
         if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):
             if isinstance(self.freq, Tick):
@@ -300,8 +349,16 @@
         raise raise_on_incompatible(self, None)
 
     def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:
-        """
-        Can we compare values of the given dtype to our own?
+        """Can we compare values of the given dtype to our own?
+
+        Parameters
+        ----------
+        dtype: DtypeObj :
+            
+
+        Returns
+        -------
+
         """
         if not isinstance(dtype, PeriodDtype):
             return False
@@ -311,11 +368,13 @@
     # Rendering Methods
 
     def _mpl_repr(self):
+        """ """
         # how to represent ourselves to matplotlib
         return self.astype(object)._values
 
     @property
     def _formatter_func(self):
+        """ """
         return self.array._formatter(boxed=False)
 
     # ------------------------------------------------------------------------
@@ -338,6 +397,7 @@
 
     @cache_readonly
     def _int64index(self) -> Int64Index:
+        """ """
         return Int64Index._simple_new(self.asi8, name=self.name)
 
     # ------------------------------------------------------------------------
@@ -377,9 +437,19 @@
         return type(self)(result, freq=self.freq, name=self.name)
 
     def asof_locs(self, where, mask: np.ndarray) -> np.ndarray:
-        """
-        where : array of timestamps
+        """where : array of timestamps
         mask : array of booleans where data is not NA
+
+        Parameters
+        ----------
+        where :
+            
+        mask: np.ndarray :
+            
+
+        Returns
+        -------
+
         """
         where_idx = where
         if isinstance(where_idx, DatetimeIndex):
@@ -401,6 +471,21 @@
 
     @doc(Index.astype)
     def astype(self, dtype, copy=True, how="start"):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+        how :
+             (Default value = "start")
+
+        Returns
+        -------
+
+        """
         dtype = pandas_dtype(dtype)
 
         if is_datetime64_any_dtype(dtype):
@@ -413,9 +498,15 @@
 
     @property
     def is_full(self) -> bool:
-        """
-        Returns True if this PeriodIndex is range-like in that all Periods
+        """Returns True if this PeriodIndex is range-like in that all Periods
         between start and end are present, in order.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if len(self) == 0:
             return True
@@ -426,12 +517,30 @@
 
     @property
     def inferred_type(self) -> str:
+        """ """
         # b/c data is represented as ints make sure we can't have ambiguous
         # indexing
         return "period"
 
     @Appender(_index_shared_docs["get_indexer"] % _index_doc_kwargs)
     def get_indexer(self, target, method=None, limit=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         target = ensure_index(target)
 
         if isinstance(target, PeriodIndex):
@@ -455,6 +564,17 @@
 
     @Appender(_index_shared_docs["get_indexer_non_unique"] % _index_doc_kwargs)
     def get_indexer_non_unique(self, target):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
+        """
         target = ensure_index(target)
 
         if not self._is_comparable_dtype(target.dtype):
@@ -467,24 +587,23 @@
         return ensure_platform_int(indexer), missing
 
     def get_loc(self, key, method=None, tolerance=None):
-        """
-        Get integer location for requested label.
+        """Get integer location for requested label.
 
         Parameters
         ----------
         key : Period, NaT, str, or datetime
             String or datetime key must be parsable as Period.
+        method :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
 
         Returns
         -------
         loc : int or ndarray[int64]
-
-        Raises
-        ------
-        KeyError
-            Key is not present in the index.
-        TypeError
-            If key is listlike or otherwise not hashable.
+            
+
+        
         """
         orig_key = key
 
@@ -541,24 +660,30 @@
             raise KeyError(orig_key) from err
 
     def _maybe_cast_slice_bound(self, label, side: str, kind: str):
-        """
-        If label is a string or a datetime, cast it to Period.ordinal according
+        """If label is a string or a datetime, cast it to Period.ordinal according
         to resolution.
 
         Parameters
         ----------
         label : object
+            
         side : {'left', 'right'}
+            
         kind : {'loc', 'getitem'}
+            
+        side: str :
+            
+        kind: str :
+            
 
         Returns
         -------
         bound : Period or object
+            
 
         Notes
         -----
         Value of `side` parameter should be validated in caller.
-
         """
         assert kind in ["loc", "getitem"]
 
@@ -580,11 +705,35 @@
         return label
 
     def _parsed_string_to_bounds(self, reso: Resolution, parsed: datetime):
+        """
+
+        Parameters
+        ----------
+        reso: Resolution :
+            
+        parsed: datetime :
+            
+
+        Returns
+        -------
+
+        """
         grp = reso.freq_group
         iv = Period(parsed, freq=grp)
         return (iv.asfreq(self.freq, how="start"), iv.asfreq(self.freq, how="end"))
 
     def _validate_partial_date_slice(self, reso: Resolution):
+        """
+
+        Parameters
+        ----------
+        reso: Resolution :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(reso, Resolution), (type(reso), reso)
         grp = reso.freq_group
         freqn = self.dtype.freq_group
@@ -596,6 +745,21 @@
             raise ValueError
 
     def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):
+        """
+
+        Parameters
+        ----------
+        key: str :
+            
+        use_lhs: bool :
+             (Default value = True)
+        use_rhs: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         # TODO: Check for non-True use_lhs/use_rhs
         parsed, reso = parse_time_string(key, self.freq)
         reso = Resolution.from_attrname(reso)
@@ -605,6 +769,19 @@
             raise KeyError(key) from err
 
     def insert(self, loc, item):
+        """
+
+        Parameters
+        ----------
+        loc :
+            
+        item :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(item, Period) or self.freq != item.freq:
             return self.astype(object).insert(loc, item)
 
@@ -615,8 +792,24 @@
         return type(self)._simple_new(arr, name=self.name)
 
     def join(self, other, how="left", level=None, return_indexers=False, sort=False):
-        """
-        See Index.join
+        """See Index.join
+
+        Parameters
+        ----------
+        other :
+            
+        how :
+             (Default value = "left")
+        level :
+             (Default value = None)
+        return_indexers :
+             (Default value = False)
+        sort :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         self._assert_can_do_setop(other)
 
@@ -640,6 +833,17 @@
     # Set Operation Methods
 
     def _assert_can_do_setop(self, other):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         super()._assert_can_do_setop(other)
 
         # *Can't* use PeriodIndexes of different freqs
@@ -648,8 +852,20 @@
             raise raise_on_incompatible(self, other)
 
     def _setop(self, other, sort, opname: str):
-        """
-        Perform a set operation by dispatching to the Int64Index implementation.
+        """Perform a set operation by dispatching to the Int64Index implementation.
+
+        Parameters
+        ----------
+        other :
+            
+        sort :
+            
+        opname: str :
+            
+
+        Returns
+        -------
+
         """
         self._validate_sort_keyword(sort)
         self._assert_can_do_setop(other)
@@ -665,6 +881,19 @@
         return result
 
     def intersection(self, other, sort=False):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        sort :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         self._validate_sort_keyword(sort)
         self._assert_can_do_setop(other)
         other = ensure_index(other)
@@ -685,6 +914,19 @@
         return self._setop(other, sort, opname="intersection")
 
     def difference(self, other, sort=None):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        sort :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self._validate_sort_keyword(sort)
         self._assert_can_do_setop(other)
         other = ensure_index(other)
@@ -702,6 +944,19 @@
         return self._setop(other, sort, opname="difference")
 
     def _union(self, other, sort):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        sort :
+            
+
+        Returns
+        -------
+
+        """
         if not len(other) or self.equals(other) or not len(self):
             return super()._union(other, sort=sort)
 
@@ -718,6 +973,17 @@
     # ------------------------------------------------------------------------
 
     def memory_usage(self, deep=False):
+        """
+
+        Parameters
+        ----------
+        deep :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         result = super().memory_usage(deep=deep)
         if hasattr(self, "_cache") and "_int64index" in self._cache:
             result += self._int64index.memory_usage(deep=deep)
@@ -731,50 +997,49 @@
 def period_range(
     start=None, end=None, periods=None, freq=None, name=None
 ) -> PeriodIndex:
-    """
-    Return a fixed frequency PeriodIndex.
-
+    """Return a fixed frequency PeriodIndex.
+    
     The day (calendar) is the default frequency.
 
     Parameters
     ----------
     start : str or period-like, default None
-        Left bound for generating periods.
+        Left bound for generating periods. (Default value = None)
     end : str or period-like, default None
-        Right bound for generating periods.
+        Right bound for generating periods. (Default value = None)
     periods : int, default None
-        Number of periods to generate.
+        Number of periods to generate. (Default value = None)
     freq : str or DateOffset, optional
         Frequency alias. By default the freq is taken from `start` or `end`
         if those are Period objects. Otherwise, the default is ``"D"`` for
         daily frequency.
     name : str, default None
-        Name of the resulting PeriodIndex.
+        Name of the resulting PeriodIndex. (Default value = None)
 
     Returns
     -------
     PeriodIndex
+        
 
     Notes
     -----
     Of the three parameters: ``start``, ``end``, and ``periods``, exactly two
     must be specified.
-
+    
     To learn more about the frequency strings, please see `this link
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.
-
     Examples
     --------
+    
+    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor
+    endpoints for a ``PeriodIndex`` with frequency matching that of the
+    ``period_range`` constructor.
     >>> pd.period_range(start='2017-01-01', end='2018-01-01', freq='M')
     PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05', '2017-06',
              '2017-07', '2017-08', '2017-09', '2017-10', '2017-11', '2017-12',
              '2018-01'],
             dtype='period[M]', freq='M')
-
-    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor
-    endpoints for a ``PeriodIndex`` with frequency matching that of the
-    ``period_range`` constructor.
-
+    
     >>> pd.period_range(start=pd.Period('2017Q1', freq='Q'),
     ...                 end=pd.Period('2017Q2', freq='Q'), freq='M')
     PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'],
