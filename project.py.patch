# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/api/project.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/api/project.py
@@ -36,7 +36,31 @@
 
 
 def _try_to_skip_duplicates(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(*args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         found_tree_nodes = []
         found_modules = []
         for definition in func(*args, **kwargs):
@@ -53,6 +77,17 @@
 
 
 def _remove_duplicates_from_path(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     used = set()
     for p in path:
         if p in used:
@@ -62,32 +97,77 @@
 
 
 def _force_unicode_list(lst):
+    """
+
+    Parameters
+    ----------
+    lst :
+        
+
+    Returns
+    -------
+
+    """
     return list(map(force_unicode, lst))
 
 
 class Project(object):
-    """
-    Projects are a simple way to manage Python folders and define how Jedi does
+    """Projects are a simple way to manage Python folders and define how Jedi does
     import resolution. It is mostly used as a parameter to :class:`.Script`.
     Additionally there are functions to search a whole project.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     _environment = None
 
     @staticmethod
     def _get_config_folder_path(base_path):
+        """
+
+        Parameters
+        ----------
+        base_path :
+            
+
+        Returns
+        -------
+
+        """
         return os.path.join(base_path, _CONFIG_FOLDER)
 
     @staticmethod
     def _get_json_path(base_path):
+        """
+
+        Parameters
+        ----------
+        base_path :
+            
+
+        Returns
+        -------
+
+        """
         return os.path.join(Project._get_config_folder_path(base_path), 'project.json')
 
     @classmethod
     def load(cls, path):
-        """
-        Loads a project from a specific path. You should not provide the path
+        """Loads a project from a specific path. You should not provide the path
         to ``.jedi/project.json``, but rather the path to the project folder.
 
-        :param path: The path of the directory you want to use as a project.
+        Parameters
+        ----------
+        path :
+            The path of the directory you want to use as a project.
+
+        Returns
+        -------
+
         """
         with open(cls._get_json_path(path)) as f:
             version, data = json.load(f)
@@ -100,9 +180,7 @@
             )
 
     def save(self):
-        """
-        Saves the project configuration in the project in ``.jedi/project.json``.
-        """
+        """Saves the project configuration in the project in ``.jedi/project.json``."""
         data = dict(self.__dict__)
         data.pop('_environment', None)
         data.pop('_django', None)  # TODO make django setting public?
@@ -138,6 +216,27 @@
         """
         def py2_comp(path, environment_path=None, load_unsafe_extensions=False,
                      sys_path=None, added_sys_path=(), smart_sys_path=True):
+            """
+
+            Parameters
+            ----------
+            path :
+                
+            environment_path :
+                 (Default value = None)
+            load_unsafe_extensions :
+                 (Default value = False)
+            sys_path :
+                 (Default value = None)
+            added_sys_path :
+                 (Default value = ())
+            smart_sys_path :
+                 (Default value = True)
+
+            Returns
+            -------
+
+            """
             self._path = os.path.abspath(path)
 
             self._environment_path = environment_path
@@ -152,13 +251,22 @@
 
     @property
     def path(self):
-        """
-        The base path for this project.
-        """
+        """The base path for this project."""
         return self._path
 
     @inference_state_as_method_param_cache()
     def _get_base_sys_path(self, inference_state):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+
+        Returns
+        -------
+
+        """
         # The sys path has not been set explicitly.
         sys_path = list(inference_state.environment.get_sys_path())
         try:
@@ -169,9 +277,21 @@
 
     @inference_state_as_method_param_cache()
     def _get_sys_path(self, inference_state, add_parent_paths=True, add_init_paths=False):
-        """
-        Keep this method private for all users of jedi. However internally this
+        """Keep this method private for all users of jedi. However internally this
         one is used like a public method.
+
+        Parameters
+        ----------
+        inference_state :
+            
+        add_parent_paths :
+             (Default value = True)
+        add_init_paths :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         suffixed = list(self.added_sys_path)
         prefixed = []
@@ -212,6 +332,7 @@
         return list(_force_unicode_list(_remove_duplicates_from_path(path)))
 
     def get_environment(self):
+        """ """
         if self._environment is None:
             if self._environment_path is not None:
                 self._environment = create_environment(self._environment_path, safe=False)
@@ -220,14 +341,13 @@
         return self._environment
 
     def search(self, string, **kwargs):
-        """
-        Searches a name in the whole project. If the project is very big,
+        """Searches a name in the whole project. If the project is very big,
         at some point Jedi will stop searching. However it's also very much
         recommended to not exhaust the generator. Just display the first ten
         results to the user.
-
+        
         There are currently three different search patterns:
-
+        
         - ``foo`` to search for a definition foo in any file or a file called
           ``foo.py`` or ``foo.pyi``.
         - ``foo.bar`` to search for the ``foo`` and then an attribute ``bar``
@@ -235,30 +355,79 @@
         - ``class foo.bar.Bar`` or ``def foo.bar.baz`` to search for a specific
           API type.
 
-        :param bool all_scopes: Default False; searches not only for
+        Parameters
+        ----------
+        bool :
+            all_scopes: Default False; searches not only for
             definitions on the top level of a module level, but also in
             functions and classes.
-        :yields: :class:`.Name`
+            :yields: :class:`.Name`
+        string :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         return self._search(string, **kwargs)
 
     def complete_search(self, string, **kwargs):
-        """
-        Like :meth:`.Script.search`, but completes that string. An empty string
+        """Like :meth:`.Script.search`, but completes that string. An empty string
         lists all definitions in a project, so be careful with that.
 
-        :param bool all_scopes: Default False; searches not only for
+        Parameters
+        ----------
+        bool :
+            all_scopes: Default False; searches not only for
             definitions on the top level of a module level, but also in
             functions and classes.
-        :yields: :class:`.Completion`
+            :yields: :class:`.Completion`
+        string :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         return self._search_func(string, complete=True, **kwargs)
 
     def _search(self, string, all_scopes=False):  # Python 2..
+        """
+
+        Parameters
+        ----------
+        string :
+            
+        all_scopes :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return self._search_func(string, all_scopes=all_scopes)
 
     @_try_to_skip_duplicates
     def _search_func(self, string, complete=False, all_scopes=False):
+        """
+
+        Parameters
+        ----------
+        string :
+            
+        complete :
+             (Default value = False)
+        all_scopes :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         # Using a Script is they easiest way to get an empty module context.
         from jedi import Script
         s = Script('', project=self)
@@ -354,6 +523,17 @@
 
 
 def _is_potential_project(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     for name in _CONTAINS_POTENTIAL_PROJECT:
         if os.path.exists(os.path.join(path, name)):
             return True
@@ -361,7 +541,17 @@
 
 
 def _is_django_path(directory):
-    """ Detects the path of the very well known Django library (if used) """
+    """Detects the path of the very well known Django library (if used)
+
+    Parameters
+    ----------
+    directory :
+        
+
+    Returns
+    -------
+
+    """
     try:
         with open(os.path.join(directory, 'manage.py'), 'rb') as f:
             return b"DJANGO_SETTINGS_MODULE" in f.read()
@@ -370,14 +560,22 @@
 
 
 def get_default_project(path=None):
-    """
-    If a project is not defined by the user, Jedi tries to define a project by
+    """If a project is not defined by the user, Jedi tries to define a project by
     itself as well as possible. Jedi traverses folders until it finds one of
     the following:
-
+    
     1. A ``.jedi/config.json``
     2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
        ``requirements.txt`` and ``MANIFEST.in``.
+
+    Parameters
+    ----------
+    path :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if path is None:
         path = os.getcwd()
@@ -421,6 +619,17 @@
 
 
 def _remove_imports(names):
+    """
+
+    Parameters
+    ----------
+    names :
+        
+
+    Returns
+    -------
+
+    """
     return [
         n for n in names
         if n.tree_name is None or n.api_type != 'module'
