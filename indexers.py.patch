# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexers.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexers.py
@@ -22,16 +22,19 @@
 
 
 def is_valid_positional_slice(slc: slice) -> bool:
-    """
-    Check if a slice object can be interpreted as a positional indexer.
+    """Check if a slice object can be interpreted as a positional indexer.
 
     Parameters
     ----------
     slc : slice
+        
+    slc: slice :
+        
 
     Returns
     -------
     bool
+        
 
     Notes
     -----
@@ -40,6 +43,17 @@
     """
 
     def is_int_or_none(val):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+
+        Returns
+        -------
+
+        """
         return val is None or is_integer(val)
 
     return (
@@ -50,34 +64,38 @@
 
 
 def is_list_like_indexer(key) -> bool:
-    """
-    Check if we have a list-like indexer that is *not* a NamedTuple.
+    """Check if we have a list-like indexer that is *not* a NamedTuple.
 
     Parameters
     ----------
     key : object
-
-    Returns
-    -------
-    bool
+        
+
+    Returns
+    -------
+
+    
     """
     # allow a list_like, but exclude NamedTuples which can be indexers
     return is_list_like(key) and not (isinstance(key, tuple) and type(key) is not tuple)
 
 
 def is_scalar_indexer(indexer, ndim: int) -> bool:
-    """
-    Return True if we are all scalar indexers.
+    """Return True if we are all scalar indexers.
 
     Parameters
     ----------
     indexer : object
+        
     ndim : int
         Number of dimensions in the object being indexed.
-
-    Returns
-    -------
-    bool
+    ndim: int :
+        
+
+    Returns
+    -------
+
+    
     """
     if isinstance(indexer, tuple):
         if len(indexer) == ndim:
@@ -89,17 +107,21 @@
 
 
 def is_empty_indexer(indexer, arr_value: np.ndarray) -> bool:
-    """
-    Check if we have an empty indexer.
+    """Check if we have an empty indexer.
 
     Parameters
     ----------
     indexer : object
+        
     arr_value : np.ndarray
-
-    Returns
-    -------
-    bool
+        
+    arr_value: np.ndarray :
+        
+
+    Returns
+    -------
+
+    
     """
     if is_list_like(indexer) and not len(indexer):
         return True
@@ -115,9 +137,8 @@
 
 
 def check_setitem_lengths(indexer, value, values) -> None:
-    """
-    Validate that value and indexer are the same length.
-
+    """Validate that value and indexer are the same length.
+    
     An special-case is allowed for when the indexer is a boolean array
     and the number of true values equals the length of ``value``. In
     this case, no exception is raised.
@@ -134,11 +155,9 @@
     Returns
     -------
     None
-
-    Raises
-    ------
-    ValueError
-        When the indexer is an ndarray or list and the lengths don't match.
+        
+
+    
     """
     # boolean with truth values == len of the value is ok too
     if isinstance(indexer, (np.ndarray, list)):
@@ -164,20 +183,28 @@
 
 
 def validate_indices(indices: np.ndarray, n: int) -> None:
-    """
-    Perform bounds-checking for an indexer.
-
+    """Perform bounds-checking for an indexer.
+    
     -1 is allowed for indicating missing values.
 
     Parameters
     ----------
     indices : ndarray
+        
     n : int
         Length of the array being indexed.
+    indices: np.ndarray :
+        
+    n: int :
+        
+
+    Returns
+    -------
 
     Raises
     ------
     ValueError
+        
 
     Examples
     --------
@@ -208,9 +235,8 @@
 
 
 def maybe_convert_indices(indices, n: int):
-    """
-    Attempt to convert indices into valid, positive indices.
-
+    """Attempt to convert indices into valid, positive indices.
+    
     If we have negative indices, translate to positive here.
     If we have indices that are out-of-bounds, raise an IndexError.
 
@@ -220,6 +246,8 @@
         Array of indices that we are to convert.
     n : int
         Number of elements in the array that we are indexing.
+    n: int :
+        
 
     Returns
     -------
@@ -227,11 +255,7 @@
         An array-like of positive indices that correspond to the ones
         that were passed in initially to this function.
 
-    Raises
-    ------
-    IndexError
-        One of the converted indices either exceeded the number of,
-        elements (specified by `n`), or was still negative.
+    
     """
     if isinstance(indices, list):
         indices = np.array(indices)
@@ -256,12 +280,19 @@
 
 
 def length_of_indexer(indexer, target=None) -> int:
-    """
-    Return the expected length of target[indexer]
-
-    Returns
-    -------
-    int
+    """Return the expected length of target[indexer]
+
+    Parameters
+    ----------
+    indexer :
+        
+    target :
+         (Default value = None)
+
+    Returns
+    -------
+
+    
     """
     if target is not None and isinstance(indexer, slice):
         target_len = len(target)
@@ -296,13 +327,23 @@
 
 
 def deprecate_ndim_indexing(result, stacklevel=3):
-    """
-    Helper function to raise the deprecation warning for multi-dimensional
+    """Helper function to raise the deprecation warning for multi-dimensional
     indexing on 1D Series/Index.
-
+    
     GH#27125 indexer like idx[:, None] expands dim, but we cannot do that
     and keep an index, so we currently return ndarray, which is deprecated
     (Deprecation GH#30588).
+
+    Parameters
+    ----------
+    result :
+        
+    stacklevel :
+         (Default value = 3)
+
+    Returns
+    -------
+
     """
     if np.ndim(result) > 1:
         warnings.warn(
@@ -315,9 +356,16 @@
 
 
 def unpack_1tuple(tup):
-    """
-    If we have a length-1 tuple/list that contains a slice, unpack to just
+    """If we have a length-1 tuple/list that contains a slice, unpack to just
     the slice.
+
+    Parameters
+    ----------
+    tup :
+        
+
+    Returns
+    -------
 
     Notes
     -----
@@ -346,18 +394,17 @@
 
 
 def check_array_indexer(array: AnyArrayLike, indexer: Any) -> Any:
-    """
-    Check if `indexer` is a valid array indexer for `array`.
-
+    """Check if `indexer` is a valid array indexer for `array`.
+    
     For a boolean mask, `array` and `indexer` are checked to have the same
     length. The dtype is validated, and if it is an integer or boolean
     ExtensionArray, it is checked if there are missing values present, and
     it is converted to the appropriate numpy array. Other dtypes will raise
     an error.
-
+    
     Non-array indexers (integer, slice, Ellipsis, tuples, ..) are passed
     through as is.
-
+    
     .. versionadded:: 1.0.0
 
     Parameters
@@ -368,6 +415,10 @@
         The array-like that's used to index. List-like input that is not yet
         a numpy array or an ExtensionArray is converted to one. Other input
         types are passed through as is.
+    array: AnyArrayLike :
+        
+    indexer: Any :
+        
 
     Returns
     -------
@@ -385,54 +436,58 @@
     See Also
     --------
     api.types.is_bool_dtype : Check if `key` is of boolean dtype.
-
     Examples
     --------
     When checking a boolean mask, a boolean ndarray is returned when the
     arguments are all valid.
-
+    
+    
+    An IndexError is raised when the lengths don't match.
+    
+    
+    NA values in a boolean array are treated as False.
+    
+    
+    A numpy boolean mask will get passed through (if the length is correct):
+    
+    
+    Similarly for integer indexers, an integer ndarray is returned when it is
+    a valid indexer, otherwise an error is  (for integer indexers, a matching
+    length is not required):
+    
+    
+    
+    For non-integer/boolean dtypes, an appropriate error is raised:
     >>> mask = pd.array([True, False])
     >>> arr = pd.array([1, 2])
     >>> pd.api.indexers.check_array_indexer(arr, mask)
     array([ True, False])
-
-    An IndexError is raised when the lengths don't match.
-
+    
     >>> mask = pd.array([True, False, True])
     >>> pd.api.indexers.check_array_indexer(arr, mask)
     Traceback (most recent call last):
     ...
     IndexError: Boolean index has wrong length: 3 instead of 2.
-
-    NA values in a boolean array are treated as False.
-
+    
     >>> mask = pd.array([True, pd.NA])
     >>> pd.api.indexers.check_array_indexer(arr, mask)
     array([ True, False])
-
-    A numpy boolean mask will get passed through (if the length is correct):
-
+    
     >>> mask = np.array([True, False])
     >>> pd.api.indexers.check_array_indexer(arr, mask)
     array([ True, False])
-
-    Similarly for integer indexers, an integer ndarray is returned when it is
-    a valid indexer, otherwise an error is  (for integer indexers, a matching
-    length is not required):
-
+    
     >>> indexer = pd.array([0, 2], dtype="Int64")
     >>> arr = pd.array([1, 2, 3])
     >>> pd.api.indexers.check_array_indexer(arr, indexer)
     array([0, 2])
-
+    
     >>> indexer = pd.array([0, pd.NA], dtype="Int64")
     >>> pd.api.indexers.check_array_indexer(arr, indexer)
     Traceback (most recent call last):
     ...
     ValueError: Cannot index with an integer indexer containing NA values
-
-    For non-integer/boolean dtypes, an appropriate error is raised:
-
+    
     >>> indexer = np.array([0., 2.], dtype="float64")
     >>> pd.api.indexers.check_array_indexer(arr, indexer)
     Traceback (most recent call last):
