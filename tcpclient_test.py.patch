# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/tcpclient_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/tcpclient_test.py
@@ -39,6 +39,7 @@
 
 
 class TestTCPServer(TCPServer):
+    """ """
     def __init__(self, family):
         super().__init__()
         self.streams = []  # type: List[IOStream]
@@ -48,38 +49,68 @@
         self.port = sockets[0].getsockname()[1]
 
     def handle_stream(self, stream, address):
+        """
+
+        Parameters
+        ----------
+        stream :
+            
+        address :
+            
+
+        Returns
+        -------
+
+        """
         self.streams.append(stream)
         self.queue.put(stream)
 
     def stop(self):
+        """ """
         super().stop()
         for stream in self.streams:
             stream.close()
 
 
 class TCPClientTest(AsyncTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.server = None
         self.client = TCPClient()
 
     def start_server(self, family):
+        """
+
+        Parameters
+        ----------
+        family :
+            
+
+        Returns
+        -------
+
+        """
         if family == socket.AF_UNSPEC and "TRAVIS" in os.environ:
             self.skipTest("dual-stack servers often have port conflicts on travis")
         self.server = TestTCPServer(family)
         return self.server.port
 
     def stop_server(self):
+        """ """
         if self.server is not None:
             self.server.stop()
             self.server = None
 
     def tearDown(self):
+        """ """
         self.client.close()
         self.stop_server()
         super().tearDown()
 
     def skipIfLocalhostV4(self):
+        """ """
         # The port used here doesn't matter, but some systems require it
         # to be non-zero if we do not also pass AI_PASSIVE.
         addrinfo = self.io_loop.run_sync(lambda: Resolver().resolve("localhost", 80))
@@ -89,6 +120,23 @@
 
     @gen_test
     def do_test_connect(self, family, host, source_ip=None, source_port=None):
+        """
+
+        Parameters
+        ----------
+        family :
+            
+        host :
+            
+        source_ip :
+             (Default value = None)
+        source_port :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         port = self.start_server(family)
         stream = yield self.client.connect(
             host, port, source_ip=source_ip, source_port=source_port
@@ -101,44 +149,51 @@
             self.assertEqual(data, b"hello")
 
     def test_connect_ipv4_ipv4(self):
+        """ """
         self.do_test_connect(socket.AF_INET, "127.0.0.1")
 
     def test_connect_ipv4_dual(self):
+        """ """
         self.do_test_connect(socket.AF_INET, "localhost")
 
     @skipIfNoIPv6
     def test_connect_ipv6_ipv6(self):
+        """ """
         self.skipIfLocalhostV4()
         self.do_test_connect(socket.AF_INET6, "::1")
 
     @skipIfNoIPv6
     def test_connect_ipv6_dual(self):
+        """ """
         self.skipIfLocalhostV4()
         if Resolver.configured_class().__name__.endswith("TwistedResolver"):
             self.skipTest("TwistedResolver does not support multiple addresses")
         self.do_test_connect(socket.AF_INET6, "localhost")
 
     def test_connect_unspec_ipv4(self):
+        """ """
         self.do_test_connect(socket.AF_UNSPEC, "127.0.0.1")
 
     @skipIfNoIPv6
     def test_connect_unspec_ipv6(self):
+        """ """
         self.skipIfLocalhostV4()
         self.do_test_connect(socket.AF_UNSPEC, "::1")
 
     def test_connect_unspec_dual(self):
+        """ """
         self.do_test_connect(socket.AF_UNSPEC, "localhost")
 
     @gen_test
     def test_refused_ipv4(self):
+        """ """
         cleanup_func, port = refusing_port()
         self.addCleanup(cleanup_func)
         with self.assertRaises(IOError):
             yield self.client.connect("127.0.0.1", port)
 
     def test_source_ip_fail(self):
-        """Fail when trying to use the source IP Address '8.8.8.8'.
-        """
+        """Fail when trying to use the source IP Address '8.8.8.8'."""
         self.assertRaises(
             socket.error,
             self.do_test_connect,
@@ -148,14 +203,12 @@
         )
 
     def test_source_ip_success(self):
-        """Success when trying to use the source IP Address '127.0.0.1'.
-        """
+        """Success when trying to use the source IP Address '127.0.0.1'."""
         self.do_test_connect(socket.AF_INET, "127.0.0.1", source_ip="127.0.0.1")
 
     @skipIfNonUnix
     def test_source_port_fail(self):
-        """Fail when trying to use source port 1.
-        """
+        """Fail when trying to use source port 1."""
         if getpass.getuser() == "root":
             # Root can use any port so we can't easily force this to fail.
             # This is mainly relevant for docker.
@@ -170,10 +223,25 @@
 
     @gen_test
     def test_connect_timeout(self):
+        """ """
         timeout = 0.05
 
         class TimeoutResolver(Resolver):
+            """ """
             def resolve(self, *args, **kwargs):
+                """
+
+                Parameters
+                ----------
+                *args :
+                    
+                **kwargs :
+                    
+
+                Returns
+                -------
+
+                """
                 return Future()  # never completes
 
         with self.assertRaises(TimeoutError):
@@ -183,13 +251,16 @@
 
 
 class TestConnectorSplit(unittest.TestCase):
+    """ """
     def test_one_family(self):
+        """ """
         # These addresses aren't in the right format, but split doesn't care.
         primary, secondary = _Connector.split([(AF1, "a"), (AF1, "b")])
         self.assertEqual(primary, [(AF1, "a"), (AF1, "b")])
         self.assertEqual(secondary, [])
 
     def test_mixed(self):
+        """ """
         primary, secondary = _Connector.split(
             [(AF1, "a"), (AF2, "b"), (AF1, "c"), (AF2, "d")]
         )
@@ -198,14 +269,18 @@
 
 
 class ConnectorTest(AsyncTestCase):
+    """ """
     class FakeStream(object):
+        """ """
         def __init__(self):
             self.closed = False
 
         def close(self):
+            """ """
             self.closed = True
 
     def setUp(self):
+        """ """
         super().setUp()
         self.connect_futures = (
             {}
@@ -214,6 +289,7 @@
         self.addrinfo = [(AF1, "a"), (AF1, "b"), (AF2, "c"), (AF2, "d")]
 
     def tearDown(self):
+        """ """
         # Unless explicitly checked (and popped) in the test, we shouldn't
         # be closing any streams
         for stream in self.streams.values():
@@ -221,6 +297,19 @@
         super().tearDown()
 
     def create_stream(self, af, addr):
+        """
+
+        Parameters
+        ----------
+        af :
+            
+        addr :
+            
+
+        Returns
+        -------
+
+        """
         stream = ConnectorTest.FakeStream()
         self.streams[addr] = stream
         future = Future()  # type: Future[ConnectorTest.FakeStream]
@@ -228,9 +317,35 @@
         return stream, future
 
     def assert_pending(self, *keys):
+        """
+
+        Parameters
+        ----------
+        *keys :
+            
+
+        Returns
+        -------
+
+        """
         self.assertEqual(sorted(self.connect_futures.keys()), sorted(keys))
 
     def resolve_connect(self, af, addr, success):
+        """
+
+        Parameters
+        ----------
+        af :
+            
+        addr :
+            
+        success :
+            
+
+        Returns
+        -------
+
+        """
         future = self.connect_futures.pop((af, addr))
         if success:
             future.set_result(self.streams[addr])
@@ -242,22 +357,46 @@
         self.wait()
 
     def assert_connector_streams_closed(self, conn):
+        """
+
+        Parameters
+        ----------
+        conn :
+            
+
+        Returns
+        -------
+
+        """
         for stream in conn.streams:
             self.assertTrue(stream.closed)
 
     def start_connect(self, addrinfo):
+        """
+
+        Parameters
+        ----------
+        addrinfo :
+            
+
+        Returns
+        -------
+
+        """
         conn = _Connector(addrinfo, self.create_stream)
         # Give it a huge timeout; we'll trigger timeouts manually.
         future = conn.start(3600, connect_timeout=self.io_loop.time() + 3600)
         return conn, future
 
     def test_immediate_success(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assertEqual(list(self.connect_futures.keys()), [(AF1, "a")])
         self.resolve_connect(AF1, "a", True)
         self.assertEqual(future.result(), (AF1, "a", self.streams["a"]))
 
     def test_immediate_failure(self):
+        """ """
         # Fail with just one address.
         conn, future = self.start_connect([(AF1, "a")])
         self.assert_pending((AF1, "a"))
@@ -265,6 +404,7 @@
         self.assertRaises(IOError, future.result)
 
     def test_one_family_second_try(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", False)
@@ -273,6 +413,7 @@
         self.assertEqual(future.result(), (AF1, "b", self.streams["b"]))
 
     def test_one_family_second_try_failure(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", False)
@@ -281,6 +422,7 @@
         self.assertRaises(IOError, future.result)
 
     def test_one_family_second_try_timeout(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         # trigger the timeout while the first lookup is pending;
@@ -293,6 +435,7 @@
         self.assertEqual(future.result(), (AF1, "b", self.streams["b"]))
 
     def test_two_families_immediate_failure(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", False)
@@ -302,6 +445,7 @@
         self.assertEqual(future.result(), (AF2, "c", self.streams["c"]))
 
     def test_two_families_timeout(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_timeout()
@@ -313,6 +457,7 @@
         self.assert_pending()
 
     def test_success_after_timeout(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_timeout()
@@ -324,6 +469,7 @@
         self.assertTrue(self.streams.pop("c").closed)
 
     def test_all_fail(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_timeout()
@@ -340,6 +486,7 @@
         self.assertRaises(IOError, future.result)
 
     def test_one_family_timeout_after_connect_timeout(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         conn.on_connect_timeout()
@@ -356,6 +503,7 @@
         self.assertRaises(TimeoutError, future.result)
 
     def test_one_family_success_before_connect_timeout(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", True)
@@ -369,6 +517,7 @@
         self.assertEqual(future.result(), (AF1, "a", self.streams["a"]))
 
     def test_one_family_second_try_after_connect_timeout(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", False)
@@ -382,6 +531,7 @@
         self.assertRaises(TimeoutError, future.result)
 
     def test_one_family_second_try_failure_before_connect_timeout(self):
+        """ """
         conn, future = self.start_connect([(AF1, "a"), (AF1, "b")])
         self.assert_pending((AF1, "a"))
         self.resolve_connect(AF1, "a", False)
@@ -394,6 +544,7 @@
         self.assertRaises(IOError, future.result)
 
     def test_two_family_timeout_before_connect_timeout(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_timeout()
@@ -409,6 +560,7 @@
         self.assertRaises(TimeoutError, future.result)
 
     def test_two_family_success_after_timeout(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_timeout()
@@ -423,6 +575,7 @@
         self.assertEqual(future.result(), (AF1, "a", self.streams["a"]))
 
     def test_two_family_timeout_after_connect_timeout(self):
+        """ """
         conn, future = self.start_connect(self.addrinfo)
         self.assert_pending((AF1, "a"))
         conn.on_connect_timeout()
