# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/iostream.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/iostream.py
@@ -82,17 +82,31 @@
 
 
 class StreamClosedError(IOError):
-    """Exception raised by `IOStream` methods when the stream is closed.
-
-    Note that the close callback is scheduled to run *after* other
-    callbacks on the stream (to allow for buffered data to be processed),
-    so you may see this error before you see the close callback.
-
-    The ``real_error`` attribute contains the underlying error that caused
-    the stream to close (if any).
-
-    .. versionchanged:: 4.3
-       Added the ``real_error`` attribute.
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    Note
+        that the close callback is scheduled to run
+    callbacks
+        on the stream
+    so
+        you may see this error before you see the close callback
+    The
+        real_error
+    the
+        stream to close
+    .
+        versionchanged
+    Added
+        the
+
     """
 
     def __init__(self, real_error: Optional[BaseException] = None) -> None:
@@ -103,22 +117,36 @@
 class UnsatisfiableReadError(Exception):
     """Exception raised when a read cannot be satisfied.
 
-    Raised by ``read_until`` and ``read_until_regex`` with a ``max_bytes``
-    argument.
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    argument
+        
+
     """
 
     pass
 
 
 class StreamBufferFullError(Exception):
-    """Exception raised by `IOStream` methods when the buffer is full.
-    """
+    """ """
 
 
 class _StreamBuffer(object):
-    """
-    A specialized buffer that tries to avoid copies when large pieces
+    """A specialized buffer that tries to avoid copies when large pieces
     of data are encountered.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self) -> None:
@@ -138,8 +166,20 @@
     _large_buf_threshold = 2048
 
     def append(self, data: Union[bytes, bytearray, memoryview]) -> None:
-        """
-        Append the given piece of data (should be a buffer-compatible object).
+        """Append the given piece of data (should be a buffer-compatible object).
+
+        Parameters
+        ----------
+        data: Union[bytes :
+            
+        bytearray :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
+
         """
         size = len(data)
         if size > self._large_buf_threshold:
@@ -160,9 +200,17 @@
         self._size += size
 
     def peek(self, size: int) -> memoryview:
-        """
-        Get a view over at most ``size`` bytes (possibly fewer) at the
+        """Get a view over at most ``size`` bytes (possibly fewer) at the
         current buffer position.
+
+        Parameters
+        ----------
+        size: int :
+            
+
+        Returns
+        -------
+
         """
         assert size > 0
         try:
@@ -177,8 +225,16 @@
             return memoryview(b)[pos : pos + size]
 
     def advance(self, size: int) -> None:
-        """
-        Advance the current buffer position by ``size`` bytes.
+        """Advance the current buffer position by ``size`` bytes.
+
+        Parameters
+        ----------
+        size: int :
+            
+
+        Returns
+        -------
+
         """
         assert 0 < size <= self._size
         self._size -= size
@@ -209,19 +265,25 @@
 
 class BaseIOStream(object):
     """A utility class to write to and read from a non-blocking file or socket.
-
+    
     We support a non-blocking ``write()`` and a family of ``read_*()``
     methods. When the operation completes, the ``Awaitable`` will resolve
     with the data read (or ``None`` for ``write()``). All outstanding
     ``Awaitables`` will resolve with a `StreamClosedError` when the
     stream is closed; `.BaseIOStream.set_close_callback` can also be used
     to be notified of a closed stream.
-
+    
     When a stream is closed due to an error, the IOStream's ``error``
     attribute contains the exception object.
-
+    
     Subclasses must implement `fileno`, `close_fd`, `write_to_fd`,
     `read_from_fd`, and optionally `get_fd_error`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -289,41 +351,75 @@
 
     def close_fd(self) -> None:
         """Closes the file underlying this stream.
-
+        
         ``close_fd`` is called by `BaseIOStream` and should not be called
         elsewhere; other users should call `close` instead.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def write_to_fd(self, data: memoryview) -> int:
         """Attempts to write ``data`` to the underlying file.
-
+        
         Returns the number of bytes written.
+
+        Parameters
+        ----------
+        data: memoryview :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:
         """Attempts to read from the underlying file.
-
+        
         Reads up to ``len(buf)`` bytes, storing them in the buffer.
         Returns the number of bytes read. Returns None if there was
         nothing to read (the socket returned `~errno.EWOULDBLOCK` or
         equivalent), and zero on EOF.
-
+        
         .. versionchanged:: 5.0
-
+        
            Interface redesigned to take a buffer and return a number
            of bytes instead of a freshly-allocated object.
+
+        Parameters
+        ----------
+        buf: Union[bytearray :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def get_fd_error(self) -> Optional[Exception]:
         """Returns information about any error on the underlying file.
-
+        
         This method is called after the `.IOLoop` has signaled an error on the
         file descriptor, and should return an Exception (such as `socket.error`
         with additional information, or None if no such information is
         available.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
@@ -331,22 +427,32 @@
         self, regex: bytes, max_bytes: Optional[int] = None
     ) -> Awaitable[bytes]:
         """Asynchronously read until we have matched the given regex.
-
+        
         The result includes the data that matches the regex and anything
         that came before it.
-
+        
         If ``max_bytes`` is not None, the connection will be closed
         if more than ``max_bytes`` bytes have been read and the regex is
         not satisfied.
-
+        
         .. versionchanged:: 4.0
             Added the ``max_bytes`` argument.  The ``callback`` argument is
             now optional and a `.Future` will be returned if it is omitted.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed. Use the returned
            `.Future` instead.
+
+        Parameters
+        ----------
+        regex: bytes :
+            
+        max_bytes: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
 
         """
         future = self._start_read()
@@ -370,21 +476,32 @@
         self, delimiter: bytes, max_bytes: Optional[int] = None
     ) -> Awaitable[bytes]:
         """Asynchronously read until we have found the given delimiter.
-
+        
         The result includes all the data read including the delimiter.
-
+        
         If ``max_bytes`` is not None, the connection will be closed
         if more than ``max_bytes`` bytes have been read and the delimiter
         is not found.
-
+        
         .. versionchanged:: 4.0
             Added the ``max_bytes`` argument.  The ``callback`` argument is
             now optional and a `.Future` will be returned if it is omitted.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed. Use the returned
            `.Future` instead.
+
+        Parameters
+        ----------
+        delimiter: bytes :
+            
+        max_bytes: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         future = self._start_read()
         self._read_delimiter = delimiter
@@ -403,19 +520,29 @@
 
     def read_bytes(self, num_bytes: int, partial: bool = False) -> Awaitable[bytes]:
         """Asynchronously read a number of bytes.
-
+        
         If ``partial`` is true, data is returned as soon as we have
         any bytes to return (but never more than ``num_bytes``)
-
+        
         .. versionchanged:: 4.0
             Added the ``partial`` argument.  The callback argument is now
             optional and a `.Future` will be returned if it is omitted.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` and ``streaming_callback`` arguments have
            been removed. Use the returned `.Future` (and
            ``partial=True`` for ``streaming_callback``) instead.
+
+        Parameters
+        ----------
+        num_bytes: int :
+            
+        partial: bool :
+             (Default value = False)
+
+        Returns
+        -------
 
         """
         future = self._start_read()
@@ -431,19 +558,29 @@
 
     def read_into(self, buf: bytearray, partial: bool = False) -> Awaitable[int]:
         """Asynchronously read a number of bytes.
-
+        
         ``buf`` must be a writable buffer into which data will be read.
-
+        
         If ``partial`` is true, the callback is run as soon as any bytes
         have been read.  Otherwise, it is run when the ``buf`` has been
         entirely filled with read data.
-
+        
         .. versionadded:: 5.0
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed. Use the returned
            `.Future` instead.
+
+        Parameters
+        ----------
+        buf: bytearray :
+            
+        partial: bool :
+             (Default value = False)
+
+        Returns
+        -------
 
         """
         future = self._start_read()
@@ -480,20 +617,26 @@
 
     def read_until_close(self) -> Awaitable[bytes]:
         """Asynchronously reads all data from the socket until it is closed.
-
+        
         This will buffer all available data until ``max_buffer_size``
         is reached. If flow control or cancellation are desired, use a
         loop with `read_bytes(partial=True) <.read_bytes>` instead.
-
+        
         .. versionchanged:: 4.0
             The callback argument is now optional and a `.Future` will
             be returned if it is omitted.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` and ``streaming_callback`` arguments have
            been removed. Use the returned `.Future` (and `read_bytes`
            with ``partial=True`` for ``streaming_callback``) instead.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         future = self._start_read()
@@ -510,22 +653,32 @@
 
     def write(self, data: Union[bytes, memoryview]) -> "Future[None]":
         """Asynchronously write the given data to this stream.
-
+        
         This method returns a `.Future` that resolves (with a result
         of ``None``) when the write has been completed.
-
+        
         The ``data`` argument may be of type `bytes` or `memoryview`.
-
+        
         .. versionchanged:: 4.0
             Now returns a `.Future` if no callback is given.
-
+        
         .. versionchanged:: 4.5
             Added support for `memoryview` arguments.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed. Use the returned
            `.Future` instead.
+
+        Parameters
+        ----------
+        data: Union[bytes :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
 
         """
         self._check_closed()
@@ -549,15 +702,26 @@
 
     def set_close_callback(self, callback: Optional[Callable[[], None]]) -> None:
         """Call the given callback when the stream is closed.
-
+        
         This mostly is not necessary for applications that use the
         `.Future` interface; all outstanding ``Futures`` will resolve
         with a `StreamClosedError` when the stream is closed. However,
         it is still useful as a way to signal that the stream has been
         closed while no other read or write is in progress.
-
+        
         Unlike other callback-based interfaces, ``set_close_callback``
         was not removed in Tornado 6.0.
+
+        Parameters
+        ----------
+        callback: Optional[Callable[[] :
+            
+        None]] :
+            
+
+        Returns
+        -------
+
         """
         self._close_callback = callback
         self._maybe_add_error_listener()
@@ -576,10 +740,34 @@
         ] = False,
     ) -> None:
         """Close this stream.
-
+        
         If ``exc_info`` is true, set the ``error`` attribute to the current
-        exception from `sys.exc_info` (or if ``exc_info`` is a tuple,
-        use that instead of `sys.exc_info`).
+
+        Parameters
+        ----------
+        exc_info: Union[None :
+            
+        bool :
+            
+        BaseException :
+            
+        Tuple["Optional[Type[BaseException]]" :
+            
+        Optional[BaseException] :
+            
+        Optional[TracebackType] :
+            
+        ] :
+             (Default value = False)
+
+        Returns
+        -------
+
+        Raises
+        ------
+        use
+            that instead of
+
         """
         if not self.closed():
             if exc_info:
@@ -611,6 +799,7 @@
         self._signal_closed()
 
     def _signal_closed(self) -> None:
+        """ """
         futures = []  # type: List[Future]
         if self._read_future is not None:
             futures.append(self._read_future)
@@ -663,23 +852,48 @@
 
     def set_nodelay(self, value: bool) -> None:
         """Sets the no-delay flag for this stream.
-
+        
         By default, data written to TCP streams may be held for a time
         to make the most efficient use of bandwidth (according to
         Nagle's algorithm).  The no-delay flag requests that data be
         written as soon as possible, even if doing so would consume
         additional bandwidth.
-
+        
         This flag is currently defined only for TCP-based ``IOStreams``.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        value: bool :
+            
+
+        Returns
+        -------
+
         """
         pass
 
     def _handle_connect(self) -> None:
+        """ """
         raise NotImplementedError()
 
     def _handle_events(self, fd: Union[int, ioloop._Selectable], events: int) -> None:
+        """
+
+        Parameters
+        ----------
+        fd: Union[int :
+            
+        ioloop._Selectable] :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
+        """
         if self.closed():
             gen_log.warning("Got events for closed stream %s", fd)
             return
@@ -733,6 +947,7 @@
             raise
 
     def _read_to_buffer_loop(self) -> Optional[int]:
+        """ """
         # This method is called from _handle_read and _try_inline_read.
         if self._read_bytes is not None:
             target_bytes = self._read_bytes  # type: Optional[int]
@@ -774,6 +989,7 @@
         return self._find_read_pos()
 
     def _handle_read(self) -> None:
+        """ """
         try:
             pos = self._read_to_buffer_loop()
         except UnsatisfiableReadError:
@@ -788,6 +1004,7 @@
             self._read_from_buffer(pos)
 
     def _start_read(self) -> Future:
+        """ """
         if self._read_future is not None:
             # It is an error to start a read while a prior read is unresolved.
             # However, if the prior read is unresolved because the stream was
@@ -811,6 +1028,19 @@
         return self._read_future
 
     def _finish_read(self, size: int, streaming: bool) -> None:
+        """
+
+        Parameters
+        ----------
+        size: int :
+            
+        streaming: bool :
+            
+
+        Returns
+        -------
+
+        """
         if self._user_read_buffer:
             self._read_buffer = self._after_user_read_buffer or bytearray()
             self._after_user_read_buffer = None
@@ -828,10 +1058,17 @@
 
     def _try_inline_read(self) -> None:
         """Attempt to complete the current read operation from buffered data.
-
+        
         If the read can be completed without blocking, schedules the
         read callback on the next IOLoop iteration; otherwise starts
         listening for reads on the socket.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # See if we've already got the data from a previous read
         pos = self._find_read_pos()
@@ -850,10 +1087,17 @@
 
     def _read_to_buffer(self) -> Optional[int]:
         """Reads from the socket and appends the result to the read buffer.
-
+        
         Returns the number of bytes read.  Returns 0 if there is nothing
         to read (i.e. the read returns EWOULDBLOCK or equivalent).  On
         error closes the socket and raises an exception.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         try:
             while True:
@@ -896,9 +1140,18 @@
 
     def _read_from_buffer(self, pos: int) -> None:
         """Attempts to complete the currently-pending read from the buffer.
-
+        
         The argument is either a position in the read buffer or None,
         as returned by _find_read_pos.
+
+        Parameters
+        ----------
+        pos: int :
+            
+
+        Returns
+        -------
+
         """
         self._read_bytes = self._read_delimiter = self._read_regex = None
         self._read_partial = False
@@ -907,9 +1160,16 @@
     def _find_read_pos(self) -> Optional[int]:
         """Attempts to find a position in the read buffer that satisfies
         the currently-pending read.
-
+        
         Returns a position in the buffer if the current read can be satisfied,
         or None if it cannot.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._read_bytes is not None and (
             self._read_buffer_size >= self._read_bytes
@@ -947,6 +1207,21 @@
         return None
 
     def _check_max_bytes(self, delimiter: Union[bytes, Pattern], size: int) -> None:
+        """
+
+        Parameters
+        ----------
+        delimiter: Union[bytes :
+            
+        Pattern] :
+            
+        size: int :
+            
+
+        Returns
+        -------
+
+        """
         if self._read_max_bytes is not None and size > self._read_max_bytes:
             raise UnsatisfiableReadError(
                 "delimiter %r not found within %d bytes"
@@ -954,6 +1229,7 @@
             )
 
     def _handle_write(self) -> None:
+        """ """
         while True:
             size = len(self._write_buffer)
             if not size:
@@ -992,6 +1268,17 @@
             future_set_result_unless_cancelled(future, None)
 
     def _consume(self, loc: int) -> bytes:
+        """
+
+        Parameters
+        ----------
+        loc: int :
+            
+
+        Returns
+        -------
+
+        """
         # Consume loc bytes from the read buffer and return them
         if loc == 0:
             return b""
@@ -1013,10 +1300,12 @@
         return b
 
     def _check_closed(self) -> None:
+        """ """
         if self.closed():
             raise StreamClosedError(real_error=self.error)
 
     def _maybe_add_error_listener(self) -> None:
+        """ """
         # This method is part of an optimization: to detect a connection that
         # is closed when we're not actively reading or writing, we must listen
         # for read events.  However, it is inefficient to do this when the
@@ -1033,12 +1322,12 @@
 
     def _add_io_state(self, state: int) -> None:
         """Adds `state` (IOLoop.{READ,WRITE} flags) to our event handler.
-
+        
         Implementation notes: Reads and writes have a fast path and a
         slow path.  The fast path reads synchronously from socket
         buffers, while the slow path uses `_add_io_state` to schedule
         an IOLoop callback.
-
+        
         To detect closed connections, we must have called
         `_add_io_state` at some point, but we want to delay this as
         much as possible so we don't have to set an `IOLoop.ERROR`
@@ -1046,8 +1335,16 @@
         operation. If a sequence of fast-path ops do not end in a
         slow-path op, (e.g. for an @asynchronous long-poll request),
         we must add the error handler.
-
+        
         TODO: reevaluate this now that callbacks are gone.
+
+        Parameters
+        ----------
+        state: int :
+            
+
+        Returns
+        -------
 
         """
         if self.closed():
@@ -1061,9 +1358,18 @@
             self.io_loop.update_handler(self.fileno(), self._state)
 
     def _is_connreset(self, exc: BaseException) -> bool:
-        """Return ``True`` if exc is ECONNRESET or equivalent.
-
-        May be overridden in subclasses.
+        """
+
+        Parameters
+        ----------
+        exc: BaseException :
+            
+
+        Returns
+        -------
+        type
+            May be overridden in subclasses.
+
         """
         return (
             isinstance(exc, (socket.error, IOError))
@@ -1072,26 +1378,26 @@
 
 
 class IOStream(BaseIOStream):
-    r"""Socket-based `IOStream` implementation.
-
+    """r"""Socket-based `IOStream` implementation.
+    
     This class supports the read and write methods from `BaseIOStream`
     plus a `connect` method.
-
+    
     The ``socket`` parameter may either be connected or unconnected.
     For server operations the socket is the result of calling
     `socket.accept <socket.socket.accept>`.  For client operations the
     socket is created with `socket.socket`, and may either be
     connected before passing it to the `IOStream` or connected with
     `IOStream.connect`.
-
+    
     A very simple (and broken) HTTP client using this class:
-
+    
     .. testcode::
-
+    
         import tornado.ioloop
         import tornado.iostream
         import socket
-
+    
         async def main():
             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
             stream = tornado.iostream.IOStream(s)
@@ -1106,18 +1412,22 @@
             body_data = await stream.read_bytes(int(headers[b"Content-Length"]))
             print(body_data)
             stream.close()
-
+    
         if __name__ == '__main__':
             tornado.ioloop.IOLoop.current().run_sync(main)
             s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
             stream = tornado.iostream.IOStream(s)
             stream.connect(("friendfeed.com", 80), send_request)
             tornado.ioloop.IOLoop.current().start()
-
+    
     .. testoutput::
        :hide:
 
-    """
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     def __init__(self, socket: socket.socket, *args: Any, **kwargs: Any) -> None:
         self.socket = socket
@@ -1125,17 +1435,33 @@
         super().__init__(*args, **kwargs)
 
     def fileno(self) -> Union[int, ioloop._Selectable]:
+        """ """
         return self.socket
 
     def close_fd(self) -> None:
+        """ """
         self.socket.close()
         self.socket = None  # type: ignore
 
     def get_fd_error(self) -> Optional[Exception]:
+        """ """
         errno = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
         return socket.error(errno, os.strerror(errno))
 
     def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:
+        """
+
+        Parameters
+        ----------
+        buf: Union[bytearray :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self.socket.recv_into(buf, len(buf))
         except BlockingIOError:
@@ -1144,6 +1470,17 @@
             del buf
 
     def write_to_fd(self, data: memoryview) -> int:
+        """
+
+        Parameters
+        ----------
+        data: memoryview :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self.socket.send(data)  # type: ignore
         finally:
@@ -1155,7 +1492,7 @@
         self: _IOStreamType, address: Any, server_hostname: Optional[str] = None
     ) -> "Future[_IOStreamType]":
         """Connects the socket to a remote address without blocking.
-
+        
         May only be called if the socket passed to the constructor was
         not previously connected.  The address parameter is in the
         same format as for `socket.connect <socket.socket.connect>` for
@@ -1166,36 +1503,47 @@
         class is recommended instead of calling this method directly.
         `.TCPClient` will do asynchronous DNS resolution and handle
         both IPv4 and IPv6.
-
+        
         If ``callback`` is specified, it will be called with no
-        arguments when the connection is completed; if not this method
-        returns a `.Future` (whose result after a successful
-        connection will be the stream itself).
-
-        In SSL mode, the ``server_hostname`` parameter will be used
-        for certificate validation (unless disabled in the
-        ``ssl_options``) and SNI (if supported; requires Python
-        2.7.9+).
-
-        Note that it is safe to call `IOStream.write
-        <BaseIOStream.write>` while the connection is pending, in
-        which case the data will be written as soon as the connection
-        is ready.  Calling `IOStream` read methods before the socket is
-        connected works on some platforms but is non-portable.
-
-        .. versionchanged:: 4.0
+
+        Parameters
+        ----------
+        self: _IOStreamType :
+            
+        address: Any :
+            
+        server_hostname: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            connection will be the stream itself).
+            
+            In SSL mode, the ``server_hostname`` parameter will be used
+            for certificate validation (unless disabled in the
+            ``ssl_options``) and SNI (if supported; requires Python
+            2.7.9+).
+            
+            Note that it is safe to call `IOStream.write
+            <BaseIOStream.write>` while the connection is pending, in
+            which case the data will be written as soon as the connection
+            is ready.  Calling `IOStream` read methods before the socket is
+            connected works on some platforms but is non-portable.
+            
+            .. versionchanged:: 4.0
             If no callback is given, returns a `.Future`.
-
-        .. versionchanged:: 4.2
-           SSL certificates are validated by default; pass
-           ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a
-           suitably-configured `ssl.SSLContext` to the
-           `SSLIOStream` constructor to disable.
-
-        .. versionchanged:: 6.0
-
-           The ``callback`` argument was removed. Use the returned
-           `.Future` instead.
+            
+            .. versionchanged:: 4.2
+            SSL certificates are validated by default; pass
+            ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a
+            suitably-configured `ssl.SSLContext` to the
+            `SSLIOStream` constructor to disable.
+            
+            .. versionchanged:: 6.0
+            
+            The ``callback`` argument was removed. Use the returned
+            `.Future` instead.
 
         """
         self._connecting = True
@@ -1226,11 +1574,11 @@
         server_hostname: Optional[str] = None,
     ) -> Awaitable["SSLIOStream"]:
         """Convert this `IOStream` to an `SSLIOStream`.
-
+        
         This enables protocols that begin in clear-text mode and
         switch to SSL after some initial negotiation (such as the
         ``STARTTLS`` extension to SMTP and IMAP).
-
+        
         This method cannot be used if there are outstanding reads
         or writes on the stream, or if there is any data in the
         IOStream's buffer (data in the operating system's socket
@@ -1238,26 +1586,43 @@
         immediately after reading or writing the last clear-text
         data.  It can also be used immediately after connecting,
         before any reads or writes.
-
+        
         The ``ssl_options`` argument may be either an `ssl.SSLContext`
         object or a dictionary of keyword arguments for the
         `ssl.wrap_socket` function.  The ``server_hostname`` argument
         will be used for certificate validation unless disabled
         in the ``ssl_options``.
-
+        
         This method returns a `.Future` whose result is the new
         `SSLIOStream`.  After this method has been called,
         any other operation on the original stream is undefined.
-
+        
         If a close callback is defined on this stream, it will be
         transferred to the new stream.
-
+        
         .. versionadded:: 4.0
-
+        
         .. versionchanged:: 4.2
            SSL certificates are validated by default; pass
            ``ssl_options=dict(cert_reqs=ssl.CERT_NONE)`` or a
            suitably-configured `ssl.SSLContext` to disable.
+
+        Parameters
+        ----------
+        server_side: bool :
+            
+        ssl_options: Optional[Union[Dict[str :
+            
+        Any] :
+            
+        ssl.SSLContext]] :
+             (Default value = None)
+        server_hostname: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if (
             self._read_future
@@ -1296,6 +1661,7 @@
         return future
 
     def _handle_connect(self) -> None:
+        """ """
         try:
             err = self.socket.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
         except socket.error as e:
@@ -1324,6 +1690,17 @@
         self._connecting = False
 
     def set_nodelay(self, value: bool) -> None:
+        """
+
+        Parameters
+        ----------
+        value: bool :
+            
+
+        Returns
+        -------
+
+        """
         if self.socket is not None and self.socket.family in (
             socket.AF_INET,
             socket.AF_INET6,
@@ -1342,14 +1719,21 @@
 
 class SSLIOStream(IOStream):
     """A utility class to write to and read from a non-blocking SSL socket.
-
+    
     If the socket passed to the constructor is already connected,
     it should be wrapped with::
-
+    
         ssl.wrap_socket(sock, do_handshake_on_connect=False, **kwargs)
-
+    
     before constructing the `SSLIOStream`.  Unconnected sockets will be
     wrapped when `IOStream.connect` is finished.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     socket = None  # type: ssl.SSLSocket
@@ -1378,12 +1762,15 @@
             self._add_io_state(self.io_loop.WRITE)
 
     def reading(self) -> bool:
+        """ """
         return self._handshake_reading or super().reading()
 
     def writing(self) -> bool:
+        """ """
         return self._handshake_writing or super().writing()
 
     def _do_ssl_handshake(self) -> None:
+        """ """
         # Based on code from test_ssl.py in the python stdlib
         try:
             self._handshake_reading = False
@@ -1441,6 +1828,7 @@
             self._finish_ssl_connect()
 
     def _finish_ssl_connect(self) -> None:
+        """ """
         if self._ssl_connect_future is not None:
             future = self._ssl_connect_future
             self._ssl_connect_future = None
@@ -1449,10 +1837,19 @@
     def _verify_cert(self, peercert: Any) -> bool:
         """Returns ``True`` if peercert is valid according to the configured
         validation mode and hostname.
-
+        
         The ssl handshake already tested the certificate for a valid
         CA signature; the only thing that remains is to check
         the hostname.
+
+        Parameters
+        ----------
+        peercert: Any :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(self._ssl_options, dict):
             verify_mode = self._ssl_options.get("cert_reqs", ssl.CERT_NONE)
@@ -1474,12 +1871,14 @@
             return True
 
     def _handle_read(self) -> None:
+        """ """
         if self._ssl_accepting:
             self._do_ssl_handshake()
             return
         super()._handle_read()
 
     def _handle_write(self) -> None:
+        """ """
         if self._ssl_accepting:
             self._do_ssl_handshake()
             return
@@ -1488,6 +1887,19 @@
     def connect(
         self, address: Tuple, server_hostname: Optional[str] = None
     ) -> "Future[SSLIOStream]":
+        """
+
+        Parameters
+        ----------
+        address: Tuple :
+            
+        server_hostname: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self._server_hostname = server_hostname
         # Ignore the result of connect(). If it fails,
         # wait_for_handshake will raise an error too. This is
@@ -1505,6 +1917,7 @@
         return self.wait_for_handshake()
 
     def _handle_connect(self) -> None:
+        """ """
         # Call the superclass method to check for errors.
         super()._handle_connect()
         if self.closed():
@@ -1533,27 +1946,40 @@
 
     def wait_for_handshake(self) -> "Future[SSLIOStream]":
         """Wait for the initial SSL handshake to complete.
-
+        
         If a ``callback`` is given, it will be called with no
-        arguments once the handshake is complete; otherwise this
-        method returns a `.Future` which will resolve to the
-        stream itself after the handshake is complete.
-
-        Once the handshake is complete, information such as
-        the peer's certificate and NPN/ALPN selections may be
-        accessed on ``self.socket``.
-
-        This method is intended for use on server-side streams
-        or after using `IOStream.start_tls`; it should not be used
-        with `IOStream.connect` (which already waits for the
-        handshake to complete). It may only be called once per stream.
-
-        .. versionadded:: 4.2
-
-        .. versionchanged:: 6.0
-
-           The ``callback`` argument was removed. Use the returned
-           `.Future` instead.
+
+        Parameters
+        ----------
+        method :
+            returns a
+        stream :
+            itself after the handshake is complete
+        Once :
+            the handshake is complete
+        the :
+            peer
+        accessed :
+            on
+        This :
+            method is intended for use on server
+        or :
+            after using
+        with :
+            IOStream
+        handshake :
+            to complete
+        versionadded :
+            
+        versionchanged :
+            
+        The :
+            callback
+        Future :
+            instead
+
+        Returns
+        -------
 
         """
         if self._ssl_connect_future is not None:
@@ -1564,6 +1990,17 @@
         return future
 
     def write_to_fd(self, data: memoryview) -> int:
+        """
+
+        Parameters
+        ----------
+        data: memoryview :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self.socket.send(data)  # type: ignore
         except ssl.SSLError as e:
@@ -1582,6 +2019,19 @@
             del data
 
     def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:
+        """
+
+        Parameters
+        ----------
+        buf: Union[bytearray :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
+
+        """
         try:
             if self._ssl_accepting:
                 # If the handshake hasn't finished yet, there can't be anything
@@ -1603,6 +2053,17 @@
             del buf
 
     def _is_connreset(self, e: BaseException) -> bool:
+        """
+
+        Parameters
+        ----------
+        e: BaseException :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(e, ssl.SSLError) and e.args[0] == ssl.SSL_ERROR_EOF:
             return True
         return super()._is_connreset(e)
@@ -1610,13 +2071,20 @@
 
 class PipeIOStream(BaseIOStream):
     """Pipe-based `IOStream` implementation.
-
+    
     The constructor takes an integer file descriptor (such as one returned
     by `os.pipe`) rather than an open file object.  Pipes are generally
     one-way, so a `PipeIOStream` can be used for reading or writing but not
     both.
-
+    
     ``PipeIOStream`` is only available on Unix-based platforms.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, fd: int, *args: Any, **kwargs: Any) -> None:
@@ -1626,12 +2094,25 @@
         super().__init__(*args, **kwargs)
 
     def fileno(self) -> int:
+        """ """
         return self.fd
 
     def close_fd(self) -> None:
+        """ """
         self._fio.close()
 
     def write_to_fd(self, data: memoryview) -> int:
+        """
+
+        Parameters
+        ----------
+        data: memoryview :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return os.write(self.fd, data)  # type: ignore
         finally:
@@ -1640,6 +2121,19 @@
             del data
 
     def read_from_fd(self, buf: Union[bytearray, memoryview]) -> Optional[int]:
+        """
+
+        Parameters
+        ----------
+        buf: Union[bytearray :
+            
+        memoryview] :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._fio.readinto(buf)  # type: ignore
         except (IOError, OSError) as e:
@@ -1655,6 +2149,7 @@
 
 
 def doctests() -> Any:
+    """ """
     import doctest
 
     return doctest.DocTestSuite()
