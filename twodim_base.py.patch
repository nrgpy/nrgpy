# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/twodim_base.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/twodim_base.py
@@ -29,7 +29,19 @@
 
 
 def _min_int(low, high):
-    """ get small int that fits the range """
+    """get small int that fits the range
+
+    Parameters
+    ----------
+    low :
+        
+    high :
+        
+
+    Returns
+    -------
+
+    """
     if high <= i1.max and low >= i1.min:
         return int8
     if high <= i2.max and low >= i2.min:
@@ -40,14 +52,24 @@
 
 
 def _flip_dispatcher(m):
+    """
+
+    Parameters
+    ----------
+    m :
+        
+
+    Returns
+    -------
+
+    """
     return (m,)
 
 
 @array_function_dispatch(_flip_dispatcher)
 def fliplr(m):
-    """
-    Flip array in the left/right direction.
-
+    """Flip array in the left/right direction.
+    
     Flip the entries in each row in the left/right direction.
     Columns are preserved, but appear in a different order than before.
 
@@ -66,11 +88,9 @@
     --------
     flipud : Flip array in the up/down direction.
     rot90 : Rotate array counterclockwise.
-
     Notes
     -----
     Equivalent to m[:,::-1]. Requires the array to be at least 2-D.
-
     Examples
     --------
     >>> A = np.diag([1.,2.,3.])
@@ -82,11 +102,10 @@
     array([[0.,  0.,  1.],
            [0.,  2.,  0.],
            [3.,  0.,  0.]])
-
+    
     >>> A = np.random.randn(2,3,5)
     >>> np.all(np.fliplr(A) == A[:,::-1,...])
     True
-
     """
     m = asanyarray(m)
     if m.ndim < 2:
@@ -96,9 +115,8 @@
 
 @array_function_dispatch(_flip_dispatcher)
 def flipud(m):
-    """
-    Flip array in the up/down direction.
-
+    """Flip array in the up/down direction.
+    
     Flip the entries in each column in the up/down direction.
     Rows are preserved, but appear in a different order than before.
 
@@ -117,12 +135,10 @@
     --------
     fliplr : Flip array in the left/right direction.
     rot90 : Rotate array counterclockwise.
-
     Notes
     -----
     Equivalent to ``m[::-1,...]``.
     Does not require the array to be two-dimensional.
-
     Examples
     --------
     >>> A = np.diag([1.0, 2, 3])
@@ -134,14 +150,13 @@
     array([[0.,  0.,  3.],
            [0.,  2.,  0.],
            [1.,  0.,  0.]])
-
+    
     >>> A = np.random.randn(2,3,5)
     >>> np.all(np.flipud(A) == A[::-1,...])
     True
-
+    
     >>> np.flipud([1,2])
     array([2, 1])
-
     """
     m = asanyarray(m)
     if m.ndim < 1:
@@ -151,38 +166,35 @@
 
 @set_module('numpy')
 def eye(N, M=None, k=0, dtype=float, order='C'):
-    """
-    Return a 2-D array with ones on the diagonal and zeros elsewhere.
+    """Return a 2-D array with ones on the diagonal and zeros elsewhere.
 
     Parameters
     ----------
     N : int
-      Number of rows in the output.
+        Number of rows in the output.
     M : int, optional
-      Number of columns in the output. If None, defaults to `N`.
+        Number of columns in the output. If None, defaults to `N`.
     k : int, optional
-      Index of the diagonal: 0 (the default) refers to the main diagonal,
-      a positive value refers to an upper diagonal, and a negative value
-      to a lower diagonal.
+        Index of the diagonal: 0 (the default) refers to the main diagonal,
+        a positive value refers to an upper diagonal, and a negative value
+        to a lower diagonal.
     dtype : data-type, optional
-      Data-type of the returned array.
+        Data-type of the returned array. (Default value = float)
     order : {'C', 'F'}, optional
         Whether the output should be stored in row-major (C-style) or
         column-major (Fortran-style) order in memory.
-
-        .. versionadded:: 1.14.0
+        .. versionadded:: 1.14.0 (Default value = 'C')
 
     Returns
     -------
     I : ndarray of shape (N,M)
-      An array where all elements are equal to zero, except for the `k`-th
-      diagonal, whose values are equal to one.
+        An array where all elements are equal to zero, except for the `k`-th
+        diagonal, whose values are equal to one.
 
     See Also
     --------
     identity : (almost) equivalent function
     diag : diagonal 2-D array from a 1-D array specified by the user.
-
     Examples
     --------
     >>> np.eye(2, dtype=int)
@@ -192,7 +204,6 @@
     array([[0.,  1.,  0.],
            [0.,  0.,  1.],
            [0.,  0.,  0.]])
-
     """
     if M is None:
         M = N
@@ -208,14 +219,26 @@
 
 
 def _diag_dispatcher(v, k=None):
+    """
+
+    Parameters
+    ----------
+    v :
+        
+    k :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (v,)
 
 
 @array_function_dispatch(_diag_dispatcher)
 def diag(v, k=0):
-    """
-    Extract a diagonal or construct a diagonal array.
-
+    """Extract a diagonal or construct a diagonal array.
+    
     See the more detailed documentation for ``numpy.diagonal`` if you use this
     function to extract a diagonal and wish to write to the resulting array;
     whether it returns a copy or a view depends on what version of numpy you
@@ -244,7 +267,6 @@
     trace : Sum along diagonals.
     triu : Upper triangle of an array.
     tril : Lower triangle of an array.
-
     Examples
     --------
     >>> x = np.arange(9).reshape((3,3))
@@ -252,19 +274,18 @@
     array([[0, 1, 2],
            [3, 4, 5],
            [6, 7, 8]])
-
+    
     >>> np.diag(x)
     array([0, 4, 8])
     >>> np.diag(x, k=1)
     array([1, 5])
     >>> np.diag(x, k=-1)
     array([3, 7])
-
+    
     >>> np.diag(np.diag(x))
     array([[0, 0, 0],
            [0, 4, 0],
            [0, 0, 8]])
-
     """
     v = asanyarray(v)
     s = v.shape
@@ -285,8 +306,7 @@
 
 @array_function_dispatch(_diag_dispatcher)
 def diagflat(v, k=0):
-    """
-    Create a two-dimensional array with the flattened input as a diagonal.
+    """Create a two-dimensional array with the flattened input as a diagonal.
 
     Parameters
     ----------
@@ -308,7 +328,6 @@
     diag : MATLAB work-alike for 1-D and 2-D arrays.
     diagonal : Return specified diagonals.
     trace : Sum along diagonals.
-
     Examples
     --------
     >>> np.diagflat([[1,2], [3,4]])
@@ -316,12 +335,11 @@
            [0, 2, 0, 0],
            [0, 0, 3, 0],
            [0, 0, 0, 4]])
-
+    
     >>> np.diagflat([1,2], 1)
     array([[0, 1, 0],
            [0, 0, 2],
            [0, 0, 0]])
-
     """
     try:
         wrap = v.__array_wrap__
@@ -345,8 +363,7 @@
 
 @set_module('numpy')
 def tri(N, M=None, k=0, dtype=float):
-    """
-    An array with ones at and below the given diagonal and zeros elsewhere.
+    """An array with ones at and below the given diagonal and zeros elsewhere.
 
     Parameters
     ----------
@@ -374,12 +391,11 @@
     array([[1, 1, 1, 0, 0],
            [1, 1, 1, 1, 0],
            [1, 1, 1, 1, 1]])
-
+    
     >>> np.tri(3, 5, -1)
     array([[0.,  0.,  0.,  0.,  0.],
            [1.,  0.,  0.,  0.,  0.],
            [1.,  1.,  0.,  0.,  0.]])
-
     """
     if M is None:
         M = N
@@ -394,14 +410,26 @@
 
 
 def _trilu_dispatcher(m, k=None):
+    """
+
+    Parameters
+    ----------
+    m :
+        
+    k :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (m,)
 
 
 @array_function_dispatch(_trilu_dispatcher)
 def tril(m, k=0):
-    """
-    Lower triangle of an array.
-
+    """Lower triangle of an array.
+    
     Return a copy of an array with elements above the `k`-th diagonal zeroed.
 
     Parameters
@@ -420,7 +448,6 @@
     See Also
     --------
     triu : same thing, only for the upper triangle
-
     Examples
     --------
     >>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
@@ -428,7 +455,6 @@
            [ 4,  0,  0],
            [ 7,  8,  0],
            [10, 11, 12]])
-
     """
     m = asanyarray(m)
     mask = tri(*m.shape[-2:], k=k, dtype=bool)
@@ -438,18 +464,26 @@
 
 @array_function_dispatch(_trilu_dispatcher)
 def triu(m, k=0):
-    """
-    Upper triangle of an array.
-
+    """Upper triangle of an array.
+    
     Return a copy of a matrix with the elements below the `k`-th diagonal
     zeroed.
-
+    
     Please refer to the documentation for `tril` for further details.
 
+    Parameters
+    ----------
+    m :
+        
+    k :
+         (Default value = 0)
+
+    Returns
+    -------
+
     See Also
     --------
     tril : lower triangle of an array
-
     Examples
     --------
     >>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
@@ -457,7 +491,6 @@
            [ 4,  5,  6],
            [ 0,  8,  9],
            [ 0,  0, 12]])
-
     """
     m = asanyarray(m)
     mask = tri(*m.shape[-2:], k=k-1, dtype=bool)
@@ -466,15 +499,29 @@
 
 
 def _vander_dispatcher(x, N=None, increasing=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    N :
+         (Default value = None)
+    increasing :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (x,)
 
 
 # Originally borrowed from John Hunter and matplotlib
 @array_function_dispatch(_vander_dispatcher)
 def vander(x, N=None, increasing=False):
-    """
-    Generate a Vandermonde matrix.
-
+    """Generate a Vandermonde matrix.
+    
     The columns of the output matrix are powers of the input vector. The
     order of the powers is determined by the `increasing` boolean argument.
     Specifically, when `increasing` is False, the `i`-th output column is
@@ -488,11 +535,10 @@
         1-D input array.
     N : int, optional
         Number of columns in the output.  If `N` is not specified, a square
-        array is returned (``N = len(x)``).
+        array is returned (``N = len(x)``). (Default value = None)
     increasing : bool, optional
         Order of the powers of the columns.  If True, the powers increase
         from left to right, if False (the default) they are reversed.
-
         .. versionadded:: 1.9.0
 
     Returns
@@ -505,9 +551,13 @@
     See Also
     --------
     polynomial.polynomial.polyvander
-
-    Examples
-    --------
+    Examples
+    --------
+    
+    
+    
+    The determinant of a square Vandermonde matrix is the product
+    of the differences between the values of the input vector:
     >>> x = np.array([1, 2, 3, 5])
     >>> N = 3
     >>> np.vander(x, N)
@@ -515,13 +565,13 @@
            [ 4,  2,  1],
            [ 9,  3,  1],
            [25,  5,  1]])
-
+    
     >>> np.column_stack([x**(N-1-i) for i in range(N)])
     array([[ 1,  1,  1],
            [ 4,  2,  1],
            [ 9,  3,  1],
            [25,  5,  1]])
-
+    
     >>> x = np.array([1, 2, 3, 5])
     >>> np.vander(x)
     array([[  1,   1,   1,   1],
@@ -533,15 +583,11 @@
            [  1,   2,   4,   8],
            [  1,   3,   9,  27],
            [  1,   5,  25, 125]])
-
-    The determinant of a square Vandermonde matrix is the product
-    of the differences between the values of the input vector:
-
+    
     >>> np.linalg.det(np.vander(x))
     48.000000000000043 # may vary
     >>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
     48
-
     """
     x = asarray(x)
     if x.ndim != 1:
@@ -563,6 +609,29 @@
 
 def _histogram2d_dispatcher(x, y, bins=None, range=None, normed=None,
                             weights=None, density=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+    bins :
+         (Default value = None)
+    range :
+         (Default value = None)
+    normed :
+         (Default value = None)
+    weights :
+         (Default value = None)
+    density :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     yield x
     yield y
 
@@ -582,8 +651,7 @@
 @array_function_dispatch(_histogram2d_dispatcher)
 def histogram2d(x, y, bins=10, range=None, normed=None, weights=None,
                 density=None):
-    """
-    Compute the bi-dimensional histogram of two data samples.
+    """Compute the bi-dimensional histogram of two data samples.
 
     Parameters
     ----------
@@ -595,22 +663,20 @@
         histogrammed.
     bins : int or array_like or [int, int] or [array, array], optional
         The bin specification:
-
-          * If int, the number of bins for the two dimensions (nx=ny=bins).
-          * If array_like, the bin edges for the two dimensions
-            (x_edges=y_edges=bins).
-          * If [int, int], the number of bins in each dimension
-            (nx, ny = bins).
-          * If [array, array], the bin edges in each dimension
-            (x_edges, y_edges = bins).
-          * A combination [int, array] or [array, int], where int
-            is the number of bins and array is the bin edges.
-
+        * If int, the number of bins for the two dimensions (nx=ny=bins).
+        * If array_like, the bin edges for the two dimensions
+        (x_edges=y_edges=bins).
+        * If [int, int], the number of bins in each dimension
+        (nx, ny = bins).
+        * If [array, array], the bin edges in each dimension
+        (x_edges, y_edges = bins).
+        * A combination [int, array] or [array, int], where int
+        is the number of bins and array is the bin edges. (Default value = 10)
     range : array_like, shape(2,2), optional
         The leftmost and rightmost edges of the bins along each dimension
         (if not specified explicitly in the `bins` parameters):
         ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
-        will be considered outliers and not tallied in the histogram.
+        will be considered outliers and not tallied in the histogram. (Default value = None)
     density : bool, optional
         If False, the default, returns the number of samples in each bin.
         If True, returns the probability *density* function at the bin,
@@ -618,12 +684,12 @@
     normed : bool, optional
         An alias for the density argument that behaves identically. To avoid
         confusion with the broken normed argument to `histogram`, `density`
-        should be preferred.
+        should be preferred. (Default value = None)
     weights : array_like, shape(N,), optional
         An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
         Weights are normalized to 1 if `normed` is True. If `normed` is
         False, the values of the returned histogram are equal to the sum of
-        the weights belonging to the samples falling into each bin.
+        the weights belonging to the samples falling into each bin. (Default value = None)
 
     Returns
     -------
@@ -640,56 +706,58 @@
     --------
     histogram : 1D histogram
     histogramdd : Multidimensional histogram
-
     Notes
     -----
     When `normed` is True, then the returned histogram is the sample
     density, defined such that the sum over bins of the product
     ``bin_value * bin_area`` is 1.
-
+    
     Please note that the histogram does not follow the Cartesian convention
     where `x` values are on the abscissa and `y` values on the ordinate
     axis.  Rather, `x` is histogrammed along the first dimension of the
     array (vertical), and `y` along the second dimension of the array
     (horizontal).  This ensures compatibility with `histogramdd`.
-
-    Examples
-    --------
+    Examples
+    --------
+    
+    Construct a 2-D histogram with variable bin width. First define the bin
+    edges:
+    
+    
+    Next we create a histogram H with random bin content:
+    
+    
+    :func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:
+    
+    
+    :func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:
+    
+    
+    :class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to
+    display actual bin edges with interpolation:
     >>> from matplotlib.image import NonUniformImage
     >>> import matplotlib.pyplot as plt
-
-    Construct a 2-D histogram with variable bin width. First define the bin
-    edges:
-
+    
     >>> xedges = [0, 1, 3, 5]
     >>> yedges = [0, 2, 3, 4, 6]
-
-    Next we create a histogram H with random bin content:
-
+    
     >>> x = np.random.normal(2, 1, 100)
     >>> y = np.random.normal(1, 1, 100)
     >>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
     >>> H = H.T  # Let each row list bins with common y range.
-
-    :func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:
-
+    
     >>> fig = plt.figure(figsize=(7, 3))
     >>> ax = fig.add_subplot(131, title='imshow: square bins')
     >>> plt.imshow(H, interpolation='nearest', origin='lower',
     ...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
     <matplotlib.image.AxesImage object at 0x...>
-
-    :func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:
-
+    
     >>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
     ...         aspect='equal')
     >>> X, Y = np.meshgrid(xedges, yedges)
     >>> ax.pcolormesh(X, Y, H)
     <matplotlib.collections.QuadMesh object at 0x...>
-
-    :class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to
-    display actual bin edges with interpolation:
-
+    
     >>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
     ...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
     >>> im = NonUniformImage(ax, interpolation='bilinear')
@@ -698,7 +766,6 @@
     >>> im.set_data(xcenters, ycenters, H)
     >>> ax.images.append(im)
     >>> plt.show()
-
     """
     from numpy import histogramdd
 
@@ -716,9 +783,8 @@
 
 @set_module('numpy')
 def mask_indices(n, mask_func, k=0):
-    """
-    Return the indices to access (n, n) arrays, given a masking function.
-
+    """Return the indices to access (n, n) arrays, given a masking function.
+    
     Assume `mask_func` is a function that, for a square array a of size
     ``(n, n)`` with a possible offset argument `k`, when called as
     ``mask_func(a, k)`` returns a new array with zeros in certain locations
@@ -736,7 +802,7 @@
     k : scalar
         An optional argument which is passed through to `mask_func`. Functions
         like `triu`, `tril` take a second argument that is interpreted as an
-        offset.
+        offset. (Default value = 0)
 
     Returns
     -------
@@ -747,20 +813,25 @@
     See Also
     --------
     triu, tril, triu_indices, tril_indices
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     Examples
     --------
     These are the indices that would allow you to access the upper triangular
     part of any 3x3 array:
-
+    
+    
+    For example, if `a` is a 3x3 array:
+    
+    
+    An offset can be passed also to the masking function.  This gets us the
+    indices starting on the first diagonal right of the main one:
+    
+    
+    with which we now extract only three elements:
     >>> iu = np.mask_indices(3, np.triu)
-
-    For example, if `a` is a 3x3 array:
-
+    
     >>> a = np.arange(9).reshape(3, 3)
     >>> a
     array([[0, 1, 2],
@@ -768,17 +839,11 @@
            [6, 7, 8]])
     >>> a[iu]
     array([0, 1, 2, 4, 5, 8])
-
-    An offset can be passed also to the masking function.  This gets us the
-    indices starting on the first diagonal right of the main one:
-
+    
     >>> iu1 = np.mask_indices(3, np.triu, 1)
-
-    with which we now extract only three elements:
-
+    
     >>> a[iu1]
     array([1, 2, 5])
-
     """
     m = ones((n, n), int)
     a = mask_func(m, k)
@@ -787,8 +852,7 @@
 
 @set_module('numpy')
 def tril_indices(n, k=0, m=None):
-    """
-    Return the indices for the lower-triangle of an (n, m) array.
+    """Return the indices for the lower-triangle of an (n, m) array.
 
     Parameters
     ----------
@@ -796,15 +860,13 @@
         The row dimension of the arrays for which the returned
         indices will be valid.
     k : int, optional
-        Diagonal offset (see `tril` for details).
+        Diagonal offset (see `tril` for details). (Default value = 0)
     m : int, optional
         .. versionadded:: 1.9.0
-
         The column dimension of the arrays for which the returned
         arrays will be valid.
         By default `m` is taken equal to `n`.
 
-
     Returns
     -------
     inds : tuple of arrays
@@ -816,65 +878,77 @@
     triu_indices : similar function, for upper-triangular.
     mask_indices : generic function accepting an arbitrary mask function.
     tril, triu
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     Examples
     --------
     Compute two different sets of indices to access 4x4 arrays, one for the
     lower triangular part starting at the main diagonal, and one starting two
     diagonals further right:
-
+    
+    
+    Here is how they can be used with a sample array:
+    
+    
+    Both for indexing:
+    
+    
+    And for assigning values:
+    
+    
+    These cover almost the whole array (two diagonals right of the main one):
     >>> il1 = np.tril_indices(4)
     >>> il2 = np.tril_indices(4, 2)
-
-    Here is how they can be used with a sample array:
-
+    
     >>> a = np.arange(16).reshape(4, 4)
     >>> a
     array([[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11],
            [12, 13, 14, 15]])
-
-    Both for indexing:
-
+    
     >>> a[il1]
     array([ 0,  4,  5, ..., 13, 14, 15])
-
-    And for assigning values:
-
+    
     >>> a[il1] = -1
     >>> a
     array([[-1,  1,  2,  3],
            [-1, -1,  6,  7],
            [-1, -1, -1, 11],
            [-1, -1, -1, -1]])
-
-    These cover almost the whole array (two diagonals right of the main one):
-
+    
     >>> a[il2] = -10
     >>> a
     array([[-10, -10, -10,   3],
            [-10, -10, -10, -10],
            [-10, -10, -10, -10],
            [-10, -10, -10, -10]])
-
     """
     return nonzero(tri(n, m, k=k, dtype=bool))
 
 
 def _trilu_indices_form_dispatcher(arr, k=None):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    k :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (arr,)
 
 
 @array_function_dispatch(_trilu_indices_form_dispatcher)
 def tril_indices_from(arr, k=0):
-    """
-    Return the indices for the lower-triangle of arr.
-
+    """Return the indices for the lower-triangle of arr.
+    
     See `tril_indices` for full details.
 
     Parameters
@@ -883,16 +957,17 @@
         The indices will be valid for square arrays whose dimensions are
         the same as arr.
     k : int, optional
-        Diagonal offset (see `tril` for details).
+        Diagonal offset (see `tril` for details). (Default value = 0)
+
+    Returns
+    -------
 
     See Also
     --------
     tril_indices, tril
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     """
     if arr.ndim != 2:
         raise ValueError("input array must be 2-d")
@@ -901,8 +976,7 @@
 
 @set_module('numpy')
 def triu_indices(n, k=0, m=None):
-    """
-    Return the indices for the upper-triangle of an (n, m) array.
+    """Return the indices for the upper-triangle of an (n, m) array.
 
     Parameters
     ----------
@@ -910,14 +984,12 @@
         The size of the arrays for which the returned indices will
         be valid.
     k : int, optional
-        Diagonal offset (see `triu` for details).
+        Diagonal offset (see `triu` for details). (Default value = 0)
     m : int, optional
         .. versionadded:: 1.9.0
-
         The column dimension of the arrays for which the returned
         arrays will be valid.
         By default `m` is taken equal to `n`.
-
 
     Returns
     -------
@@ -931,62 +1003,61 @@
     tril_indices : similar function, for lower-triangular.
     mask_indices : generic function accepting an arbitrary mask function.
     triu, tril
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     Examples
     --------
     Compute two different sets of indices to access 4x4 arrays, one for the
     upper triangular part starting at the main diagonal, and one starting two
     diagonals further right:
-
+    
+    
+    Here is how they can be used with a sample array:
+    
+    
+    Both for indexing:
+    
+    
+    And for assigning values:
+    
+    
+    These cover only a small part of the whole array (two diagonals right
+    of the main one):
     >>> iu1 = np.triu_indices(4)
     >>> iu2 = np.triu_indices(4, 2)
-
-    Here is how they can be used with a sample array:
-
+    
     >>> a = np.arange(16).reshape(4, 4)
     >>> a
     array([[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11],
            [12, 13, 14, 15]])
-
-    Both for indexing:
-
+    
     >>> a[iu1]
     array([ 0,  1,  2, ..., 10, 11, 15])
-
-    And for assigning values:
-
+    
     >>> a[iu1] = -1
     >>> a
     array([[-1, -1, -1, -1],
            [ 4, -1, -1, -1],
            [ 8,  9, -1, -1],
            [12, 13, 14, -1]])
-
-    These cover only a small part of the whole array (two diagonals right
-    of the main one):
-
+    
     >>> a[iu2] = -10
     >>> a
     array([[ -1,  -1, -10, -10],
            [  4,  -1,  -1, -10],
            [  8,   9,  -1,  -1],
            [ 12,  13,  14,  -1]])
-
     """
     return nonzero(~tri(n, m, k=k-1, dtype=bool))
 
 
 @array_function_dispatch(_trilu_indices_form_dispatcher)
 def triu_indices_from(arr, k=0):
-    """
-    Return the indices for the upper-triangle of arr.
-
+    """Return the indices for the upper-triangle of arr.
+    
     See `triu_indices` for full details.
 
     Parameters
@@ -994,7 +1065,7 @@
     arr : ndarray, shape(N, N)
         The indices will be valid for square arrays.
     k : int, optional
-        Diagonal offset (see `triu` for details).
+        Diagonal offset (see `triu` for details). (Default value = 0)
 
     Returns
     -------
@@ -1004,11 +1075,9 @@
     See Also
     --------
     triu_indices, triu
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     """
     if arr.ndim != 2:
         raise ValueError("input array must be 2-d")
