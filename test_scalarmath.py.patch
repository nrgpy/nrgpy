# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_scalarmath.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_scalarmath.py
@@ -24,12 +24,15 @@
 # This compares scalarmath against ufuncs.
 
 class TestTypes:
+    """ """
     def test_types(self):
+        """ """
         for atype in types:
             a = atype(1)
             assert_(a == 1, "error with %r: got %r" % (atype, a))
 
     def test_type_add(self):
+        """ """
         # list of types
         for k, atype in enumerate(types):
             a_scalar = atype(3)
@@ -50,12 +53,14 @@
                             (k, np.dtype(atype).char, l, np.dtype(btype).char))
 
     def test_type_create(self):
+        """ """
         for k, atype in enumerate(types):
             a = np.array([1, 2, 3], atype)
             b = atype([1, 2, 3])
             assert_equal(a, b)
 
     def test_leak(self):
+        """ """
         # test leak of scalar objects
         # a leak would show up in valgrind as still-reachable of ~2.6MB
         for i in range(200000):
@@ -63,7 +68,9 @@
 
 
 class TestBaseMath:
+    """ """
     def test_blocked(self):
+        """ """
         # test alignments offsets for simd instructions
         # alignments for vz + 2 * (vs - 1) + 1
         for dt, sz in [(np.float32, 11), (np.float64, 7), (np.int32, 11)]:
@@ -96,6 +103,7 @@
                 assert_almost_equal(out, exp1 + 2, err_msg=msg)
 
     def test_lower_align(self):
+        """ """
         # check data that is not aligned to element size
         # i.e doubles are aligned to 4 bytes on i386
         d = np.zeros(23 * 8, dtype=np.int8)[4:-4].view(np.float64)
@@ -109,13 +117,16 @@
 
 
 class TestPower:
+    """ """
     def test_small_types(self):
+        """ """
         for t in [np.int8, np.int16, np.float16]:
             a = t(3)
             b = a ** 4
             assert_(b == 81, "error with %r: got %r" % (t, b))
 
     def test_large_types(self):
+        """ """
         for t in [np.int32, np.int64, np.float32, np.float64, np.longdouble]:
             a = t(51)
             b = a ** 4
@@ -126,6 +137,7 @@
                 assert_almost_equal(b, 6765201, err_msg=msg)
 
     def test_integers_to_negative_integer_power(self):
+        """ """
         # Note that the combination of uint64 with a signed integer
         # has common type np.float64. The other combinations should all
         # raise a ValueError for integer ** negative integer.
@@ -162,6 +174,7 @@
                 assert_almost_equal(res, .5)
 
     def test_mixed_types(self):
+        """ """
         typelist = [np.int8, np.int16, np.float16,
                     np.float32, np.float64, np.int8,
                     np.int16, np.int32, np.int64]
@@ -178,6 +191,7 @@
                     assert_almost_equal(result, 9, err_msg=msg)
 
     def test_modular_power(self):
+        """ """
         # modular power is not implemented, so ensure it errors
         a = 5
         b = 4
@@ -190,10 +204,34 @@
 
 
 def floordiv_and_mod(x, y):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+
+    Returns
+    -------
+
+    """
     return (x // y, x % y)
 
 
 def _signs(dt):
+    """
+
+    Parameters
+    ----------
+    dt :
+        
+
+    Returns
+    -------
+
+    """
     if dt in np.typecodes['UnsignedInteger']:
         return (+1,)
     else:
@@ -201,8 +239,10 @@
 
 
 class TestModulus:
+    """ """
 
     def test_modulus_basic(self):
+        """ """
         dt = np.typecodes['AllInteger'] + np.typecodes['Float']
         for op in [floordiv_and_mod, divmod]:
             for dt1, dt2 in itertools.product(dt, dt):
@@ -219,6 +259,7 @@
                         assert_(b > rem >= 0, msg)
 
     def test_float_modulus_exact(self):
+        """ """
         # test that float results are exact for small integers. This also
         # holds for the same integers scaled by powers of two.
         nlst = list(range(-127, 0))
@@ -246,6 +287,7 @@
                 assert_equal(rem, tgtrem, err_msg=msg)
 
     def test_float_modulus_roundoff(self):
+        """ """
         # gh-6127
         dt = np.typecodes['Float']
         for op in [floordiv_and_mod, divmod]:
@@ -264,6 +306,7 @@
                         assert_(b > rem >= 0, msg)
 
     def test_float_modulus_corner_cases(self):
+        """ """
         # Check remainder magnitude.
         for dt in np.typecodes['Float']:
             b = np.array(1.0, dtype=dt)
@@ -292,6 +335,7 @@
                 assert_(np.isnan(rem), 'dt: %s' % dt)
 
     def test_inplace_floordiv_handling(self):
+        """ """
         # issue gh-12927
         # this only applies to in-place floordiv //=, because the output type
         # promotes to float which does not fit
@@ -303,7 +347,9 @@
 
 
 class TestComplexDivision:
+    """ """
     def test_zero_division(self):
+        """ """
         with np.errstate(all="ignore"):
             for t in [np.complex64, np.complex128]:
                 a = t(0.0)
@@ -321,6 +367,7 @@
                 assert_(np.isnan(b/a))
 
     def test_signed_zeros(self):
+        """ """
         with np.errstate(all="ignore"):
             for t in [np.complex64, np.complex128]:
                 # tupled (numerator, denominator, expected)
@@ -346,6 +393,7 @@
                     assert_equal(result.imag, ex[1])
 
     def test_branches(self):
+        """ """
         with np.errstate(all="ignore"):
             for t in [np.complex64, np.complex128]:
                 # tupled (numerator, denominator, expected)
@@ -375,7 +423,9 @@
 
 
 class TestConversion:
+    """ """
     def test_int_from_long(self):
+        """ """
         l = [1e6, 1e12, 1e18, -1e6, -1e12, -1e18]
         li = [10**6, 10**12, 10**18, -10**6, -10**12, -10**18]
         for T in [None, np.float64, np.int64]:
@@ -386,6 +436,7 @@
         assert_equal([int(_m) for _m in a], li[:3])
 
     def test_iinfo_long_values(self):
+        """ """
         for code in 'bBhH':
             res = np.array(np.iinfo(code).max + 1, dtype=code)
             tgt = np.iinfo(code).min
@@ -402,13 +453,26 @@
             assert_(res == tgt)
 
     def test_int_raise_behaviour(self):
+        """ """
         def overflow_error_func(dtype):
+            """
+
+            Parameters
+            ----------
+            dtype :
+                
+
+            Returns
+            -------
+
+            """
             np.typeDict[dtype](np.iinfo(dtype).max + 1)
 
         for code in 'lLqQ':
             assert_raises(OverflowError, overflow_error_func, code)
 
     def test_int_from_infinite_longdouble(self):
+        """ """
         # gh-627
         x = np.longdouble(np.inf)
         assert_raises(OverflowError, int, x)
@@ -420,6 +484,7 @@
 
     @pytest.mark.skipif(not IS_PYPY, reason="Test is PyPy only (gh-9972)")
     def test_int_from_infinite_longdouble___int__(self):
+        """ """
         x = np.longdouble(np.inf)
         assert_raises(OverflowError, x.__int__)
         with suppress_warnings() as sup:
@@ -433,6 +498,7 @@
     @pytest.mark.skipif(platform.machine().startswith("ppc"),
                         reason="IBM double double")
     def test_int_from_huge_longdouble(self):
+        """ """
         # Produce a longdouble that would overflow a double,
         # use exponent that avoids bug in Darwin pow function.
         exp = np.finfo(np.double).maxexp - 1
@@ -442,12 +508,14 @@
         assert_equal(int(huge_ld), huge_i)
 
     def test_int_from_longdouble(self):
+        """ """
         x = np.longdouble(1.5)
         assert_equal(int(x), 1)
         x = np.longdouble(-10.5)
         assert_equal(int(x), -10)
 
     def test_numpy_scalar_relational_operators(self):
+        """ """
         # All integer
         for dt1 in np.typecodes['AllInteger']:
             assert_(1 > np.array(0, dtype=dt1)[()], "type %s failed" % (dt1,))
@@ -489,6 +557,7 @@
                         "type %s and %s failed" % (dt1, dt2))
 
     def test_scalar_comparison_to_none(self):
+        """ """
         # Scalars should just return False and not give a warnings.
         # The comparisons are flagged by pep8, ignore that.
         with warnings.catch_warnings(record=True) as w:
@@ -520,7 +589,19 @@
 
 
 class TestRepr:
+    """ """
     def _test_type_repr(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         finfo = np.finfo(t)
         last_fraction_bit_idx = finfo.nexp + finfo.nmant
         last_exponent_bit_idx = finfo.nexp
@@ -546,6 +627,7 @@
                 assert_equal(val, val2)
 
     def test_float_repr(self):
+        """ """
         # long double test cannot work, because eval goes through a python
         # float
         for t in [np.float32, np.float64]:
@@ -555,19 +637,24 @@
 if not IS_PYPY:
     # sys.getsizeof() is not valid on PyPy
     class TestSizeOf:
+        """ """
 
         def test_equal_nbytes(self):
+            """ """
             for type in types:
                 x = type(0)
                 assert_(sys.getsizeof(x) > x.nbytes)
 
         def test_error(self):
+            """ """
             d = np.float32()
             assert_raises(TypeError, d.__sizeof__, "a")
 
 
 class TestMultiply:
+    """ """
     def test_seq_repeat(self):
+        """ """
         # Test that basic sequences get repeated when multiplied with
         # numpy integers. And errors are raised when multiplied with others.
         # Some of this behaviour may be controversial and could be open for
@@ -600,10 +687,12 @@
                 assert_raises(TypeError, operator.mul, i, seq)
 
     def test_no_seq_repeat_basic_array_like(self):
+        """ """
         # Test that an array-like which does not know how to be multiplied
         # does not attempt sequence repeat (raise TypeError).
         # See also gh-7428.
         class ArrayLike:
+            """ """
             def __init__(self, arr):
                 self.arr = arr
             def __array__(self):
@@ -618,11 +707,14 @@
 
 
 class TestNegative:
+    """ """
     def test_exceptions(self):
+        """ """
         a = np.ones((), dtype=np.bool_)[()]
         assert_raises(TypeError, operator.neg, a)
 
     def test_result(self):
+        """ """
         types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']
         with suppress_warnings() as sup:
             sup.filter(RuntimeWarning)
@@ -632,11 +724,14 @@
 
 
 class TestSubtract:
+    """ """
     def test_exceptions(self):
+        """ """
         a = np.ones((), dtype=np.bool_)[()]
         assert_raises(TypeError, operator.sub, a, a)
 
     def test_result(self):
+        """ """
         types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']
         with suppress_warnings() as sup:
             sup.filter(RuntimeWarning)
@@ -646,7 +741,19 @@
 
 
 class TestAbs:
+    """ """
     def _test_abs_func(self, absfunc):
+        """
+
+        Parameters
+        ----------
+        absfunc :
+            
+
+        Returns
+        -------
+
+        """
         for tp in floating_types + complex_floating_types:
             x = tp(-1.5)
             assert_equal(absfunc(x), 1.5)
@@ -668,19 +775,34 @@
             assert_equal(absfunc(x), -x.real)
 
     def test_builtin_abs(self):
+        """ """
         self._test_abs_func(abs)
 
     def test_numpy_abs(self):
+        """ """
         self._test_abs_func(np.abs)
 
 
 class TestBitShifts:
+    """ """
 
     @pytest.mark.parametrize('type_code', np.typecodes['AllInteger'])
     @pytest.mark.parametrize('op',
         [operator.rshift, operator.lshift], ids=['>>', '<<'])
     def test_shift_all_bits(self, type_code, op):
-        """ Shifts where the shift amount is the width of the type or wider """
+        """Shifts where the shift amount is the width of the type or wider
+
+        Parameters
+        ----------
+        type_code :
+            
+        op :
+            
+
+        Returns
+        -------
+
+        """
         # gh-2449
         dt = np.dtype(type_code)
         nbits = dt.itemsize * 8
