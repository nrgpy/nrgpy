# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/names.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/names.py
@@ -13,6 +13,17 @@
 
 
 def _merge_name_docs(names):
+    """
+
+    Parameters
+    ----------
+    names :
+        
+
+    Returns
+    -------
+
+    """
     doc = ''
     for name in names:
         if doc:
@@ -24,6 +35,7 @@
 
 
 class AbstractNameDefinition(object):
+    """ """
     start_pos = None
     string_name = None
     parent_context = None
@@ -35,15 +47,28 @@
 
     @abstractmethod
     def infer(self):
+        """ """
         raise NotImplementedError
 
     @abstractmethod
     def goto(self):
+        """ """
         # Typically names are already definitions and therefore a goto on that
         # name will always result on itself.
         return {self}
 
     def get_qualified_names(self, include_module_names=False):
+        """
+
+        Parameters
+        ----------
+        include_module_names :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         qualified_names = self._get_qualified_names()
         if qualified_names is None or not include_module_names:
             return qualified_names
@@ -54,13 +79,16 @@
         return module_names + qualified_names
 
     def _get_qualified_names(self):
+        """ """
         # By default, a name has no qualified names.
         return None
 
     def get_root_context(self):
+        """ """
         return self.parent_context.get_root_context()
 
     def get_public_name(self):
+        """ """
         return self.string_name
 
     def __repr__(self):
@@ -70,28 +98,34 @@
                                                       self.string_name, self.start_pos)
 
     def is_import(self):
+        """ """
         return False
 
     def py__doc__(self):
+        """ """
         return ''
 
     @property
     def api_type(self):
+        """ """
         return self.parent_context.api_type
 
     def get_defining_qualified_value(self):
-        """
-        Returns either None or the value that is public and qualified. Won't
-        return a function, because a name in a function is never public.
-        """
+        """Returns either None or the value that is public and qualified. Won't"""
         return None
 
 
 class AbstractArbitraryName(AbstractNameDefinition):
-    """
-    When you e.g. want to complete dicts keys, you probably want to complete
+    """When you e.g. want to complete dicts keys, you probably want to complete
     string literals, which is not really a name, but for Jedi we use this
     concept of Name for completions as well.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     is_value_name = False
 
@@ -101,15 +135,28 @@
         self.parent_context = inference_state.builtins_module
 
     def infer(self):
+        """ """
         return NO_VALUES
 
 
 class AbstractTreeName(AbstractNameDefinition):
+    """ """
     def __init__(self, parent_context, tree_name):
         self.parent_context = parent_context
         self.tree_name = tree_name
 
     def get_qualified_names(self, include_module_names=False):
+        """
+
+        Parameters
+        ----------
+        include_module_names :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         import_node = search_ancestor(self.tree_name, 'import_name', 'import_from')
         # For import nodes we cannot just have names, because it's very unclear
         # how they would look like. For now we just ignore them in most cases.
@@ -126,12 +173,14 @@
         return super(AbstractTreeName, self).get_qualified_names(include_module_names)
 
     def _get_qualified_names(self):
+        """ """
         parent_names = self.parent_context.get_qualified_names()
         if parent_names is None:
             return None
         return parent_names + (self.tree_name.value,)
 
     def get_defining_qualified_value(self):
+        """ """
         if self.is_import():
             raise NotImplementedError("Shouldn't really happen, please report")
         elif self.parent_context:
@@ -139,6 +188,7 @@
         return None
 
     def goto(self):
+        """ """
         context = self.parent_context
         name = self.tree_name
         definition = name.get_definition(import_name_always=True)
@@ -211,23 +261,29 @@
             return context.goto(name, position=stmt.start_pos)
 
     def is_import(self):
+        """ """
         imp = search_ancestor(self.tree_name, 'import_from', 'import_name')
         return imp is not None
 
     @property
     def string_name(self):
+        """ """
         return self.tree_name.value
 
     @property
     def start_pos(self):
+        """ """
         return self.tree_name.start_pos
 
 
 class ValueNameMixin(object):
+    """ """
     def infer(self):
+        """ """
         return ValueSet([self._value])
 
     def py__doc__(self):
+        """ """
         doc = self._value.py__doc__()
         if not doc and self._value.is_stub():
             from jedi.inference.gradual.conversion import convert_names
@@ -237,14 +293,17 @@
         return doc
 
     def _get_qualified_names(self):
+        """ """
         return self._value.get_qualified_names()
 
     def get_root_context(self):
+        """ """
         if self.parent_context is None:  # A module
             return self._value.as_context()
         return super(ValueNameMixin, self).get_root_context()
 
     def get_defining_qualified_value(self):
+        """ """
         context = self.parent_context
         if context.is_module() or context.is_class():
             return self.parent_context.get_value()  # Might be None
@@ -252,19 +311,23 @@
 
     @property
     def api_type(self):
+        """ """
         return self._value.api_type
 
 
 class ValueName(ValueNameMixin, AbstractTreeName):
+    """ """
     def __init__(self, value, tree_name):
         super(ValueName, self).__init__(value.parent_context, tree_name)
         self._value = value
 
     def goto(self):
+        """ """
         return ValueSet([self._value.name])
 
 
 class TreeNameDefinition(AbstractTreeName):
+    """ """
     _API_TYPES = dict(
         import_name='module',
         import_from='module',
@@ -274,6 +337,7 @@
     )
 
     def infer(self):
+        """ """
         # Refactor this, should probably be here.
         from jedi.inference.syntax_tree import tree_name_to_values
         return tree_name_to_values(
@@ -284,25 +348,32 @@
 
     @property
     def api_type(self):
+        """ """
         definition = self.tree_name.get_definition(import_name_always=True)
         if definition is None:
             return 'statement'
         return self._API_TYPES.get(definition.type, 'statement')
 
     def assignment_indexes(self):
-        """
-        Returns an array of tuple(int, node) of the indexes that are used in
+        """Returns an array of tuple(int, node) of the indexes that are used in
         tuple assignments.
-
+        
         For example if the name is ``y`` in the following code::
-
+        
             x, (y, z) = 2, ''
-
+        
         would result in ``[(1, xyz_node), (0, yz_node)]``.
-
+        
         When searching for b in the case ``a, *b, c = [...]`` it will return::
-
+        
             [(slice(1, -1), abc_node)]
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         indexes = []
         is_star_expr = False
@@ -331,6 +402,7 @@
         return indexes
 
     def py__doc__(self):
+        """ """
         api_type = self.api_type
         if api_type in ('function', 'class'):
             # Make sure the names are not TreeNameDefinitions anymore.
@@ -347,19 +419,43 @@
 
 
 class _ParamMixin(object):
+    """ """
     def maybe_positional_argument(self, include_star=True):
+        """
+
+        Parameters
+        ----------
+        include_star :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         options = [Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD]
         if include_star:
             options.append(Parameter.VAR_POSITIONAL)
         return self.get_kind() in options
 
     def maybe_keyword_argument(self, include_stars=True):
+        """
+
+        Parameters
+        ----------
+        include_stars :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         options = [Parameter.KEYWORD_ONLY, Parameter.POSITIONAL_OR_KEYWORD]
         if include_stars:
             options.append(Parameter.VAR_KEYWORD)
         return self.get_kind() in options
 
     def _kind_string(self):
+        """ """
         kind = self.get_kind()
         if kind == Parameter.VAR_POSITIONAL:  # *args
             return '*'
@@ -368,31 +464,52 @@
         return ''
 
     def get_qualified_names(self, include_module_names=False):
+        """
+
+        Parameters
+        ----------
+        include_module_names :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return None
 
 
 class ParamNameInterface(_ParamMixin):
+    """ """
     api_type = u'param'
 
     def get_kind(self):
+        """ """
         raise NotImplementedError
 
     def to_string(self):
+        """ """
         raise NotImplementedError
 
     def get_executed_param_name(self):
-        """
-        For dealing with type inference and working around the graph, we
+        """For dealing with type inference and working around the graph, we
         sometimes want to have the param name of the execution. This feels a
         bit strange and we might have to refactor at some point.
-
+        
         For now however it exists to avoid infering params when we don't really
         need them (e.g. when we can just instead use annotations.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     @property
     def star_count(self):
+        """ """
         kind = self.get_kind()
         if kind == Parameter.VAR_POSITIONAL:
             return 1
@@ -402,10 +519,12 @@
 
 
 class BaseTreeParamName(ParamNameInterface, AbstractTreeName):
+    """ """
     annotation_node = None
     default_node = None
 
     def to_string(self):
+        """ """
         output = self._kind_string() + self.get_public_name()
         annotation = self.annotation_node
         default = self.default_node
@@ -416,6 +535,7 @@
         return output
 
     def get_public_name(self):
+        """ """
         name = self.string_name
         if name.startswith('__'):
             # Params starting with __ are an equivalent to positional only
@@ -424,23 +544,50 @@
         return name
 
     def goto(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return [self]
 
 
 class _ActualTreeParamName(BaseTreeParamName):
+    """ """
     def __init__(self, function_value, tree_name):
         super(_ActualTreeParamName, self).__init__(
             function_value.get_default_param_context(), tree_name)
         self.function_value = function_value
 
     def _get_param_node(self):
+        """ """
         return search_ancestor(self.tree_name, 'param')
 
     @property
     def annotation_node(self):
+        """ """
         return self._get_param_node().annotation
 
     def infer_annotation(self, execute_annotation=True, ignore_stars=False):
+        """
+
+        Parameters
+        ----------
+        execute_annotation :
+             (Default value = True)
+        ignore_stars :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         from jedi.inference.gradual.annotation import infer_param
         values = infer_param(
             self.function_value, self._get_param_node(),
@@ -450,6 +597,7 @@
         return values
 
     def infer_default(self):
+        """ """
         node = self.default_node
         if node is None:
             return NO_VALUES
@@ -457,9 +605,11 @@
 
     @property
     def default_node(self):
+        """ """
         return self._get_param_node().default
 
     def get_kind(self):
+        """ """
         tree_param = self._get_param_node()
         if tree_param.star_count == 1:  # *args
             return Parameter.VAR_POSITIONAL
@@ -488,6 +638,7 @@
         return Parameter.POSITIONAL_OR_KEYWORD
 
     def infer(self):
+        """ """
         values = self.infer_annotation()
         if values:
             return values
@@ -497,12 +648,15 @@
 
 
 class AnonymousParamName(_ActualTreeParamName):
+    """ """
     @plugin_manager.decorate(name='goto_anonymous_param')
     def goto(self):
+        """ """
         return super(AnonymousParamName, self).goto()
 
     @plugin_manager.decorate(name='infer_anonymous_param')
     def infer(self):
+        """ """
         values = super(AnonymousParamName, self).infer()
         if values:
             return values
@@ -526,11 +680,13 @@
 
 
 class ParamName(_ActualTreeParamName):
+    """ """
     def __init__(self, function_value, tree_name, arguments):
         super(ParamName, self).__init__(function_value, tree_name)
         self.arguments = arguments
 
     def infer(self):
+        """ """
         values = super(ParamName, self).infer()
         if values:
             return values
@@ -538,12 +694,14 @@
         return self.get_executed_param_name().infer()
 
     def get_executed_param_name(self):
+        """ """
         from jedi.inference.param import get_executed_param_names
         params_names = get_executed_param_names(self.function_value, self.arguments)
         return params_names[self._get_param_node().position_index]
 
 
 class ParamNameWrapper(_ParamMixin):
+    """ """
     def __init__(self, param_name):
         self._wrapped_param_name = param_name
 
@@ -555,6 +713,7 @@
 
 
 class ImportName(AbstractNameDefinition):
+    """ """
     start_pos = (1, 0)
     _level = 0
 
@@ -563,6 +722,17 @@
         self.string_name = string_name
 
     def get_qualified_names(self, include_module_names=False):
+        """
+
+        Parameters
+        ----------
+        include_module_names :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if include_module_names:
             if self._level:
                 assert self._level == 1, "Everything else is not supported for now"
@@ -575,6 +745,7 @@
 
     @property
     def parent_context(self):
+        """ """
         m = self._from_module_context
         import_values = self.infer()
         if not import_values:
@@ -585,26 +756,32 @@
 
     @memoize_method
     def infer(self):
+        """ """
         from jedi.inference.imports import Importer
         m = self._from_module_context
         return Importer(m.inference_state, [self.string_name], m, level=self._level).follow()
 
     def goto(self):
+        """ """
         return [m.name for m in self.infer()]
 
     @property
     def api_type(self):
+        """ """
         return 'module'
 
     def py__doc__(self):
+        """ """
         return _merge_name_docs(self.goto())
 
 
 class SubModuleName(ImportName):
+    """ """
     _level = 1
 
 
 class NameWrapper(object):
+    """ """
     def __init__(self, wrapped_name):
         self._wrapped_name = wrapped_name
 
@@ -616,7 +793,9 @@
 
 
 class StubNameMixin(object):
+    """ """
     def py__doc__(self):
+        """ """
         from jedi.inference.gradual.conversion import convert_names
         # Stubs are not complicated and we can just follow simple statements
         # that have an equals in them, because they typically make something
@@ -636,7 +815,9 @@
 
 # From here on down we make looking up the sys.version_info fast.
 class StubName(StubNameMixin, TreeNameDefinition):
+    """ """
     def infer(self):
+        """ """
         inferred = super(StubName, self).infer()
         if self.string_name == 'version_info' and self.get_root_context().py__name__() == 'sys':
             from jedi.inference.gradual.stub_value import VersionInfo
@@ -645,6 +826,7 @@
 
 
 class ModuleName(ValueNameMixin, AbstractNameDefinition):
+    """ """
     start_pos = 1, 0
 
     def __init__(self, value, name):
@@ -653,8 +835,10 @@
 
     @property
     def string_name(self):
+        """ """
         return self._name
 
 
 class StubModuleName(StubNameMixin, ModuleName):
+    """ """
     pass
