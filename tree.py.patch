# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/parso/python/tree.py
+++ b/..//venv/lib/python3.8/site-packages/parso/python/tree.py
@@ -70,12 +70,11 @@
 
 
 class DocstringMixin(object):
+    """ """
     __slots__ = ()
 
     def get_doc_node(self):
-        """
-        Returns the string leaf of a docstring. e.g. ``r'''foo'''``.
-        """
+        """Returns the string leaf of a docstring. e.g. ``r'''foo'''``."""
         if self.type == 'file_input':
             node = self.children[0]
         elif self.type in ('funcdef', 'classdef'):
@@ -98,15 +97,21 @@
 
 
 class PythonMixin(object):
-    """
-    Some Python specific utilities.
-    """
+    """Some Python specific utilities."""
     __slots__ = ()
 
     def get_name_of_position(self, position):
-        """
-        Given a (line, column) tuple, returns a :py:class:`Name` or ``None`` if
+        """Given a (line, column) tuple, returns a :py:class:`Name` or ``None`` if
         there is no name at that position.
+
+        Parameters
+        ----------
+        position :
+            
+
+        Returns
+        -------
+
         """
         for c in self.children:
             if isinstance(c, Leaf):
@@ -120,15 +125,15 @@
 
 
 class PythonLeaf(PythonMixin, Leaf):
+    """ """
     __slots__ = ()
 
     def _split_prefix(self):
+        """ """
         return split_prefix(self, self.get_start_pos_of_prefix())
 
     def get_start_pos_of_prefix(self):
-        """
-        Basically calls :py:meth:`parso.tree.NodeOrLeaf.get_start_pos_of_prefix`.
-        """
+        """Basically calls :py:meth:`parso.tree.NodeOrLeaf.get_start_pos_of_prefix`."""
         # TODO it is really ugly that we have to override it. Maybe change
         #   indent error leafs somehow? No idea how, though.
         previous_leaf = self.get_previous_leaf()
@@ -144,34 +149,38 @@
 
 
 class _LeafWithoutNewlines(PythonLeaf):
-    """
-    Simply here to optimize performance.
-    """
+    """Simply here to optimize performance."""
     __slots__ = ()
 
     @property
     def end_pos(self):
+        """ """
         return self.line, self.column + len(self.value)
 
 
 # Python base classes
 class PythonBaseNode(PythonMixin, BaseNode):
+    """ """
     __slots__ = ()
 
 
 class PythonNode(PythonMixin, Node):
+    """ """
     __slots__ = ()
 
 
 class PythonErrorNode(PythonMixin, ErrorNode):
+    """ """
     __slots__ = ()
 
 
 class PythonErrorLeaf(ErrorLeaf, PythonLeaf):
+    """ """
     __slots__ = ()
 
 
 class EndMarker(_LeafWithoutNewlines):
+    """ """
     __slots__ = ()
     type = 'endmarker'
 
@@ -193,9 +202,15 @@
 
 
 class Name(_LeafWithoutNewlines):
-    """
-    A string. Sometimes it is important to know if the string belongs to a name
+    """A string. Sometimes it is important to know if the string belongs to a name
     or not.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'name'
     __slots__ = ()
@@ -205,18 +220,34 @@
                                    self.line, self.column)
 
     def is_definition(self, include_setitem=False):
-        """
-        Returns True if the name is being defined.
+        """Returns True if the name is being defined.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         return self.get_definition(include_setitem=include_setitem) is not None
 
     def get_definition(self, import_name_always=False, include_setitem=False):
-        """
-        Returns None if there's no definition for a name.
-
-        :param import_name_always: Specifies if an import name is always a
+        """Returns None if there's no definition for a name.
+
+        Parameters
+        ----------
+        import_name_always :
+            Specifies if an import name is always a
             definition. Normally foo in `from foo import bar` is not a
-            definition.
+            definition. (Default value = False)
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         node = self.parent
         type_ = node.type
@@ -250,23 +281,28 @@
 
 
 class Literal(PythonLeaf):
+    """ """
     __slots__ = ()
 
 
 class Number(Literal):
+    """ """
     type = 'number'
     __slots__ = ()
 
 
 class String(Literal):
+    """ """
     type = 'string'
     __slots__ = ()
 
     @property
     def string_prefix(self):
+        """ """
         return re.match(r'\w*(?=[\'"])', self.value).group(0)
 
     def _get_payload(self):
+        """ """
         match = re.search(
             r'''('{3}|"{3}|'|")(.*)$''',
             self.value,
@@ -276,27 +312,45 @@
 
 
 class FStringString(PythonLeaf):
-    """
-    f-strings contain f-string expressions and normal python strings. These are
+    """f-strings contain f-string expressions and normal python strings. These are
     the string parts of f-strings.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'fstring_string'
     __slots__ = ()
 
 
 class FStringStart(PythonLeaf):
-    """
-    f-strings contain f-string expressions and normal python strings. These are
+    """f-strings contain f-string expressions and normal python strings. These are
     the string parts of f-strings.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'fstring_start'
     __slots__ = ()
 
 
 class FStringEnd(PythonLeaf):
-    """
-    f-strings contain f-string expressions and normal python strings. These are
+    """f-strings contain f-string expressions and normal python strings. These are
     the string parts of f-strings.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'fstring_end'
     __slots__ = ()
@@ -304,10 +358,16 @@
 
 class _StringComparisonMixin(object):
     def __eq__(self, other):
-        """
-        Make comparisons with strings easy.
+    """Make comparisons with strings easy.
         Improves the readability of the parser.
-        """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
         if isinstance(other, (str, unicode)):
             return self.value == other
 
@@ -322,20 +382,28 @@
 
 
 class Operator(_LeafWithoutNewlines, _StringComparisonMixin):
+    """ """
     type = 'operator'
     __slots__ = ()
 
 
 class Keyword(_LeafWithoutNewlines, _StringComparisonMixin):
+    """ """
     type = 'keyword'
     __slots__ = ()
 
 
 class Scope(PythonBaseNode, DocstringMixin):
-    """
-    Super class for the parser tree, which represents the state of a python
+    """Super class for the parser tree, which represents the state of a python
     text file.
     A Scope is either a function, class or lambda.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     __slots__ = ()
 
@@ -343,25 +411,41 @@
         super(Scope, self).__init__(children)
 
     def iter_funcdefs(self):
-        """
-        Returns a generator of `funcdef` nodes.
-        """
+        """Returns a generator of `funcdef` nodes."""
         return self._search_in_scope('funcdef')
 
     def iter_classdefs(self):
-        """
-        Returns a generator of `classdef` nodes.
-        """
+        """Returns a generator of `classdef` nodes."""
         return self._search_in_scope('classdef')
 
     def iter_imports(self):
-        """
-        Returns a generator of `import_name` and `import_from` nodes.
-        """
+        """Returns a generator of `import_name` and `import_from` nodes."""
         return self._search_in_scope('import_name', 'import_from')
 
     def _search_in_scope(self, *names):
+        """
+
+        Parameters
+        ----------
+        *names :
+            
+
+        Returns
+        -------
+
+        """
         def scan(children):
+            """
+
+            Parameters
+            ----------
+            children :
+                
+
+            Returns
+            -------
+
+            """
             for element in children:
                 if element.type in names:
                     yield element
@@ -372,9 +456,7 @@
         return scan(self.children)
 
     def get_suite(self):
-        """
-        Returns the part that is executed by the function.
-        """
+        """Returns the part that is executed by the function."""
         return self.children[-1]
 
     def __repr__(self):
@@ -388,10 +470,16 @@
 
 
 class Module(Scope):
-    """
-    The top scope, which is always a module.
+    """The top scope, which is always a module.
     Depending on the underlying parser this may be a full module or just a part
     of a module.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     __slots__ = ('_used_names',)
     type = 'file_input'
@@ -402,8 +490,15 @@
 
     def _iter_future_import_names(self):
         """
-        :return: A list of future import names.
-        :rtype: list of str
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        list of str
+            A list of future import names.
+
         """
         # In Python it's not allowed to use future imports after the first
         # actual (non-future) statement. However this is not a linter here,
@@ -417,11 +512,17 @@
                         yield names[1]
 
     def _has_explicit_absolute_import(self):
-        """
-        Checks if imports in this module are explicitly absolute, i.e. there
+        """Checks if imports in this module are explicitly absolute, i.e. there
         is a ``__future__`` import.
         Currently not public, might be in the future.
         :return bool:
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         for name in self._iter_future_import_names():
             if name == 'absolute_import':
@@ -429,15 +530,32 @@
         return False
 
     def get_used_names(self):
-        """
-        Returns all the :class:`Name` leafs that exist in this module. This
+        """Returns all the :class:`Name` leafs that exist in this module. This
         includes both definitions and references of names.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._used_names is None:
             # Don't directly use self._used_names to eliminate a lookup.
             dct = {}
 
             def recurse(node):
+                """
+
+                Parameters
+                ----------
+                node :
+                    
+
+                Returns
+                -------
+
+                """
                 try:
                     children = node.children
                 except AttributeError:
@@ -454,24 +572,22 @@
 
 
 class Decorator(PythonBaseNode):
+    """ """
     type = 'decorator'
     __slots__ = ()
 
 
 class ClassOrFunc(Scope):
+    """ """
     __slots__ = ()
 
     @property
     def name(self):
-        """
-        Returns the `Name` leaf that defines the function or class name.
-        """
+        """Returns the `Name` leaf that defines the function or class name."""
         return self.children[1]
 
     def get_decorators(self):
-        """
-        :rtype: list of :class:`Decorator`
-        """
+        """ """
         decorated = self.parent
         if decorated.type == 'async_funcdef':
             decorated = decorated.parent
@@ -486,9 +602,7 @@
 
 
 class Class(ClassOrFunc):
-    """
-    Used to store the parsed contents of a python class.
-    """
+    """Used to store the parsed contents of a python class."""
     type = 'classdef'
     __slots__ = ()
 
@@ -496,9 +610,15 @@
         super(Class, self).__init__(children)
 
     def get_super_arglist(self):
-        """
-        Returns the `arglist` node that defines the super classes. It returns
+        """Returns the `arglist` node that defines the super classes. It returns
         None if there are no arguments.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self.children[2] != '(':  # Has no parentheses
             return None
@@ -510,8 +630,7 @@
 
 
 def _create_params(parent, argslist_list):
-    """
-    `argslist_list` is a list that can contain an argslist as a first item, but
+    """`argslist_list` is a list that can contain an argslist as a first item, but
     most not. It's basically the items between the parameter brackets (which is
     at most one item).
     This function modifies the parser structure. It generates `Param` objects
@@ -519,12 +638,31 @@
     make the evaluation of the ast tree so much easier.
     You could also say that this function replaces the argslist node with a
     list of Param objects.
+
+    Parameters
+    ----------
+    parent :
+        
+    argslist_list :
+        
+
+    Returns
+    -------
+
     """
     def check_python2_nested_param(node):
-        """
-        Python 2 allows params to look like ``def x(a, (b, c))``, which is
+        """Python 2 allows params to look like ``def x(a, (b, c))``, which is
         basically a way of unpacking tuples in params. Python 3 has ditched
         this behavior. Jedi currently just ignores those constructs.
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
         """
         return node.type == 'fpdef' and node.children[0] == '('
 
@@ -567,11 +705,10 @@
 
 
 class Function(ClassOrFunc):
-    """
-    Used to store the parsed contents of a python function.
-
+    """Used to store the parsed contents of a python function.
+    
     Children::
-
+    
         0. <Keyword: def>
         1. <Name>
         2. parameter list (including open-paren and close-paren <Operator>s)
@@ -579,6 +716,13 @@
         4. or 6. Node() representing function body
         3. -> (if annotation is also present)
         4. annotation (if present)
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'funcdef'
 
@@ -588,23 +732,32 @@
         parameters.children[1:-1] = _create_params(parameters, parameters.children[1:-1])
 
     def _get_param_nodes(self):
+        """ """
         return self.children[2].children
 
     def get_params(self):
-        """
-        Returns a list of `Param()`.
-        """
+        """Returns a list of `Param()`."""
         return [p for p in self._get_param_nodes() if p.type == 'param']
 
     @property
     def name(self):
+        """ """
         return self.children[1]  # First token after `def`
 
     def iter_yield_exprs(self):
-        """
-        Returns a generator of `yield_expr`.
-        """
+        """Returns a generator of `yield_expr`."""
         def scan(children):
+            """
+
+            Parameters
+            ----------
+            children :
+                
+
+            Returns
+            -------
+
+            """
             for element in children:
                 if element.type in ('classdef', 'funcdef', 'lambdef'):
                     continue
@@ -624,10 +777,19 @@
         return scan(self.children)
 
     def iter_return_stmts(self):
-        """
-        Returns a generator of `return_stmt`.
-        """
+        """Returns a generator of `return_stmt`."""
         def scan(children):
+            """
+
+            Parameters
+            ----------
+            children :
+                
+
+            Returns
+            -------
+
+            """
             for element in children:
                 if element.type == 'return_stmt' \
                         or element.type == 'keyword' and element.value == 'return':
@@ -639,10 +801,19 @@
         return scan(self.children)
 
     def iter_raise_stmts(self):
-        """
-        Returns a generator of `raise_stmt`. Includes raise statements inside try-except blocks
-        """
+        """Returns a generator of `raise_stmt`. Includes raise statements inside try-except blocks"""
         def scan(children):
+            """
+
+            Parameters
+            ----------
+            children :
+                
+
+            Returns
+            -------
+
+            """
             for element in children:
                 if element.type == 'raise_stmt' \
                         or element.type == 'keyword' and element.value == 'raise':
@@ -654,16 +825,12 @@
         return scan(self.children)
 
     def is_generator(self):
-        """
-        :return bool: Checks if a function is a generator or not.
-        """
+        """:return bool: Checks if a function is a generator or not."""
         return next(self.iter_yield_exprs(), None) is not None
 
     @property
     def annotation(self):
-        """
-        Returns the test node after `->` or `None` if there is no annotation.
-        """
+        """Returns the test node after `->` or `None` if there is no annotation."""
         try:
             if self.children[3] == "->":
                 return self.children[4]
@@ -674,15 +841,21 @@
 
 
 class Lambda(Function):
-    """
-    Lambdas are basically trimmed functions, so give it the same interface.
-
+    """Lambdas are basically trimmed functions, so give it the same interface.
+    
     Children::
-
+    
          0. <Keyword: lambda>
          *. <Param x> for each argument x
         -2. <Operator: :>
         -1. Node() representing body
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'lambdef'
     __slots__ = ()
@@ -695,19 +868,16 @@
 
     @property
     def name(self):
-        """
-        Raises an AttributeError. Lambdas don't have a defined name.
-        """
+        """Raises an AttributeError. Lambdas don't have a defined name."""
         raise AttributeError("lambda is not named.")
 
     def _get_param_nodes(self):
+        """ """
         return self.children[1:-2]
 
     @property
     def annotation(self):
-        """
-        Returns `None`, lambdas don't have annotations.
-        """
+        """Returns `None`, lambdas don't have annotations."""
         return None
 
     def __repr__(self):
@@ -715,31 +885,47 @@
 
 
 class Flow(PythonBaseNode):
+    """ """
     __slots__ = ()
 
 
 class IfStmt(Flow):
+    """ """
     type = 'if_stmt'
     __slots__ = ()
 
     def get_test_nodes(self):
-        """
-        E.g. returns all the `test` nodes that are named as x, below:
-
+        """E.g. returns all the `test` nodes that are named as x, below:
+        
             if x:
                 pass
             elif x:
                 pass
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         for i, c in enumerate(self.children):
             if c in ('elif', 'if'):
                 yield self.children[i + 1]
 
     def get_corresponding_test_node(self, node):
-        """
-        Searches for the branch in which the node is and returns the
+        """Searches for the branch in which the node is and returns the
         corresponding test node (see function above). However if the node is in
         the test node itself and not in the suite return None.
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
         """
         start_pos = node.start_pos
         for check_node in reversed(list(self.get_test_nodes())):
@@ -752,8 +938,16 @@
                     return check_node
 
     def is_node_after_else(self, node):
-        """
-        Checks if a node is defined after `else`.
+        """Checks if a node is defined after `else`.
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
         """
         for c in self.children:
             if c == 'else':
@@ -764,32 +958,50 @@
 
 
 class WhileStmt(Flow):
+    """ """
     type = 'while_stmt'
     __slots__ = ()
 
 
 class ForStmt(Flow):
+    """ """
     type = 'for_stmt'
     __slots__ = ()
 
     def get_testlist(self):
-        """
-        Returns the input node ``y`` from: ``for x in y:``.
-        """
+        """Returns the input node ``y`` from: ``for x in y:``."""
         return self.children[3]
 
     def get_defined_names(self, include_setitem=False):
+        """
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return _defined_names(self.children[1], include_setitem)
 
 
 class TryStmt(Flow):
+    """ """
     type = 'try_stmt'
     __slots__ = ()
 
     def get_except_clause_tests(self):
-        """
-        Returns the ``test`` nodes found in ``except_clause`` nodes.
+        """Returns the ``test`` nodes found in ``except_clause`` nodes.
         Returns ``[None]`` for except clauses without an exception given.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         for node in self.children:
             if node.type == 'except_clause':
@@ -799,13 +1011,22 @@
 
 
 class WithStmt(Flow):
+    """ """
     type = 'with_stmt'
     __slots__ = ()
 
     def get_defined_names(self, include_setitem=False):
-        """
-        Returns the a list of `Name` that the with statement defines. The
+        """Returns the a list of `Name` that the with statement defines. The
         defined names are set after `as`.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         names = []
         for with_item in self.children[1:-2:2]:
@@ -815,6 +1036,17 @@
         return names
 
     def get_test_node_from_name(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         node = name.parent
         if node.type != 'with_item':
             raise ValueError('The name is not actually part of a with statement.')
@@ -822,13 +1054,22 @@
 
 
 class Import(PythonBaseNode):
+    """ """
     __slots__ = ()
 
     def get_path_for_name(self, name):
-        """
-        The path is the list of names that leads to the searched name.
-
+        """The path is the list of names that leads to the searched name.
+        
         :return list of Name:
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
         """
         try:
             # The name may be an alias. If it is, just map it back to the name.
@@ -842,21 +1083,32 @@
         raise ValueError('Name should be defined in the import itself')
 
     def is_nested(self):
+        """ """
         return False  # By default, sub classes may overwrite this behavior
 
     def is_star_import(self):
+        """ """
         return self.children[-1] == '*'
 
 
 class ImportFrom(Import):
+    """ """
     type = 'import_from'
     __slots__ = ()
 
     def get_defined_names(self, include_setitem=False):
-        """
-        Returns the a list of `Name` that the import defines. The
+        """Returns the a list of `Name` that the import defines. The
         defined names are set after `import` or in case an alias - `as` - is
         present that name is returned.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         return [alias or name for name, alias in self._as_name_tuples()]
 
@@ -866,6 +1118,7 @@
                     if alias is not None)
 
     def get_from_names(self):
+        """ """
         for n in self.children[1:]:
             if n not in ('.', '...'):
                 break
@@ -888,6 +1141,7 @@
         return level
 
     def _as_name_tuples(self):
+        """ """
         last = self.children[-1]
         if last == ')':
             last = self.children[-2]
@@ -905,11 +1159,17 @@
                 yield as_name.children[::2]  # yields x, y -> ``x as y``
 
     def get_paths(self):
-        """
-        The import paths defined in an import statement. Typically an array
+        """The import paths defined in an import statement. Typically an array
         like this: ``[<Name: datetime>, <Name: date>]``.
-
+        
         :return list of list of Name:
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         dotted = self.get_from_names()
 
@@ -924,10 +1184,18 @@
     __slots__ = ()
 
     def get_defined_names(self, include_setitem=False):
-        """
-        Returns the a list of `Name` that the import defines. The defined names
+        """Returns the a list of `Name` that the import defines. The defined names
         is always the first name after `import` or in case an alias - `as` - is
         present that name is returned.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         return [alias or path[0] for path, alias in self._dotted_as_names()]
 
@@ -937,6 +1205,7 @@
         return 0  # Obviously 0 for imports without from.
 
     def get_paths(self):
+        """ """
         return [path for path, alias in self._dotted_as_names()]
 
     def _dotted_as_names(self):
@@ -960,46 +1229,74 @@
                 yield as_name.children[::2], alias
 
     def is_nested(self):
-        """
-        This checks for the special case of nested imports, without aliases and
+        """This checks for the special case of nested imports, without aliases and
         from statement::
-
+        
             import foo.bar
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return bool([1 for path, alias in self._dotted_as_names()
                     if alias is None and len(path) > 1])
 
     def _aliases(self):
-        """
-        :return list of Name: Returns all the alias
-        """
+        """:return list of Name: Returns all the alias"""
         return dict((alias, path[-1]) for path, alias in self._dotted_as_names()
                     if alias is not None)
 
 
 class KeywordStatement(PythonBaseNode):
-    """
-    For the following statements: `assert`, `del`, `global`, `nonlocal`,
+    """For the following statements: `assert`, `del`, `global`, `nonlocal`,
     `raise`, `return`, `yield`.
-
+    
     `pass`, `continue` and `break` are not in there, because they are just
     simple keywords and the parser reduces it to a keyword.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     __slots__ = ()
 
     @property
     def type(self):
-        """
-        Keyword statements start with the keyword and end with `_stmt`. You can
+        """Keyword statements start with the keyword and end with `_stmt`. You can
         crosscheck this with the Python grammar.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return '%s_stmt' % self.keyword
 
     @property
     def keyword(self):
+        """ """
         return self.children[0].value
 
     def get_defined_names(self, include_setitem=False):
+        """
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         keyword = self.keyword
         if keyword == 'del':
             return _defined_names(self.children[1], include_setitem)
@@ -1009,33 +1306,49 @@
 
 
 class AssertStmt(KeywordStatement):
+    """ """
     __slots__ = ()
 
     @property
     def assertion(self):
+        """ """
         return self.children[1]
 
 
 class GlobalStmt(KeywordStatement):
+    """ """
     __slots__ = ()
 
     def get_global_names(self):
+        """ """
         return self.children[1::2]
 
 
 class ReturnStmt(KeywordStatement):
+    """ """
     __slots__ = ()
 
 
 class YieldExpr(PythonBaseNode):
+    """ """
     type = 'yield_expr'
     __slots__ = ()
 
 
 def _defined_names(current, include_setitem):
-    """
-    A helper function to find the defined names in statements, for loops and
+    """A helper function to find the defined names in statements, for loops and
     list comprehensions.
+
+    Parameters
+    ----------
+    current :
+        
+    include_setitem :
+        
+
+    Returns
+    -------
+
     """
     names = []
     if current.type in ('testlist_star_expr', 'testlist_comp', 'exprlist', 'testlist'):
@@ -1062,12 +1375,21 @@
 
 
 class ExprStmt(PythonBaseNode, DocstringMixin):
+    """ """
     type = 'expr_stmt'
     __slots__ = ()
 
     def get_defined_names(self, include_setitem=False):
-        """
-        Returns a list of `Name` defined before the `=` sign.
+        """Returns a list of `Name` defined before the `=` sign.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         names = []
         if self.children[1].type == 'annassign':
@@ -1090,9 +1412,7 @@
         return node
 
     def yield_operators(self):
-        """
-        Returns a generator of `+=`, `=`, etc. or None if there is no operation.
-        """
+        """Returns a generator of `+=`, `=`, etc. or None if there is no operation."""
         first = self.children[1]
         if first.type == 'annassign':
             if len(first.children) <= 2:
@@ -1106,10 +1426,16 @@
 
 
 class Param(PythonBaseNode):
-    """
-    It's a helper class that makes business logic with params much easier. The
+    """It's a helper class that makes business logic with params much easier. The
     Python grammar defines no ``param`` node. It defines it in a different way
     that is not really suited to working with parameters.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     type = 'param'
 
@@ -1121,9 +1447,15 @@
 
     @property
     def star_count(self):
-        """
-        Is `0` in case of `foo`, `1` in case of `*foo` or `2` in case of
+        """Is `0` in case of `foo`, `1` in case of `*foo` or `2` in case of
         `**foo`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         first = self.children[0]
         if first in ('*', '**'):
@@ -1132,9 +1464,15 @@
 
     @property
     def default(self):
-        """
-        The default is the test node that appears after the `=`. Is `None` in
+        """The default is the test node that appears after the `=`. Is `None` in
         case no default is present.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         has_comma = self.children[-1] == ','
         try:
@@ -1145,9 +1483,15 @@
 
     @property
     def annotation(self):
-        """
-        The default is the test node that appears after `:`. Is `None` in case
+        """The default is the test node that appears after `:`. Is `None` in case
         no annotation is present.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         tfpdef = self._tfpdef()
         if tfpdef.type == 'tfpdef':
@@ -1159,30 +1503,35 @@
             return None
 
     def _tfpdef(self):
-        """
-        tfpdef: see e.g. grammar36.txt.
-        """
+        """tfpdef: see e.g. grammar36.txt."""
         offset = int(self.children[0] in ('*', '**'))
         return self.children[offset]
 
     @property
     def name(self):
-        """
-        The `Name` leaf of the param.
-        """
+        """The `Name` leaf of the param."""
         if self._tfpdef().type == 'tfpdef':
             return self._tfpdef().children[0]
         else:
             return self._tfpdef()
 
     def get_defined_names(self, include_setitem=False):
+        """
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return [self.name]
 
     @property
     def position_index(self):
-        """
-        Property for the positional index of a paramter.
-        """
+        """Property for the positional index of a paramter."""
         index = self.parent.children.index(self)
         try:
             keyword_only_index = self.parent.children.index('*')
@@ -1201,17 +1550,23 @@
         return index - 1
 
     def get_parent_function(self):
-        """
-        Returns the function/lambda of a parameter.
-        """
+        """Returns the function/lambda of a parameter."""
         return search_ancestor(self, 'funcdef', 'lambdef')
 
     def get_code(self, include_prefix=True, include_comma=True):
-        """
-        Like all the other get_code functions, but includes the param
+        """Like all the other get_code functions, but includes the param
         `include_comma`.
 
-        :param include_comma bool: If enabled includes the comma in the string output.
+        Parameters
+        ----------
+        include_comma :
+            bool: If enabled includes the comma in the string output. (Default value = True)
+        include_prefix :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         if include_comma:
             return super(Param, self).get_code(include_prefix)
@@ -1230,12 +1585,21 @@
 
 
 class SyncCompFor(PythonBaseNode):
+    """ """
     type = 'sync_comp_for'
     __slots__ = ()
 
     def get_defined_names(self, include_setitem=False):
-        """
-        Returns the a list of `Name` that the comprehension defines.
+        """Returns the a list of `Name` that the comprehension defines.
+
+        Parameters
+        ----------
+        include_setitem :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         # allow async for
         return _defined_names(self.children[1], include_setitem)
@@ -1247,9 +1611,7 @@
 
 
 class UsedNamesMapping(Mapping):
-    """
-    This class exists for the sole purpose of creating an immutable dict.
-    """
+    """This class exists for the sole purpose of creating an immutable dict."""
     def __init__(self, dct):
         self._dict = dct
 
