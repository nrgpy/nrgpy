# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/simple_httpclient_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/simple_httpclient_test.py
@@ -43,19 +43,36 @@
 
 
 class SimpleHTTPClientCommonTestCase(httpclient_test.HTTPClientCommonTestCase):
+    """ """
     def get_http_client(self):
+        """ """
         client = SimpleAsyncHTTPClient(force_instance=True)
         self.assertTrue(isinstance(client, SimpleAsyncHTTPClient))
         return client
 
 
 class TriggerHandler(RequestHandler):
+    """ """
     def initialize(self, queue, wake_callback):
+        """
+
+        Parameters
+        ----------
+        queue :
+            
+        wake_callback :
+            
+
+        Returns
+        -------
+
+        """
         self.queue = queue
         self.wake_callback = wake_callback
 
     @gen.coroutine
     def get(self):
+        """ """
         logging.debug("queuing trigger")
         event = Event()
         self.queue.append(event.set)
@@ -65,12 +82,15 @@
 
 
 class ContentLengthHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.stream = self.detach()
         IOLoop.current().spawn_callback(self.write_response)
 
     @gen.coroutine
     def write_response(self):
+        """ """
         yield self.stream.write(
             utf8(
                 "HTTP/1.0 200 OK\r\nContent-Length: %s\r\n\r\nok"
@@ -81,24 +101,32 @@
 
 
 class HeadHandler(RequestHandler):
+    """ """
     def head(self):
+        """ """
         self.set_header("Content-Length", "7")
 
 
 class OptionsHandler(RequestHandler):
+    """ """
     def options(self):
+        """ """
         self.set_header("Access-Control-Allow-Origin", "*")
         self.write("ok")
 
 
 class NoContentHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.set_status(204)
         self.finish()
 
 
 class SeeOtherPostHandler(RequestHandler):
+    """ """
     def post(self):
+        """ """
         redirect_code = int(self.request.body)
         assert redirect_code in (302, 303), "unexpected body %r" % self.request.body
         self.set_header("Location", "/see_other_get")
@@ -106,19 +134,25 @@
 
 
 class SeeOtherGetHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         if self.request.body:
             raise Exception("unexpected body %r" % self.request.body)
         self.write("ok")
 
 
 class HostEchoHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.write(self.request.headers["Host"])
 
 
 class NoContentLengthHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         if self.request.version.startswith("HTTP/1"):
             # Emulate the old HTTP/1.0 behavior of returning a body with no
             # content-length.  Tornado handles content-length at the framework
@@ -131,22 +165,49 @@
 
 
 class EchoPostHandler(RequestHandler):
+    """ """
     def post(self):
+        """ """
         self.write(self.request.body)
 
 
 @stream_request_body
 class RespondInPrepareHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         self.set_status(403)
         self.finish("forbidden")
 
 
 class SimpleHTTPClientTestMixin(object):
+    """ """
     def create_client(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def get_app(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # callable objects to finish pending /trigger requests
         self.triggers = (
             collections.deque()
@@ -178,6 +239,17 @@
         )
 
     def test_singleton(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Class "constructor" reuses objects on the same IOLoop
         self.assertTrue(SimpleAsyncHTTPClient() is SimpleAsyncHTTPClient())
         # unless force_instance is used
@@ -196,6 +268,17 @@
             self.assertTrue(client1 is not client2)
 
     def test_connection_limit(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         with closing(self.create_client(max_clients=2)) as client:
             self.assertEqual(client.max_clients, 2)
             seen = []
@@ -204,6 +287,19 @@
             for i in range(4):
 
                 def cb(fut, i=i):
+                    """
+
+                    Parameters
+                    ----------
+                    fut :
+                        
+                    i :
+                         (Default value = i)
+
+                    Returns
+                    -------
+
+                    """
                     seen.append(i)
                     self.stop()
 
@@ -227,12 +323,34 @@
 
     @gen_test
     def test_redirect_connection_limit(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # following redirects should not consume additional connections
         with closing(self.create_client(max_clients=1)) as client:
             response = yield client.fetch(self.get_url("/countdown/3"), max_redirects=3)
             response.rethrow()
 
     def test_max_redirects(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/countdown/5", max_redirects=3)
         self.assertEqual(302, response.code)
         # We requested 5, followed three redirects for 4, 3, 2, then the last
@@ -242,6 +360,17 @@
         self.assertTrue(response.headers["Location"].endswith("/countdown/1"))
 
     def test_header_reuse(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Apps may reuse a headers object if they are only passing in constant
         # headers like user-agent.  The header object should not be modified.
         headers = HTTPHeaders({"User-Agent": "Foo"})
@@ -249,11 +378,33 @@
         self.assertEqual(list(headers.get_all()), [("User-Agent", "Foo")])
 
     def test_default_user_agent(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/user_agent", method="GET")
         self.assertEqual(200, response.code)
         self.assertEqual(response.body.decode(), "Tornado/{}".format(version))
 
     def test_see_other_redirect(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         for code in (302, 303):
             response = self.fetch("/see_other_post", method="POST", body="%d" % code)
             self.assertEqual(200, response.code)
@@ -265,12 +416,24 @@
     @skipOnTravis
     @gen_test
     def test_connect_timeout(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         timeout = 0.1
 
         cleanup_event = Event()
         test = self
 
         class TimeoutResolver(Resolver):
+            """ """
             async def resolve(self, *args, **kwargs):
                 await cleanup_event.wait()
                 # Return something valid so the test doesn't raise during shutdown.
@@ -293,6 +456,17 @@
 
     @skipOnTravis
     def test_request_timeout(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         timeout = 0.1
         if os.name == "nt":
             timeout = 0.5
@@ -305,6 +479,17 @@
 
     @skipIfNoIPv6
     def test_ipv6(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         [sock] = bind_sockets(0, "::1", family=socket.AF_INET6)
         port = sock.getsockname()[1]
         self.http_server.add_socket(sock)
@@ -318,6 +503,17 @@
         self.assertEqual(response.body, b"Hello world!")
 
     def test_multiple_content_length_accepted(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/content_length?value=2,2")
         self.assertEqual(response.body, b"ok")
         response = self.fetch("/content_length?value=2,%202,2")
@@ -332,12 +528,34 @@
                 self.fetch("/content_length?value=2,%202,3", raise_error=True)
 
     def test_head_request(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/head", method="HEAD")
         self.assertEqual(response.code, 200)
         self.assertEqual(response.headers["content-length"], "7")
         self.assertFalse(response.body)
 
     def test_options_request(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/options", method="OPTIONS")
         self.assertEqual(response.code, 200)
         self.assertEqual(response.headers["content-length"], "2")
@@ -345,6 +563,17 @@
         self.assertEqual(response.body, b"ok")
 
     def test_no_content(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/no_content")
         self.assertEqual(response.code, 204)
         # 204 status shouldn't have a content-length
@@ -354,6 +583,17 @@
         self.assertNotIn("Content-Length", response.headers)
 
     def test_host_header(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         host_re = re.compile(b"^127.0.0.1:[0-9]+$")
         response = self.fetch("/host_echo")
         self.assertTrue(host_re.match(response.body))
@@ -363,6 +603,17 @@
         self.assertTrue(host_re.match(response.body), response.body)
 
     def test_connection_refused(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         cleanup_func, port = refusing_port()
         self.addCleanup(cleanup_func)
         with ExpectLog(gen_log, ".*", required=False):
@@ -383,6 +634,17 @@
             self.assertTrue(expected_message in str(cm.exception), cm.exception)
 
     def test_queue_timeout(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         with closing(self.create_client(max_clients=1)) as client:
             # Wait for the trigger request to block, not complete.
             fut1 = client.fetch(self.get_url("/trigger"), request_timeout=10)
@@ -399,6 +661,17 @@
             self.io_loop.run_sync(lambda: fut1)
 
     def test_no_content_length(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/no_content_length")
         if response.body == b"HTTP/1 required":
             self.skipTest("requires HTTP/1.x")
@@ -406,16 +679,49 @@
             self.assertEqual(b"hello", response.body)
 
     def sync_body_producer(self, write):
+        """
+
+        Parameters
+        ----------
+        write :
+            
+
+        Returns
+        -------
+
+        """
         write(b"1234")
         write(b"5678")
 
     @gen.coroutine
     def async_body_producer(self, write):
+        """
+
+        Parameters
+        ----------
+        write :
+            
+
+        Returns
+        -------
+
+        """
         yield write(b"1234")
         yield gen.moment
         yield write(b"5678")
 
     def test_sync_body_producer_chunked(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/echo_post", method="POST", body_producer=self.sync_body_producer
         )
@@ -423,6 +729,17 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_sync_body_producer_content_length(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/echo_post",
             method="POST",
@@ -433,6 +750,17 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_async_body_producer_chunked(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/echo_post", method="POST", body_producer=self.async_body_producer
         )
@@ -440,6 +768,17 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_async_body_producer_content_length(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/echo_post",
             method="POST",
@@ -450,6 +789,17 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_native_body_producer_chunked(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         async def body_producer(write):
             await write(b"1234")
             import asyncio
@@ -462,6 +812,17 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_native_body_producer_content_length(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         async def body_producer(write):
             await write(b"1234")
             import asyncio
@@ -479,13 +840,46 @@
         self.assertEqual(response.body, b"12345678")
 
     def test_100_continue(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/echo_post", method="POST", body=b"1234", expect_100_continue=True
         )
         self.assertEqual(response.body, b"1234")
 
     def test_100_continue_early_response(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         def body_producer(write):
+            """
+
+            Parameters
+            ----------
+            write :
+                
+
+            Returns
+            -------
+
+            """
             raise Exception("should not be called")
 
         response = self.fetch(
@@ -497,6 +891,17 @@
         self.assertEqual(response.code, 403)
 
     def test_streaming_follow_redirects(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # When following redirects, header and streaming callbacks
         # should only be called for the final result.
         # TODO(bdarnell): this test belongs in httpclient_test instead of
@@ -518,33 +923,62 @@
 
 
 class SimpleHTTPClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.http_client = self.create_client()
 
     def create_client(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return SimpleAsyncHTTPClient(force_instance=True, **kwargs)
 
 
 class SimpleHTTPSClientTestCase(SimpleHTTPClientTestMixin, AsyncHTTPSTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.http_client = self.create_client()
 
     def create_client(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return SimpleAsyncHTTPClient(
             force_instance=True, defaults=dict(validate_cert=False), **kwargs
         )
 
     def test_ssl_options(self):
+        """ """
         resp = self.fetch("/hello", ssl_options={})
         self.assertEqual(resp.body, b"Hello world!")
 
     def test_ssl_context(self):
+        """ """
         resp = self.fetch("/hello", ssl_options=ssl.SSLContext(ssl.PROTOCOL_SSLv23))
         self.assertEqual(resp.body, b"Hello world!")
 
     def test_ssl_options_handshake_fail(self):
+        """ """
         with ExpectLog(gen_log, "SSL Error|Uncaught exception", required=False):
             with self.assertRaises(ssl.SSLError):
                 self.fetch(
@@ -554,6 +988,7 @@
                 )
 
     def test_ssl_context_handshake_fail(self):
+        """ """
         with ExpectLog(gen_log, "SSL Error|Uncaught exception"):
             ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
             ctx.verify_mode = ssl.CERT_REQUIRED
@@ -561,6 +996,7 @@
                 self.fetch("/hello", ssl_options=ctx, raise_error=True)
 
     def test_error_logging(self):
+        """ """
         # No stack traces are logged for SSL errors (in this case,
         # failure to validate the testing self-signed cert).
         # The SSLError is exposed through ssl.SSLError.
@@ -571,15 +1007,19 @@
 
 
 class CreateAsyncHTTPClientTestCase(AsyncTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.saved = AsyncHTTPClient._save_configuration()
 
     def tearDown(self):
+        """ """
         AsyncHTTPClient._restore_configuration(self.saved)
         super().tearDown()
 
     def test_max_clients(self):
+        """ """
         AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
         with closing(AsyncHTTPClient(force_instance=True)) as client:
             self.assertEqual(client.max_clients, 10)  # type: ignore
@@ -598,7 +1038,19 @@
 
 
 class HTTP100ContinueTestCase(AsyncHTTPTestCase):
+    """ """
     def respond_100(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         self.http1 = request.version.startswith("HTTP/1.")
         if not self.http1:
             request.connection.write_headers(
@@ -611,6 +1063,17 @@
         fut.add_done_callback(self.respond_200)
 
     def respond_200(self, fut):
+        """
+
+        Parameters
+        ----------
+        fut :
+            
+
+        Returns
+        -------
+
+        """
         fut.result()
         fut = self.request.connection.stream.write(
             b"HTTP/1.1 200 OK\r\nContent-Length: 1\r\n\r\nA"
@@ -618,10 +1081,12 @@
         fut.add_done_callback(lambda f: self.request.connection.stream.close())
 
     def get_app(self):
+        """ """
         # Not a full Application, but works as an HTTPServer callback
         return self.respond_100
 
     def test_100_continue(self):
+        """ """
         res = self.fetch("/")
         if not self.http1:
             self.skipTest("requires HTTP/1.x")
@@ -629,7 +1094,19 @@
 
 
 class HTTP204NoContentTestCase(AsyncHTTPTestCase):
+    """ """
     def respond_204(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         self.http1 = request.version.startswith("HTTP/1.")
         if not self.http1:
             # Close the request cleanly in HTTP/2; it will be skipped anyway.
@@ -655,9 +1132,11 @@
         stream.close()
 
     def get_app(self):
+        """ """
         return self.respond_204
 
     def test_204_no_content(self):
+        """ """
         resp = self.fetch("/")
         if not self.http1:
             self.skipTest("requires HTTP/1.x")
@@ -665,6 +1144,7 @@
         self.assertEqual(resp.body, b"")
 
     def test_204_invalid_content_length(self):
+        """ """
         # 204 status with non-zero content length is malformed
         with ExpectLog(
             gen_log, ".*Response with code 204 should not have body", level=logging.INFO
@@ -678,7 +1158,9 @@
 
 
 class HostnameMappingTestCase(AsyncHTTPTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.http_client = SimpleAsyncHTTPClient(
             hostname_mapping={
@@ -688,28 +1170,47 @@
         )
 
     def get_app(self):
+        """ """
         return Application([url("/hello", HelloWorldHandler)])
 
     def test_hostname_mapping(self):
+        """ """
         response = self.fetch("http://www.example.com:%d/hello" % self.get_http_port())
         response.rethrow()
         self.assertEqual(response.body, b"Hello world!")
 
     def test_port_mapping(self):
+        """ """
         response = self.fetch("http://foo.example.com:8000/hello")
         response.rethrow()
         self.assertEqual(response.body, b"Hello world!")
 
 
 class ResolveTimeoutTestCase(AsyncHTTPTestCase):
+    """ """
     def setUp(self):
+        """ """
         self.cleanup_event = Event()
         test = self
 
         # Dummy Resolver subclass that never finishes.
         class BadResolver(Resolver):
+            """ """
             @gen.coroutine
             def resolve(self, *args, **kwargs):
+                """
+
+                Parameters
+                ----------
+                *args :
+                    
+                **kwargs :
+                    
+
+                Returns
+                -------
+
+                """
                 yield test.cleanup_event.wait()
                 # Return something valid so the test doesn't raise during cleanup.
                 return [(socket.AF_INET, ("127.0.0.1", test.get_http_port()))]
@@ -718,9 +1219,11 @@
         self.http_client = SimpleAsyncHTTPClient(resolver=BadResolver())
 
     def get_app(self):
+        """ """
         return Application([url("/hello", HelloWorldHandler)])
 
     def test_resolve_timeout(self):
+        """ """
         with self.assertRaises(HTTPTimeoutError):
             self.fetch("/hello", connect_timeout=0.1, raise_error=True)
 
@@ -730,54 +1233,72 @@
 
 
 class MaxHeaderSizeTest(AsyncHTTPTestCase):
+    """ """
     def get_app(self):
+        """ """
         class SmallHeaders(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_header("X-Filler", "a" * 100)
                 self.write("ok")
 
         class LargeHeaders(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_header("X-Filler", "a" * 1000)
                 self.write("ok")
 
         return Application([("/small", SmallHeaders), ("/large", LargeHeaders)])
 
     def get_http_client(self):
+        """ """
         return SimpleAsyncHTTPClient(max_header_size=1024)
 
     def test_small_headers(self):
+        """ """
         response = self.fetch("/small")
         response.rethrow()
         self.assertEqual(response.body, b"ok")
 
     def test_large_headers(self):
+        """ """
         with ExpectLog(gen_log, "Unsatisfiable read", level=logging.INFO):
             with self.assertRaises(UnsatisfiableReadError):
                 self.fetch("/large", raise_error=True)
 
 
 class MaxBodySizeTest(AsyncHTTPTestCase):
+    """ """
     def get_app(self):
+        """ """
         class SmallBody(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.write("a" * 1024 * 64)
 
         class LargeBody(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.write("a" * 1024 * 100)
 
         return Application([("/small", SmallBody), ("/large", LargeBody)])
 
     def get_http_client(self):
+        """ """
         return SimpleAsyncHTTPClient(max_body_size=1024 * 64)
 
     def test_small_body(self):
+        """ """
         response = self.fetch("/small")
         response.rethrow()
         self.assertEqual(response.body, b"a" * 1024 * 64)
 
     def test_large_body(self):
+        """ """
         with ExpectLog(
             gen_log,
             "Malformed HTTP message from None: Content-Length too long",
@@ -788,29 +1309,39 @@
 
 
 class MaxBufferSizeTest(AsyncHTTPTestCase):
+    """ """
     def get_app(self):
+        """ """
         class LargeBody(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.write("a" * 1024 * 100)
 
         return Application([("/large", LargeBody)])
 
     def get_http_client(self):
+        """ """
         # 100KB body with 64KB buffer
         return SimpleAsyncHTTPClient(
             max_body_size=1024 * 100, max_buffer_size=1024 * 64
         )
 
     def test_large_body(self):
+        """ """
         response = self.fetch("/large")
         response.rethrow()
         self.assertEqual(response.body, b"a" * 1024 * 100)
 
 
 class ChunkedWithContentLengthTest(AsyncHTTPTestCase):
+    """ """
     def get_app(self):
+        """ """
         class ChunkedWithContentLength(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 # Add an invalid Transfer-Encoding to the response
                 self.set_header("Transfer-Encoding", "chunked")
                 self.write("Hello world")
@@ -818,9 +1349,11 @@
         return Application([("/chunkwithcl", ChunkedWithContentLength)])
 
     def get_http_client(self):
+        """ """
         return SimpleAsyncHTTPClient()
 
     def test_chunked_with_content_length(self):
+        """ """
         # Make sure the invalid headers are detected
         with ExpectLog(
             gen_log,
