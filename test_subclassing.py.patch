# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/ma/tests/test_subclassing.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/ma/tests/test_subclassing.py
@@ -16,10 +16,24 @@
 # from numpy.ma.core import (
 
 def assert_startswith(a, b):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     # produces a better error message than assert_(a.startswith(b))
     assert_equal(a[:len(b)], b)
 
 class SubArray(np.ndarray):
+    """ """
     # Defines a generic np.ndarray subclass, that stores some metadata
     # in the  dictionary `info`.
     def __new__(cls,arr,info={}):
@@ -57,6 +71,7 @@
 
 
 class MSubArray(SubArray, MaskedArray):
+    """ """
 
     def __new__(cls, data, info={}, mask=nomask):
         subarr = SubArray(data, info)
@@ -66,6 +81,7 @@
 
     @property
     def _series(self):
+        """ """
         _view = self.view(MaskedArray)
         _view._sharedmask = False
         return _view
@@ -79,11 +95,17 @@
 # doesn't get destroyed by MaskedArray._update_from.  But this one also needs
 # its own iterator...
 class CSAIterator:
-    """
-    Flat iterator object that uses its own setter/getter
+    """Flat iterator object that uses its own setter/getter
     (works around ndarray.flat not propagating subclass setters/getters
     see https://github.com/numpy/numpy/issues/4564)
     roughly following MaskedIterator
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, a):
         self._original = a
@@ -107,6 +129,7 @@
 
 
 class ComplicatedSubArray(SubArray):
+    """ """
 
     def __str__(self):
         return 'myprefix {0} mypostfix'.format(self.view(SubArray))
@@ -116,6 +139,17 @@
         return '<{0} {1}>'.format(self.__class__.__name__, self)
 
     def _validate_input(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(value, ComplicatedSubArray):
             raise ValueError("Can only set to MySubArray values")
         return value
@@ -135,10 +169,22 @@
 
     @property
     def flat(self):
+        """ """
         return CSAIterator(self)
 
     @flat.setter
     def flat(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         y = self.ravel()
         y[:] = value
 
@@ -151,14 +197,17 @@
 
 
 class TestSubclassing:
+    """ """
     # Test suite for masked subclasses of ndarray.
 
     def setup(self):
+        """ """
         x = np.arange(5, dtype='float')
         mx = msubarray(x, mask=[0, 1, 0, 0, 0])
         self.data = (x, mx)
 
     def test_data_subclassing(self):
+        """ """
         # Tests whether the subclass is kept.
         x = np.arange(5)
         m = [0, 0, 1, 0, 0]
@@ -169,11 +218,13 @@
         assert_(isinstance(xmsub._data, SubArray))
 
     def test_maskedarray_subclassing(self):
+        """ """
         # Tests subclassing MaskedArray
         (x, mx) = self.data
         assert_(isinstance(mx._data, subarray))
 
     def test_masked_unary_operations(self):
+        """ """
         # Tests masked_unary_operation
         (x, mx) = self.data
         with np.errstate(divide='ignore'):
@@ -181,6 +232,7 @@
             assert_equal(log(x), np.log(x))
 
     def test_masked_binary_operations(self):
+        """ """
         # Tests masked_binary_operation
         (x, mx) = self.data
         # Result should be a msubarray
@@ -194,6 +246,7 @@
         assert_(isinstance(hypot(mx, x), msubarray))
 
     def test_masked_binary_operations2(self):
+        """ """
         # Tests domained_masked_binary_operation
         (x, mx) = self.data
         xmx = masked_array(mx.data.__array__(), mask=mx.mask)
@@ -202,6 +255,7 @@
         assert_equal(divide(mx, mx), divide(xmx, xmx))
 
     def test_attributepropagation(self):
+        """ """
         x = array(arange(5), mask=[0]+[1]*4)
         my = masked_array(subarray(x))
         ym = msubarray(x)
@@ -235,6 +289,7 @@
         assert_equal(mxsub.info, xsub.info)
 
     def test_subclasspreservation(self):
+        """ """
         # Checks that masked_array(...,subok=True) preserves the class.
         x = np.arange(5)
         m = [0, 0, 1, 0, 0]
@@ -299,6 +354,7 @@
         mxcsub.flat[1:4] = xcsub[1:4]
 
     def test_subclass_nomask_items(self):
+        """ """
         x = np.arange(5)
         xcsub = ComplicatedSubArray(x)
         mxcsub_nomask = masked_array(xcsub)
@@ -311,7 +367,15 @@
 
     def test_subclass_repr(self):
         """test that repr uses the name of the subclass
-        and 'array' for np.ndarray"""
+        and 'array' for np.ndarray
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         x = np.arange(5)
         mx = masked_array(x, mask=[True, False, True, False, False])
         assert_startswith(repr(mx), 'masked_array')
@@ -335,6 +399,7 @@
         assert_equal(str(mxcsub), 'myprefix [-- 1 -- 3 4] mypostfix')
 
     def test_pure_subclass_info_preservation(self):
+        """ """
         # Test that ufuncs and methods conserve extra information consistently;
         # see gh-7122.
         arr1 = SubMaskedArray('test', data=[1,2,3,4,5,6])
