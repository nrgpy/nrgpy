# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/multi.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/multi.py
@@ -72,16 +72,21 @@
 
 
 class MultiIndexUIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.UInt64Engine):
+    """This class manages a MultiIndex by mapping label combinations to positive
+    integers.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
-    This class manages a MultiIndex by mapping label combinations to positive
-    integers.
-    """
 
     _base = libindex.UInt64Engine
 
     def _codes_to_ints(self, codes):
-        """
-        Transform combination(s) of uint64 in one uint64 (each), in a strictly
+        """Transform combination(s) of uint64 in one uint64 (each), in a strictly
         monotonic way (i.e. respecting the lexicographic order of integer
         combinations): see BaseMultiIndexCodesEngine documentation.
 
@@ -92,8 +97,8 @@
 
         Returns
         -------
-        scalar or 1-dimensional array, of dtype uint64
-            Integer(s) representing one combination (each).
+
+        
         """
         # Shift the representation of each level by the pre-calculated number
         # of bits:
@@ -111,17 +116,22 @@
 
 
 class MultiIndexPyIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.ObjectEngine):
-    """
-    This class manages those (extreme) cases in which the number of possible
+    """This class manages those (extreme) cases in which the number of possible
     label combinations overflows the 64 bits integers, and uses an ObjectEngine
     containing Python integers.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     _base = libindex.ObjectEngine
 
     def _codes_to_ints(self, codes):
-        """
-        Transform combination(s) of uint64 in one Python integer (each), in a
+        """Transform combination(s) of uint64 in one Python integer (each), in a
         strictly monotonic way (i.e. respecting the lexicographic order of
         integer combinations): see BaseMultiIndexCodesEngine documentation.
 
@@ -132,8 +142,8 @@
 
         Returns
         -------
-        int, or 1-dimensional array of dtype object
-            Integer(s) representing one combination (each).
+
+        
         """
         # Shift the representation of each level by the pre-calculated number
         # of bits. Since this can overflow uint64, first make sure we are
@@ -152,8 +162,7 @@
 
 
 class MultiIndex(Index):
-    """
-    A multi-level, or hierarchical, index object for pandas objects.
+    """A multi-level, or hierarchical, index object for pandas objects.
 
     Parameters
     ----------
@@ -161,7 +170,6 @@
         The unique labels for each level.
     codes : sequence of arrays
         Integers for each level designating which label at each location.
-
         .. versionadded:: 0.24.0
     sortorder : optional int
         Level of sortedness (must be lexicographically sorted by that
@@ -173,6 +181,9 @@
     verify_integrity : bool, default True
         Check that the levels/codes are consistent and valid.
 
+    Returns
+    -------
+
     Attributes
     ----------
     names
@@ -180,7 +191,6 @@
     codes
     nlevels
     levshape
-
     Methods
     -------
     from_arrays
@@ -198,7 +208,6 @@
     reorder_levels
     remove_unused_levels
     get_locs
-
     See Also
     --------
     MultiIndex.from_arrays  : Convert list of arrays to MultiIndex.
@@ -207,19 +216,20 @@
     MultiIndex.from_tuples  : Convert list of tuples to a MultiIndex.
     MultiIndex.from_frame   : Make a MultiIndex from a DataFrame.
     Index : The base pandas Index type.
-
     Notes
     -----
     See the `user guide
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html>`_
     for more.
-
     Examples
     --------
     A new ``MultiIndex`` is typically constructed using one of the helper
     methods :meth:`MultiIndex.from_arrays`, :meth:`MultiIndex.from_product`
     and :meth:`MultiIndex.from_tuples`. For example (using ``.from_arrays``):
-
+    
+    
+    See further examples for how to construct a MultiIndex in the doc strings
+    of the mentioned helper methods.
     >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]
     >>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))
     MultiIndex([(1,  'red'),
@@ -227,9 +237,6 @@
                 (2,  'red'),
                 (2, 'blue')],
                names=['number', 'color'])
-
-    See further examples for how to construct a MultiIndex in the doc strings
-    of the mentioned helper methods.
     """
 
     _deprecations = Index._deprecations | frozenset()
@@ -298,8 +305,7 @@
         return result
 
     def _validate_codes(self, level: List, code: List):
-        """
-        Reassign code values as -1 if their corresponding levels are NaN.
+        """Reassign code values as -1 if their corresponding levels are NaN.
 
         Parameters
         ----------
@@ -307,11 +313,15 @@
             Code to reassign.
         level : list
             Level to check for missing values (NaN, NaT, None).
-
-        Returns
-        -------
-        new code where code value = -1 if it corresponds
-        to a level with missing values (NaN, NaT, None).
+        level: List :
+            
+        code: List :
+            
+
+        Returns
+        -------
+
+        
         """
         null_mask = isna(level)
         if np.any(null_mask):
@@ -322,12 +332,20 @@
         self, codes: Optional[List] = None, levels: Optional[List] = None
     ):
         """
+
         Parameters
         ----------
         codes : optional list
             Codes to check for validity. Defaults to current codes.
         levels : optional list
             Levels to check for validity. Defaults to current levels.
+        codes: Optional[List] :
+             (Default value = None)
+        levels: Optional[List] :
+             (Default value = None)
+
+        Returns
+        -------
 
         Raises
         ------
@@ -335,10 +353,7 @@
             If length of levels and codes don't match, if the codes for any
             level would exceed level bounds, or there are any duplicate levels.
 
-        Returns
-        -------
-        new codes where code value = -1 if it corresponds to a
-        NaN level.
+        
         """
         # NOTE: Currently does not check, among other things, that cached
         # nlevels matches nor that sortorder matches actually sortorder.
@@ -384,8 +399,7 @@
 
     @classmethod
     def from_arrays(cls, arrays, sortorder=None, names=lib.no_default) -> "MultiIndex":
-        """
-        Convert arrays to MultiIndex.
+        """Convert arrays to MultiIndex.
 
         Parameters
         ----------
@@ -394,13 +408,14 @@
             len(arrays) is the number of levels.
         sortorder : int or None
             Level of sortedness (must be lexicographically sorted by that
-            level).
+            level). (Default value = None)
         names : list / sequence of str, optional
-            Names for the levels in the index.
+            Names for the levels in the index. (Default value = lib.no_default)
 
         Returns
         -------
         MultiIndex
+            
 
         See Also
         --------
@@ -408,7 +423,6 @@
         MultiIndex.from_product : Make a MultiIndex from cartesian product
                                   of iterables.
         MultiIndex.from_frame : Make a MultiIndex from a DataFrame.
-
         Examples
         --------
         >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]
@@ -450,8 +464,7 @@
 
     @classmethod
     def from_tuples(cls, tuples, sortorder=None, names=None):
-        """
-        Convert list of tuples to MultiIndex.
+        """Convert list of tuples to MultiIndex.
 
         Parameters
         ----------
@@ -459,13 +472,14 @@
             Each tuple is the index of one row/column.
         sortorder : int or None
             Level of sortedness (must be lexicographically sorted by that
-            level).
+            level). (Default value = None)
         names : list / sequence of str, optional
-            Names for the levels in the index.
+            Names for the levels in the index. (Default value = None)
 
         Returns
         -------
         MultiIndex
+            
 
         See Also
         --------
@@ -473,7 +487,6 @@
         MultiIndex.from_product : Make a MultiIndex from cartesian product
                                   of iterables.
         MultiIndex.from_frame : Make a MultiIndex from a DataFrame.
-
         Examples
         --------
         >>> tuples = [(1, 'red'), (1, 'blue'),
@@ -508,8 +521,7 @@
 
     @classmethod
     def from_product(cls, iterables, sortorder=None, names=lib.no_default):
-        """
-        Make a MultiIndex from the cartesian product of multiple iterables.
+        """Make a MultiIndex from the cartesian product of multiple iterables.
 
         Parameters
         ----------
@@ -517,25 +529,23 @@
             Each iterable has unique labels for each level of the index.
         sortorder : int or None
             Level of sortedness (must be lexicographically sorted by that
-            level).
+            level). (Default value = None)
         names : list / sequence of str, optional
             Names for the levels in the index.
-
             .. versionchanged:: 1.0.0
-
-               If not explicitly provided, names will be inferred from the
-               elements of iterables if an element has a name attribute
+            If not explicitly provided, names will be inferred from the
+            elements of iterables if an element has a name attribute (Default value = lib.no_default)
 
         Returns
         -------
         MultiIndex
+            
 
         See Also
         --------
         MultiIndex.from_arrays : Convert list of arrays to MultiIndex.
         MultiIndex.from_tuples : Convert list of tuples to MultiIndex.
         MultiIndex.from_frame : Make a MultiIndex from a DataFrame.
-
         Examples
         --------
         >>> numbers = [0, 1, 2]
@@ -567,9 +577,8 @@
 
     @classmethod
     def from_frame(cls, df, sortorder=None, names=None):
-        """
-        Make a MultiIndex from a DataFrame.
-
+        """Make a MultiIndex from a DataFrame.
+        
         .. versionadded:: 0.24.0
 
         Parameters
@@ -578,11 +587,11 @@
             DataFrame to be converted to MultiIndex.
         sortorder : int, optional
             Level of sortedness (must be lexicographically sorted by that
-            level).
+            level). (Default value = None)
         names : list-like, optional
             If no names are provided, use the column names, or tuple of column
             names if the columns is a MultiIndex. If a sequence, overwrite
-            names with the given sequence.
+            names with the given sequence. (Default value = None)
 
         Returns
         -------
@@ -595,9 +604,11 @@
         MultiIndex.from_tuples : Convert list of tuples to MultiIndex.
         MultiIndex.from_product : Make a MultiIndex from cartesian product
                                   of iterables.
-
         Examples
         --------
+        
+        
+        Using explicit names, instead of the column names
         >>> df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'],
         ...                    ['NJ', 'Temp'], ['NJ', 'Precip']],
         ...                   columns=['a', 'b'])
@@ -607,16 +618,14 @@
         1    HI  Precip
         2    NJ    Temp
         3    NJ  Precip
-
+        
         >>> pd.MultiIndex.from_frame(df)
         MultiIndex([('HI',   'Temp'),
                     ('HI', 'Precip'),
                     ('NJ',   'Temp'),
                     ('NJ', 'Precip')],
                    names=['a', 'b'])
-
-        Using explicit names, instead of the column names
-
+        
         >>> pd.MultiIndex.from_frame(df, names=['state', 'observation'])
         MultiIndex([('HI',   'Temp'),
                     ('HI', 'Precip'),
@@ -635,11 +644,13 @@
 
     @property
     def _values(self):
+        """ """
         # We override here, since our parent uses _data, which we don't use.
         return self.values
 
     @property
     def values(self):
+        """ """
         if self._tuples is not None:
             return self._tuples
 
@@ -661,13 +672,16 @@
 
     @property
     def array(self):
-        """
-        Raises a ValueError for `MultiIndex` because there's no single
+        """Raises a ValueError for `MultiIndex` because there's no single
         array backing a MultiIndex.
 
-        Raises
-        ------
-        ValueError
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        
         """
         raise ValueError(
             "MultiIndex has no single backing array. Use "
@@ -676,9 +690,7 @@
 
     @property
     def shape(self):
-        """
-        Return a tuple of the shape of the underlying data.
-        """
+        """ """
         # overriding the base Index.shape definition to avoid materializing
         # the values (GH-27384, GH-27775)
         return (len(self),)
@@ -691,6 +703,7 @@
 
     @cache_readonly
     def levels(self):
+        """ """
         # Use cache_readonly to ensure that self.get_locs doesn't repeatedly
         # create new IndexEngine
         # https://github.com/pandas-dev/pandas/issues/31648
@@ -705,6 +718,25 @@
     def _set_levels(
         self, levels, level=None, copy=False, validate=True, verify_integrity=False
     ):
+        """
+
+        Parameters
+        ----------
+        levels :
+            
+        level :
+             (Default value = None)
+        copy :
+             (Default value = False)
+        validate :
+             (Default value = True)
+        verify_integrity :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         # This is NOT part of the levels property because it should be
         # externally not allowed to set levels. User beware if you change
         # _levels directly
@@ -740,26 +772,32 @@
         self._reset_cache()
 
     def set_levels(self, levels, level=None, inplace=False, verify_integrity=True):
-        """
-        Set new levels on MultiIndex. Defaults to returning new index.
+        """Set new levels on MultiIndex. Defaults to returning new index.
 
         Parameters
         ----------
         levels : sequence or list of sequence
             New level(s) to apply.
         level : int, level name, or sequence of int/level names (default None)
-            Level(s) to set (None for all levels).
+            Level(s) to set (None for all levels). (Default value = None)
         inplace : bool
-            If True, mutates in place.
+            If True, mutates in place. (Default value = False)
         verify_integrity : bool, default True
-            If True, checks that levels and codes are compatible.
+            If True, checks that levels and codes are compatible. (Default value = True)
 
         Returns
         -------
         new index (of same type and class...etc)
+            
 
         Examples
         --------
+        
+        
+        If any of the levels passed to ``set_levels()`` exceeds the
+        existing length, all of the values from that argument will
+        be stored in the MultiIndex levels, though the values will
+        be truncated in the MultiIndex output.
         >>> idx = pd.MultiIndex.from_tuples(
         ...     [
         ...         (1, "one"),
@@ -779,7 +817,7 @@
             (3, 'one'),
             (3, 'two')],
            names=['foo', 'bar'])
-
+        
         >>> idx.set_levels([['a', 'b', 'c'], [1, 2]])
         MultiIndex([('a', 1),
                     ('a', 2),
@@ -804,12 +842,7 @@
                     (3, 'a'),
                     (3, 'b')],
                    names=['foo', 'bar'])
-
-        If any of the levels passed to ``set_levels()`` exceeds the
-        existing length, all of the values from that argument will
-        be stored in the MultiIndex levels, though the values will
-        be truncated in the MultiIndex output.
-
+        
         >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1])
         MultiIndex([('a', 1),
             ('a', 2),
@@ -848,16 +881,12 @@
 
     @property
     def nlevels(self) -> int:
-        """
-        Integer number of levels in this MultiIndex.
-        """
+        """Integer number of levels in this MultiIndex."""
         return len(self._levels)
 
     @property
     def levshape(self):
-        """
-        A tuple with the length of each level.
-        """
+        """A tuple with the length of each level."""
         return tuple(len(x) for x in self.levels)
 
     # --------------------------------------------------------------------
@@ -865,11 +894,31 @@
 
     @property
     def codes(self):
+        """ """
         return self._codes
 
     def _set_codes(
         self, codes, level=None, copy=False, validate=True, verify_integrity=False
     ):
+        """
+
+        Parameters
+        ----------
+        codes :
+            
+        level :
+             (Default value = None)
+        copy :
+             (Default value = False)
+        validate :
+             (Default value = True)
+        verify_integrity :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if validate:
             if level is None and len(codes) != self.nlevels:
                 raise ValueError("Length of codes must match number of levels")
@@ -898,11 +947,10 @@
         self._reset_cache()
 
     def set_codes(self, codes, level=None, inplace=False, verify_integrity=True):
-        """
-        Set new codes on MultiIndex. Defaults to returning new index.
-
+        """Set new codes on MultiIndex. Defaults to returning new index.
+        
         .. versionadded:: 0.24.0
-
+        
            New name for deprecated method `set_labels`.
 
         Parameters
@@ -910,15 +958,16 @@
         codes : sequence or list of sequence
             New codes to apply.
         level : int, level name, or sequence of int/level names (default None)
-            Level(s) to set (None for all levels).
+            Level(s) to set (None for all levels). (Default value = None)
         inplace : bool
-            If True, mutates in place.
+            If True, mutates in place. (Default value = False)
         verify_integrity : bool (default True)
-            If True, checks that levels and codes are compatible.
+            If True, checks that levels and codes are compatible. (Default value = True)
 
         Returns
         -------
         new index (of same type and class...etc)
+            
 
         Examples
         --------
@@ -931,7 +980,7 @@
             (2, 'one'),
             (2, 'two')],
            names=['foo', 'bar'])
-
+        
         >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]])
         MultiIndex([(2, 'one'),
                     (1, 'one'),
@@ -982,6 +1031,7 @@
 
     @cache_readonly
     def _engine(self):
+        """ """
         # Calculate the number of bits needed to represent labels in each
         # level, as log2 of their sizes (including -1 for NaN):
         sizes = np.ceil(np.log2([len(l) + 1 for l in self.levels]))
@@ -1004,6 +1054,7 @@
 
     @property
     def _constructor(self):
+        """ """
         return MultiIndex.from_tuples
 
     @doc(Index._shallow_copy)
@@ -1018,6 +1069,31 @@
         names=lib.no_default,
         _set_identity: bool = True,
     ):
+        """
+
+        Parameters
+        ----------
+        values :
+             (Default value = None)
+        name :
+             (Default value = lib.no_default)
+        levels :
+             (Default value = None)
+        codes :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        sortorder :
+             (Default value = None)
+        names :
+             (Default value = lib.no_default)
+        _set_identity: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if names is not lib.no_default and name is not lib.no_default:
             raise TypeError("Can only provide one of `names` and `name`")
         elif names is lib.no_default:
@@ -1044,6 +1120,21 @@
         return result
 
     def symmetric_difference(self, other, result_name=None, sort=None):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        result_name :
+             (Default value = None)
+        sort :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # On equal symmetric_difference MultiIndexes the difference is empty.
         # Therefore, an empty MultiIndex is returned GH13490
         tups = Index.symmetric_difference(self, other, result_name, sort)
@@ -1067,23 +1158,30 @@
         name=None,
         _set_identity=False,
     ):
-        """
-        Make a copy of this object. Names, dtype, levels and codes can be
+        """Make a copy of this object. Names, dtype, levels and codes can be
         passed and will be set on new copy.
 
         Parameters
         ----------
         names : sequence, optional
+             (Default value = None)
         dtype : numpy dtype or pandas type, optional
+             (Default value = None)
         levels : sequence, optional
+             (Default value = None)
         codes : sequence, optional
+             (Default value = None)
         deep : bool, default False
+             (Default value = False)
         name : Label
-            Kept for compatibility with 1-dimensional Index. Should not be used.
+            Kept for compatibility with 1-dimensional Index. Should not be used. (Default value = None)
+        _set_identity :
+             (Default value = False)
 
         Returns
         -------
         MultiIndex
+            
 
         Notes
         -----
@@ -1114,7 +1212,17 @@
         return self.values
 
     def view(self, cls=None):
-        """ this is defined as a copy with the same identity """
+        """this is defined as a copy with the same identity
+
+        Parameters
+        ----------
+        cls :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = self.copy()
         result._id = self._id
         return result
@@ -1130,18 +1238,41 @@
 
     @cache_readonly
     def dtype(self) -> np.dtype:
+        """ """
         return np.dtype("O")
 
     def _is_memory_usage_qualified(self) -> bool:
-        """ return a boolean if we need a qualified .info display """
+        """ """
 
         def f(l):
+            """
+
+            Parameters
+            ----------
+            l :
+                
+
+            Returns
+            -------
+
+            """
             return "mixed" in l or "string" in l or "unicode" in l
 
         return any(f(l) for l in self._inferred_type_levels)
 
     @doc(Index.memory_usage)
     def memory_usage(self, deep: bool = False) -> int:
+        """
+
+        Parameters
+        ----------
+        deep: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         # we are overwriting our base class to avoid
         # computing .values here which could materialize
         # a tuple representation unnecessarily
@@ -1149,17 +1280,25 @@
 
     @cache_readonly
     def nbytes(self) -> int:
-        """ return the number of bytes in the underlying data """
+        """ """
         return self._nbytes(False)
 
     def _nbytes(self, deep: bool = False) -> int:
         """
-        return the number of bytes in the underlying data
-        deeply introspect the level data if deep=True
-
-        include the engine hashtable
-
-        *this is in internal routine*
+
+        Parameters
+        ----------
+        deep: bool :
+             (Default value = False)
+
+        Returns
+        -------
+        type
+            deeply introspect the level data if deep=True
+            
+            include the engine hashtable
+            
+            *this is in internal routine*
 
         """
         # for implementations with no useful getsizeof (PyPy)
@@ -1178,27 +1317,56 @@
     # Rendering Methods
 
     def _formatter_func(self, tup):
-        """
-        Formats each item in tup according to its level's formatter function.
+        """Formats each item in tup according to its level's formatter function.
+
+        Parameters
+        ----------
+        tup :
+            
+
+        Returns
+        -------
+
         """
         formatter_funcs = [level._formatter_func for level in self.levels]
         return tuple(func(val) for func, val in zip(formatter_funcs, tup))
 
     def _format_data(self, name=None):
         """
-        Return the formatted data as a unicode string
+
+        Parameters
+        ----------
+        name :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            
+
         """
         return format_object_summary(
             self, self._formatter_func, name=name, line_break_each_value=True
         )
 
     def _format_attrs(self):
-        """
-        Return a list of tuples of the (attr,formatted_value).
-        """
+        """ """
         return format_object_attrs(self, include_dtype=False)
 
     def _format_native_types(self, na_rep="nan", **kwargs):
+        """
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "nan")
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         new_levels = []
         new_codes = []
 
@@ -1240,6 +1408,29 @@
         sparsify=None,
         adjoin: bool = True,
     ) -> List:
+        """
+
+        Parameters
+        ----------
+        name: Optional[bool] :
+             (Default value = None)
+        formatter: Optional[Callable] :
+             (Default value = None)
+        na_rep: Optional[str] :
+             (Default value = None)
+        names: bool :
+             (Default value = False)
+        space: int :
+             (Default value = 2)
+        sparsify :
+             (Default value = None)
+        adjoin: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if name is not None:
             names = name
 
@@ -1309,11 +1500,11 @@
     # Names Methods
 
     def _get_names(self):
+        """ """
         return FrozenList(self._names)
 
     def _set_names(self, names, level=None, validate=True):
-        """
-        Set new names on index. Each name has to be a hashable type.
+        """Set new names on index. Each name has to be a hashable type.
 
         Parameters
         ----------
@@ -1321,18 +1512,24 @@
             name(s) to set
         level : int, level name, or sequence of int/level names (default None)
             If the index is a MultiIndex (hierarchical), level(s) to set (None
-            for all levels).  Otherwise level must be None
+            for all levels).  Otherwise level must be None (Default value = None)
         validate : boolean, default True
-            validate that the names match level lengths
+            validate that the names match level lengths (Default value = True)
+        names :
+            
+
+        Returns
+        -------
 
         Raises
         ------
         TypeError if each name is not hashable.
+            
 
         Notes
         -----
         sets names on levels. WARNING: mutates!
-
+        
         Note that you generally want to set this *after* changing levels, so
         that it only acts on copies
         """
@@ -1377,6 +1574,19 @@
 
     @doc(Index._get_grouper_for_level)
     def _get_grouper_for_level(self, mapper, level):
+        """
+
+        Parameters
+        ----------
+        mapper :
+            
+        level :
+            
+
+        Returns
+        -------
+
+        """
         indexer = self.codes[level]
         level_index = self.levels[level]
 
@@ -1414,9 +1624,21 @@
 
     @cache_readonly
     def inferred_type(self) -> str:
+        """ """
         return "mixed"
 
     def _get_level_number(self, level) -> int:
+        """
+
+        Parameters
+        ----------
+        level :
+            
+
+        Returns
+        -------
+
+        """
         count = self.names.count(level)
         if (count > 1) and not is_integer(level):
             raise ValueError(
@@ -1445,14 +1667,22 @@
 
     @property
     def _has_complex_internals(self) -> bool:
+        """ """
         # used to avoid libreduction code paths, which raise or require conversion
         return True
 
     @cache_readonly
     def is_monotonic_increasing(self) -> bool:
         """
-        return if the index is monotonic increasing (only equal or
-        increasing) values.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            increasing) values.
+
         """
         if any(-1 in code for code in self.codes):
             return False
@@ -1478,32 +1708,71 @@
     @cache_readonly
     def is_monotonic_decreasing(self) -> bool:
         """
-        return if the index is monotonic decreasing (only equal or
-        decreasing) values.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            decreasing) values.
+
         """
         # monotonic decreasing if and only if reverse is monotonic increasing
         return self[::-1].is_monotonic_increasing
 
     @cache_readonly
     def _inferred_type_levels(self):
-        """ return a list of the inferred types, one for each level """
+        """ """
         return [i.inferred_type for i in self.levels]
 
     @doc(Index.duplicated)
     def duplicated(self, keep="first"):
+        """
+
+        Parameters
+        ----------
+        keep :
+             (Default value = "first")
+
+        Returns
+        -------
+
+        """
         shape = map(len, self.levels)
         ids = get_group_index(self.codes, shape, sort=False, xnull=False)
 
         return duplicated_int64(ids, keep)
 
     def fillna(self, value=None, downcast=None):
-        """
-        fillna is not implemented for MultiIndex
+        """fillna is not implemented for MultiIndex
+
+        Parameters
+        ----------
+        value :
+             (Default value = None)
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         raise NotImplementedError("isna is not defined for MultiIndex")
 
     @doc(Index.dropna)
     def dropna(self, how="any"):
+        """
+
+        Parameters
+        ----------
+        how :
+             (Default value = "any")
+
+        Returns
+        -------
+
+        """
         nans = [level_codes == -1 for level_codes in self.codes]
         if how == "any":
             indexer = np.any(nans, axis=0)
@@ -1516,21 +1785,22 @@
         return self.copy(codes=new_codes, deep=True)
 
     def _get_level_values(self, level, unique=False):
-        """
-        Return vector of label values for requested level,
+        """Return vector of label values for requested level,
         equal to the length of the index
-
+        
         **this is an internal method**
 
         Parameters
         ----------
         level : int level
+            
         unique : bool, default False
-            if True, drop duplicated values
-
-        Returns
-        -------
-        values : ndarray
+            if True, drop duplicated values (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         lev = self.levels[level]
         level_codes = self.codes[level]
@@ -1541,9 +1811,8 @@
         return lev._shallow_copy(filled, name=name)
 
     def get_level_values(self, level):
-        """
-        Return vector of label values for requested level.
-
+        """Return vector of label values for requested level.
+        
         Length of returned vector is equal to the length of the index.
 
         Parameters
@@ -1561,12 +1830,12 @@
         Examples
         --------
         Create a MultiIndex:
-
+        
+        
+        Get level values by supplying level as either integer or name:
         >>> mi = pd.MultiIndex.from_arrays((list('abc'), list('def')))
         >>> mi.names = ['level_1', 'level_2']
-
-        Get level values by supplying level as either integer or name:
-
+        
         >>> mi.get_level_values(0)
         Index(['a', 'b', 'c'], dtype='object', name='level_1')
         >>> mi.get_level_values('level_2')
@@ -1578,6 +1847,17 @@
 
     @doc(Index.unique)
     def unique(self, level=None):
+        """
+
+        Parameters
+        ----------
+        level :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if level is None:
             return super().unique()
@@ -1586,29 +1866,28 @@
             return self._get_level_values(level=level, unique=True)
 
     def _to_safe_for_reshape(self):
-        """ convert to object if we are a categorical """
+        """convert to object if we are a categorical"""
         return self.set_levels([i._to_safe_for_reshape() for i in self.levels])
 
     def to_frame(self, index=True, name=None):
-        """
-        Create a DataFrame with the levels of the MultiIndex as columns.
-
+        """Create a DataFrame with the levels of the MultiIndex as columns.
+        
         Column ordering is determined by the DataFrame constructor with data as
         a dict.
-
+        
         .. versionadded:: 0.24.0
 
         Parameters
         ----------
         index : bool, default True
-            Set the index of the returned DataFrame as the original MultiIndex.
-
+            Set the index of the returned DataFrame as the original MultiIndex. (Default value = True)
         name : list / sequence of str, optional
-            The passed names should substitute index level names.
+            The passed names should substitute index level names. (Default value = None)
 
         Returns
         -------
         DataFrame : a DataFrame containing the original MultiIndex data.
+            
 
         See Also
         --------
@@ -1643,10 +1922,12 @@
         return result
 
     def to_flat_index(self):
-        """
-        Convert a MultiIndex to an Index of Tuples containing the level values.
-
+        """Convert a MultiIndex to an Index of Tuples containing the level values.
+        
         .. versionadded:: 0.24.0
+
+        Parameters
+        ----------
 
         Returns
         -------
@@ -1657,7 +1938,6 @@
         -----
         This method will simply return the caller if called by anything other
         than a MultiIndex.
-
         Examples
         --------
         >>> index = pd.MultiIndex.from_product(
@@ -1672,29 +1952,33 @@
 
     @property
     def is_all_dates(self) -> bool:
+        """ """
         return False
 
     def is_lexsorted(self) -> bool:
-        """
-        Return True if the codes are lexicographically sorted.
+        """Return True if the codes are lexicographically sorted.
+
+        Parameters
+        ----------
 
         Returns
         -------
         bool
+            
 
         Examples
         --------
         In the below examples, the first level of the MultiIndex is sorted because
         a<b<c, so there is no need to look at the next level.
-
+        
+        
+        In case there is a tie, the lexicographical sorting looks
+        at the next level of the MultiIndex.
         >>> pd.MultiIndex.from_arrays([['a', 'b', 'c'], ['d', 'e', 'f']]).is_lexsorted()
         True
         >>> pd.MultiIndex.from_arrays([['a', 'b', 'c'], ['d', 'f', 'e']]).is_lexsorted()
         True
-
-        In case there is a tie, the lexicographical sorting looks
-        at the next level of the MultiIndex.
-
+        
         >>> pd.MultiIndex.from_arrays([[0, 1, 1], ['a', 'b', 'c']]).is_lexsorted()
         True
         >>> pd.MultiIndex.from_arrays([[0, 1, 1], ['a', 'c', 'b']]).is_lexsorted()
@@ -1710,19 +1994,23 @@
 
     @cache_readonly
     def lexsort_depth(self):
+        """ """
         if self.sortorder is not None:
             return self.sortorder
 
         return self._lexsort_depth()
 
     def _lexsort_depth(self) -> int:
-        """
-        Compute and return the lexsort_depth, the number of levels of the
+        """Compute and return the lexsort_depth, the number of levels of the
         MultiIndex that are sorted lexically
 
-        Returns
-        -------
-        int
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        
         """
         int64_codes = [ensure_int64(level_codes) for level_codes in self.codes]
         for k in range(self.nlevels, 0, -1):
@@ -1731,20 +2019,23 @@
         return 0
 
     def _sort_levels_monotonic(self):
-        """
-        This is an *internal* function.
-
+        """This is an *internal* function.
+        
         Create a new MultiIndex from the current to monotonically sorted
         items IN the levels. This does not actually make the entire MultiIndex
         monotonic, JUST the levels.
-
+        
         The resulting MultiIndex will have the same outward
         appearance, meaning the same .values and ordering. It will also
         be .equals() to the original.
 
+        Parameters
+        ----------
+
         Returns
         -------
         MultiIndex
+            
 
         Examples
         --------
@@ -1756,7 +2047,7 @@
                     ('b', 'bb'),
                     ('b', 'aa')],
                    )
-
+        
         >>> mi.sort_values()
         MultiIndex([('a', 'aa'),
                     ('a', 'bb'),
@@ -1798,20 +2089,27 @@
         )
 
     def remove_unused_levels(self):
-        """
-        Create new MultiIndex from current that removes unused levels.
-
+        """Create new MultiIndex from current that removes unused levels.
+        
         Unused level(s) means levels that are not expressed in the
         labels. The resulting MultiIndex will have the same outward
         appearance, meaning the same .values and ordering. It will
         also be .equals() to the original.
 
+        Parameters
+        ----------
+
         Returns
         -------
         MultiIndex
+            
 
         Examples
         --------
+        
+        
+        The 0 from the first level is not represented
+        and can be removed
         >>> mi = pd.MultiIndex.from_product([range(2), list('ab')])
         >>> mi
         MultiIndex([(0, 'a'),
@@ -1819,15 +2117,12 @@
                     (1, 'a'),
                     (1, 'b')],
                    )
-
+        
         >>> mi[2:]
         MultiIndex([(1, 'a'),
                     (1, 'b')],
                    )
-
-        The 0 from the first level is not represented
-        and can be removed
-
+        
         >>> mi2 = mi[2:].remove_unused_levels()
         >>> mi2.levels
         FrozenList([[1], ['a', 'b']])
@@ -1931,6 +2226,25 @@
 
     @Appender(_index_shared_docs["take"] % _index_doc_kwargs)
     def take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):
+        """
+
+        Parameters
+        ----------
+        indices :
+            
+        axis :
+             (Default value = 0)
+        allow_fill :
+             (Default value = True)
+        fill_value :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_take(tuple(), kwargs)
         indices = ensure_platform_int(indices)
         taken = self._assert_take_fillable(
@@ -1947,7 +2261,25 @@
     def _assert_take_fillable(
         self, values, indices, allow_fill=True, fill_value=None, na_value=None
     ):
-        """ Internal method to handle NA filling of take """
+        """Internal method to handle NA filling of take
+
+        Parameters
+        ----------
+        values :
+            
+        indices :
+            
+        allow_fill :
+             (Default value = True)
+        fill_value :
+             (Default value = None)
+        na_value :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # only fill if we are passing a non-None fill_value
         if allow_fill and fill_value is not None:
             if (indices < -1).any():
@@ -1970,16 +2302,17 @@
         return taken
 
     def append(self, other):
-        """
-        Append a collection of Index options together
+        """Append a collection of Index options together
 
         Parameters
         ----------
         other : Index or list/tuple of indices
-
-        Returns
-        -------
-        appended : Index
+            
+
+        Returns
+        -------
+
+        
         """
         if not isinstance(other, (list, tuple)):
             other = [other]
@@ -2004,10 +2337,36 @@
             return Index(new_tuples)
 
     def argsort(self, *args, **kwargs) -> np.ndarray:
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self._values.argsort(*args, **kwargs)
 
     @Appender(_index_shared_docs["repeat"] % _index_doc_kwargs)
     def repeat(self, repeats, axis=None):
+        """
+
+        Parameters
+        ----------
+        repeats :
+            
+        axis :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         nv.validate_repeat(tuple(), dict(axis=axis))
         repeats = ensure_platform_int(repeats)
         return MultiIndex(
@@ -2022,22 +2381,37 @@
         )
 
     def where(self, cond, other=None):
+        """
+
+        Parameters
+        ----------
+        cond :
+            
+        other :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError(".where is not supported for MultiIndex operations")
 
     def drop(self, codes, level=None, errors="raise"):
-        """
-        Make new MultiIndex with passed list of codes deleted
+        """Make new MultiIndex with passed list of codes deleted
 
         Parameters
         ----------
         codes : array-like
             Must be a list of tuples
         level : int or level name, default None
+             (Default value = None)
         errors : str, default 'raise'
-
-        Returns
-        -------
-        dropped : MultiIndex
+             (Default value = "raise")
+
+        Returns
+        -------
+
+        
         """
         if level is not None:
             return self._drop_from_level(codes, level, errors)
@@ -2078,6 +2452,21 @@
         return self.delete(inds)
 
     def _drop_from_level(self, codes, level, errors="raise"):
+        """
+
+        Parameters
+        ----------
+        codes :
+            
+        level :
+            
+        errors :
+             (Default value = "raise")
+
+        Returns
+        -------
+
+        """
         codes = com.index_labels_to_array(codes)
         i = self._get_level_number(level)
         index = self.levels[i]
@@ -2090,19 +2479,18 @@
         return self[mask]
 
     def swaplevel(self, i=-2, j=-1):
-        """
-        Swap level i with level j.
-
+        """Swap level i with level j.
+        
         Calling this method does not change the ordering of the values.
 
         Parameters
         ----------
         i : int, str, default -2
             First level of index to be swapped. Can pass level name as string.
-            Type of parameters can be mixed.
+            Type of parameters can be mixed. (Default value = -2)
         j : int, str, default -1
             Second level of index to be swapped. Can pass level name as string.
-            Type of parameters can be mixed.
+            Type of parameters can be mixed. (Default value = -1)
 
         Returns
         -------
@@ -2114,7 +2502,6 @@
         Series.swaplevel : Swap levels i and j in a MultiIndex.
         Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a
             particular axis.
-
         Examples
         --------
         >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],
@@ -2148,8 +2535,7 @@
         )
 
     def reorder_levels(self, order):
-        """
-        Rearrange levels using input order. May not drop or duplicate levels.
+        """Rearrange levels using input order. May not drop or duplicate levels.
 
         Parameters
         ----------
@@ -2159,7 +2545,8 @@
 
         Returns
         -------
-        MultiIndex
+
+        
         """
         order = [self._get_level_number(i) for i in order]
         if len(order) != self.nlevels:
@@ -2176,15 +2563,32 @@
         )
 
     def _get_codes_for_sorting(self):
-        """
-        we categorizing our codes by using the
+        """we categorizing our codes by using the
         available categories (all, not just observed)
         excluding any missing ones (-1); this is in preparation
         for sorting, where we need to disambiguate that -1 is not
         a valid valid
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         def cats(level_codes):
+            """
+
+            Parameters
+            ----------
+            level_codes :
+                
+
+            Returns
+            -------
+
+            """
             return np.arange(
                 np.array(level_codes).max() + 1 if len(level_codes) else 0,
                 dtype=level_codes.dtype,
@@ -2196,9 +2600,8 @@
         ]
 
     def sortlevel(self, level=0, ascending=True, sort_remaining=True):
-        """
-        Sort MultiIndex at the requested level.
-
+        """Sort MultiIndex at the requested level.
+        
         The result will respect the original ordering of the associated
         factor at that level.
 
@@ -2206,18 +2609,17 @@
         ----------
         level : list-like, int or str, default 0
             If a string is given, must be a name of the level.
-            If list-like must be names or ints of levels.
+            If list-like must be names or ints of levels. (Default value = 0)
         ascending : bool, default True
             False to sort in descending order.
-            Can also be a list to specify a directed ordering.
+            Can also be a list to specify a directed ordering. (Default value = True)
         sort_remaining : sort by the remaining levels after level
-
-        Returns
-        -------
-        sorted_index : pd.MultiIndex
-            Resulting index.
-        indexer : np.ndarray
-            Indices of output values in original index.
+             (Default value = True)
+
+        Returns
+        -------
+
+        
         """
         if isinstance(level, (str, int)):
             level = [level]
@@ -2274,16 +2676,25 @@
         return new_index, indexer
 
     def reindex(self, target, method=None, level=None, limit=None, tolerance=None):
-        """
-        Create index with target's values (move/add/delete values as necessary)
-
-        Returns
-        -------
-        new_index : pd.MultiIndex
-            Resulting index
-        indexer : np.ndarray or None
-            Indices of output values in original index.
-
+        """Create index with target's values (move/add/delete values as necessary)
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        level :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         # GH6552: preserve names when reindexing to non-named target
         # (i.e. neither Index nor Series).
@@ -2341,6 +2752,17 @@
     # Indexing Methods
 
     def _check_indexing_error(self, key):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        """
         if not is_hashable(key) or is_iterator(key):
             # We allow tuples if they are hashable, whereas other Index
             #  subclasses require scalar.
@@ -2348,18 +2770,28 @@
             raise InvalidIndexError(key)
 
     def _should_fallback_to_positional(self) -> bool:
-        """
-        Should integer key(s) be treated as positional?
-        """
+        """Should integer key(s) be treated as positional?"""
         # GH#33355
         return self.levels[0]._should_fallback_to_positional()
 
     def _get_values_for_loc(self, series: "Series", loc, key):
-        """
-        Do a positional lookup on the given Series, returning either a scalar
+        """Do a positional lookup on the given Series, returning either a scalar
         or a Series.
-
+        
         Assumes that `series.index is self`
+
+        Parameters
+        ----------
+        series: "Series" :
+            
+        loc :
+            
+        key :
+            
+
+        Returns
+        -------
+
         """
         new_values = series._values[loc]
         if is_scalar(loc):
@@ -2372,6 +2804,7 @@
 
     def _convert_listlike_indexer(self, keyarr):
         """
+
         Parameters
         ----------
         keyarr : list-like
@@ -2379,9 +2812,8 @@
 
         Returns
         -------
-        tuple (indexer, keyarr)
-            indexer is an ndarray or None if cannot convert
-            keyarr are tuple-safe keys
+
+        
         """
         indexer, keyarr = super()._convert_listlike_indexer(keyarr)
 
@@ -2402,11 +2834,19 @@
         return indexer, keyarr
 
     def _get_partial_string_timestamp_match_key(self, key):
-        """
-        Translate any partial string timestamp matches in key, returning the
+        """Translate any partial string timestamp matches in key, returning the
         new key.
-
+        
         Only relevant for MultiIndex.
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
         """
         # GH#10331
         if isinstance(key, str) and self.levels[0]._supports_partial_string_indexing:
@@ -2432,6 +2872,23 @@
 
     @Appender(_index_shared_docs["get_indexer"] % _index_doc_kwargs)
     def get_indexer(self, target, method=None, limit=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         method = missing.clean_reindex_fill_method(method)
         target = ensure_index(target)
 
@@ -2473,23 +2930,44 @@
 
     @Appender(_index_shared_docs["get_indexer_non_unique"] % _index_doc_kwargs)
     def get_indexer_non_unique(self, target):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
+        """
         return super().get_indexer_non_unique(target)
 
     def get_slice_bound(
         self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str
     ) -> int:
-        """
-        For an ordered MultiIndex, compute slice bound
+        """For an ordered MultiIndex, compute slice bound
         that corresponds to given label.
-
+        
         Returns leftmost (one-past-the-rightmost if `side=='right') position
         of given label.
 
         Parameters
         ----------
         label : object or tuple of objects
+            
         side : {'left', 'right'}
+            
         kind : {'loc', 'getitem'}
+            
+        label: Union[Hashable :
+            
+        Sequence[Hashable]] :
+            
+        side: str :
+            
+        kind: str :
+            
 
         Returns
         -------
@@ -2499,38 +2977,37 @@
         Notes
         -----
         This method only works if level 0 index of the MultiIndex is lexsorted.
-
         Examples
         --------
-        >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])
-
+        
         Get the locations from the leftmost 'b' in the first level
         until the end of the multiindex:
-
-        >>> mi.get_slice_bound('b', side="left", kind="loc")
-        1
-
+        
+        
         Like above, but if you get the locations from the rightmost
         'b' in the first level and 'f' in the second level:
-
-        >>> mi.get_slice_bound(('b','f'), side="right", kind="loc")
-        3
-
+        
         See Also
         --------
         MultiIndex.get_loc : Get location for a label or a tuple of labels.
         MultiIndex.get_locs : Get location for a label/slice/list/mask or a
                               sequence of such.
+        >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])
+        
+        >>> mi.get_slice_bound('b', side="left", kind="loc")
+        1
+        
+        >>> mi.get_slice_bound(('b','f'), side="right", kind="loc")
+        3
         """
         if not isinstance(label, tuple):
             label = (label,)
         return self._partial_tup_index(label, side=side)
 
     def slice_locs(self, start=None, end=None, step=None, kind=None):
-        """
-        For an ordered MultiIndex, compute the slice locations for input
+        """For an ordered MultiIndex, compute the slice locations for input
         labels.
-
+        
         The input labels can be tuples representing partial levels, e.g. for a
         MultiIndex with 3 levels, you can pass a single value (corresponding to
         the first level), or a 1-, 2-, or 3-tuple.
@@ -2542,47 +3019,62 @@
         end : label or tuple
             If None, defaults to the end
         step : int or None
-            Slice step
+            Slice step (Default value = None)
         kind : string, optional, defaults None
+             (Default value = None)
 
         Returns
         -------
         (start, end) : (int, int)
+            
 
         Notes
         -----
         This method only works if the MultiIndex is properly lexsorted. So,
         if only the first 2 levels of a 3-level MultiIndex are lexsorted,
         you can only pass two levels to ``.slice_locs``.
-
         Examples
         --------
-        >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],
-        ...                                names=['A', 'B'])
-
+        
         Get the slice locations from the beginning of 'b' in the first level
         until the end of the multiindex:
-
-        >>> mi.slice_locs(start='b')
-        (1, 4)
-
+        
+        
         Like above, but stop at the end of 'b' in the first level and 'f' in
         the second level:
-
-        >>> mi.slice_locs(start='b', end=('b', 'f'))
-        (1, 3)
-
+        
         See Also
         --------
         MultiIndex.get_loc : Get location for a label or a tuple of labels.
         MultiIndex.get_locs : Get location for a label/slice/list/mask or a
                               sequence of such.
+        >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],
+        ...                                names=['A', 'B'])
+        
+        >>> mi.slice_locs(start='b')
+        (1, 4)
+        
+        >>> mi.slice_locs(start='b', end=('b', 'f'))
+        (1, 3)
         """
         # This function adds nothing to its parent implementation (the magic
         # happens in get_slice_bound method), but it adds meaningful doc.
         return super().slice_locs(start, end, step, kind=kind)
 
     def _partial_tup_index(self, tup, side="left"):
+        """
+
+        Parameters
+        ----------
+        tup :
+            
+        side :
+             (Default value = "left")
+
+        Returns
+        -------
+
+        """
         if len(tup) > self.lexsort_depth:
             raise UnsortedIndexError(
                 f"Key length ({len(tup)}) was greater than MultiIndex lexsort depth "
@@ -2613,13 +3105,18 @@
                 return start + section.searchsorted(idx, side=side)
 
     def _get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int:
-        """
-        If key is NA value, location of index unify as -1.
-
-        Parameters
-        ----------
-        level_index: Index
+        """If key is NA value, location of index unify as -1.
+
+        Parameters
+        ----------
+        level_index : Index
+            
         key : label
+            
+        level_index: Index :
+            
+        key: Hashable :
+            
 
         Returns
         -------
@@ -2637,16 +3134,17 @@
             return level_index.get_loc(key)
 
     def get_loc(self, key, method=None):
-        """
-        Get location for a label or a tuple of labels.
-
+        """Get location for a label or a tuple of labels.
+        
         The location is returned as an integer/slice or boolean
         mask.
 
         Parameters
         ----------
         key : label or tuple of labels (one for each level)
+            
         method : None
+             (Default value = None)
 
         Returns
         -------
@@ -2661,20 +3159,18 @@
                                 end label(s).
         MultiIndex.get_locs : Get location for a label/slice/list/mask or a
                               sequence of such.
-
         Notes
         -----
         The key cannot be a slice, list of same-level labels, a boolean mask,
         or a sequence of such. If you want to use those, use
         :meth:`MultiIndex.get_locs` instead.
-
         Examples
         --------
         >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])
-
+        
         >>> mi.get_loc('b')
         slice(1, 3, None)
-
+        
         >>> mi.get_loc(('b', 'e'))
         1
         """
@@ -2687,7 +3183,17 @@
         hash(key)
 
         def _maybe_to_slice(loc):
-            """convert integer indexer to boolean mask or slice if possible"""
+            """convert integer indexer to boolean mask or slice if possible
+
+            Parameters
+            ----------
+            loc :
+                
+
+            Returns
+            -------
+
+            """
             if not isinstance(loc, np.ndarray) or loc.dtype != np.intp:
                 return loc
 
@@ -2749,45 +3255,62 @@
         return _maybe_to_slice(loc) if len(loc) != stop - start else slice(start, stop)
 
     def get_loc_level(self, key, level=0, drop_level: bool = True):
-        """
-        Get location and sliced index for requested label(s)/level(s).
+        """Get location and sliced index for requested label(s)/level(s).
 
         Parameters
         ----------
         key : label or sequence of labels
+            
         level : int/level name or list thereof, optional
+             (Default value = 0)
         drop_level : bool, default True
             If ``False``, the resulting index will not drop any level.
+        drop_level: bool :
+             (Default value = True)
 
         Returns
         -------
         loc : A 2-tuple where the elements are:
-              Element 0: int, slice object or boolean array
-              Element 1: The resulting sliced multiindex/index. If the key
-              contains all levels, this will be ``None``.
+            Element 0: int, slice object or boolean array
+            Element 1: The resulting sliced multiindex/index. If the key
+            contains all levels, this will be ``None``.
 
         See Also
         --------
         MultiIndex.get_loc  : Get location for a label or a tuple of labels.
         MultiIndex.get_locs : Get location for a label/slice/list/mask or a
                               sequence of such.
-
         Examples
         --------
         >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],
         ...                                names=['A', 'B'])
-
+        
         >>> mi.get_loc_level('b')
         (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))
-
+        
         >>> mi.get_loc_level('e', level='B')
         (array([False,  True, False]), Index(['b'], dtype='object', name='A'))
-
+        
         >>> mi.get_loc_level(['b', 'e'])
         (1, None)
         """
         # different name to distinguish from maybe_droplevels
         def maybe_mi_droplevels(indexer, levels, drop_level: bool):
+            """
+
+            Parameters
+            ----------
+            indexer :
+                
+            levels :
+                
+            drop_level: bool :
+                
+
+            Returns
+            -------
+
+            """
             if not drop_level:
                 return self[indexer]
             # kludge around
@@ -2840,6 +3363,19 @@
                 # partial selection
                 # optionally get indexer to avoid re-calculation
                 def partial_selection(key, indexer=None):
+                    """
+
+                    Parameters
+                    ----------
+                    key :
+                        
+                    indexer :
+                         (Default value = None)
+
+                    Returns
+                    -------
+
+                    """
                     if indexer is None:
                         indexer = self.get_loc(key)
                     ilevels = [
@@ -2886,6 +3422,21 @@
             return indexer, maybe_mi_droplevels(indexer, [level], drop_level)
 
     def _get_level_indexer(self, key, level=0, indexer=None):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        level :
+             (Default value = 0)
+        indexer :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # return an indexer, boolean array or a slice showing where the key is
         # in the totality of values
         # if the indexer is provided, then use this
@@ -2894,6 +3445,25 @@
         level_codes = self.codes[level]
 
         def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):
+            """
+
+            Parameters
+            ----------
+            start :
+                
+            stop :
+                
+            step :
+                
+            indexer :
+                 (Default value = indexer)
+            codes :
+                 (Default value = level_codes)
+
+            Returns
+            -------
+
+            """
             # given the inputs and the codes/indexer, compute an indexer set
             # if we have a provided indexer, then this need not consider
             # the entire labels set
@@ -2984,14 +3554,13 @@
             return slice(i, j)
 
     def get_locs(self, seq):
-        """
-        Get location for a sequence of labels.
+        """Get location for a sequence of labels.
 
         Parameters
         ----------
         seq : label, slice, list, mask or a sequence of such
-           You should use one of the above for each level.
-           If a level should not be used, set it to ``slice(None)``.
+            You should use one of the above for each level.
+            If a level should not be used, set it to ``slice(None)``.
 
         Returns
         -------
@@ -3003,17 +3572,16 @@
         MultiIndex.get_loc : Get location for a label or a tuple of labels.
         MultiIndex.slice_locs : Get slice location given start label(s) and
                                 end label(s).
-
         Examples
         --------
         >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])
-
+        
         >>> mi.get_locs('b')  # doctest: +SKIP
         array([1, 2], dtype=int64)
-
+        
         >>> mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP
         array([1, 2], dtype=int64)
-
+        
         >>> mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP
         array([2], dtype=int64)
         """
@@ -3032,6 +3600,17 @@
         indexer = None
 
         def _convert_to_indexer(r) -> Int64Index:
+            """
+
+            Parameters
+            ----------
+            r :
+                
+
+            Returns
+            -------
+
+            """
             # return an indexer
             if isinstance(r, slice):
                 m = np.zeros(n, dtype=bool)
@@ -3048,6 +3627,19 @@
             return Int64Index(r)
 
         def _update_indexer(idxr, indexer=indexer):
+            """
+
+            Parameters
+            ----------
+            idxr :
+                
+            indexer :
+                 (Default value = indexer)
+
+            Returns
+            -------
+
+            """
             if indexer is None:
                 indexer = Index(np.arange(n))
             if idxr is None:
@@ -3118,18 +3710,30 @@
         seq: Tuple[Union[Scalar, Iterable, AnyArrayLike], ...],
         indexer: Int64Index,
     ) -> Int64Index:
-        """
-        Reorder an indexer of a MultiIndex (self) so that the label are in the
+        """Reorder an indexer of a MultiIndex (self) so that the label are in the
         same order as given in seq
 
         Parameters
         ----------
         seq : label/slice/list/mask or a sequence of such
-        indexer: an Int64Index indexer of self
-
-        Returns
-        -------
-        indexer : a sorted Int64Index indexer of self ordered as seq
+            
+        indexer : an Int64Index indexer of self
+            
+        seq: Tuple[Union[Scalar :
+            
+        Iterable :
+            
+        AnyArrayLike] :
+            
+        ...] :
+            
+        indexer: Int64Index :
+            
+
+        Returns
+        -------
+
+        
         """
         # If the index is lexsorted and the list_like label in seq are sorted
         # then we do not need to sort
@@ -3175,8 +3779,7 @@
         return indexer[ind]
 
     def truncate(self, before=None, after=None):
-        """
-        Slice index between two labels / tuples, return new MultiIndex
+        """Slice index between two labels / tuples, return new MultiIndex
 
         Parameters
         ----------
@@ -3187,7 +3790,8 @@
 
         Returns
         -------
-        truncated : MultiIndex
+
+        
         """
         if after and before and after < before:
             raise ValueError("after < before")
@@ -3209,9 +3813,16 @@
         )
 
     def equals(self, other) -> bool:
-        """
-        Determines if two MultiIndex objects have the same labeling information
+        """Determines if two MultiIndex objects have the same labeling information
         (the levels themselves do not necessarily have to be the same)
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
 
         See Also
         --------
@@ -3266,7 +3877,16 @@
 
     def equal_levels(self, other) -> bool:
         """
-        Return True if the levels of both MultiIndex objects are the same
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+        type
+            
 
         """
         if self.nlevels != other.nlevels:
@@ -3281,34 +3901,29 @@
     # Set Methods
 
     def union(self, other, sort=None):
-        """
-        Form the union of two MultiIndex objects
+        """Form the union of two MultiIndex objects
 
         Parameters
         ----------
         other : MultiIndex or array / Index of tuples
+            
         sort : False or None, default None
             Whether to sort the resulting Index.
-
             * None : Sort the result, except when
-
-              1. `self` and `other` are equal.
-              2. `self` has length 0.
-              3. Some values in `self` or `other` cannot be compared.
-                 A RuntimeWarning is issued in this case.
-
+            1. `self` and `other` are equal.
+            2. `self` has length 0.
+            3. Some values in `self` or `other` cannot be compared.
+            A RuntimeWarning is issued in this case.
             * False : do not sort the result.
-
             .. versionadded:: 0.24.0
-
             .. versionchanged:: 0.24.1
-
-               Changed the default value from ``True`` to ``None``
-               (without change in behaviour).
+            Changed the default value from ``True`` to ``None``
+            (without change in behaviour).
 
         Returns
         -------
         Index
+            
 
         Examples
         --------
@@ -3330,7 +3945,7 @@
             (2,   'Red'),
             (2, 'Green')],
            )
-
+        
         >>> idx1.union(idx2)
         MultiIndex([(1,  'Blue'),
             (1,   'Red'),
@@ -3340,7 +3955,7 @@
             (3, 'Green'),
             (3,   'Red')],
            )
-
+        
         >>> idx1.union(idx2, sort=False)
         MultiIndex([(1,   'Red'),
             (1,  'Blue'),
@@ -3373,25 +3988,23 @@
         )
 
     def intersection(self, other, sort=False):
-        """
-        Form the intersection of two MultiIndex objects.
+        """Form the intersection of two MultiIndex objects.
 
         Parameters
         ----------
         other : MultiIndex or array / Index of tuples
+            
         sort : False or None, default False
             Sort the resulting MultiIndex if possible
-
             .. versionadded:: 0.24.0
-
             .. versionchanged:: 0.24.1
-
-               Changed the default from ``True`` to ``False``, to match
-               behaviour from before 0.24.0
-
-        Returns
-        -------
-        Index
+            Changed the default from ``True`` to ``False``, to match
+            behaviour from before 0.24.0
+
+        Returns
+        -------
+
+        
         """
         self._validate_sort_keyword(sort)
         self._assert_can_do_setop(other)
@@ -3444,25 +4057,23 @@
             )
 
     def difference(self, other, sort=None):
-        """
-        Compute set difference of two MultiIndex objects
+        """Compute set difference of two MultiIndex objects
 
         Parameters
         ----------
         other : MultiIndex
+            
         sort : False or None, default None
             Sort the resulting MultiIndex if possible
-
             .. versionadded:: 0.24.0
-
             .. versionchanged:: 0.24.1
-
-               Changed the default value from ``True`` to ``None``
-               (without change in behaviour).
-
-        Returns
-        -------
-        diff : MultiIndex
+            Changed the default value from ``True`` to ``None``
+            (without change in behaviour).
+
+        Returns
+        -------
+
+        
         """
         self._validate_sort_keyword(sort)
         self._assert_can_do_setop(other)
@@ -3500,6 +4111,17 @@
             return MultiIndex.from_tuples(difference, sortorder=0, names=result_names)
 
     def _convert_can_do_setop(self, other):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         result_names = self.names
 
         if not isinstance(other, Index):
@@ -3524,6 +4146,19 @@
 
     @doc(Index.astype)
     def astype(self, dtype, copy=True):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         dtype = pandas_dtype(dtype)
         if is_categorical_dtype(dtype):
             msg = "> 1 ndim Categorical are not supported at this time"
@@ -3538,18 +4173,21 @@
         return self
 
     def insert(self, loc: int, item):
-        """
-        Make new MultiIndex inserting new item at location
+        """Make new MultiIndex inserting new item at location
 
         Parameters
         ----------
         loc : int
+            
         item : tuple
             Must be same length as number of levels in the MultiIndex
-
-        Returns
-        -------
-        new_index : Index
+        loc: int :
+            
+
+        Returns
+        -------
+
+        
         """
         # Pad the key with empty strings if lower levels of the key
         # aren't specified:
@@ -3578,12 +4216,17 @@
         )
 
     def delete(self, loc):
-        """
-        Make new index with passed location deleted
-
-        Returns
-        -------
-        new_index : MultiIndex
+        """Make new index with passed location deleted
+
+        Parameters
+        ----------
+        loc :
+            
+
+        Returns
+        -------
+
+        
         """
         new_codes = [np.delete(level_codes, loc) for level_codes in self.codes]
         return MultiIndex(
@@ -3594,11 +4237,37 @@
         )
 
     def _wrap_joined_index(self, joined, other):
+        """
+
+        Parameters
+        ----------
+        joined :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         names = self.names if self.names == other.names else None
         return MultiIndex.from_tuples(joined, names=names)
 
     @doc(Index.isin)
     def isin(self, values, level=None):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        level :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if level is None:
             values = MultiIndex.from_tuples(values, names=self.names)._values
             return algos.isin(self._values, values)
@@ -3617,6 +4286,21 @@
 
 
 def _sparsify(label_list, start: int = 0, sentinel=""):
+    """
+
+    Parameters
+    ----------
+    label_list :
+        
+    start: int :
+         (Default value = 0)
+    sentinel :
+         (Default value = "")
+
+    Returns
+    -------
+
+    """
     pivoted = list(zip(*label_list))
     k = len(label_list)
 
@@ -3645,21 +4329,34 @@
 
 
 def _get_na_rep(dtype) -> str:
-    return {np.datetime64: "NaT", np.timedelta64: "NaT"}.get(dtype, "NaN")
-
-
-def maybe_droplevels(index, key):
     """
-    Attempt to drop level or levels from the given index.
 
     Parameters
     ----------
-    index: Index
-    key : scalar or tuple
+    dtype :
+        
 
     Returns
     -------
-    Index
+
+    """
+    return {np.datetime64: "NaT", np.timedelta64: "NaT"}.get(dtype, "NaN")
+
+
+def maybe_droplevels(index, key):
+    """Attempt to drop level or levels from the given index.
+
+    Parameters
+    ----------
+    index : Index
+        
+    key : scalar or tuple
+        
+
+    Returns
+    -------
+
+    
     """
     # drop levels
     original_index = index
@@ -3680,20 +4377,24 @@
 
 
 def _coerce_indexer_frozen(array_like, categories, copy: bool = False) -> np.ndarray:
-    """
-    Coerce the array_like indexer to the smallest integer dtype that can encode all
+    """Coerce the array_like indexer to the smallest integer dtype that can encode all
     of the given categories.
 
     Parameters
     ----------
     array_like : array-like
+        
     categories : array-like
+        
     copy : bool
+        
+    copy: bool :
+         (Default value = False)
 
     Returns
     -------
-    np.ndarray
-        Non-writeable.
+
+    
     """
     array_like = coerce_indexer_dtype(array_like, categories)
     if copy:
