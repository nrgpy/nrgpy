# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/getattr_static.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/getattr_static.py
@@ -13,6 +13,19 @@
 
 
 def _check_instance(obj, attr):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    attr :
+        
+
+    Returns
+    -------
+
+    """
     instance_dict = {}
     try:
         instance_dict = object.__getattribute__(obj, "__dict__")
@@ -22,6 +35,19 @@
 
 
 def _check_class(klass, attr):
+    """
+
+    Parameters
+    ----------
+    klass :
+        
+    attr :
+        
+
+    Returns
+    -------
+
+    """
     for entry in _static_getmro(klass):
         if _shadowed_dict(type(entry)) is _sentinel:
             try:
@@ -32,6 +58,17 @@
 
 
 def _is_type(obj):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    """
     try:
         _static_getmro(obj)
     except TypeError:
@@ -40,6 +77,17 @@
 
 
 def _shadowed_dict_newstyle(klass):
+    """
+
+    Parameters
+    ----------
+    klass :
+        
+
+    Returns
+    -------
+
+    """
     dict_attr = type.__dict__["__dict__"]
     for entry in _static_getmro(klass):
         try:
@@ -55,6 +103,17 @@
 
 
 def _static_getmro_newstyle(klass):
+    """
+
+    Parameters
+    ----------
+    klass :
+        
+
+    Returns
+    -------
+
+    """
     mro = type.__dict__['__mro__'].__get__(klass)
     if not isinstance(mro, (tuple, list)):
         # There are unfortunately no tests for this, I was not able to
@@ -71,39 +130,59 @@
     _static_getmro = _static_getmro_newstyle
 else:
     def _shadowed_dict(klass):
-        """
-        In Python 2 __dict__ is not overwritable:
-
+        """In Python 2 __dict__ is not overwritable:
+        
             class Foo(object): pass
             setattr(Foo, '__dict__', 4)
-
+        
             Traceback (most recent call last):
               File "<stdin>", line 1, in <module>
             TypeError: __dict__ must be a dictionary object
-
+        
         It applies to both newstyle and oldstyle classes:
-
+        
             class Foo(object): pass
             setattr(Foo, '__dict__', 4)
             Traceback (most recent call last):
               File "<stdin>", line 1, in <module>
             AttributeError: attribute '__dict__' of 'type' objects is not writable
-
+        
         It also applies to instances of those objects. However to keep things
         straight forward, newstyle classes always use the complicated way of
         accessing it while oldstyle classes just use getattr.
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
         """
         if type(klass) is _oldstyle_class_type:
             return getattr(klass, '__dict__', _sentinel)
         return _shadowed_dict_newstyle(klass)
 
     class _OldStyleClass:
+        """ """
         pass
 
     _oldstyle_instance_type = type(_OldStyleClass())
     _oldstyle_class_type = type(_OldStyleClass)
 
     def _get_type(obj):
+        """
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         type_ = object.__getattribute__(obj, '__class__')
         if type_ is _oldstyle_instance_type:
             # Somehow for old style classes we need to access it directly.
@@ -111,11 +190,30 @@
         return type_
 
     def _static_getmro(klass):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
+        """
         if type(klass) is _oldstyle_class_type:
             def oldstyle_mro(klass):
-                """
-                Oldstyle mro is a really simplistic way of look up mro:
+                """Oldstyle mro is a really simplistic way of look up mro:
                 https://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python
+
+                Parameters
+                ----------
+                klass :
+                    
+
+                Returns
+                -------
+
                 """
                 yield klass
                 for base in klass.__bases__:
@@ -128,26 +226,63 @@
 
 
 def _safe_hasattr(obj, name):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     return _check_class(_get_type(obj), name) is not _sentinel
 
 
 def _safe_is_data_descriptor(obj):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    """
     return _safe_hasattr(obj, '__set__') or _safe_hasattr(obj, '__delete__')
 
 
 def getattr_static(obj, attr, default=_sentinel):
     """Retrieve attributes without triggering dynamic lookup via the
        descriptor protocol,  __getattr__ or __getattribute__.
-
+    
        Note: this function may not be able to retrieve all attributes
        that getattr can fetch (like dynamically created attributes)
        and may find attributes that getattr can't (like descriptors
        that raise AttributeError). It can also return descriptor objects
        instead of instance members in some cases. See the
        documentation for details.
-
+    
        Returns a tuple `(attr, is_get_descriptor)`. is_get_descripter means that
        the attribute is a descriptor that has a `__get__` attribute.
+
+    Parameters
+    ----------
+    obj :
+        
+    attr :
+        
+    default :
+         (Default value = _sentinel)
+
+    Returns
+    -------
+
     """
     instance_result = _sentinel
     if not _is_type(obj):
