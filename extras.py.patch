# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/ma/extras.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/ma/extras.py
@@ -41,16 +41,22 @@
 
 
 def issequence(seq):
-    """
-    Is seq a sequence (ndarray, list or tuple)?
+    """Is seq a sequence (ndarray, list or tuple)?
+
+    Parameters
+    ----------
+    seq :
+        
+
+    Returns
+    -------
 
     """
     return isinstance(seq, (ndarray, tuple, list))
 
 
 def count_masked(arr, axis=None):
-    """
-    Count the number of masked elements along the given axis.
+    """Count the number of masked elements along the given axis.
 
     Parameters
     ----------
@@ -69,9 +75,10 @@
     See Also
     --------
     MaskedArray.count : Count non-masked elements.
-
     Examples
     --------
+    
+    When the `axis` keyword is used an array is returned.
     >>> import numpy.ma as ma
     >>> a = np.arange(9).reshape((3,3))
     >>> a = ma.array(a)
@@ -89,23 +96,19 @@
       fill_value=999999)
     >>> ma.count_masked(a)
     3
-
-    When the `axis` keyword is used an array is returned.
-
+    
     >>> ma.count_masked(a, axis=0)
     array([1, 1, 1])
     >>> ma.count_masked(a, axis=1)
     array([0, 2, 1])
-
     """
     m = getmaskarray(arr)
     return m.sum(axis)
 
 
 def masked_all(shape, dtype=float):
-    """
-    Empty masked array with all elements masked.
-
+    """Empty masked array with all elements masked.
+    
     Return an empty masked array of the given shape and dtype, where all the
     data are masked.
 
@@ -114,7 +117,7 @@
     shape : tuple
         Shape of the required MaskedArray.
     dtype : dtype, optional
-        Data type of the output.
+        Data type of the output. (Default value = float)
 
     Returns
     -------
@@ -124,9 +127,10 @@
     See Also
     --------
     masked_all_like : Empty masked array modelled on an existing array.
-
     Examples
     --------
+    
+    The `dtype` parameter defines the underlying data type.
     >>> import numpy.ma as ma
     >>> ma.masked_all((3, 3))
     masked_array(
@@ -138,16 +142,13 @@
             [ True,  True,  True]],
       fill_value=1e+20,
       dtype=float64)
-
-    The `dtype` parameter defines the underlying data type.
-
+    
     >>> a = ma.masked_all((3, 3))
     >>> a.dtype
     dtype('float64')
     >>> a = ma.masked_all((3, 3), dtype=np.int32)
     >>> a.dtype
     dtype('int32')
-
     """
     a = masked_array(np.empty(shape, dtype),
                      mask=np.ones(shape, make_mask_descr(dtype)))
@@ -155,9 +156,8 @@
 
 
 def masked_all_like(arr):
-    """
-    Empty masked array with the properties of an existing array.
-
+    """Empty masked array with the properties of an existing array.
+    
     Return an empty masked array of the same shape and dtype as
     the array `arr`, where all the data are masked.
 
@@ -179,9 +179,10 @@
     See Also
     --------
     masked_all : Empty masked array with all elements masked.
-
     Examples
     --------
+    
+    The dtype of the masked array matches the dtype of `arr`.
     >>> import numpy.ma as ma
     >>> arr = np.zeros((2, 3), dtype=np.float32)
     >>> arr
@@ -195,14 +196,11 @@
             [ True,  True,  True]],
       fill_value=1e+20,
       dtype=float32)
-
-    The dtype of the masked array matches the dtype of `arr`.
-
+    
     >>> arr.dtype
     dtype('float32')
     >>> ma.masked_all_like(arr).dtype
     dtype('float32')
-
     """
     a = np.empty_like(arr).view(MaskedArray)
     a._mask = np.ones(a.shape, dtype=make_mask_descr(a.dtype))
@@ -213,23 +211,23 @@
 #---- --- Standard functions ---
 #####--------------------------------------------------------------------------
 class _fromnxfunction:
-    """
-    Defines a wrapper to adapt NumPy functions to masked arrays.
-
-
+    """Defines a wrapper to adapt NumPy functions to masked arrays.
+    
+    
     An instance of `_fromnxfunction` can be called with the same parameters
     as the wrapped NumPy function. The docstring of `newfunc` is adapted from
     the wrapped function as well, see `getdoc`.
-
+    
     This class should not be used directly. Instead, one of its extensions that
     provides support for a specific type of input should be used.
 
     Parameters
     ----------
-    funcname : str
-        The name of the function to be adapted. The function should be
-        in the NumPy namespace (i.e. ``np.funcname``).
-
+
+    Returns
+    -------
+
+    
     """
 
     def __init__(self, funcname):
@@ -237,13 +235,12 @@
         self.__doc__ = self.getdoc()
 
     def getdoc(self):
-        """
-        Retrieve the docstring and signature from the function.
-
+        """Retrieve the docstring and signature from the function.
+        
         The ``__doc__`` attribute of the function is used as the docstring for
         the new masked array version of the function. A note on application
         of the function to the mask is appended.
-
+        
         .. warning::
           If the function docstring already contained a Notes section, the
           new docstring will have two Notes sections instead of appending a note
@@ -251,8 +248,11 @@
 
         Parameters
         ----------
-        None
-
+
+        Returns
+        -------
+
+        
         """
         npfunc = getattr(np, self.__name__, None)
         doc = getattr(npfunc, '__doc__', None)
@@ -268,10 +268,16 @@
 
 
 class _fromnxfunction_single(_fromnxfunction):
-    """
-    A version of `_fromnxfunction` that is called with a single array
+    """A version of `_fromnxfunction` that is called with a single array
     argument followed by auxiliary args that are passed verbatim for
     both the data and mask calls.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __call__(self, x, *args, **params):
         func = getattr(np, self.__name__)
@@ -286,10 +292,16 @@
 
 
 class _fromnxfunction_seq(_fromnxfunction):
-    """
-    A version of `_fromnxfunction` that is called with a single sequence
+    """A version of `_fromnxfunction` that is called with a single sequence
     of arrays followed by auxiliary args that are passed verbatim for
     both the data and mask calls.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __call__(self, x, *args, **params):
         func = getattr(np, self.__name__)
@@ -299,13 +311,19 @@
 
 
 class _fromnxfunction_args(_fromnxfunction):
-    """
-    A version of `_fromnxfunction` that is called with multiple array
+    """A version of `_fromnxfunction` that is called with multiple array
     arguments. The first non-array-like input marks the beginning of the
-    arguments that are passed verbatim for both the data and mask calls.
-    Array arguments are processed independently and the results are
-    returned in a list. If only one array is found, the return value is
-    just the processed array instead of a list.
+
+    Parameters
+    ----------
+    Array :
+        arguments are processed independently and the results are
+
+    Returns
+    -------
+    type
+        just the processed array instead of a list.
+
     """
     def __call__(self, *args, **params):
         func = getattr(np, self.__name__)
@@ -324,15 +342,22 @@
 
 
 class _fromnxfunction_allargs(_fromnxfunction):
-    """
-    A version of `_fromnxfunction` that is called with multiple array
+    """A version of `_fromnxfunction` that is called with multiple array
     arguments. Similar to `_fromnxfunction_args` except that all args
     are converted to arrays even if they are not so already. This makes
     it possible to process scalars as 1-D arrays. Only keyword arguments
     are passed through verbatim for the data and mask calls. Arrays
-    arguments are processed independently and the results are returned
-    in a list. If only one arg is present, the return value is just the
-    processed array instead of a list.
+
+    Parameters
+    ----------
+    in :
+        a list
+    processed :
+        array instead of a list
+
+    Returns
+    -------
+
     """
     def __call__(self, *args, **params):
         func = getattr(np, self.__name__)
@@ -365,7 +390,17 @@
 #----
 #####--------------------------------------------------------------------------
 def flatten_inplace(seq):
-    """Flatten a sequence in place."""
+    """Flatten a sequence in place.
+
+    Parameters
+    ----------
+    seq :
+        
+
+    Returns
+    -------
+
+    """
     k = 0
     while (k != len(seq)):
         while hasattr(seq[k], '__iter__'):
@@ -375,8 +410,24 @@
 
 
 def apply_along_axis(func1d, axis, arr, *args, **kwargs):
-    """
-    (This docstring should be overwritten)
+    """(This docstring should be overwritten)
+
+    Parameters
+    ----------
+    func1d :
+        
+    axis :
+        
+    arr :
+        
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
     """
     arr = array(arr, copy=False, subok=True)
     nd = arr.ndim
@@ -458,8 +509,20 @@
 
 
 def apply_over_axes(func, a, axes):
-    """
-    (This docstring will be overwritten)
+    """(This docstring will be overwritten)
+
+    Parameters
+    ----------
+    func :
+        
+    a :
+        
+    axes :
+        
+
+    Returns
+    -------
+
     """
     val = asarray(a)
     N = a.ndim
@@ -531,8 +594,7 @@
 
 
 def average(a, axis=None, weights=None, returned=False):
-    """
-    Return the weighted average of array over the given axis.
+    """Return the weighted average of array over the given axis.
 
     Parameters
     ----------
@@ -541,17 +603,15 @@
         Masked entries are not taken into account in the computation.
     axis : int, optional
         Axis along which to average `a`. If None, averaging is done over
-        the flattened array.
+        the flattened array. (Default value = None)
     weights : array_like, optional
         The importance that each element has in the computation of the average.
         The weights array can either be 1-D (in which case its length must be
         the size of `a` along the given axis) or of the same shape as `a`.
         If ``weights=None``, then all data in `a` are assumed to have a
         weight equal to one.  The 1-D calculation is::
-
-            avg = sum(a * weights) / sum(weights)
-
-        The only constraint on `weights` is that `sum(weights)` must not be 0.
+        avg = sum(a * weights) / sum(weights)
+        The only constraint on `weights` is that `sum(weights)` must not be 0. (Default value = None)
     returned : bool, optional
         Flag indicating whether a tuple ``(result, sum of weights)``
         should be returned as output (True), or just the result (False).
@@ -572,7 +632,7 @@
     >>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
     >>> np.ma.average(a, weights=[3, 1, 0, 0])
     1.25
-
+    
     >>> x = np.ma.arange(6.).reshape(3, 2)
     >>> x
     masked_array(
@@ -587,7 +647,6 @@
     masked_array(data=[2.6666666666666665, 3.6666666666666665],
                  mask=[False, False],
            fill_value=1e+20)
-
     """
     a = asarray(a)
     m = getmask(a)
@@ -637,9 +696,8 @@
 
 
 def median(a, axis=None, out=None, overwrite_input=False, keepdims=False):
-    """
-    Compute the median along the specified axis.
-
+    """Compute the median along the specified axis.
+    
     Returns the median of the array elements.
 
     Parameters
@@ -652,7 +710,7 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output
-        but the type will be cast if necessary.
+        but the type will be cast if necessary. (Default value = None)
     overwrite_input : bool, optional
         If True, then allow use of memory of input array (a) for
         calculations. The input array will be modified by the call to
@@ -665,8 +723,7 @@
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
-        .. versionadded:: 1.10.0
+        .. versionadded:: 1.10.0 (Default value = False)
 
     Returns
     -------
@@ -679,20 +736,18 @@
     See Also
     --------
     mean
-
     Notes
     -----
     Given a vector ``V`` with ``N`` non masked values, the median of ``V``
     is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
     ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
     when ``N`` is even.
-
     Examples
     --------
     >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
     >>> np.ma.median(x)
     1.5
-
+    
     >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
     >>> np.ma.median(x)
     2.5
@@ -700,7 +755,6 @@
     masked_array(data=[2.0, 5.0],
                  mask=[False, False],
            fill_value=1e+20)
-
     """
     if not hasattr(a, 'mask'):
         m = np.median(getdata(a, subok=True), axis=axis,
@@ -719,6 +773,23 @@
         return r
 
 def _median(a, axis=None, out=None, overwrite_input=False):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     # when an unmasked NaN is present return it, so we need to sort the NaN
     # values behind the mask
     if np.issubdtype(a.dtype, np.inexact):
@@ -781,6 +852,17 @@
     low_high = np.take_along_axis(asorted, lh, axis=axis)
 
     def replace_masked(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         # Replace masked entries with minimum_full_value unless it all values
         # are masked. This is required as the sort order of values equal or
         # larger than the fill value is undefined and a valid value placed
@@ -818,12 +900,12 @@
         parameter.
         - If axis is a tuple of ints, those are the axes to suppress slices from.
         - If axis is an int, then that is the only axis to suppress slices from.
-        - If axis is None, all axis are selected.
-
-    Returns
-    -------
-    compress_array : ndarray
-        The compressed array.
+        - If axis is None, all axis are selected. (Default value = None)
+
+    Returns
+    -------
+
+    
     """
     x = asarray(x)
     m = getmask(x)
@@ -847,12 +929,11 @@
     return data
 
 def compress_rowcols(x, axis=None):
-    """
-    Suppress the rows and/or columns of a 2-D array that contain
+    """Suppress the rows and/or columns of a 2-D array that contain
     masked values.
-
+    
     The suppression behavior is selected with the `axis` parameter.
-
+    
     - If axis is None, both rows and columns are suppressed.
     - If axis is 0, only rows are suppressed.
     - If axis is 1 or -1, only columns are suppressed.
@@ -885,7 +966,7 @@
             [ True, False, False],
             [False, False, False]],
       fill_value=999999)
-
+    
     >>> np.ma.compress_rowcols(x)
     array([[7, 8]])
     >>> np.ma.compress_rowcols(x, 0)
@@ -894,7 +975,6 @@
     array([[1, 2],
            [4, 5],
            [7, 8]])
-
     """
     if asarray(x).ndim != 2:
         raise NotImplementedError("compress_rowcols works for 2D arrays only.")
@@ -902,16 +982,22 @@
 
 
 def compress_rows(a):
-    """
-    Suppress whole rows of a 2-D array that contain masked values.
-
+    """Suppress whole rows of a 2-D array that contain masked values.
+    
     This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
     `extras.compress_rowcols` for details.
 
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
     See Also
     --------
     extras.compress_rowcols
-
     """
     a = asarray(a)
     if a.ndim != 2:
@@ -919,16 +1005,22 @@
     return compress_rowcols(a, 0)
 
 def compress_cols(a):
-    """
-    Suppress whole columns of a 2-D array that contain masked values.
-
+    """Suppress whole columns of a 2-D array that contain masked values.
+    
     This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
     `extras.compress_rowcols` for details.
 
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
     See Also
     --------
     extras.compress_rowcols
-
     """
     a = asarray(a)
     if a.ndim != 2:
@@ -936,16 +1028,24 @@
     return compress_rowcols(a, 1)
 
 def mask_rows(a, axis=np._NoValue):
-    """
-    Mask rows of a 2D array that contain masked values.
-
+    """Mask rows of a 2D array that contain masked values.
+    
     This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = np._NoValue)
+
+    Returns
+    -------
 
     See Also
     --------
     mask_rowcols : Mask rows and/or columns of a 2D array.
     masked_where : Mask where a condition is met.
-
     Examples
     --------
     >>> import numpy.ma as ma
@@ -965,7 +1065,7 @@
             [False,  True, False],
             [False, False, False]],
       fill_value=1)
-
+    
     >>> ma.mask_rows(a)
     masked_array(
       data=[[0, 0, 0],
@@ -975,7 +1075,6 @@
             [ True,  True,  True],
             [False, False, False]],
       fill_value=1)
-
     """
     if axis is not np._NoValue:
         # remove the axis argument when this deprecation expires
@@ -986,16 +1085,24 @@
     return mask_rowcols(a, 0)
 
 def mask_cols(a, axis=np._NoValue):
-    """
-    Mask columns of a 2D array that contain masked values.
-
+    """Mask columns of a 2D array that contain masked values.
+    
     This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = np._NoValue)
+
+    Returns
+    -------
 
     See Also
     --------
     mask_rowcols : Mask rows and/or columns of a 2D array.
     masked_where : Mask where a condition is met.
-
     Examples
     --------
     >>> import numpy.ma as ma
@@ -1024,7 +1131,6 @@
             [False,  True, False],
             [False,  True, False]],
       fill_value=1)
-
     """
     if axis is not np._NoValue:
         # remove the axis argument when this deprecation expires
@@ -1040,16 +1146,26 @@
 #####--------------------------------------------------------------------------
 
 def ediff1d(arr, to_end=None, to_begin=None):
-    """
-    Compute the differences between consecutive elements of an array.
-
+    """Compute the differences between consecutive elements of an array.
+    
     This function is the equivalent of `numpy.ediff1d` that takes masked
     values into account, see `numpy.ediff1d` for details.
 
+    Parameters
+    ----------
+    arr :
+        
+    to_end :
+         (Default value = None)
+    to_begin :
+         (Default value = None)
+
+    Returns
+    -------
+
     See Also
     --------
     numpy.ediff1d : Equivalent function for ndarrays.
-
     """
     arr = ma.asanyarray(arr).flat
     ed = arr[1:] - arr[:-1]
@@ -1069,16 +1185,26 @@
 
 
 def unique(ar1, return_index=False, return_inverse=False):
-    """
-    Finds the unique elements of an array.
-
+    """Finds the unique elements of an array.
+    
     Masked values are considered the same element (masked). The output array
     is always a masked array. See `numpy.unique` for more details.
 
+    Parameters
+    ----------
+    ar1 :
+        
+    return_index :
+         (Default value = False)
+    return_inverse :
+         (Default value = False)
+
+    Returns
+    -------
+
     See Also
     --------
     numpy.unique : Equivalent function for ndarrays.
-
     """
     output = np.unique(ar1,
                        return_index=return_index,
@@ -1093,18 +1219,28 @@
 
 
 def intersect1d(ar1, ar2, assume_unique=False):
-    """
-    Returns the unique elements common to both arrays.
-
+    """Returns the unique elements common to both arrays.
+    
     Masked values are considered equal one to the other.
     The output is always a masked array.
-
+    
     See `numpy.intersect1d` for more details.
 
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = False)
+
+    Returns
+    -------
+
     See Also
     --------
     numpy.intersect1d : Equivalent function for ndarrays.
-
     Examples
     --------
     >>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])
@@ -1113,7 +1249,6 @@
     masked_array(data=[1, 3, --],
                  mask=[False, False,  True],
            fill_value=999999)
-
     """
     if assume_unique:
         aux = ma.concatenate((ar1, ar2))
@@ -1125,15 +1260,25 @@
 
 
 def setxor1d(ar1, ar2, assume_unique=False):
-    """
-    Set exclusive-or of 1-D arrays with unique elements.
-
+    """Set exclusive-or of 1-D arrays with unique elements.
+    
     The output is always a masked array. See `numpy.setxor1d` for more details.
 
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = False)
+
+    Returns
+    -------
+
     See Also
     --------
     numpy.setxor1d : Equivalent function for ndarrays.
-
     """
     if not assume_unique:
         ar1 = unique(ar1)
@@ -1152,23 +1297,34 @@
 
 
 def in1d(ar1, ar2, assume_unique=False, invert=False):
-    """
-    Test whether each element of an array is also present in a second
+    """Test whether each element of an array is also present in a second
     array.
-
+    
     The output is always a masked array. See `numpy.in1d` for more details.
-
+    
     We recommend using :func:`isin` instead of `in1d` for new code.
+
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = False)
+    invert :
+         (Default value = False)
+
+    Returns
+    -------
 
     See Also
     --------
     isin       : Version of this function that preserves the shape of ar1.
     numpy.in1d : Equivalent function for ndarrays.
-
     Notes
     -----
     .. versionadded:: 1.4.0
-
     """
     if not assume_unique:
         ar1, rev_idx = unique(ar1, return_inverse=True)
@@ -1194,22 +1350,33 @@
 
 
 def isin(element, test_elements, assume_unique=False, invert=False):
-    """
-    Calculates `element in test_elements`, broadcasting over
+    """Calculates `element in test_elements`, broadcasting over
     `element` only.
-
+    
     The output is always a masked array of the same shape as `element`.
     See `numpy.isin` for more details.
 
+    Parameters
+    ----------
+    element :
+        
+    test_elements :
+        
+    assume_unique :
+         (Default value = False)
+    invert :
+         (Default value = False)
+
+    Returns
+    -------
+
     See Also
     --------
     in1d       : Flattened version of this function.
     numpy.isin : Equivalent function for ndarrays.
-
     Notes
     -----
     .. versionadded:: 1.13.0
-
     """
     element = ma.asarray(element)
     return in1d(element, test_elements, assume_unique=assume_unique,
@@ -1217,30 +1384,48 @@
 
 
 def union1d(ar1, ar2):
-    """
-    Union of two arrays.
-
+    """Union of two arrays.
+    
     The output is always a masked array. See `numpy.union1d` for more details.
 
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+
+    Returns
+    -------
+
     See also
     --------
     numpy.union1d : Equivalent function for ndarrays.
-
     """
     return unique(ma.concatenate((ar1, ar2), axis=None))
 
 
 def setdiff1d(ar1, ar2, assume_unique=False):
-    """
-    Set difference of 1D arrays with unique elements.
-
+    """Set difference of 1D arrays with unique elements.
+    
     The output is always a masked array. See `numpy.setdiff1d` for more
     details.
 
+    Parameters
+    ----------
+    ar1 :
+        
+    ar2 :
+        
+    assume_unique :
+         (Default value = False)
+
+    Returns
+    -------
+
     See Also
     --------
     numpy.setdiff1d : Equivalent function for ndarrays.
-
     Examples
     --------
     >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
@@ -1248,7 +1433,6 @@
     masked_array(data=[3, --],
                  mask=[False,  True],
            fill_value=999999)
-
     """
     if assume_unique:
         ar1 = ma.asarray(ar1).ravel()
@@ -1264,9 +1448,22 @@
 
 
 def _covhelper(x, y=None, rowvar=True, allow_masked=True):
-    """
-    Private function for the computation of covariance and correlation
+    """Private function for the computation of covariance and correlation
     coefficients.
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+         (Default value = None)
+    rowvar :
+         (Default value = True)
+    allow_masked :
+         (Default value = True)
+
+    Returns
+    -------
 
     """
     x = ma.array(x, ndmin=2, copy=True, dtype=float)
@@ -1307,12 +1504,11 @@
 
 
 def cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None):
-    """
-    Estimate the covariance matrix.
-
+    """Estimate the covariance matrix.
+    
     Except for the handling of missing data this function does the same as
     `numpy.cov`. For more details and examples, see `numpy.cov`.
-
+    
     By default, masked values are recognized as such. If `x` and `y` have the
     same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
     ``y[i,j]`` will also be masked.
@@ -1327,7 +1523,7 @@
         observation of all those variables. Also see `rowvar` below.
     y : array_like, optional
         An additional set of variables and observations. `y` has the same
-        form as `x`.
+        form as `x`. (Default value = None)
     rowvar : bool, optional
         If `rowvar` is True (default), then each row represents a
         variable, with observations in the columns. Otherwise, the relationship
@@ -1341,13 +1537,15 @@
     allow_masked : bool, optional
         If True, masked values are propagated pair-wise: if a value is masked
         in `x`, the corresponding value is masked in `y`.
-        If False, raises a `ValueError` exception when some values are missing.
+        If False, raises a `ValueError` exception when some values are missing. (Default value = True)
     ddof : {None, int}, optional
         If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
         the number of observations; this overrides the value implied by
         ``bias``. The default value is ``None``.
-
         .. versionadded:: 1.5
+
+    Returns
+    -------
 
     Raises
     ------
@@ -1357,7 +1555,6 @@
     See Also
     --------
     numpy.cov
-
     """
     # Check inputs
     if ddof is not None and ddof != int(ddof):
@@ -1381,9 +1578,8 @@
 
 def corrcoef(x, y=None, rowvar=True, bias=np._NoValue, allow_masked=True,
              ddof=np._NoValue):
-    """
-    Return Pearson product-moment correlation coefficients.
-
+    """Return Pearson product-moment correlation coefficients.
+    
     Except for the handling of missing data this function does the same as
     `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.
 
@@ -1395,7 +1591,7 @@
         observation of all those variables. Also see `rowvar` below.
     y : array_like, optional
         An additional set of variables and observations. `y` has the same
-        shape as `x`.
+        shape as `x`. (Default value = None)
     rowvar : bool, optional
         If `rowvar` is True (default), then each row represents a
         variable, with observations in the columns. Otherwise, the relationship
@@ -1403,23 +1599,23 @@
         contain observations.
     bias : _NoValue, optional
         Has no effect, do not use.
-
-        .. deprecated:: 1.10.0
+        .. deprecated:: 1.10.0 (Default value = np._NoValue)
     allow_masked : bool, optional
         If True, masked values are propagated pair-wise: if a value is masked
         in `x`, the corresponding value is masked in `y`.
         If False, raises an exception.  Because `bias` is deprecated, this
-        argument needs to be treated as keyword only to avoid a warning.
+        argument needs to be treated as keyword only to avoid a warning. (Default value = True)
     ddof : _NoValue, optional
         Has no effect, do not use.
-
-        .. deprecated:: 1.10.0
+        .. deprecated:: 1.10.0 (Default value = np._NoValue)
+
+    Returns
+    -------
 
     See Also
     --------
     numpy.corrcoef : Equivalent function in top-level NumPy module.
     cov : Estimate the covariance matrix.
-
     Notes
     -----
     This function accepts but discards arguments `bias` and `ddof`.  This is
@@ -1470,20 +1666,35 @@
 #####--------------------------------------------------------------------------
 
 class MAxisConcatenator(AxisConcatenator):
-    """
-    Translate slice objects to concatenation along an axis.
-
+    """Translate slice objects to concatenation along an axis.
+    
     For documentation on usage, see `mr_class`.
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     See Also
     --------
     mr_class
-
     """
     concatenate = staticmethod(concatenate)
 
     @classmethod
     def makemat(cls, arr):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+
+        Returns
+        -------
+
+        """
         # There used to be a view as np.matrix here, but we may eventually
         # deprecate that class. In preparation, we use the unmasked version
         # to construct the matrix (with copy=False for backwards compatibility
@@ -1500,22 +1711,25 @@
 
 
 class mr_class(MAxisConcatenator):
-    """
-    Translate slice objects to concatenation along the first axis.
-
+    """Translate slice objects to concatenation along the first axis.
+    
     This is the masked array version of `lib.index_tricks.RClass`.
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     See Also
     --------
     lib.index_tricks.RClass
-
     Examples
     --------
     >>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]
     masked_array(data=[1, 2, 3, ..., 4, 5, 6],
                  mask=False,
            fill_value=999999)
-
     """
     def __init__(self):
         MAxisConcatenator.__init__(self, 0)
@@ -1527,9 +1741,8 @@
 #####--------------------------------------------------------------------------
 
 def flatnotmasked_edges(a):
-    """
-    Find the indices of the first and last unmasked values.
-
+    """Find the indices of the first and last unmasked values.
+    
     Expects a 1-D `MaskedArray`, returns None if all values are masked.
 
     Parameters
@@ -1547,29 +1760,26 @@
     --------
     flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges
     clump_masked, clump_unmasked
-
     Notes
     -----
     Only accepts 1-D arrays.
-
     Examples
     --------
     >>> a = np.ma.arange(10)
     >>> np.ma.flatnotmasked_edges(a)
     array([0, 9])
-
+    
     >>> mask = (a < 3) | (a > 8) | (a == 5)
     >>> a[mask] = np.ma.masked
     >>> np.array(a[~a.mask])
     array([3, 4, 6, 7, 8])
-
+    
     >>> np.ma.flatnotmasked_edges(a)
     array([3, 8])
-
+    
     >>> a[:] = np.ma.masked
     >>> print(np.ma.flatnotmasked_edges(a))
     None
-
     """
     m = getmask(a)
     if m is nomask or not np.any(m):
@@ -1582,9 +1792,8 @@
 
 
 def notmasked_edges(a, axis=None):
-    """
-    Find the indices of the first and last unmasked values along an axis.
-
+    """Find the indices of the first and last unmasked values along an axis.
+    
     If all values are masked, return None.  Otherwise, return a list
     of two tuples, corresponding to the indices of the first and last
     unmasked values respectively.
@@ -1608,20 +1817,18 @@
     --------
     flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous
     clump_masked, clump_unmasked
-
     Examples
     --------
     >>> a = np.arange(9).reshape((3, 3))
     >>> m = np.zeros_like(a)
     >>> m[1:, 1:] = 1
-
+    
     >>> am = np.ma.array(a, mask=m)
     >>> np.array(am[~am.mask])
     array([0, 1, 2, 3, 6])
-
+    
     >>> np.ma.notmasked_edges(am)
     array([0, 6])
-
     """
     a = asarray(a)
     if axis is None or a.ndim == 1:
@@ -1633,8 +1840,7 @@
 
 
 def flatnotmasked_contiguous(a):
-    """
-    Find contiguous unmasked data in a masked array along the given axis.
+    """Find contiguous unmasked data in a masked array along the given axis.
 
     Parameters
     ----------
@@ -1645,36 +1851,32 @@
     -------
     slice_list : list
         A sorted sequence of `slice` objects (start index, end index).
-
         ..versionchanged:: 1.15.0
-            Now returns an empty list instead of None for a fully masked array
+        Now returns an empty list instead of None for a fully masked array
 
     See Also
     --------
     flatnotmasked_edges, notmasked_contiguous, notmasked_edges
     clump_masked, clump_unmasked
-
     Notes
     -----
     Only accepts 2-D arrays at most.
-
     Examples
     --------
     >>> a = np.ma.arange(10)
     >>> np.ma.flatnotmasked_contiguous(a)
     [slice(0, 10, None)]
-
+    
     >>> mask = (a < 3) | (a > 8) | (a == 5)
     >>> a[mask] = np.ma.masked
     >>> np.array(a[~a.mask])
     array([3, 4, 6, 7, 8])
-
+    
     >>> np.ma.flatnotmasked_contiguous(a)
     [slice(3, 5, None), slice(6, 9, None)]
     >>> a[:] = np.ma.masked
     >>> np.ma.flatnotmasked_contiguous(a)
     []
-
     """
     m = getmask(a)
     if m is nomask:
@@ -1689,8 +1891,7 @@
     return result
 
 def notmasked_contiguous(a, axis=None):
-    """
-    Find contiguous unmasked data in a masked array along the given axis.
+    """Find contiguous unmasked data in a masked array along the given axis.
 
     Parameters
     ----------
@@ -1706,18 +1907,15 @@
     endpoints : list
         A list of slices (start and end indexes) of unmasked indexes
         in the array.
-
         If the input is 2d and axis is specified, the result is a list of lists.
 
     See Also
     --------
     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
     clump_masked, clump_unmasked
-
     Notes
     -----
     Only accepts 2-D arrays at most.
-
     Examples
     --------
     >>> a = np.arange(12).reshape((3, 4))
@@ -1735,16 +1933,15 @@
       fill_value=999999)
     >>> np.array(ma[~ma.mask])
     array([ 0,  2,  3,  7, 8, 11])
-
+    
     >>> np.ma.notmasked_contiguous(ma)
     [slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]
-
+    
     >>> np.ma.notmasked_contiguous(ma, axis=0)
     [[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]
-
+    
     >>> np.ma.notmasked_contiguous(ma, axis=1)
     [[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]
-
     """
     a = asarray(a)
     nd = a.ndim
@@ -1766,10 +1963,18 @@
 
 
 def _ezclump(mask):
-    """
-    Finds the clumps (groups of data with the same values) for a 1D bool array.
-
+    """Finds the clumps (groups of data with the same values) for a 1D bool array.
+    
     Returns a series of slices.
+
+    Parameters
+    ----------
+    mask :
+        
+
+    Returns
+    -------
+
     """
     if mask.ndim > 1:
         mask = mask.ravel()
@@ -1795,8 +2000,7 @@
 
 
 def clump_unmasked(a):
-    """
-    Return list of slices corresponding to the unmasked clumps of a 1-D array.
+    """Return list of slices corresponding to the unmasked clumps of a 1-D array.
     (A "clump" is defined as a contiguous region of the array).
 
     Parameters
@@ -1813,19 +2017,16 @@
     Notes
     -----
     .. versionadded:: 1.4.0
-
     See Also
     --------
     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
     notmasked_contiguous, clump_masked
-
     Examples
     --------
     >>> a = np.ma.masked_array(np.arange(10))
     >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
     >>> np.ma.clump_unmasked(a)
     [slice(3, 6, None), slice(7, 8, None)]
-
     """
     mask = getattr(a, '_mask', nomask)
     if mask is nomask:
@@ -1834,8 +2035,7 @@
 
 
 def clump_masked(a):
-    """
-    Returns a list of slices corresponding to the masked clumps of a 1-D array.
+    """Returns a list of slices corresponding to the masked clumps of a 1-D array.
     (A "clump" is defined as a contiguous region of the array).
 
     Parameters
@@ -1852,19 +2052,16 @@
     Notes
     -----
     .. versionadded:: 1.4.0
-
     See Also
     --------
     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
     notmasked_contiguous, clump_unmasked
-
     Examples
     --------
     >>> a = np.ma.masked_array(np.arange(10))
     >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
     >>> np.ma.clump_masked(a)
     [slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]
-
     """
     mask = ma.getmask(a)
     if mask is nomask:
@@ -1878,8 +2075,17 @@
 
 
 def vander(x, n=None):
-    """
-    Masked values in the input array result in rows of zeros.
+    """Masked values in the input array result in rows of zeros.
+
+    Parameters
+    ----------
+    x :
+        
+    n :
+         (Default value = None)
+
+    Returns
+    -------
 
     """
     _vander = np.vander(x, n)
@@ -1892,8 +2098,27 @@
 
 
 def polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):
-    """
-    Any masked values in x is propagated in y, and vice-versa.
+    """Any masked values in x is propagated in y, and vice-versa.
+
+    Parameters
+    ----------
+    x :
+        
+    y :
+        
+    deg :
+        
+    rcond :
+         (Default value = None)
+    full :
+         (Default value = False)
+    w :
+         (Default value = None)
+    cov :
+         (Default value = False)
+
+    Returns
+    -------
 
     """
     x = asarray(x)
