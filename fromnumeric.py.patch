# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/fromnumeric.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/fromnumeric.py
@@ -37,6 +37,23 @@
 
 # functions that are now methods
 def _wrapit(obj, method, *args, **kwds):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    method :
+        
+    *args :
+        
+    **kwds :
+        
+
+    Returns
+    -------
+
+    """
     try:
         wrap = obj.__array_wrap__
     except AttributeError:
@@ -50,6 +67,23 @@
 
 
 def _wrapfunc(obj, method, *args, **kwds):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    method :
+        
+    *args :
+        
+    **kwds :
+        
+
+    Returns
+    -------
+
+    """
     bound = getattr(obj, method, None)
     if bound is None:
         return _wrapit(obj, method, *args, **kwds)
@@ -68,6 +102,29 @@
 
 
 def _wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    ufunc :
+        
+    method :
+        
+    axis :
+        
+    dtype :
+        
+    out :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     passkwargs = {k: v for k, v in kwargs.items()
                   if v is not np._NoValue}
 
@@ -88,24 +145,42 @@
 
 
 def _take_dispatcher(a, indices, axis=None, out=None, mode=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    indices :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    mode :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_take_dispatcher)
 def take(a, indices, axis=None, out=None, mode='raise'):
-    """
-    Take elements from an array along an axis.
-
+    """Take elements from an array along an axis.
+    
     When axis is not None, this function does the same thing as "fancy"
     indexing (indexing arrays using arrays); however, it can be easier to use
     if you need elements along a given axis. A call such as
     ``np.take(arr, indices, axis=3)`` is equivalent to
     ``arr[:,:,:,indices,...]``.
-
+    
     Explained without fancy indexing, this is equivalent to the following use
     of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
     indices::
-
+    
         Ni, Nk = a.shape[:axis], a.shape[axis+1:]
         Nj = indices.shape
         for ii in ndindex(Ni):
@@ -119,9 +194,7 @@
         The source array.
     indices : array_like (Nj...)
         The indices of the values to extract.
-
         .. versionadded:: 1.8.0
-
         Also allow scalars for indices.
     axis : int, optional
         The axis over which to select values. By default, the flattened
@@ -129,14 +202,12 @@
     out : ndarray, optional (Ni..., Nj..., Nk...)
         If provided, the result will be placed in this array. It should
         be of the appropriate shape and dtype. Note that `out` is always
-        buffered if `mode='raise'`; use other modes for better performance.
+        buffered if `mode='raise'`; use other modes for better performance. (Default value = None)
     mode : {'raise', 'wrap', 'clip'}, optional
         Specifies how out-of-bounds indices will behave.
-
         * 'raise' -- raise an error (default)
         * 'wrap' -- wrap around
         * 'clip' -- clip to the range
-
         'clip' mode means that all indices that are too large are replaced
         by the index that addresses the last element along that axis. Note
         that this disables indexing with negative numbers.
@@ -151,39 +222,38 @@
     compress : Take elements using a boolean mask
     ndarray.take : equivalent method
     take_along_axis : Take elements by matching the array and the index arrays
-
     Notes
     -----
-
+    
     By eliminating the inner loop in the description above, and using `s_` to
     build simple slice objects, `take` can be expressed  in terms of applying
     fancy indexing to each 1-d slice::
-
+    
         Ni, Nk = a.shape[:axis], a.shape[axis+1:]
         for ii in ndindex(Ni):
             for kk in ndindex(Nj):
                 out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]
-
+    
     For this reason, it is equivalent to (but faster than) the following use
     of `apply_along_axis`::
-
+    
         out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)
-
     Examples
     --------
+    
+    In this example if `a` is an ndarray, "fancy" indexing can be used.
+    
+    
+    If `indices` is not one dimensional, the output also has these dimensions.
     >>> a = [4, 3, 5, 7, 6, 8]
     >>> indices = [0, 1, 4]
     >>> np.take(a, indices)
     array([4, 3, 6])
-
-    In this example if `a` is an ndarray, "fancy" indexing can be used.
-
+    
     >>> a = np.array(a)
     >>> a[indices]
     array([4, 3, 6])
-
-    If `indices` is not one dimensional, the output also has these dimensions.
-
+    
     >>> np.take(a, [[0, 1], [2, 3]])
     array([[4, 3],
            [5, 7]])
@@ -192,14 +262,28 @@
 
 
 def _reshape_dispatcher(a, newshape, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    newshape :
+        
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 # not deprecated --- copy if necessary, view otherwise
 @array_function_dispatch(_reshape_dispatcher)
 def reshape(a, newshape, order='C'):
-    """
-    Gives a new shape to an array without changing its data.
+    """Gives a new shape to an array without changing its data.
 
     Parameters
     ----------
@@ -222,7 +306,7 @@
         the underlying array, and only refer to the order of indexing.
         'A' means to read / write the elements in Fortran-like index
         order if `a` is Fortran *contiguous* in memory, C-like order
-        otherwise.
+        otherwise. (Default value = 'C')
 
     Returns
     -------
@@ -234,42 +318,47 @@
     See Also
     --------
     ndarray.reshape : Equivalent method.
-
     Notes
     -----
     It is not always possible to change the shape of an array without
     copying the data. If you want an error to be raised when the data is copied,
     you should assign the new shape to the shape attribute of the array::
-
-     >>> a = np.zeros((10, 2))
-
+    
+    
      # A transpose makes the array non-contiguous
-     >>> b = a.T
-
+    
      # Taking a view makes it possible to modify the shape without modifying
      # the initial object.
+    
+    The `order` keyword gives the index ordering both for *fetching* the values
+    from `a`, and then *placing* the values into the output array.
+    For example, let's say you have an array:
+    
+    
+    You can think of reshaping as first raveling the array (using the given
+    index order), then inserting the elements from the raveled array into the
+    new array using the same kind of index ordering as was used for the
+    raveling.
+    
+    Examples
+    --------
+    >>> a = np.zeros((10, 2))
+    
+     >>> b = a.T
+    
      >>> c = b.view()
      >>> c.shape = (20)
      Traceback (most recent call last):
         ...
      AttributeError: Incompatible shape for in-place modification. Use
      `.reshape()` to make a copy with the desired shape.
-
-    The `order` keyword gives the index ordering both for *fetching* the values
-    from `a`, and then *placing* the values into the output array.
-    For example, let's say you have an array:
-
+    
     >>> a = np.arange(6).reshape((3, 2))
     >>> a
     array([[0, 1],
            [2, 3],
            [4, 5]])
-
-    You can think of reshaping as first raveling the array (using the given
-    index order), then inserting the elements from the raveled array into the
-    new array using the same kind of index ordering as was used for the
-    raveling.
-
+    
     >>> np.reshape(a, (2, 3)) # C-like index ordering
     array([[0, 1, 2],
            [3, 4, 5]])
@@ -282,15 +371,13 @@
     >>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
     array([[0, 4, 3],
            [2, 1, 5]])
-
-    Examples
-    --------
+    
     >>> a = np.array([[1,2,3], [4,5,6]])
     >>> np.reshape(a, 6)
     array([1, 2, 3, 4, 5, 6])
     >>> np.reshape(a, 6, order='F')
     array([1, 4, 2, 5, 3, 6])
-
+    
     >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
     array([[1, 2],
            [3, 4],
@@ -300,6 +387,23 @@
 
 
 def _choose_dispatcher(a, choices, out=None, mode=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    choices :
+        
+    out :
+         (Default value = None)
+    mode :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     yield a
     yield from choices
     yield out
@@ -307,36 +411,35 @@
 
 @array_function_dispatch(_choose_dispatcher)
 def choose(a, choices, out=None, mode='raise'):
-    """
-    Construct an array from an index array and a set of arrays to choose from.
-
+    """Construct an array from an index array and a set of arrays to choose from.
+    
     First of all, if confused or uncertain, definitely look at the Examples -
     in its full generality, this function is less simple than it might
     seem from the following code description (below ndi =
     `numpy.lib.index_tricks`):
-
+    
     ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.
-
+    
     But this omits some subtleties.  Here is a fully general summary:
-
+    
     Given an "index" array (`a`) of integers and a sequence of `n` arrays
     (`choices`), `a` and each choice array are first broadcast, as necessary,
     to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
     0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
     for each `i`.  Then, a new array with shape ``Ba.shape`` is created as
     follows:
-
+    
     * if ``mode=raise`` (the default), then, first of all, each element of
       `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that
       `i` (in that range) is the value at the `(j0, j1, ..., jm)` position
       in `Ba` - then the value at the same position in the new array is the
       value in `Bchoices[i]` at that same position;
-
+    
     * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)
       integer; modular arithmetic is used to map integers outside the range
       `[0, n-1]` back into that range; and then the new array is constructed
       as above;
-
+    
     * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)
       integer; negative integers are mapped to 0; values greater than `n-1`
       are mapped to `n-1`; and then the new array is constructed as above.
@@ -355,13 +458,12 @@
     out : array, optional
         If provided, the result will be inserted into this array. It should
         be of the appropriate shape and dtype. Note that `out` is always
-        buffered if `mode='raise'`; use other modes for better performance.
+        buffered if `mode='raise'`; use other modes for better performance. (Default value = None)
     mode : {'raise' (default), 'wrap', 'clip'}, optional
         Specifies how indices outside `[0, n-1]` will be treated:
-
-          * 'raise' : an exception is raised
-          * 'wrap' : value becomes value mod `n`
-          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1
+        * 'raise' : an exception is raised
+        * 'wrap' : value becomes value mod `n`
+        * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1 (Default value = 'raise')
 
     Returns
     -------
@@ -370,7 +472,7 @@
 
     Raises
     ------
-    ValueError: shape mismatch
+    ValueError
         If `a` and each choice array are not all broadcastable to the same
         shape.
 
@@ -378,17 +480,17 @@
     --------
     ndarray.choose : equivalent method
     numpy.take_along_axis : Preferable if `choices` is an array
-
     Notes
     -----
     To reduce the chance of misinterpretation, even though the following
     "abuse" is nominally supported, `choices` should neither be, nor be
     thought of as, a single array, i.e., the outermost sequence-like container
     should be either a list or a tuple.
-
     Examples
     --------
-
+    
+    
+    A couple examples illustrating how choose broadcasts:
     >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
     ...   [20, 21, 22, 23], [30, 31, 32, 33]]
     >>> np.choose([2, 3, 1, 0], choices
@@ -404,16 +506,14 @@
     >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
     array([20,  1, 12,  3])
     >>> # i.e., 0
-
-    A couple examples illustrating how choose broadcasts:
-
+    
     >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
     >>> choices = [-10, 10]
     >>> np.choose(a, choices)
     array([[ 10, -10,  10],
            [-10,  10, -10],
            [ 10, -10,  10]])
-
+    
     >>> # With thanks to Anne Archibald
     >>> a = np.array([0, 1]).reshape((2,1,1))
     >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
@@ -425,19 +525,32 @@
            [[-1, -2, -3, -4, -5],
             [-1, -2, -3, -4, -5],
             [-1, -2, -3, -4, -5]]])
-
     """
     return _wrapfunc(a, 'choose', choices, out=out, mode=mode)
 
 
 def _repeat_dispatcher(a, repeats, axis=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    repeats :
+        
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_repeat_dispatcher)
 def repeat(a, repeats, axis=None):
-    """
-    Repeat elements of an array.
+    """Repeat elements of an array.
 
     Parameters
     ----------
@@ -459,7 +572,6 @@
     See Also
     --------
     tile : Tile an array.
-
     Examples
     --------
     >>> np.repeat(3, 4)
@@ -474,25 +586,40 @@
     array([[1, 2],
            [3, 4],
            [3, 4]])
-
     """
     return _wrapfunc(a, 'repeat', repeats, axis=axis)
 
 
 def _put_dispatcher(a, ind, v, mode=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    ind :
+        
+    v :
+        
+    mode :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, ind, v)
 
 
 @array_function_dispatch(_put_dispatcher)
 def put(a, ind, v, mode='raise'):
-    """
-    Replaces specified elements of an array with given values.
-
+    """Replaces specified elements of an array with given values.
+    
     The indexing works on the flattened target array. `put` is roughly
     equivalent to:
-
+    
     ::
-
+    
         a.flat[ind] = v
 
     Parameters
@@ -506,33 +633,32 @@
         `ind` it will be repeated as necessary.
     mode : {'raise', 'wrap', 'clip'}, optional
         Specifies how out-of-bounds indices will behave.
-
         * 'raise' -- raise an error (default)
         * 'wrap' -- wrap around
         * 'clip' -- clip to the range
-
         'clip' mode means that all indices that are too large are replaced
         by the index that addresses the last element along that axis. Note
         that this disables indexing with negative numbers. In 'raise' mode,
         if an exception occurs the target array may still be modified.
 
+    Returns
+    -------
+
     See Also
     --------
     putmask, place
     put_along_axis : Put elements by matching the array and the index arrays
-
     Examples
     --------
     >>> a = np.arange(5)
     >>> np.put(a, [0, 2], [-44, -55])
     >>> a
     array([-44,   1, -55,   3,   4])
-
+    
     >>> a = np.arange(5)
     >>> np.put(a, 22, -5, mode='clip')
     >>> a
     array([ 0,  1,  2,  3, -5])
-
     """
     try:
         put = a.put
@@ -544,13 +670,27 @@
 
 
 def _swapaxes_dispatcher(a, axis1, axis2):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis1 :
+        
+    axis2 :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_swapaxes_dispatcher)
 def swapaxes(a, axis1, axis2):
-    """
-    Interchange two axes of an array.
+    """Interchange two axes of an array.
 
     Parameters
     ----------
@@ -576,33 +716,44 @@
     array([[1],
            [2],
            [3]])
-
+    
     >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
     >>> x
     array([[[0, 1],
             [2, 3]],
            [[4, 5],
             [6, 7]]])
-
+    
     >>> np.swapaxes(x,0,2)
     array([[[0, 4],
             [2, 6]],
            [[1, 5],
             [3, 7]]])
-
     """
     return _wrapfunc(a, 'swapaxes', axis1, axis2)
 
 
 def _transpose_dispatcher(a, axes=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axes :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_transpose_dispatcher)
 def transpose(a, axes=None):
-    """
-    Reverse or permute the axes of an array; returns the modified array.
-
+    """Reverse or permute the axes of an array; returns the modified array.
+    
     For an array a with two axes, transpose(a) gives the matrix transpose.
 
     Parameters
@@ -626,49 +777,64 @@
     --------
     moveaxis
     argsort
-
     Notes
     -----
     Use `transpose(a, argsort(axes))` to invert the transposition of tensors
     when using the `axes` keyword argument.
-
+    
     Transposing a 1-D array returns an unchanged view of the original array.
-
     Examples
     --------
     >>> x = np.arange(4).reshape((2,2))
     >>> x
     array([[0, 1],
            [2, 3]])
-
+    
     >>> np.transpose(x)
     array([[0, 2],
            [1, 3]])
-
+    
     >>> x = np.ones((1, 2, 3))
     >>> np.transpose(x, (1, 0, 2)).shape
     (2, 1, 3)
-
     """
     return _wrapfunc(a, 'transpose', axes)
 
 
 def _partition_dispatcher(a, kth, axis=None, kind=None, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    kth :
+        
+    axis :
+         (Default value = None)
+    kind :
+         (Default value = None)
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_partition_dispatcher)
 def partition(a, kth, axis=-1, kind='introselect', order=None):
-    """
-    Return a partitioned copy of an array.
-
+    """Return a partitioned copy of an array.
+    
     Creates a copy of the array with its elements rearranged in such a
     way that the value of the element in k-th position is in the
     position it would be in a sorted array. All elements smaller than
     the k-th element are moved before this element and all equal or
     greater are moved behind it. The ordering of the elements in the two
     partitions is undefined.
-
+    
     .. versionadded:: 1.8.0
 
     Parameters
@@ -692,7 +858,7 @@
         specifies which fields to compare first, second, etc.  A single
         field can be specified as a string.  Not all fields need be
         specified, but unspecified fields will still be used, in the
-        order in which they come up in the dtype, to break ties.
+        order in which they come up in the dtype, to break ties. (Default value = None)
 
     Returns
     -------
@@ -704,7 +870,6 @@
     ndarray.partition : Method to sort an array in-place.
     argpartition : Indirect partition.
     sort : Full sorting
-
     Notes
     -----
     The various selection algorithms are characterized by their average
@@ -712,32 +877,30 @@
     stable. A stable sort keeps items with the same key in the same
     relative order. The available algorithms have the following
     properties:
-
+    
     ================= ======= ============= ============ =======
        kind            speed   worst case    work space  stable
     ================= ======= ============= ============ =======
     'introselect'        1        O(n)           0         no
     ================= ======= ============= ============ =======
-
+    
     All the partition algorithms make temporary copies of the data when
     partitioning along any but the last axis.  Consequently,
     partitioning along the last axis is faster and uses less space than
     partitioning along any other axis.
-
+    
     The sort order for complex numbers is lexicographic. If both the
     real and imaginary parts are non-nan then the order is determined by
     the real parts except when they are equal, in which case the order
     is determined by the imaginary parts.
-
     Examples
     --------
     >>> a = np.array([3, 4, 2, 1])
     >>> np.partition(a, 3)
     array([2, 1, 3, 4])
-
+    
     >>> np.partition(a, (1, 3))
     array([1, 2, 3, 4])
-
     """
     if axis is None:
         # flatten returns (1, N) for np.matrix, so always use the last axis
@@ -750,17 +913,35 @@
 
 
 def _argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    kth :
+        
+    axis :
+         (Default value = None)
+    kind :
+         (Default value = None)
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_argpartition_dispatcher)
 def argpartition(a, kth, axis=-1, kind='introselect', order=None):
-    """
-    Perform an indirect partition along the given axis using the
+    """Perform an indirect partition along the given axis using the
     algorithm specified by the `kind` keyword. It returns an array of
     indices of the same shape as `a` that index data along the given
     axis in partitioned order.
-
+    
     .. versionadded:: 1.8.0
 
     Parameters
@@ -784,7 +965,7 @@
         specifies which fields to compare first, second, etc. A single
         field can be specified as a string, and not all fields need be
         specified, but unspecified fields will still be used, in the
-        order in which they come up in the dtype, to break ties.
+        order in which they come up in the dtype, to break ties. (Default value = None)
 
     Returns
     -------
@@ -801,45 +982,59 @@
     argsort : Full indirect sort.
     take_along_axis : Apply ``index_array`` from argpartition
                       to an array as if by calling partition.
-
     Notes
     -----
     See `partition` for notes on the different selection algorithms.
-
     Examples
     --------
     One dimensional array:
-
+    
+    
+    
+    Multi-dimensional array:
     >>> x = np.array([3, 4, 2, 1])
     >>> x[np.argpartition(x, 3)]
     array([2, 1, 3, 4])
     >>> x[np.argpartition(x, (1, 3))]
     array([1, 2, 3, 4])
-
+    
     >>> x = [3, 4, 2, 1]
     >>> np.array(x)[np.argpartition(x, 3)]
     array([2, 1, 3, 4])
-
-    Multi-dimensional array:
-
+    
     >>> x = np.array([[3, 4, 2], [1, 3, 1]])
     >>> index_array = np.argpartition(x, kth=1, axis=-1)
     >>> np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)
     array([[2, 3, 4],
            [1, 1, 3]])
-
     """
     return _wrapfunc(a, 'argpartition', kth, axis=axis, kind=kind, order=order)
 
 
 def _sort_dispatcher(a, axis=None, kind=None, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    kind :
+         (Default value = None)
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_sort_dispatcher)
 def sort(a, axis=-1, kind=None, order=None):
-    """
-    Return a sorted copy of an array.
+    """Return a sorted copy of an array.
 
     Parameters
     ----------
@@ -853,16 +1048,14 @@
         and 'mergesort' use timsort or radix sort under the covers and, in general,
         the actual implementation will vary with data type. The 'mergesort' option
         is retained for backwards compatibility.
-
         .. versionchanged:: 1.15.0.
-           The 'stable' option was added.
-
+        The 'stable' option was added.
     order : str or list of str, optional
         When `a` is an array with fields defined, this argument specifies
         which fields to compare first, second, etc.  A single field can
         be specified as a string, and not all fields need be specified,
         but unspecified fields will still be used, in the order in which
-        they come up in the dtype, to break ties.
+        they come up in the dtype, to break ties. (Default value = None)
 
     Returns
     -------
@@ -876,7 +1069,6 @@
     lexsort : Indirect stable sort on multiple keys.
     searchsorted : Find elements in a sorted array.
     partition : Partial sort.
-
     Notes
     -----
     The various sorting algorithms are characterized by their average speed,
@@ -884,7 +1076,7 @@
     stable sort keeps items with the same key in the same relative
     order. The four algorithms implemented in NumPy have the following
     properties:
-
+    
     =========== ======= ============= ============ ========
        kind      speed   worst case    work space   stable
     =========== ======= ============= ============ ========
@@ -893,39 +1085,39 @@
     'mergesort'    2     O(n*log(n))      ~n/2        yes
     'timsort'      2     O(n*log(n))      ~n/2        yes
     =========== ======= ============= ============ ========
-
+    
     .. note:: The datatype determines which of 'mergesort' or 'timsort'
        is actually used, even if 'mergesort' is specified. User selection
        at a finer scale is not currently available.
-
+    
     All the sort algorithms make temporary copies of the data when
     sorting along any but the last axis.  Consequently, sorting along
     the last axis is faster and uses less space than sorting along
     any other axis.
-
+    
     The sort order for complex numbers is lexicographic. If both the real
     and imaginary parts are non-nan then the order is determined by the
     real parts except when they are equal, in which case the order is
     determined by the imaginary parts.
-
+    
     Previous to numpy 1.4.0 sorting real and complex arrays containing nan
     values led to undefined behaviour. In numpy versions >= 1.4.0 nan
     values are sorted to the end. The extended sort order is:
-
+    
       * Real: [R, nan]
       * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
-
+    
     where R is a non-nan real value. Complex values with the same nan
     placements are sorted according to the non-nan part if it exists.
     Non-nan values are sorted as before.
-
+    
     .. versionadded:: 1.12.0
-
+    
     quicksort has been changed to `introsort <https://en.wikipedia.org/wiki/Introsort>`_.
     When sorting does not make enough progress it switches to
     `heapsort <https://en.wikipedia.org/wiki/Heapsort>`_.
     This implementation makes quicksort O(n*log(n)) in the worst case.
-
+    
     'stable' automatically chooses the best stable sorting algorithm
     for the data type being sorted.
     It, along with 'mergesort' is currently mapped to
@@ -935,9 +1127,9 @@
     API forward compatibility currently limits the
     ability to select the implementation and it is hardwired for the different
     data types.
-
+    
     .. versionadded:: 1.17.0
-
+    
     Timsort is added for better performance on already or nearly
     sorted data. On random data timsort is almost identical to
     mergesort. It is now used for stable sort while quicksort is still the
@@ -945,13 +1137,18 @@
     `CPython listsort.txt <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_.
     'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an
     O(n) sort instead of O(n log n).
-
+    
     .. versionchanged:: 1.18.0
-
+    
     NaT now sorts to the end of arrays for consistency with NaN.
-
     Examples
     --------
+    
+    Use the `order` keyword to specify a field to use when sorting a
+    structured array:
+    
+    
+    Sort by age, then height if ages are equal:
     >>> a = np.array([[1,4],[3,1]])
     >>> np.sort(a)                # sort along the last axis
     array([[1, 4],
@@ -961,10 +1158,7 @@
     >>> np.sort(a, axis=0)        # sort along the first axis
     array([[1, 1],
            [3, 4]])
-
-    Use the `order` keyword to specify a field to use when sorting a
-    structured array:
-
+    
     >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
     >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
     ...           ('Galahad', 1.7, 38)]
@@ -973,14 +1167,11 @@
     array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
            ('Lancelot', 1.8999999999999999, 38)],
           dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
-
-    Sort by age, then height if ages are equal:
-
+    
     >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
     array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
            ('Arthur', 1.8, 41)],
           dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
-
     """
     if axis is None:
         # flatten returns (1, N) for np.matrix, so always use the last axis
@@ -993,14 +1184,30 @@
 
 
 def _argsort_dispatcher(a, axis=None, kind=None, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    kind :
+         (Default value = None)
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_argsort_dispatcher)
 def argsort(a, axis=-1, kind=None, order=None):
-    """
-    Returns the indices that would sort an array.
-
+    """Returns the indices that would sort an array.
+    
     Perform an indirect sort along the given axis using the algorithm specified
     by the `kind` keyword. It returns an array of indices of the same shape as
     `a` that index data along the given axis in sorted order.
@@ -1017,15 +1224,14 @@
         and 'mergesort' use timsort under the covers and, in general, the
         actual implementation will vary with data type. The 'mergesort' option
         is retained for backwards compatibility.
-
         .. versionchanged:: 1.15.0.
-           The 'stable' option was added.
+        The 'stable' option was added.
     order : str or list of str, optional
         When `a` is an array with fields defined, this argument specifies
         which fields to compare first, second, etc.  A single field can
         be specified as a string, and not all fields need be specified,
         but unspecified fields will still be used, in the order in which
-        they come up in the dtype, to break ties.
+        they come up in the dtype, to break ties. (Default value = None)
 
     Returns
     -------
@@ -1043,29 +1249,35 @@
     argpartition : Indirect partial sort.
     take_along_axis : Apply ``index_array`` from argsort
                       to an array as if by calling sort.
-
     Notes
     -----
     See `sort` for notes on the different sorting algorithms.
-
+    
     As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
     nan values. The enhanced sort order is documented in `sort`.
-
     Examples
     --------
     One dimensional array:
-
+    
+    
+    Two-dimensional array:
+    
+    
+    
+    
+    Indices of the sorted elements of a N-dimensional array:
+    
+    
+    Sorting with keys:
     >>> x = np.array([3, 1, 2])
     >>> np.argsort(x)
     array([1, 2, 0])
-
-    Two-dimensional array:
-
+    
     >>> x = np.array([[0, 3], [2, 2]])
     >>> x
     array([[0, 3],
            [2, 2]])
-
+    
     >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)
     >>> ind
     array([[0, 1],
@@ -1073,7 +1285,7 @@
     >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
     array([[0, 2],
            [2, 3]])
-
+    
     >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)
     >>> ind
     array([[0, 1],
@@ -1081,40 +1293,49 @@
     >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
     array([[0, 3],
            [2, 2]])
-
-    Indices of the sorted elements of a N-dimensional array:
-
+    
     >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
     >>> ind
     (array([0, 1, 1, 0]), array([0, 0, 1, 1]))
     >>> x[ind]  # same as np.sort(x, axis=None)
     array([0, 2, 2, 3])
-
-    Sorting with keys:
-
+    
     >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
     >>> x
     array([(1, 0), (0, 1)],
           dtype=[('x', '<i4'), ('y', '<i4')])
-
+    
     >>> np.argsort(x, order=('x','y'))
     array([1, 0])
-
+    
     >>> np.argsort(x, order=('y','x'))
     array([0, 1])
-
     """
     return _wrapfunc(a, 'argsort', axis=axis, kind=kind, order=order)
 
 
 def _argmax_dispatcher(a, axis=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_argmax_dispatcher)
 def argmax(a, axis=None, out=None):
-    """
-    Returns the indices of the maximum values along an axis.
+    """Returns the indices of the maximum values along an axis.
 
     Parameters
     ----------
@@ -1125,7 +1346,7 @@
         along the specified axis.
     out : array, optional
         If provided, the result will be inserted into this array. It should
-        be of the appropriate shape and dtype.
+        be of the appropriate shape and dtype. (Default value = None)
 
     Returns
     -------
@@ -1140,14 +1361,14 @@
     unravel_index : Convert a flat index into an index tuple.
     take_along_axis : Apply ``np.expand_dims(index_array, axis)``
                       from argmax to an array as if by calling max.
-
     Notes
     -----
     In case of multiple occurrences of the maximum values, the indices
     corresponding to the first occurrence are returned.
-
     Examples
     --------
+    
+    Indexes of the maximal elements of a N-dimensional array:
     >>> a = np.arange(6).reshape(2,3) + 10
     >>> a
     array([[10, 11, 12],
@@ -1158,22 +1379,20 @@
     array([1, 1, 1])
     >>> np.argmax(a, axis=1)
     array([2, 2])
-
-    Indexes of the maximal elements of a N-dimensional array:
-
+    
     >>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
     >>> ind
     (1, 2)
     >>> a[ind]
     15
-
+    
     >>> b = np.arange(6)
     >>> b[1] = 5
     >>> b
     array([0, 5, 2, 3, 4, 5])
     >>> np.argmax(b)  # Only the first occurrence is returned.
     1
-
+    
     >>> x = np.array([[4,2,3], [1,0,3]])
     >>> index_array = np.argmax(x, axis=-1)
     >>> # Same as np.max(x, axis=-1, keepdims=True)
@@ -1183,19 +1402,32 @@
     >>> # Same as np.max(x, axis=-1)
     >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
     array([4, 3])
-
     """
     return _wrapfunc(a, 'argmax', axis=axis, out=out)
 
 
 def _argmin_dispatcher(a, axis=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_argmin_dispatcher)
 def argmin(a, axis=None, out=None):
-    """
-    Returns the indices of the minimum values along an axis.
+    """Returns the indices of the minimum values along an axis.
 
     Parameters
     ----------
@@ -1206,7 +1438,7 @@
         along the specified axis.
     out : array, optional
         If provided, the result will be inserted into this array. It should
-        be of the appropriate shape and dtype.
+        be of the appropriate shape and dtype. (Default value = None)
 
     Returns
     -------
@@ -1221,14 +1453,14 @@
     unravel_index : Convert a flat index into an index tuple.
     take_along_axis : Apply ``np.expand_dims(index_array, axis)``
                       from argmin to an array as if by calling min.
-
     Notes
     -----
     In case of multiple occurrences of the minimum values, the indices
     corresponding to the first occurrence are returned.
-
     Examples
     --------
+    
+    Indices of the minimum elements of a N-dimensional array:
     >>> a = np.arange(6).reshape(2,3) + 10
     >>> a
     array([[10, 11, 12],
@@ -1239,22 +1471,20 @@
     array([0, 0, 0])
     >>> np.argmin(a, axis=1)
     array([0, 0])
-
-    Indices of the minimum elements of a N-dimensional array:
-
+    
     >>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
     >>> ind
     (0, 0)
     >>> a[ind]
     10
-
+    
     >>> b = np.arange(6) + 10
     >>> b[4] = 10
     >>> b
     array([10, 11, 12, 13, 10, 15])
     >>> np.argmin(b)  # Only the first occurrence is returned.
     0
-
+    
     >>> x = np.array([[4,2,3], [1,0,3]])
     >>> index_array = np.argmin(x, axis=-1)
     >>> # Same as np.min(x, axis=-1, keepdims=True)
@@ -1264,26 +1494,41 @@
     >>> # Same as np.max(x, axis=-1)
     >>> np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)
     array([2, 0])
-
     """
     return _wrapfunc(a, 'argmin', axis=axis, out=out)
 
 
 def _searchsorted_dispatcher(a, v, side=None, sorter=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    v :
+        
+    side :
+         (Default value = None)
+    sorter :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, v, sorter)
 
 
 @array_function_dispatch(_searchsorted_dispatcher)
 def searchsorted(a, v, side='left', sorter=None):
-    """
-    Find indices where elements should be inserted to maintain order.
-
+    """Find indices where elements should be inserted to maintain order.
+    
     Find the indices into a sorted array `a` such that, if the
     corresponding elements in `v` were inserted before the indices, the
     order of `a` would be preserved.
-
+    
     Assuming that `a` is sorted:
-
+    
     ======  ============================
     `side`  returned index `i` satisfies
     ======  ============================
@@ -1302,12 +1547,11 @@
     side : {'left', 'right'}, optional
         If 'left', the index of the first suitable location found is given.
         If 'right', return the last such index.  If there is no suitable
-        index, return either 0 or N (where N is the length of `a`).
+        index, return either 0 or N (where N is the length of `a`). (Default value = 'left')
     sorter : 1-D array_like, optional
         Optional array of integer indices that sort array a into ascending
         order. They are typically the result of argsort.
-
-        .. versionadded:: 1.7.0
+        .. versionadded:: 1.7.0 (Default value = None)
 
     Returns
     -------
@@ -1318,18 +1562,16 @@
     --------
     sort : Return a sorted copy of an array.
     histogram : Produce histogram from 1-D data.
-
     Notes
     -----
     Binary search is used to find the required insertion points.
-
+    
     As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
     `nan` values. The enhanced sort order is documented in `sort`.
-
+    
     This function uses the same algorithm as the builtin python `bisect.bisect_left`
     (``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
     which is also vectorized in the `v` argument.
-
     Examples
     --------
     >>> np.searchsorted([1,2,3,4,5], 3)
@@ -1338,20 +1580,31 @@
     3
     >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
     array([0, 5, 1, 2])
-
     """
     return _wrapfunc(a, 'searchsorted', v, side=side, sorter=sorter)
 
 
 def _resize_dispatcher(a, new_shape):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    new_shape :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_resize_dispatcher)
 def resize(a, new_shape):
-    """
-    Return a new array with the specified shape.
-
+    """Return a new array with the specified shape.
+    
     If the new array is larger than the original array, then the new
     array is filled with repeated copies of `a`.  Note that this behavior
     is different from a.resize(new_shape) which fills with zeros instead
@@ -1361,7 +1614,6 @@
     ----------
     a : array_like
         Array to be resized.
-
     new_shape : int or tuple of int
         Shape of resized array.
 
@@ -1375,7 +1627,6 @@
     See Also
     --------
     ndarray.resize : resize an array in-place.
-
     Notes
     -----
     Warning: This functionality does **not** consider axes separately,
@@ -1385,7 +1636,6 @@
     (This is in case the new shape is smaller. For larger, see above.)
     This functionality is therefore not suitable to resize images,
     or data where each axis represents a separate and distinct entity.
-
     Examples
     --------
     >>> a=np.array([[0,1],[2,3]])
@@ -1397,7 +1647,6 @@
     >>> np.resize(a,(2,4))
     array([[0, 1, 2, 3],
            [0, 1, 2, 3]])
-
     """
     if isinstance(new_shape, (int, nt.integer)):
         new_shape = (new_shape,)
@@ -1422,13 +1671,25 @@
 
 
 def _squeeze_dispatcher(a, axis=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_squeeze_dispatcher)
 def squeeze(a, axis=None):
-    """
-    Remove single-dimensional entries from the shape of an array.
+    """Remove single-dimensional entries from the shape of an array.
 
     Parameters
     ----------
@@ -1436,10 +1697,9 @@
         Input data.
     axis : None or int or tuple of ints, optional
         .. versionadded:: 1.7.0
-
         Selects a subset of the single-dimensional entries in the
         shape. If an axis is selected with shape entry greater than
-        one, an error is raised.
+        one, an error is raised. (Default value = None)
 
     Returns
     -------
@@ -1458,7 +1718,6 @@
     --------
     expand_dims : The inverse operation, adding singleton dimensions
     reshape : Insert, remove, and combine dimensions, and resize existing ones
-
     Examples
     --------
     >>> x = np.array([[[0], [1], [2]]])
@@ -1483,7 +1742,6 @@
     ()
     >>> np.squeeze(x)[()]
     1234
-
     """
     try:
         squeeze = a.squeeze
@@ -1496,14 +1754,30 @@
 
 
 def _diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    offset :
+         (Default value = None)
+    axis1 :
+         (Default value = None)
+    axis2 :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_diagonal_dispatcher)
 def diagonal(a, offset=0, axis1=0, axis2=1):
-    """
-    Return specified diagonals.
-
+    """Return specified diagonals.
+    
     If `a` is 2-D, returns the diagonal of `a` with the given offset,
     i.e., the collection of elements of the form ``a[i, i+offset]``.  If
     `a` has more than two dimensions, then the axes specified by `axis1`
@@ -1511,24 +1785,24 @@
     returned.  The shape of the resulting array can be determined by
     removing `axis1` and `axis2` and appending an index to the right equal
     to the size of the resulting diagonals.
-
+    
     In versions of NumPy prior to 1.7, this function always returned a new,
     independent array containing a copy of the values in the diagonal.
-
+    
     In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
     but depending on this fact is deprecated. Writing to the resulting
     array continues to work as it used to, but a FutureWarning is issued.
-
+    
     Starting in NumPy 1.9 it returns a read-only view on the original array.
     Attempting to write to the resulting array will produce an error.
-
+    
     In some future release, it will return a read/write view and writing to
     the returned array will alter your original array.  The returned array
     will have the same type as the input array.
-
+    
     If you don't write to the array returned by this function, then you can
     just ignore all of the above.
-
+    
     If you depend on the current behavior, then we suggest copying the
     returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
     of just ``np.diagonal(a)``. This will work with both past and future
@@ -1555,7 +1829,6 @@
         same type as `a` is returned unless `a` is a `matrix`, in which case
         a 1-D array rather than a (2-D) `matrix` is returned in order to
         maintain backward compatibility.
-
         If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`
         are removed, and a new axis inserted at the end corresponding to the
         diagonal.
@@ -1570,9 +1843,23 @@
     diag : MATLAB work-a-like for 1-D and 2-D arrays.
     diagflat : Create diagonal arrays.
     trace : Sum along diagonals.
-
     Examples
     --------
+    
+    A 3-D example:
+    
+    
+    The sub-arrays whose main diagonals we just obtained; note that each
+    corresponds to fixing the right-most (column) axis, and that the
+    diagonals are "packed" in rows.
+    
+    
+    The anti-diagonal can be obtained by reversing the order of elements
+    using either `numpy.flipud` or `numpy.fliplr`.
+    
+    
+    Note that the order in which the diagonal is retrieved varies depending
+    on the flip function.
     >>> a = np.arange(4).reshape(2,2)
     >>> a
     array([[0, 1],
@@ -1581,9 +1868,7 @@
     array([0, 3])
     >>> a.diagonal(1)
     array([1])
-
-    A 3-D example:
-
+    
     >>> a = np.arange(8).reshape(2,2,2); a
     array([[[0, 1],
             [2, 3]],
@@ -1594,21 +1879,14 @@
     ...            1)  # the "middle" (row) axis first.
     array([[0, 6],
            [1, 7]])
-
-    The sub-arrays whose main diagonals we just obtained; note that each
-    corresponds to fixing the right-most (column) axis, and that the
-    diagonals are "packed" in rows.
-
+    
     >>> a[:,:,0]  # main diagonal is [0 6]
     array([[0, 2],
            [4, 6]])
     >>> a[:,:,1]  # main diagonal is [1 7]
     array([[1, 3],
            [5, 7]])
-
-    The anti-diagonal can be obtained by reversing the order of elements
-    using either `numpy.flipud` or `numpy.fliplr`.
-
+    
     >>> a = np.arange(9).reshape(3, 3)
     >>> a
     array([[0, 1, 2],
@@ -1618,9 +1896,6 @@
     array([2, 4, 6])
     >>> np.flipud(a).diagonal()  # Vertical flip
     array([6, 4, 2])
-
-    Note that the order in which the diagonal is retrieved varies depending
-    on the flip function.
     """
     if isinstance(a, np.matrix):
         # Make diagonal of matrix 1-D to preserve backward compatibility.
@@ -1631,17 +1906,37 @@
 
 def _trace_dispatcher(
         a, offset=None, axis1=None, axis2=None, dtype=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    offset :
+         (Default value = None)
+    axis1 :
+         (Default value = None)
+    axis2 :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_trace_dispatcher)
 def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):
-    """
-    Return the sum along diagonals of the array.
-
+    """Return the sum along diagonals of the array.
+    
     If `a` is 2-D, the sum along its diagonal with the given offset
     is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.
-
+    
     If `a` has more than two dimensions, then the axes specified by axis1 and
     axis2 are used to determine the 2-D sub-arrays whose traces are returned.
     The shape of the resulting array is the same as that of `a` with `axis1`
@@ -1666,7 +1961,11 @@
         the precision is the same as that of `a`.
     out : ndarray, optional
         Array into which the output is placed. Its type is preserved and
-        it must be of the right shape to hold the output.
+        it must be of the right shape to hold the output. (Default value = None)
+    axis1 :
+         (Default value = 0)
+    axis2 :
+         (Default value = 1)
 
     Returns
     -------
@@ -1677,7 +1976,6 @@
     See Also
     --------
     diag, diagonal, diagflat
-
     Examples
     --------
     >>> np.trace(np.eye(3))
@@ -1685,11 +1983,10 @@
     >>> a = np.arange(8).reshape((2,2,2))
     >>> np.trace(a)
     array([6, 8])
-
+    
     >>> a = np.arange(24).reshape((2,2,2,3))
     >>> np.trace(a).shape
     (2, 3)
-
     """
     if isinstance(a, np.matrix):
         # Get trace of matrix via an array to preserve backward compatibility.
@@ -1699,16 +1996,29 @@
 
 
 def _ravel_dispatcher(a, order=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    order :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_ravel_dispatcher)
 def ravel(a, order='C'):
     """Return a contiguous flattened array.
-
+    
     A 1-D array, containing the elements of the input, is returned.  A copy is
     made only if needed.
-
+    
     As of NumPy 1.10, the returned array will have the same type as the input
     array. (for example, a masked array will be returned for a masked array
     input)
@@ -1719,7 +2029,6 @@
         Input array.  The elements in `a` are read in the order specified by
         `order`, and packed as a 1-D array.
     order : {'C','F', 'A', 'K'}, optional
-
         The elements of `a` are read using this index order. 'C' means
         to index the elements in row-major, C-style order,
         with the last axis index changing fastest, back to the first
@@ -1748,7 +2057,6 @@
     ndarray.flatten : 1-D array copy of the elements of an array
                       in row-major order.
     ndarray.reshape : Change the shape of an array without changing its data.
-
     Notes
     -----
     In row-major, C-style order, in two dimensions, the row index
@@ -1757,41 +2065,43 @@
     implies that the index along the first axis varies slowest, and
     the index along the last quickest.  The opposite holds for
     column-major, Fortran-style index ordering.
-
+    
     When a view is desired in as many cases as possible, ``arr.reshape(-1)``
     may be preferable.
-
     Examples
     --------
     It is equivalent to ``reshape(-1, order=order)``.
-
+    
+    
+    
+    
+    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:
+    
+    
+    When ``order`` is 'K', it will preserve orderings that are neither 'C'
+    nor 'F', but won't reverse axes:
     >>> x = np.array([[1, 2, 3], [4, 5, 6]])
     >>> np.ravel(x)
     array([1, 2, 3, 4, 5, 6])
-
+    
     >>> x.reshape(-1)
     array([1, 2, 3, 4, 5, 6])
-
+    
     >>> np.ravel(x, order='F')
     array([1, 4, 2, 5, 3, 6])
-
-    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:
-
+    
     >>> np.ravel(x.T)
     array([1, 4, 2, 5, 3, 6])
     >>> np.ravel(x.T, order='A')
     array([1, 2, 3, 4, 5, 6])
-
-    When ``order`` is 'K', it will preserve orderings that are neither 'C'
-    nor 'F', but won't reverse axes:
-
+    
     >>> a = np.arange(3)[::-1]; a
     array([2, 1, 0])
     >>> a.ravel(order='C')
     array([2, 1, 0])
     >>> a.ravel(order='K')
     array([2, 1, 0])
-
+    
     >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
     array([[[ 0,  2,  4],
             [ 1,  3,  5]],
@@ -1801,7 +2111,6 @@
     array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
     >>> a.ravel(order='K')
     array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
-
     """
     if isinstance(a, np.matrix):
         return asarray(a).ravel(order=order)
@@ -1810,29 +2119,39 @@
 
 
 def _nonzero_dispatcher(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_nonzero_dispatcher)
 def nonzero(a):
-    """
-    Return the indices of the elements that are non-zero.
-
+    """Return the indices of the elements that are non-zero.
+    
     Returns a tuple of arrays, one for each dimension of `a`,
     containing the indices of the non-zero elements in that
     dimension. The values in `a` are always tested and returned in
     row-major, C-style order.
-
+    
     To group the indices by element, rather than dimension, use `argwhere`,
     which returns a row for each non-zero element.
-
+    
     .. note::
-
+    
        When called on a zero-d array or scalar, ``nonzero(a)`` is treated
        as ``nonzero(atleast1d(a))``.
-
+    
        .. deprecated:: 1.17.0
-
+    
           Use `atleast1d` explicitly if this behavior is deliberate.
 
     Parameters
@@ -1854,15 +2173,25 @@
         Equivalent ndarray method.
     count_nonzero :
         Counts the number of non-zero elements in the input array.
-
     Notes
     -----
     While the nonzero values can be obtained with ``a[nonzero(a)]``, it is
     recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which
     will correctly handle 0-d arrays.
-
     Examples
     --------
+    
+    
+    A common use for ``nonzero`` is to find the indices of an array, where
+    a condition is True.  Given an array `a`, the condition `a` > 3 is a
+    boolean array and since False is interpreted as 0, np.nonzero(a > 3)
+    yields the indices of the `a` where the condition is true.
+    
+    
+    Using this result to index `a` is equivalent to using the mask directly:
+    
+    
+    ``nonzero`` can also be called as a method of the array.
     >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
     >>> x
     array([[3, 0, 0],
@@ -1870,7 +2199,7 @@
            [5, 6, 0]])
     >>> np.nonzero(x)
     (array([0, 1, 2, 2]), array([0, 1, 0, 1]))
-
+    
     >>> x[np.nonzero(x)]
     array([3, 4, 5, 6])
     >>> np.transpose(np.nonzero(x))
@@ -1878,12 +2207,7 @@
            [1, 1],
            [2, 0],
            [2, 1]])
-
-    A common use for ``nonzero`` is to find the indices of an array, where
-    a condition is True.  Given an array `a`, the condition `a` > 3 is a
-    boolean array and since False is interpreted as 0, np.nonzero(a > 3)
-    yields the indices of the `a` where the condition is true.
-
+    
     >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
     >>> a > 3
     array([[False, False, False],
@@ -1891,31 +2215,36 @@
            [ True,  True,  True]])
     >>> np.nonzero(a > 3)
     (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
-
-    Using this result to index `a` is equivalent to using the mask directly:
-
+    
     >>> a[np.nonzero(a > 3)]
     array([4, 5, 6, 7, 8, 9])
     >>> a[a > 3]  # prefer this spelling
     array([4, 5, 6, 7, 8, 9])
-
-    ``nonzero`` can also be called as a method of the array.
-
+    
     >>> (a > 3).nonzero()
     (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
-
     """
     return _wrapfunc(a, 'nonzero')
 
 
 def _shape_dispatcher(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_shape_dispatcher)
 def shape(a):
-    """
-    Return the shape of an array.
+    """Return the shape of an array.
 
     Parameters
     ----------
@@ -1932,7 +2261,6 @@
     --------
     alen
     ndarray.shape : Equivalent array method.
-
     Examples
     --------
     >>> np.shape(np.eye(3))
@@ -1943,13 +2271,12 @@
     (1,)
     >>> np.shape(0)
     ()
-
+    
     >>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
     >>> np.shape(a)
     (2,)
     >>> a.shape
     (2,)
-
     """
     try:
         result = a.shape
@@ -1959,14 +2286,30 @@
 
 
 def _compress_dispatcher(condition, a, axis=None, out=None):
+    """
+
+    Parameters
+    ----------
+    condition :
+        
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (condition, a, out)
 
 
 @array_function_dispatch(_compress_dispatcher)
 def compress(condition, a, axis=None, out=None):
-    """
-    Return selected slices of an array along given axis.
-
+    """Return selected slices of an array along given axis.
+    
     When working along a given axis, a slice along that axis is returned in
     `output` for each index where `condition` evaluates to True. When
     working on a 1-D array, `compress` is equivalent to `extract`.
@@ -1984,7 +2327,7 @@
         flattened array.
     out : ndarray, optional
         Output array.  Its type is preserved and it must be of the right
-        shape to hold the output.
+        shape to hold the output. (Default value = None)
 
     Returns
     -------
@@ -1998,9 +2341,11 @@
     ndarray.compress : Equivalent method in ndarray
     np.extract: Equivalent method when working on 1-D arrays
     ufuncs-output-type
-
     Examples
     --------
+    
+    Working on the flattened array does not return slices along an axis but
+    selects elements.
     >>> a = np.array([[1, 2], [3, 4], [5, 6]])
     >>> a
     array([[1, 2],
@@ -2015,33 +2360,47 @@
     array([[2],
            [4],
            [6]])
-
-    Working on the flattened array does not return slices along an axis but
-    selects elements.
-
+    
     >>> np.compress([False, True], a)
     array([2])
-
     """
     return _wrapfunc(a, 'compress', condition, axis=axis, out=out)
 
 
 def _clip_dispatcher(a, a_min, a_max, out=None, **kwargs):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    a_min :
+        
+    a_max :
+        
+    out :
+         (Default value = None)
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return (a, a_min, a_max)
 
 
 @array_function_dispatch(_clip_dispatcher)
 def clip(a, a_min, a_max, out=None, **kwargs):
-    """
-    Clip (limit) the values in an array.
-
+    """Clip (limit) the values in an array.
+    
     Given an interval, values outside the interval are clipped to
     the interval edges.  For example, if an interval of ``[0, 1]``
     is specified, values smaller than 0 become 0, and values larger
     than 1 become 1.
-
+    
     Equivalent to but faster than ``np.minimum(a_max, np.maximum(a, a_min))``.
-
+    
     No check is performed to ensure ``a_min < a_max``.
 
     Parameters
@@ -2060,11 +2419,10 @@
     out : ndarray, optional
         The results will be placed in this array. It may be the input
         array for in-place clipping.  `out` must be of the right shape
-        to hold the output.  Its type is preserved.
-    **kwargs
+        to hold the output.  Its type is preserved. (Default value = None)
+    **kwargs :
         For other keyword-only arguments, see the
         :ref:`ufunc docs <ufuncs.kwargs>`.
-
         .. versionadded:: 1.17.0
 
     Returns
@@ -2077,7 +2435,6 @@
     See Also
     --------
     ufuncs-output-type
-
     Examples
     --------
     >>> a = np.arange(10)
@@ -2092,21 +2449,42 @@
     array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
     >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
     array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
-
     """
     return _wrapfunc(a, 'clip', a_min, a_max, out=out, **kwargs)
 
 
 def _sum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
                     initial=None, where=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+    initial :
+         (Default value = None)
+    where :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_sum_dispatcher)
 def sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
         initial=np._NoValue, where=np._NoValue):
-    """
-    Sum of array elements over a given axis.
+    """Sum of array elements over a given axis.
 
     Parameters
     ----------
@@ -2116,9 +2494,7 @@
         Axis or axes along which a sum is performed.  The default,
         axis=None, will sum all of the elements of the input array.  If
         axis is negative it counts from the last to the first axis.
-
         .. versionadded:: 1.7.0
-
         If axis is a tuple of ints, a sum is performed on all of the axes
         specified in the tuple instead of a single axis or all the axes as
         before.
@@ -2132,12 +2508,11 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must have
         the same shape as the expected output, but the type of the output
-        values will be cast if necessary.
+        values will be cast if necessary. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `sum` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -2145,13 +2520,10 @@
         exceptions will be raised.
     initial : scalar, optional
         Starting value for the sum. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.15.0
-
+        .. versionadded:: 1.15.0 (Default value = np._NoValue)
     where : array_like of bool, optional
         Elements to include in the sum. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.17.0
+        .. versionadded:: 1.17.0 (Default value = np._NoValue)
 
     Returns
     -------
@@ -2164,25 +2536,22 @@
     See Also
     --------
     ndarray.sum : Equivalent method.
-
+    
     add.reduce : Equivalent functionality of `add`.
-
+    
     cumsum : Cumulative sum of array elements.
-
+    
     trapz : Integration of array values using the composite trapezoidal rule.
-
+    
     mean, average
-
     Notes
     -----
     Arithmetic is modular when using integer types, and no error is
     raised on overflow.
-
+    
     The sum of an empty array is the neutral element 0:
-
-    >>> np.sum([])
-    0.0
-
+    
+    
     For floating point numbers the numerical precision of sum (and
     ``np.add.reduce``) is in general limited by directly adding each number
     individually to the result causing rounding errors in every step.
@@ -2199,9 +2568,16 @@
     numbers, such as ``float32``, numerical errors can become significant.
     In such cases it can be advisable to use `dtype="float64"` to use a higher
     precision for the output.
-
     Examples
     --------
+    
+    If the accumulator is too small, overflow occurs:
+    
+    
+    You can also start the sum with a value other than zero:
+    >>> np.sum([])
+    0.0
+    
     >>> np.sum([0.5, 1.5])
     2.0
     >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
@@ -2214,14 +2590,10 @@
     array([1, 5])
     >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
     array([1., 5.])
-
-    If the accumulator is too small, overflow occurs:
-
+    
     >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
     -128
-
-    You can also start the sum with a value other than zero:
-
+    
     >>> np.sum([10], initial=5)
     15
     """
@@ -2243,14 +2615,30 @@
 
 
 def _any_dispatcher(a, axis=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_any_dispatcher)
 def any(a, axis=None, out=None, keepdims=np._NoValue):
-    """
-    Test whether any array element along a given axis evaluates to True.
-
+    """Test whether any array element along a given axis evaluates to True.
+    
     Returns single boolean unless `axis` is not ``None``
 
     Parameters
@@ -2262,9 +2650,7 @@
         The default (``axis=None``) is to perform a logical OR over all
         the dimensions of the input array. `axis` may be negative, in
         which case it counts from the last to the first axis.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, a reduction is performed on multiple
         axes, instead of a single axis or all the axes as before.
     out : ndarray, optional
@@ -2272,13 +2658,11 @@
         the same shape as the expected output and its type is preserved
         (e.g., if it is of type float, then it will remain so, returning
         1.0 for True and 0.0 for False, regardless of the type of `a`).
-        See `ufuncs-output-type` for more details.
-
+        See `ufuncs-output-type` for more details. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `any` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -2294,28 +2678,26 @@
     See Also
     --------
     ndarray.any : equivalent method
-
+    
     all : Test whether all elements along a given axis evaluate to True.
-
     Notes
     -----
     Not a Number (NaN), positive infinity and negative infinity evaluate
     to `True` because these are not equal to zero.
-
     Examples
     --------
     >>> np.any([[True, False], [True, True]])
     True
-
+    
     >>> np.any([[True, False], [False, False]], axis=0)
     array([ True, False])
-
+    
     >>> np.any([-1, 0, 5])
     True
-
+    
     >>> np.any(np.nan)
     True
-
+    
     >>> o=np.array(False)
     >>> z=np.any([-1, 4, 5], out=o)
     >>> z, o
@@ -2325,19 +2707,34 @@
     True
     >>> id(z), id(o) # identity of z and o              # doctest: +SKIP
     (191614240, 191614240)
-
     """
     return _wrapreduction(a, np.logical_or, 'any', axis, None, out, keepdims=keepdims)
 
 
 def _all_dispatcher(a, axis=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_all_dispatcher)
 def all(a, axis=None, out=None, keepdims=np._NoValue):
-    """
-    Test whether all array elements along a given axis evaluate to True.
+    """Test whether all array elements along a given axis evaluate to True.
 
     Parameters
     ----------
@@ -2348,9 +2745,7 @@
         The default (``axis=None``) is to perform a logical AND over all
         the dimensions of the input array. `axis` may be negative, in
         which case it counts from the last to the first axis.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, a reduction is performed on multiple
         axes, instead of a single axis or all the axes as before.
     out : ndarray, optional
@@ -2358,13 +2753,11 @@
         It must have the same shape as the expected output and its
         type is preserved (e.g., if ``dtype(out)`` is float, the result
         will consist of 0.0's and 1.0's). See `ufuncs-output-type` for more
-        details.
-
+        details. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `all` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -2380,45 +2773,58 @@
     See Also
     --------
     ndarray.all : equivalent method
-
+    
     any : Test whether any element along a given axis evaluates to True.
-
     Notes
     -----
     Not a Number (NaN), positive infinity and negative infinity
     evaluate to `True` because these are not equal to zero.
-
     Examples
     --------
     >>> np.all([[True,False],[True,True]])
     False
-
+    
     >>> np.all([[True,False],[True,True]], axis=0)
     array([ True, False])
-
+    
     >>> np.all([-1, 4, 5])
     True
-
+    
     >>> np.all([1.0, np.nan])
     True
-
+    
     >>> o=np.array(False)
     >>> z=np.all([-1, 4, 5], out=o)
     >>> id(z), id(o), z
     (28293632, 28293632, array(True)) # may vary
-
     """
     return _wrapreduction(a, np.logical_and, 'all', axis, None, out, keepdims=keepdims)
 
 
 def _cumsum_dispatcher(a, axis=None, dtype=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_cumsum_dispatcher)
 def cumsum(a, axis=None, dtype=None, out=None):
-    """
-    Return the cumulative sum of the elements along a given axis.
+    """Return the cumulative sum of the elements along a given axis.
 
     Parameters
     ----------
@@ -2437,7 +2843,7 @@
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output
         but the type will be cast if necessary. See `ufuncs-output-type` for
-        more details.
+        more details. (Default value = None)
 
     Returns
     -------
@@ -2447,20 +2853,17 @@
         result has the same size as `a`, and the same shape as `a` if
         `axis` is not None or `a` is a 1-d array.
 
-
     See Also
     --------
     sum : Sum array elements.
-
+    
     trapz : Integration of array values using the composite trapezoidal rule.
-
+    
     diff :  Calculate the n-th discrete difference along given axis.
-
     Notes
     -----
     Arithmetic is modular when using integer types, and no error is
     raised on overflow.
-
     Examples
     --------
     >>> a = np.array([[1,2,3], [4,5,6]])
@@ -2471,29 +2874,44 @@
     array([ 1,  3,  6, 10, 15, 21])
     >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
     array([  1.,   3.,   6.,  10.,  15.,  21.])
-
+    
     >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
     array([[1, 2, 3],
            [5, 7, 9]])
     >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
     array([[ 1,  3,  6],
            [ 4,  9, 15]])
-
     """
     return _wrapfunc(a, 'cumsum', axis=axis, dtype=dtype, out=out)
 
 
 def _ptp_dispatcher(a, axis=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_ptp_dispatcher)
 def ptp(a, axis=None, out=None, keepdims=np._NoValue):
-    """
-    Range of values (maximum - minimum) along an axis.
-
+    """Range of values (maximum - minimum) along an axis.
+    
     The name of the function comes from the acronym for 'peak to peak'.
-
+    
     .. warning::
         `ptp` preserves the data type of the array. This means the
         return value for an input of signed integers with n bits
@@ -2510,21 +2928,17 @@
         Axis along which to find the peaks.  By default, flatten the
         array.  `axis` may be negative, in
         which case it counts from the last to the first axis.
-
         .. versionadded:: 1.15.0
-
         If this is a tuple of ints, a reduction is performed on multiple
         axes, instead of a single axis or all the axes as before.
     out : array_like
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output,
-        but the type of the output values will be cast if necessary.
-
+        but the type of the output values will be cast if necessary. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `ptp` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -2539,34 +2953,37 @@
 
     Examples
     --------
+    
+    
+    
+    
+    This example shows that a negative value can be returned when
+    the input is an array of signed integers.
+    
+    
+    A work-around is to use the `view()` method to view the result as
+    unsigned integers with the same bit width:
     >>> x = np.array([[4, 9, 2, 10],
     ...               [6, 9, 7, 12]])
-
+    
     >>> np.ptp(x, axis=1)
     array([8, 6])
-
+    
     >>> np.ptp(x, axis=0)
     array([2, 0, 5, 2])
-
+    
     >>> np.ptp(x)
     10
-
-    This example shows that a negative value can be returned when
-    the input is an array of signed integers.
-
+    
     >>> y = np.array([[1, 127],
     ...               [0, 127],
     ...               [-1, 127],
     ...               [-2, 127]], dtype=np.int8)
     >>> np.ptp(y, axis=1)
     array([ 126,  127, -128, -127], dtype=int8)
-
-    A work-around is to use the `view()` method to view the result as
-    unsigned integers with the same bit width:
-
+    
     >>> np.ptp(y, axis=1).view(np.uint8)
     array([126, 127, 128, 129], dtype=uint8)
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -2583,14 +3000,34 @@
 
 def _amax_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
                      where=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+    initial :
+         (Default value = None)
+    where :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_amax_dispatcher)
 def amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
          where=np._NoValue):
-    """
-    Return the maximum of an array or maximum along an axis.
+    """Return the maximum of an array or maximum along an axis.
 
     Parameters
     ----------
@@ -2599,38 +3036,30 @@
     axis : None or int or tuple of ints, optional
         Axis or axes along which to operate.  By default, flattened input is
         used.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, the maximum is selected over multiple axes,
         instead of a single axis or all the axes as before.
     out : ndarray, optional
         Alternative output array in which to place the result.  Must
         be of the same shape and buffer length as the expected output.
-        See `ufuncs-output-type` for more details.
-
+        See `ufuncs-output-type` for more details. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `amax` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
         sub-class' method does not implement `keepdims` any
         exceptions will be raised.
-
     initial : scalar, optional
         The minimum value of an output element. Must be present to allow
         computation on empty slice. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.15.0
-
+        .. versionadded:: 1.15.0 (Default value = np._NoValue)
     where : array_like of bool, optional
         Elements to compare for the maximum. See `~numpy.ufunc.reduce`
         for details.
-
-        .. versionadded:: 1.17.0
+        .. versionadded:: 1.17.0 (Default value = np._NoValue)
 
     Returns
     -------
@@ -2651,21 +3080,27 @@
         Element-wise maximum of two arrays, ignoring any NaNs.
     argmax :
         Return the indices of the maximum values.
-
+    
     nanmin, minimum, fmin
-
     Notes
     -----
     NaN values are propagated, that is if at least one item is NaN, the
     corresponding max value will be NaN as well. To ignore NaN values
     (MATLAB behavior), please use nanmax.
-
+    
     Don't use `amax` for element-wise comparison of 2 arrays; when
     ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
     ``amax(a, axis=0)``.
-
     Examples
     --------
+    
+    You can use an initial value to compute the maximum of an empty slice, or
+    to initialize it to a different value:
+    
+    
+    Notice that the initial value is used as one of the elements for which the
+    maximum is determined, unlike for the default argument Python's max
+    function, which is only used for empty iterables.
     >>> a = np.arange(4).reshape((2,2))
     >>> a
     array([[0, 1],
@@ -2686,17 +3121,10 @@
     4.0
     >>> np.nanmax(b)
     4.0
-
-    You can use an initial value to compute the maximum of an empty slice, or
-    to initialize it to a different value:
-
+    
     >>> np.max([[-50], [10]], axis=-1, initial=0)
     array([ 0, 10])
-
-    Notice that the initial value is used as one of the elements for which the
-    maximum is determined, unlike for the default argument Python's max
-    function, which is only used for empty iterables.
-
+    
     >>> np.max([5], initial=6)
     6
     >>> max([5], default=6)
@@ -2708,14 +3136,34 @@
 
 def _amin_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
                      where=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+    initial :
+         (Default value = None)
+    where :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_amin_dispatcher)
 def amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
          where=np._NoValue):
-    """
-    Return the minimum of an array or minimum along an axis.
+    """Return the minimum of an array or minimum along an axis.
 
     Parameters
     ----------
@@ -2724,38 +3172,30 @@
     axis : None or int or tuple of ints, optional
         Axis or axes along which to operate.  By default, flattened input is
         used.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, the minimum is selected over multiple axes,
         instead of a single axis or all the axes as before.
     out : ndarray, optional
         Alternative output array in which to place the result.  Must
         be of the same shape and buffer length as the expected output.
-        See `ufuncs-output-type` for more details.
-
+        See `ufuncs-output-type` for more details. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `amin` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
         sub-class' method does not implement `keepdims` any
         exceptions will be raised.
-
     initial : scalar, optional
         The maximum value of an output element. Must be present to allow
         computation on empty slice. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.15.0
-
+        .. versionadded:: 1.15.0 (Default value = np._NoValue)
     where : array_like of bool, optional
         Elements to compare for the minimum. See `~numpy.ufunc.reduce`
         for details.
-
-        .. versionadded:: 1.17.0
+        .. versionadded:: 1.17.0 (Default value = np._NoValue)
 
     Returns
     -------
@@ -2776,21 +3216,27 @@
         Element-wise minimum of two arrays, ignoring any NaNs.
     argmin :
         Return the indices of the minimum values.
-
+    
     nanmax, maximum, fmax
-
     Notes
     -----
     NaN values are propagated, that is if at least one item is NaN, the
     corresponding min value will be NaN as well. To ignore NaN values
     (MATLAB behavior), please use nanmin.
-
+    
     Don't use `amin` for element-wise comparison of 2 arrays; when
     ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
     ``amin(a, axis=0)``.
-
     Examples
     --------
+    
+    
+    
+    Notice that the initial value is used as one of the elements for which the
+    minimum is determined, unlike for the default argument Python's max
+    function, which is only used for empty iterables.
+    
+    Notice that this isn't the same as Python's ``default`` argument.
     >>> a = np.arange(4).reshape((2,2))
     >>> a
     array([[0, 1],
@@ -2803,7 +3249,7 @@
     array([0, 2])
     >>> np.amin(a, where=[False, True], initial=10, axis=0)
     array([10,  1])
-
+    
     >>> b = np.arange(5, dtype=float)
     >>> b[2] = np.NaN
     >>> np.amin(b)
@@ -2812,16 +3258,10 @@
     0.0
     >>> np.nanmin(b)
     0.0
-
+    
     >>> np.min([[-50], [10]], axis=-1, initial=0)
     array([-50,   0])
-
-    Notice that the initial value is used as one of the elements for which the
-    minimum is determined, unlike for the default argument Python's max
-    function, which is only used for empty iterables.
-
-    Notice that this isn't the same as Python's ``default`` argument.
-
+    
     >>> np.min([6], initial=5)
     5
     >>> min([6], default=5)
@@ -2832,28 +3272,37 @@
 
 
 def _alen_dispathcer(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_alen_dispathcer)
 def alen(a):
-    """
-    Return the length of the first dimension of the input array.
+    """Return the length of the first dimension of the input array.
 
     Parameters
     ----------
     a : array_like
-       Input array.
+        Input array.
 
     Returns
     -------
     alen : int
-       Length of the first dimension of `a`.
+        Length of the first dimension of `a`.
 
     See Also
     --------
     shape, size
-
     Examples
     --------
     >>> a = np.zeros((7,4,5))
@@ -2861,7 +3310,6 @@
     7
     >>> np.alen(a)
     7
-
     """
     # NumPy 1.18.0, 2019-08-02
     warnings.warn(
@@ -2875,14 +3323,36 @@
 
 def _prod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
                      initial=None, where=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+    initial :
+         (Default value = None)
+    where :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_prod_dispatcher)
 def prod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
          initial=np._NoValue, where=np._NoValue):
-    """
-    Return the product of array elements over a given axis.
+    """Return the product of array elements over a given axis.
 
     Parameters
     ----------
@@ -2893,9 +3363,7 @@
         axis=None, will calculate the product of all the elements in the
         input array. If axis is negative it counts from the last to the
         first axis.
-
         .. versionadded:: 1.7.0
-
         If axis is a tuple of ints, a product is performed on all of the
         axes specified in the tuple instead of a single axis or all the
         axes as before.
@@ -2909,12 +3377,11 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must have
         the same shape as the expected output, but the type of the output
-        values will be cast if necessary.
+        values will be cast if necessary. (Default value = None)
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left in the
         result as dimensions with size one. With this option, the result
         will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `prod` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -2922,13 +3389,10 @@
         exceptions will be raised.
     initial : scalar, optional
         The starting value for this product. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.15.0
-
+        .. versionadded:: 1.15.0 (Default value = np._NoValue)
     where : array_like of bool, optional
         Elements to include in the product. See `~numpy.ufunc.reduce` for details.
-
-        .. versionadded:: 1.17.0
+        .. versionadded:: 1.17.0 (Default value = np._NoValue)
 
     Returns
     -------
@@ -2940,59 +3404,64 @@
     --------
     ndarray.prod : equivalent method
     ufuncs-output-type
-
     Notes
     -----
     Arithmetic is modular when using integer types, and no error is
     raised on overflow.  That means that, on a 32-bit platform:
-
+    
+    
+    The product of an empty array is the neutral element 1:
+    
+    Examples
+    --------
+    By default, calculate the product of all elements:
+    
+    
+    Even when the input array is two-dimensional:
+    
+    
+    But we can also specify the axis over which to multiply:
+    
+    
+    Or select specific elements to include:
+    
+    
+    If the type of `x` is unsigned, then the output type is
+    the unsigned platform integer:
+    
+    
+    If `x` is of a signed integer type, then the output type
+    is the default platform integer:
+    
+    
+    You can also start the product with a value other than one:
     >>> x = np.array([536870910, 536870910, 536870910, 536870910])
     >>> np.prod(x)
     16 # may vary
-
-    The product of an empty array is the neutral element 1:
-
+    
     >>> np.prod([])
     1.0
-
-    Examples
-    --------
-    By default, calculate the product of all elements:
-
+    
     >>> np.prod([1.,2.])
     2.0
-
-    Even when the input array is two-dimensional:
-
+    
     >>> np.prod([[1.,2.],[3.,4.]])
     24.0
-
-    But we can also specify the axis over which to multiply:
-
+    
     >>> np.prod([[1.,2.],[3.,4.]], axis=1)
     array([  2.,  12.])
-
-    Or select specific elements to include:
-
+    
     >>> np.prod([1., np.nan, 3.], where=[True, False, True])
     3.0
-
-    If the type of `x` is unsigned, then the output type is
-    the unsigned platform integer:
-
+    
     >>> x = np.array([1, 2, 3], dtype=np.uint8)
     >>> np.prod(x).dtype == np.uint
     True
-
-    If `x` is of a signed integer type, then the output type
-    is the default platform integer:
-
+    
     >>> x = np.array([1, 2, 3], dtype=np.int8)
     >>> np.prod(x).dtype == int
     True
-
-    You can also start the product with a value other than one:
-
+    
     >>> np.prod([1, 2], initial=5)
     10
     """
@@ -3001,13 +3470,29 @@
 
 
 def _cumprod_dispatcher(a, axis=None, dtype=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_cumprod_dispatcher)
 def cumprod(a, axis=None, dtype=None, out=None):
-    """
-    Return the cumulative product of elements along a given axis.
+    """Return the cumulative product of elements along a given axis.
 
     Parameters
     ----------
@@ -3025,7 +3510,7 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output
-        but the type of the resulting values will be cast if necessary.
+        but the type of the resulting values will be cast if necessary. (Default value = None)
 
     Returns
     -------
@@ -3036,14 +3521,17 @@
     See Also
     --------
     ufuncs-output-type
-
     Notes
     -----
     Arithmetic is modular when using integer types, and no error is
     raised on overflow.
-
     Examples
     --------
+    
+    The cumulative product for each column (i.e., over the rows) of `a`:
+    
+    
+    The cumulative product for each row (i.e. over the columns) of `a`:
     >>> a = np.array([1,2,3])
     >>> np.cumprod(a) # intermediate results 1, 1*2
     ...               # total product 1*2*3 = 6
@@ -3051,31 +3539,36 @@
     >>> a = np.array([[1, 2, 3], [4, 5, 6]])
     >>> np.cumprod(a, dtype=float) # specify type of output
     array([   1.,    2.,    6.,   24.,  120.,  720.])
-
-    The cumulative product for each column (i.e., over the rows) of `a`:
-
+    
     >>> np.cumprod(a, axis=0)
     array([[ 1,  2,  3],
            [ 4, 10, 18]])
-
-    The cumulative product for each row (i.e. over the columns) of `a`:
-
+    
     >>> np.cumprod(a,axis=1)
     array([[  1,   2,   6],
            [  4,  20, 120]])
-
     """
     return _wrapfunc(a, 'cumprod', axis=axis, dtype=dtype, out=out)
 
 
 def _ndim_dispatcher(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_ndim_dispatcher)
 def ndim(a):
-    """
-    Return the number of dimensions of an array.
+    """Return the number of dimensions of an array.
 
     Parameters
     ----------
@@ -3093,7 +3586,6 @@
     ndarray.ndim : equivalent method
     shape : dimensions of array
     ndarray.shape : dimensions of array
-
     Examples
     --------
     >>> np.ndim([[1,2,3],[4,5,6]])
@@ -3102,7 +3594,6 @@
     2
     >>> np.ndim(1)
     0
-
     """
     try:
         return a.ndim
@@ -3111,13 +3602,25 @@
 
 
 def _size_dispatcher(a, axis=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_size_dispatcher)
 def size(a, axis=None):
-    """
-    Return the number of elements along a given axis.
+    """Return the number of elements along a given axis.
 
     Parameters
     ----------
@@ -3137,7 +3640,6 @@
     shape : dimensions of array
     ndarray.shape : dimensions of array
     ndarray.size : number of elements in array
-
     Examples
     --------
     >>> a = np.array([[1,2,3],[4,5,6]])
@@ -3147,7 +3649,6 @@
     3
     >>> np.size(a,0)
     2
-
     """
     if axis is None:
         try:
@@ -3162,13 +3663,27 @@
 
 
 def _around_dispatcher(a, decimals=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    decimals :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_around_dispatcher)
 def around(a, decimals=0, out=None):
-    """
-    Evenly round to the given number of decimals.
+    """Evenly round to the given number of decimals.
 
     Parameters
     ----------
@@ -3182,7 +3697,7 @@
         Alternative output array in which to place the result. It must have
         the same shape as the expected output, but the type of the output
         values will be cast if necessary. See `ufuncs-output-type` for more
-        details.
+        details. (Default value = None)
 
     Returns
     -------
@@ -3190,53 +3705,42 @@
         An array of the same type as `a`, containing the rounded values.
         Unless `out` was specified, a new array is created.  A reference to
         the result is returned.
-
         The real and imaginary parts of complex numbers are rounded
         separately.  The result of rounding a float is a float.
 
     See Also
     --------
     ndarray.round : equivalent method
-
+    
     ceil, fix, floor, rint, trunc
-
-
+    
     Notes
     -----
     For values exactly halfway between rounded decimal values, NumPy
     rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
     -0.5 and 0.5 round to 0.0, etc.
-
+    
     ``np.around`` uses a fast but sometimes inexact algorithm to round
     floating-point datatypes. For positive `decimals` it is equivalent to
     ``np.true_divide(np.rint(a * 10**decimals), 10**decimals)``, which has
     error due to the inexact representation of decimal fractions in the IEEE
     floating point standard [1]_ and errors introduced when scaling by powers
     of ten. For instance, note the extra "1" in the following:
-
-        >>> np.round(56294995342131.5, 3)
-        56294995342131.51
-
+    
+    
     If your goal is to print such values with a fixed number of decimals, it is
     preferable to use numpy's float printing routines to limit the number of
     printed decimals:
-
-        >>> np.format_float_positional(56294995342131.5, precision=3)
-        '56294995342131.5'
-
+    
+    
     The float printing routines use an accurate but much more computationally
     demanding algorithm to compute the number of digits after the decimal
     point.
-
+    
     Alternatively, Python's builtin `round` function uses a more accurate
     but slower algorithm for 64-bit floating point values:
-
-        >>> round(56294995342131.5, 3)
-        56294995342131.5
-        >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
-        (16.06, 16.05)
-
-
+    
+    
     References
     ----------
     .. [1] "Lecture Notes on the Status of IEEE 754", William Kahan,
@@ -3244,9 +3748,19 @@
     .. [2] "How Futile are Mindless Assessments of
            Roundoff in Floating-Point Computation?", William Kahan,
            https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf
-
     Examples
     --------
+    >>> np.round(56294995342131.5, 3)
+        56294995342131.51
+    
+        >>> np.format_float_positional(56294995342131.5, precision=3)
+        '56294995342131.5'
+    
+        >>> round(56294995342131.5, 3)
+        56294995342131.5
+        >>> np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
+        (16.06, 16.05)
+    
     >>> np.around([0.37, 1.64])
     array([0.,  2.])
     >>> np.around([0.37, 1.64], decimals=1)
@@ -3257,20 +3771,37 @@
     array([ 1,  2,  3, 11])
     >>> np.around([1,2,3,11], decimals=-1)
     array([ 0,  0,  0, 10])
-
     """
     return _wrapfunc(a, 'round', decimals=decimals, out=out)
 
 
 def _mean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_mean_dispatcher)
 def mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):
-    """
-    Compute the arithmetic mean along the specified axis.
-
+    """Compute the arithmetic mean along the specified axis.
+    
     Returns the average of the array elements.  The average is taken over
     the flattened array by default, otherwise over the specified axis.
     `float64` intermediate and return values are used for integer inputs.
@@ -3283,9 +3814,7 @@
     axis : None or int or tuple of ints, optional
         Axis or axes along which the means are computed. The default is to
         compute the mean of the flattened array.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, a mean is performed over multiple axes,
         instead of a single axis or all the axes as before.
     dtype : data-type, optional
@@ -3297,12 +3826,10 @@
         is ``None``; if provided, it must have the same shape as the
         expected output, but the type will be cast if necessary.
         See `ufuncs-output-type` for more details.
-
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `mean` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -3319,23 +3846,26 @@
     --------
     average : Weighted average
     std, var, nanmean, nanstd, nanvar
-
     Notes
     -----
     The arithmetic mean is the sum of the elements along the axis divided
     by the number of elements.
-
+    
     Note that for floating-point input, the mean is computed using the
     same precision the input has.  Depending on the input data, this can
     cause the results to be inaccurate, especially for `float32` (see
     example below).  Specifying a higher-precision accumulator using the
     `dtype` keyword can alleviate this issue.
-
+    
     By default, `float16` results are computed using `float32` intermediates
     for extra precision.
-
     Examples
     --------
+    
+    In single precision, `mean` can be inaccurate:
+    
+    
+    Computing the mean in float64 is more accurate:
     >>> a = np.array([[1, 2], [3, 4]])
     >>> np.mean(a)
     2.5
@@ -3343,20 +3873,15 @@
     array([2., 3.])
     >>> np.mean(a, axis=1)
     array([1.5, 3.5])
-
-    In single precision, `mean` can be inaccurate:
-
+    
     >>> a = np.zeros((2, 512*512), dtype=np.float32)
     >>> a[0, :] = 1.0
     >>> a[1, :] = 0.1
     >>> np.mean(a)
     0.54999924
-
-    Computing the mean in float64 is more accurate:
-
+    
     >>> np.mean(a, dtype=np.float64)
     0.55000000074505806 # may vary
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -3375,14 +3900,34 @@
 
 def _std_dispatcher(
         a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    ddof :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_std_dispatcher)
 def std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
-    """
-    Compute the standard deviation along the specified axis.
-
+    """Compute the standard deviation along the specified axis.
+    
     Returns the standard deviation, a measure of the spread of a distribution,
     of the array elements. The standard deviation is computed for the
     flattened array by default, otherwise over the specified axis.
@@ -3394,9 +3939,7 @@
     axis : None or int or tuple of ints, optional
         Axis or axes along which the standard deviation is computed. The
         default is to compute the standard deviation of the flattened array.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, a standard deviation is performed over
         multiple axes, instead of a single axis or all the axes as before.
     dtype : dtype, optional
@@ -3406,7 +3949,7 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must have
         the same shape as the expected output but the type (of the calculated
-        values) will be cast if necessary.
+        values) will be cast if necessary. (Default value = None)
     ddof : int, optional
         Means Delta Degrees of Freedom.  The divisor used in calculations
         is ``N - ddof``, where ``N`` represents the number of elements.
@@ -3415,7 +3958,6 @@
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `std` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -3432,12 +3974,11 @@
     --------
     var, mean, nanmean, nanstd, nanvar
     ufuncs-output-type
-
     Notes
     -----
     The standard deviation is the square root of the average of the squared
     deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.
-
+    
     The average squared deviation is normally calculated as
     ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
     the divisor ``N - ddof`` is used instead. In standard statistical
@@ -3447,18 +3988,22 @@
     standard deviation computed in this function is the square root of
     the estimated variance, so even with ``ddof=1``, it will not be an
     unbiased estimate of the standard deviation per se.
-
+    
     Note that, for complex numbers, `std` takes the absolute
     value before squaring, so that the result is always real and nonnegative.
-
+    
     For floating-point input, the *std* is computed using the same
     precision the input has. Depending on the input data, this can cause
     the results to be inaccurate, especially for float32 (see example below).
     Specifying a higher-accuracy accumulator using the `dtype` keyword can
     alleviate this issue.
-
     Examples
     --------
+    
+    In single precision, std() can be inaccurate:
+    
+    
+    Computing the standard deviation in float64 is more accurate:
     >>> a = np.array([[1, 2], [3, 4]])
     >>> np.std(a)
     1.1180339887498949 # may vary
@@ -3466,20 +4011,15 @@
     array([1.,  1.])
     >>> np.std(a, axis=1)
     array([0.5,  0.5])
-
-    In single precision, std() can be inaccurate:
-
+    
     >>> a = np.zeros((2, 512*512), dtype=np.float32)
     >>> a[0, :] = 1.0
     >>> a[1, :] = 0.1
     >>> np.std(a)
     0.45000005
-
-    Computing the standard deviation in float64 is more accurate:
-
+    
     >>> np.std(a, dtype=np.float64)
     0.44999999925494177 # may vary
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -3499,14 +4039,34 @@
 
 def _var_dispatcher(
         a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    ddof :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_var_dispatcher)
 def var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
-    """
-    Compute the variance along the specified axis.
-
+    """Compute the variance along the specified axis.
+    
     Returns the variance of the array elements, a measure of the spread of a
     distribution.  The variance is computed for the flattened array by
     default, otherwise over the specified axis.
@@ -3519,9 +4079,7 @@
     axis : None or int or tuple of ints, optional
         Axis or axes along which the variance is computed.  The default is to
         compute the variance of the flattened array.
-
         .. versionadded:: 1.7.0
-
         If this is a tuple of ints, a variance is performed over multiple axes,
         instead of a single axis or all the axes as before.
     dtype : data-type, optional
@@ -3531,7 +4089,7 @@
     out : ndarray, optional
         Alternate output array in which to place the result.  It must have
         the same shape as the expected output, but the type is cast if
-        necessary.
+        necessary. (Default value = None)
     ddof : int, optional
         "Delta Degrees of Freedom": the divisor used in the calculation is
         ``N - ddof``, where ``N`` represents the number of elements. By
@@ -3540,7 +4098,6 @@
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the input array.
-
         If the default value is passed, then `keepdims` will not be
         passed through to the `var` method of sub-classes of
         `ndarray`, however any non-default value will be.  If the
@@ -3557,30 +4114,33 @@
     --------
     std, mean, nanmean, nanstd, nanvar
     ufuncs-output-type
-
     Notes
     -----
     The variance is the average of the squared deviations from the mean,
     i.e.,  ``var = mean(abs(x - x.mean())**2)``.
-
+    
     The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
     If, however, `ddof` is specified, the divisor ``N - ddof`` is used
     instead.  In standard statistical practice, ``ddof=1`` provides an
     unbiased estimator of the variance of a hypothetical infinite population.
     ``ddof=0`` provides a maximum likelihood estimate of the variance for
     normally distributed variables.
-
+    
     Note that for complex numbers, the absolute value is taken before
     squaring, so that the result is always real and nonnegative.
-
+    
     For floating-point input, the variance is computed using the same
     precision the input has.  Depending on the input data, this can cause
     the results to be inaccurate, especially for `float32` (see example
     below).  Specifying a higher-accuracy accumulator using the ``dtype``
     keyword can alleviate this issue.
-
     Examples
     --------
+    
+    In single precision, var() can be inaccurate:
+    
+    
+    Computing the variance in float64 is more accurate:
     >>> a = np.array([[1, 2], [3, 4]])
     >>> np.var(a)
     1.25
@@ -3588,22 +4148,17 @@
     array([1.,  1.])
     >>> np.var(a, axis=1)
     array([0.25,  0.25])
-
-    In single precision, var() can be inaccurate:
-
+    
     >>> a = np.zeros((2, 512*512), dtype=np.float32)
     >>> a[0, :] = 1.0
     >>> a[1, :] = 0.1
     >>> np.var(a)
     0.20250003
-
-    Computing the variance in float64 is more accurate:
-
+    
     >>> np.var(a, dtype=np.float64)
     0.20249999932944759 # may vary
     >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
     0.2025
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -3627,8 +4182,19 @@
 
 @array_function_dispatch(_around_dispatcher)
 def round_(a, decimals=0, out=None):
-    """
-    Round an array to the given number of decimals.
+    """Round an array to the given number of decimals.
+
+    Parameters
+    ----------
+    a :
+        
+    decimals :
+         (Default value = 0)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
 
     See Also
     --------
@@ -3639,8 +4205,17 @@
 
 @array_function_dispatch(_prod_dispatcher, verify=False)
 def product(*args, **kwargs):
-    """
-    Return the product of array elements over a given axis.
+    """Return the product of array elements over a given axis.
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
 
     See Also
     --------
@@ -3651,8 +4226,17 @@
 
 @array_function_dispatch(_cumprod_dispatcher, verify=False)
 def cumproduct(*args, **kwargs):
-    """
-    Return the cumulative product over the given axis.
+    """Return the cumulative product over the given axis.
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
 
     See Also
     --------
@@ -3663,10 +4247,19 @@
 
 @array_function_dispatch(_any_dispatcher, verify=False)
 def sometrue(*args, **kwargs):
-    """
-    Check whether some values are true.
-
+    """Check whether some values are true.
+    
     Refer to `any` for full documentation.
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
 
     See Also
     --------
@@ -3677,8 +4270,17 @@
 
 @array_function_dispatch(_all_dispatcher, verify=False)
 def alltrue(*args, **kwargs):
-    """
-    Check if all elements of input array are true.
+    """Check if all elements of input array are true.
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
 
     See Also
     --------
