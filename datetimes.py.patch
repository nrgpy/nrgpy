# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/datetimes.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/datetimes.py
@@ -38,9 +38,17 @@
 
 
 def _new_DatetimeIndex(cls, d):
-    """
-    This is called upon unpickling, rather than the default which doesn't
+    """This is called upon unpickling, rather than the default which doesn't
     have arguments and breaks __new__
+
+    Parameters
+    ----------
+    d :
+        
+
+    Returns
+    -------
+
     """
     if "data" in d and not isinstance(d["data"], DatetimeIndex):
         # Avoid need to verify integrity by calling simple_new directly
@@ -102,9 +110,8 @@
     DatetimeArray,
 )
 class DatetimeIndex(DatetimeTimedeltaMixin):
-    """
-    Immutable ndarray-like of datetime64 data.
-
+    """Immutable ndarray-like of datetime64 data.
+    
     Represented internally as int64, and which can be boxed to Timestamp objects
     that are subclasses of datetime and carry metadata.
 
@@ -129,12 +136,11 @@
         DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC
         and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter
         dictates how ambiguous times should be handled.
-
         - 'infer' will attempt to infer fall dst-transition hours based on
-          order
+        order
         - bool-ndarray where True signifies a DST time, False signifies a
-          non-DST time (note that this flag is only applicable for ambiguous
-          times)
+        non-DST time (note that this flag is only applicable for ambiguous
+        times)
         - 'NaT' will return NaT where there are ambiguous times
         - 'raise' will raise an AmbiguousTimeError if there are ambiguous times.
     dayfirst : bool, default False
@@ -147,6 +153,9 @@
         Make a copy of input ndarray.
     name : label, default None
         Name to be stored in the index.
+
+    Returns
+    -------
 
     Attributes
     ----------
@@ -178,7 +187,6 @@
     is_year_end
     is_leap_year
     inferred_freq
-
     Methods
     -------
     normalize
@@ -197,7 +205,6 @@
     month_name
     day_name
     mean
-
     See Also
     --------
     Index : The base pandas Index type.
@@ -205,7 +212,6 @@
     PeriodIndex : Index of Period data.
     to_datetime : Convert argument to datetime.
     date_range : Create a fixed-frequency DatetimeIndex.
-
     Notes
     -----
     To learn more about the frequency strings, please see `this link
@@ -232,11 +238,37 @@
     def tz_localize(
         self, tz, ambiguous="raise", nonexistent="raise"
     ) -> "DatetimeIndex":
+        """
+
+        Parameters
+        ----------
+        tz :
+            
+        ambiguous :
+             (Default value = "raise")
+        nonexistent :
+             (Default value = "raise")
+
+        Returns
+        -------
+
+        """
         arr = self._data.tz_localize(tz, ambiguous, nonexistent)
         return type(self)._simple_new(arr, name=self.name)
 
     @doc(DatetimeArray.to_period)
     def to_period(self, freq=None) -> "DatetimeIndex":
+        """
+
+        Parameters
+        ----------
+        freq :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         arr = self._data.to_period(freq)
         return type(self)._simple_new(arr, name=self.name)
 
@@ -284,6 +316,19 @@
 
     @classmethod
     def _simple_new(cls, values: DatetimeArray, name: Label = None):
+        """
+
+        Parameters
+        ----------
+        values: DatetimeArray :
+            
+        name: Label :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         assert isinstance(values, DatetimeArray), type(values)
 
         result = object.__new__(cls)
@@ -300,13 +345,7 @@
 
     @cache_readonly
     def _is_dates_only(self) -> bool:
-        """
-        Return a boolean if we are only dates (and don't have a timezone)
-
-        Returns
-        -------
-        bool
-        """
+        """Return a boolean if we are only dates (and don't have a timezone)"""
         from pandas.io.formats.format import _is_dates_only
 
         return self.tz is None and _is_dates_only(self._values)
@@ -321,16 +360,32 @@
         return _new_DatetimeIndex, (type(self), d), None
 
     def _convert_for_op(self, value):
-        """
-        Convert value to be insertable to ndarray.
+        """Convert value to be insertable to ndarray.
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
         """
         if self._has_same_tz(value):
             return Timestamp(value).asm8
         raise ValueError("Passed item and index have different timezone")
 
     def _is_comparable_dtype(self, dtype: DtypeObj) -> bool:
-        """
-        Can we compare values of the given dtype to our own?
+        """Can we compare values of the given dtype to our own?
+
+        Parameters
+        ----------
+        dtype: DtypeObj :
+            
+
+        Returns
+        -------
+
         """
         if not is_datetime64_any_dtype(dtype):
             return False
@@ -344,11 +399,13 @@
     # Rendering Methods
 
     def _mpl_repr(self):
+        """ """
         # how to represent ourselves to matplotlib
         return ints_to_pydatetime(self.asi8, self.tz)
 
     @property
     def _formatter_func(self):
+        """ """
         from pandas.io.formats.format import _get_format_datetime64
 
         formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)
@@ -358,8 +415,16 @@
     # Set Operation Methods
 
     def union_many(self, others):
-        """
-        A bit of a hack to accelerate unioning a collection of indexes.
+        """A bit of a hack to accelerate unioning a collection of indexes.
+
+        Parameters
+        ----------
+        others :
+            
+
+        Returns
+        -------
+
         """
         this = self
 
@@ -385,13 +450,7 @@
     # --------------------------------------------------------------------
 
     def _get_time_micros(self):
-        """
-        Return the number of microseconds since midnight.
-
-        Returns
-        -------
-        ndarray[int64_t]
-        """
+        """Return the number of microseconds since midnight."""
         values = self.asi8
         if self.tz is not None and not timezones.is_utc(self.tz):
             values = self._data._local_timestamps()
@@ -403,33 +462,25 @@
         return micros
 
     def to_series(self, keep_tz=lib.no_default, index=None, name=None):
-        """
-        Create a Series with both index and values equal to the index keys
+        """Create a Series with both index and values equal to the index keys
         useful with map for returning an indexer based on an index.
 
         Parameters
         ----------
         keep_tz : optional, defaults True
             Return the data keeping the timezone.
-
             If keep_tz is True:
-
-              If the timezone is not set, the resulting
-              Series will have a datetime64[ns] dtype.
-
-              Otherwise the Series will have an datetime64[ns, tz] dtype; the
-              tz will be preserved.
-
+            If the timezone is not set, the resulting
+            Series will have a datetime64[ns] dtype.
+            Otherwise the Series will have an datetime64[ns, tz] dtype; the
+            tz will be preserved.
             If keep_tz is False:
-
-              Series will have a datetime64[ns] dtype. TZ aware
-              objects will have the tz removed.
-
+            Series will have a datetime64[ns] dtype. TZ aware
+            objects will have the tz removed.
             .. versionchanged:: 1.0.0
-                The default value is now True.  In a future version,
-                this keyword will be removed entirely.  Stop passing the
-                argument to obtain the future behavior and silence the warning.
-
+            The default value is now True.  In a future version,
+            this keyword will be removed entirely.  Stop passing the
+            argument to obtain the future behavior and silence the warning.
         index : Index, optional
             Index of resulting Series. If None, defaults to original index.
         name : str, optional
@@ -438,7 +489,8 @@
 
         Returns
         -------
-        Series
+
+        
         """
         from pandas import Series
 
@@ -478,12 +530,17 @@
         return Series(values, index=index, name=name)
 
     def snap(self, freq="S"):
-        """
-        Snap time stamps to nearest occurring frequency.
-
-        Returns
-        -------
-        DatetimeIndex
+        """Snap time stamps to nearest occurring frequency.
+
+        Parameters
+        ----------
+        freq :
+             (Default value = "S")
+
+        Returns
+        -------
+
+        
         """
         # Superdumb, punting on any optimizing
         freq = to_offset(freq)
@@ -505,8 +562,7 @@
         return DatetimeIndex._simple_new(dta, name=self.name)
 
     def _parsed_string_to_bounds(self, reso: Resolution, parsed: datetime):
-        """
-        Calculate datetime bounds for parsed time string and its resolution.
+        """Calculate datetime bounds for parsed time string and its resolution.
 
         Parameters
         ----------
@@ -514,10 +570,15 @@
             Resolution provided by parsed string.
         parsed : datetime
             Datetime from parsed string.
-
-        Returns
-        -------
-        lower, upper: pd.Timestamp
+        reso: Resolution :
+            
+        parsed: datetime :
+            
+
+        Returns
+        -------
+
+        
         """
         assert isinstance(reso, Resolution), (type(reso), reso)
         valid_resos = {
@@ -557,6 +618,17 @@
         return start, end
 
     def _validate_partial_date_slice(self, reso: Resolution):
+        """
+
+        Parameters
+        ----------
+        reso: Resolution :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(reso, Resolution), (type(reso), reso)
         if (
             self.is_monotonic
@@ -575,12 +647,21 @@
             raise KeyError
 
     def get_loc(self, key, method=None, tolerance=None):
-        """
-        Get integer location for requested label
-
-        Returns
-        -------
-        loc : int
+        """Get integer location for requested label
+
+        Parameters
+        ----------
+        key :
+            
+        method :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if not is_scalar(key):
             raise InvalidIndexError(key)
@@ -627,6 +708,17 @@
             raise KeyError(orig_key) from err
 
     def _maybe_cast_for_get_loc(self, key) -> Timestamp:
+        """
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        """
         # needed to localize naive datetimes
         key = Timestamp(key)
         if key.tzinfo is None:
@@ -636,18 +728,23 @@
         return key
 
     def _maybe_cast_slice_bound(self, label, side: str, kind):
-        """
-        If label is a string, cast it to datetime according to resolution.
+        """If label is a string, cast it to datetime according to resolution.
 
         Parameters
         ----------
         label : object
+            
         side : {'left', 'right'}
+            
         kind : {'loc', 'getitem'} or None
+            
+        side: str :
+            
 
         Returns
         -------
         label : object
+            
 
         Notes
         -----
@@ -676,6 +773,21 @@
             return label
 
     def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):
+        """
+
+        Parameters
+        ----------
+        key: str :
+            
+        use_lhs: bool :
+             (Default value = True)
+        use_rhs: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         freq = getattr(self, "freqstr", getattr(self, "inferred_freq", None))
         parsed, reso = parsing.parse_time_string(key, freq)
         reso = Resolution.from_attrname(reso)
@@ -684,16 +796,30 @@
 
     def slice_indexer(self, start=None, end=None, step=None, kind=None):
         """
-        Return indexer for specified label slice.
-        Index.slice_indexer, customized to handle time slicing.
-
-        In addition to functionality provided by Index.slice_indexer, does the
-        following:
-
-        - if both `start` and `end` are instances of `datetime.time`, it
-          invokes `indexer_between_time`
-        - if `start` and `end` are both either string or None perform
-          value-based selection in non-monotonic cases.
+
+        Parameters
+        ----------
+        start :
+             (Default value = None)
+        end :
+             (Default value = None)
+        step :
+             (Default value = None)
+        kind :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            Index.slice_indexer, customized to handle time slicing.
+            
+            In addition to functionality provided by Index.slice_indexer, does the
+            following:
+            
+            - if both `start` and `end` are instances of `datetime.time`, it
+            invokes `indexer_between_time`
+            - if `start` and `end` are both either string or None perform
+            value-based selection in non-monotonic cases.
 
         """
         # For historical reasons DatetimeIndex supports slices between two
@@ -743,17 +869,28 @@
     # --------------------------------------------------------------------
 
     def is_type_compatible(self, typ) -> bool:
+        """
+
+        Parameters
+        ----------
+        typ :
+            
+
+        Returns
+        -------
+
+        """
         return typ == self.inferred_type or typ == "datetime"
 
     @property
     def inferred_type(self) -> str:
+        """ """
         # b/c datetime is represented as microseconds since the epoch, make
         # sure we can't have ambiguous indexing
         return "datetime64"
 
     def indexer_at_time(self, time, asof=False):
-        """
-        Return index locations of values at particular time of day
+        """Return index locations of values at particular time of day
         (e.g. 9:30AM).
 
         Parameters
@@ -762,10 +899,13 @@
             Time passed in either as object (datetime.time) or as string in
             appropriate format ("%H:%M", "%H%M", "%I:%M%p", "%I%M%p",
             "%H:%M:%S", "%H%M%S", "%I:%M:%S%p", "%I%M%S%p").
+        asof :
+             (Default value = False)
 
         Returns
         -------
         values_at_time : array of integers
+            
 
         See Also
         --------
@@ -793,8 +933,7 @@
     def indexer_between_time(
         self, start_time, end_time, include_start=True, include_end=True
     ):
-        """
-        Return index locations of values between particular times of day
+        """Return index locations of values between particular times of day
         (e.g., 9:00-9:30AM).
 
         Parameters
@@ -804,11 +943,18 @@
             appropriate format ("%H:%M", "%H%M", "%I:%M%p", "%I%M%p",
             "%H:%M:%S", "%H%M%S", "%I:%M:%S%p","%I%M%S%p").
         include_start : bool, default True
+             (Default value = True)
         include_end : bool, default True
+             (Default value = True)
+        start_time :
+            
+        end_time :
+            
 
         Returns
         -------
         values_between_time : array of integers
+            
 
         See Also
         --------
@@ -857,38 +1003,38 @@
     closed=None,
     **kwargs,
 ) -> DatetimeIndex:
-    """
-    Return a fixed frequency DatetimeIndex.
+    """Return a fixed frequency DatetimeIndex.
 
     Parameters
     ----------
     start : str or datetime-like, optional
-        Left bound for generating dates.
+        Left bound for generating dates. (Default value = None)
     end : str or datetime-like, optional
-        Right bound for generating dates.
+        Right bound for generating dates. (Default value = None)
     periods : int, optional
-        Number of periods to generate.
+        Number of periods to generate. (Default value = None)
     freq : str or DateOffset, default 'D'
         Frequency strings can have multiples, e.g. '5H'. See
         :ref:`here <timeseries.offset_aliases>` for a list of
-        frequency aliases.
+        frequency aliases. (Default value = None)
     tz : str or tzinfo, optional
         Time zone name for returning localized DatetimeIndex, for example
         'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is
         timezone-naive.
     normalize : bool, default False
-        Normalize start/end dates to midnight before generating date range.
+        Normalize start/end dates to midnight before generating date range. (Default value = False)
     name : str, default None
-        Name of the resulting DatetimeIndex.
+        Name of the resulting DatetimeIndex. (Default value = None)
     closed : {None, 'left', 'right'}, optional
         Make the interval closed with respect to the given frequency to
         the 'left', 'right', or both sides (None, the default).
-    **kwargs
+    **kwargs :
         For compatibility. Has no effect on the result.
 
     Returns
     -------
     rng : DatetimeIndex
+        
 
     See Also
     --------
@@ -896,99 +1042,106 @@
     timedelta_range : Return a fixed frequency TimedeltaIndex.
     period_range : Return a fixed frequency PeriodIndex.
     interval_range : Return a fixed frequency IntervalIndex.
-
     Notes
     -----
     Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,
     exactly three must be specified. If ``freq`` is omitted, the resulting
     ``DatetimeIndex`` will have ``periods`` linearly spaced elements between
     ``start`` and ``end`` (closed on both sides).
-
+    
     To learn more about the frequency strings, please see `this link
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.
-
     Examples
     --------
     **Specifying the values**
-
+    
     The next four examples generate the same `DatetimeIndex`, but vary
     the combination of `start`, `end` and `periods`.
-
+    
     Specify `start` and `end`, with the default daily frequency.
-
+    
+    
+    Specify `start` and `periods`, the number of periods (days).
+    
+    
+    Specify `end` and `periods`, the number of periods (days).
+    
+    
+    Specify `start`, `end`, and `periods`; the frequency is generated
+    automatically (linearly spaced).
+    
+    
+    **Other Parameters**
+    
+    Changed the `freq` (frequency) to ``'M'`` (month end frequency).
+    
+    
+    Multiples are allowed
+    
+    
+    `freq` can also be specified as an Offset object.
+    
+    
+    Specify `tz` to set the timezone.
+    
+    
+    `closed` controls whether to include `start` and `end` that are on the
+    boundary. The default includes boundary points on either end.
+    
+    
+    Use ``closed='left'`` to exclude `end` if it falls on the boundary.
+    
+    
+    Use ``closed='right'`` to exclude `start` if it falls on the boundary.
     >>> pd.date_range(start='1/1/2018', end='1/08/2018')
     DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
                    '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
                   dtype='datetime64[ns]', freq='D')
-
-    Specify `start` and `periods`, the number of periods (days).
-
+    
     >>> pd.date_range(start='1/1/2018', periods=8)
     DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
                    '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
                   dtype='datetime64[ns]', freq='D')
-
-    Specify `end` and `periods`, the number of periods (days).
-
+    
     >>> pd.date_range(end='1/1/2018', periods=8)
     DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',
                    '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],
                   dtype='datetime64[ns]', freq='D')
-
-    Specify `start`, `end`, and `periods`; the frequency is generated
-    automatically (linearly spaced).
-
+    
     >>> pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)
     DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',
                    '2018-04-27 00:00:00'],
                   dtype='datetime64[ns]', freq=None)
-
-    **Other Parameters**
-
-    Changed the `freq` (frequency) to ``'M'`` (month end frequency).
-
+    
     >>> pd.date_range(start='1/1/2018', periods=5, freq='M')
     DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',
                    '2018-05-31'],
                   dtype='datetime64[ns]', freq='M')
-
-    Multiples are allowed
-
+    
     >>> pd.date_range(start='1/1/2018', periods=5, freq='3M')
     DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
                    '2019-01-31'],
                   dtype='datetime64[ns]', freq='3M')
-
-    `freq` can also be specified as an Offset object.
-
+    
     >>> pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))
     DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
                    '2019-01-31'],
                   dtype='datetime64[ns]', freq='3M')
-
-    Specify `tz` to set the timezone.
-
+    
     >>> pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')
     DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',
                    '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',
                    '2018-01-05 00:00:00+09:00'],
                   dtype='datetime64[ns, Asia/Tokyo]', freq='D')
-
-    `closed` controls whether to include `start` and `end` that are on the
-    boundary. The default includes boundary points on either end.
-
+    
     >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed=None)
     DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],
                   dtype='datetime64[ns]', freq='D')
-
-    Use ``closed='left'`` to exclude `end` if it falls on the boundary.
-
+    
     >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='left')
     DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],
                   dtype='datetime64[ns]', freq='D')
-
-    Use ``closed='right'`` to exclude `start` if it falls on the boundary.
-
+    
     >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='right')
     DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],
                   dtype='datetime64[ns]', freq='D')
@@ -1022,27 +1175,26 @@
     closed=None,
     **kwargs,
 ) -> DatetimeIndex:
-    """
-    Return a fixed frequency DatetimeIndex, with business day as the default
+    """Return a fixed frequency DatetimeIndex, with business day as the default
     frequency.
 
     Parameters
     ----------
     start : str or datetime-like, default None
-        Left bound for generating dates.
+        Left bound for generating dates. (Default value = None)
     end : str or datetime-like, default None
-        Right bound for generating dates.
+        Right bound for generating dates. (Default value = None)
     periods : int, default None
-        Number of periods to generate.
+        Number of periods to generate. (Default value = None)
     freq : str or DateOffset, default 'B' (business daily)
-        Frequency strings can have multiples, e.g. '5H'.
+        Frequency strings can have multiples, e.g. '5H'. (Default value = "B")
     tz : str or None
         Time zone name for returning localized DatetimeIndex, for example
-        Asia/Beijing.
+        Asia/Beijing. (Default value = None)
     normalize : bool, default False
-        Normalize start/end dates to midnight before generating date range.
+        Normalize start/end dates to midnight before generating date range. (Default value = True)
     name : str, default None
-        Name of the resulting DatetimeIndex.
+        Name of the resulting DatetimeIndex. (Default value = None)
     weekmask : str or None, default None
         Weekmask of valid business days, passed to ``numpy.busdaycalendar``,
         only used when custom frequency strings are passed.  The default
@@ -1050,16 +1202,17 @@
     holidays : list-like or None, default None
         Dates to exclude from the set of valid business days, passed to
         ``numpy.busdaycalendar``, only used when custom frequency strings
-        are passed.
+        are passed. (Default value = None)
     closed : str, default None
         Make the interval closed with respect to the given frequency to
-        the 'left', 'right', or both sides (None).
-    **kwargs
+        the 'left', 'right', or both sides (None). (Default value = None)
+    **kwargs :
         For compatibility. Has no effect on the result.
 
     Returns
     -------
     DatetimeIndex
+        
 
     Notes
     -----
@@ -1067,14 +1220,12 @@
     exactly three must be specified.  Specifying ``freq`` is a requirement
     for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not
     desired.
-
+    
     To learn more about the frequency strings, please see `this link
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.
-
     Examples
     --------
     Note how the two weekend days are skipped in the result.
-
     >>> pd.bdate_range(start='1/1/2018', end='1/08/2018')
     DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
                '2018-01-05', '2018-01-08'],
@@ -1112,5 +1263,16 @@
 
 
 def _time_to_micros(time_obj: time) -> int:
+    """
+
+    Parameters
+    ----------
+    time_obj: time :
+        
+
+    Returns
+    -------
+
+    """
     seconds = time_obj.hour * 60 * 60 + 60 * time_obj.minute + time_obj.second
     return 1_000_000 * seconds + time_obj.microsecond
