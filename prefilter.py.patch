# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/core/prefilter.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/core/prefilter.py
@@ -33,6 +33,7 @@
 
 
 class PrefilterError(Exception):
+    """ """
     pass
 
 
@@ -62,7 +63,19 @@
 def is_shadowed(identifier, ip):
     """Is the given identifier defined in one of the namespaces which shadow
     the alias and magic namespaces?  Note that an identifier is different
-    than ifun, because it can not contain a '.' character."""
+    than ifun, because it can not contain a '.' character.
+
+    Parameters
+    ----------
+    identifier :
+        
+    ip :
+        
+
+    Returns
+    -------
+
+    """
     # This is much safer than calling ofind, which can change state
     return (identifier in ip.user_ns \
             or identifier in ip.user_global_ns \
@@ -77,24 +90,24 @@
 
 class PrefilterManager(Configurable):
     """Main prefilter component.
-
+    
     The IPython prefilter is run on all user input before it is run.  The
     prefilter consumes lines of input and produces transformed lines of
     input.
-
+    
     The implementation consists of two phases:
-
+    
     1. Transformers
     2. Checkers and handlers
-
+    
     Over time, we plan on deprecating the checkers and handlers and doing
     everything in the transformers.
-
+    
     The transformers are instances of :class:`PrefilterTransformer` and have
     a single method :meth:`transform` that takes a line and returns a
     transformed line.  The transformation can be accomplished using any
     tool, but our current ones use regular expressions for speed.
-
+    
     After all the transformers have been run, the line is fed to the checkers,
     which are instances of :class:`PrefilterChecker`.  The line is passed to
     the :meth:`check` method, which either returns `None` or a
@@ -102,16 +115,23 @@
     checkers are tried.  If an :class:`PrefilterHandler` instance is returned,
     the line is passed to the :meth:`handle` method of the returned
     handler and no further checkers are tried.
-
+    
     Both transformers and checkers have a `priority` attribute, that determines
     the order in which they are called.  Smaller priorities are tried first.
-
+    
     Both transformers and checkers also have `enabled` attribute, which is
     a boolean that determines if the instance is used.
-
+    
     Users or developers can change the priority or enabled attribute of
     transformers or checkers, but they must call the :meth:`sort_checkers`
     or :meth:`sort_transformers` method after changing the priority.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     multi_line_specials = Bool(True).tag(config=True)
@@ -138,25 +158,52 @@
 
     def sort_transformers(self):
         """Sort the transformers by priority.
-
+        
         This must be called after the priority of a transformer is changed.
         The :meth:`register_transformer` method calls this automatically.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self._transformers.sort(key=lambda x: x.priority)
 
     @property
     def transformers(self):
-        """Return a list of checkers, sorted by priority."""
+        """ """
         return self._transformers
 
     def register_transformer(self, transformer):
-        """Register a transformer instance."""
+        """Register a transformer instance.
+
+        Parameters
+        ----------
+        transformer :
+            
+
+        Returns
+        -------
+
+        """
         if transformer not in self._transformers:
             self._transformers.append(transformer)
             self.sort_transformers()
 
     def unregister_transformer(self, transformer):
-        """Unregister a transformer instance."""
+        """Unregister a transformer instance.
+
+        Parameters
+        ----------
+        transformer :
+            
+
+        Returns
+        -------
+
+        """
         if transformer in self._transformers:
             self._transformers.remove(transformer)
 
@@ -174,25 +221,52 @@
 
     def sort_checkers(self):
         """Sort the checkers by priority.
-
+        
         This must be called after the priority of a checker is changed.
         The :meth:`register_checker` method calls this automatically.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self._checkers.sort(key=lambda x: x.priority)
 
     @property
     def checkers(self):
-        """Return a list of checkers, sorted by priority."""
+        """ """
         return self._checkers
 
     def register_checker(self, checker):
-        """Register a checker instance."""
+        """Register a checker instance.
+
+        Parameters
+        ----------
+        checker :
+            
+
+        Returns
+        -------
+
+        """
         if checker not in self._checkers:
             self._checkers.append(checker)
             self.sort_checkers()
 
     def unregister_checker(self, checker):
-        """Unregister a checker instance."""
+        """Unregister a checker instance.
+
+        Parameters
+        ----------
+        checker :
+            
+
+        Returns
+        -------
+
+        """
         if checker in self._checkers:
             self._checkers.remove(checker)
 
@@ -211,17 +285,45 @@
 
     @property
     def handlers(self):
-        """Return a dict of all the handlers."""
+        """ """
         return self._handlers
 
     def register_handler(self, name, handler, esc_strings):
-        """Register a handler instance by name with esc_strings."""
+        """Register a handler instance by name with esc_strings.
+
+        Parameters
+        ----------
+        name :
+            
+        handler :
+            
+        esc_strings :
+            
+
+        Returns
+        -------
+
+        """
         self._handlers[name] = handler
         for esc_str in esc_strings:
             self._esc_handlers[esc_str] = handler
 
     def unregister_handler(self, name, handler, esc_strings):
-        """Unregister a handler instance by name with esc_strings."""
+        """Unregister a handler instance by name with esc_strings.
+
+        Parameters
+        ----------
+        name :
+            
+        handler :
+            
+        esc_strings :
+            
+
+        Returns
+        -------
+
+        """
         try:
             del self._handlers[name]
         except KeyError:
@@ -232,11 +334,31 @@
                 del self._esc_handlers[esc_str]
 
     def get_handler_by_name(self, name):
-        """Get a handler by its name."""
+        """Get a handler by its name.
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return self._handlers.get(name)
 
     def get_handler_by_esc(self, esc_str):
-        """Get a handler by its escape string."""
+        """Get a handler by its escape string.
+
+        Parameters
+        ----------
+        esc_str :
+            
+
+        Returns
+        -------
+
+        """
         return self._esc_handlers.get(esc_str)
 
     #-------------------------------------------------------------------------
@@ -245,15 +367,34 @@
 
     def prefilter_line_info(self, line_info):
         """Prefilter a line that has been converted to a LineInfo object.
-
+        
         This implements the checker/handler part of the prefilter pipe.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
         """
         # print "prefilter_line_info: ", line_info
         handler = self.find_handler(line_info)
         return handler.handle(line_info)
 
     def find_handler(self, line_info):
-        """Find a handler for the line_info by trying checkers."""
+        """Find a handler for the line_info by trying checkers.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         for checker in self.checkers:
             if checker.enabled:
                 handler = checker.check(line_info)
@@ -262,7 +403,19 @@
         return self.get_handler_by_name('normal')
 
     def transform_line(self, line, continue_prompt):
-        """Calls the enabled transformers in order of increasing priority."""
+        """Calls the enabled transformers in order of increasing priority.
+
+        Parameters
+        ----------
+        line :
+            
+        continue_prompt :
+            
+
+        Returns
+        -------
+
+        """
         for transformer in self.transformers:
             if transformer.enabled:
                 line = transformer.transform(line, continue_prompt)
@@ -270,9 +423,20 @@
 
     def prefilter_line(self, line, continue_prompt=False):
         """Prefilter a single input line as text.
-
+        
         This method prefilters a single line of text by calling the
         transformers and then the checkers/handlers.
+
+        Parameters
+        ----------
+        line :
+            
+        continue_prompt :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
 
         # print "prefilter_line: ", line, continue_prompt
@@ -313,14 +477,25 @@
 
     def prefilter_lines(self, lines, continue_prompt=False):
         """Prefilter multiple input lines of text.
-
+        
         This is the main entry point for prefiltering multiple lines of
         input.  This simply calls :meth:`prefilter_line` for each line of
         input.
-
+        
         This covers cases where there are multiple lines in the user entry,
         which is the case when the user goes back to a multiline history
         entry and presses enter.
+
+        Parameters
+        ----------
+        lines :
+            
+        continue_prompt :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         llines = lines.rstrip('\n').split('\n')
         # We can get multiple lines in one shot, where multiline input 'blends'
@@ -358,7 +533,19 @@
         self.prefilter_manager.register_transformer(self)
 
     def transform(self, line, continue_prompt):
-        """Transform a line, returning the new one."""
+        """Transform a line, returning the new one.
+
+        Parameters
+        ----------
+        line :
+            
+        continue_prompt :
+            
+
+        Returns
+        -------
+
+        """
         return None
 
     def __repr__(self):
@@ -386,7 +573,17 @@
         self.prefilter_manager.register_checker(self)
 
     def check(self, line_info):
-        """Inspect line_info and return a handler instance or None."""
+        """Inspect line_info and return a handler instance or None.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         return None
 
     def __repr__(self):
@@ -395,11 +592,23 @@
 
 
 class EmacsChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(100).tag(config=True)
     enabled = Bool(False).tag(config=True)
 
     def check(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         "Emacs ipython-mode tags certain input lines."
         if line_info.line.endswith('# PYTHON-MODE'):
             return self.prefilter_manager.get_handler_by_name('emacs')
@@ -408,10 +617,22 @@
 
 
 class MacroChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(250).tag(config=True)
 
     def check(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         obj = self.shell.user_ns.get(line_info.ifun)
         if isinstance(obj, Macro):
             return self.prefilter_manager.get_handler_by_name('macro')
@@ -420,10 +641,22 @@
 
 
 class IPyAutocallChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(300).tag(config=True)
 
     def check(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         "Instances of IPyAutocall in user_ns get autocalled immediately"
         obj = self.shell.user_ns.get(line_info.ifun, None)
         if isinstance(obj, IPyAutocall):
@@ -434,16 +667,27 @@
 
 
 class AssignmentChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(600).tag(config=True)
 
     def check(self, line_info):
         """Check to see if user is assigning to a var for the first time, in
         which case we want to avoid any sort of automagic / autocall games.
-
+        
         This allows users to assign to either alias or magic names true python
         variables (the magic/alias systems always take second seat to true
-        python code).  E.g. ls='hi', or ls,that=1,2"""
+        python code).  E.g. ls='hi', or ls,that=1,2
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         if line_info.the_rest:
             if line_info.the_rest[0] in '=,':
                 return self.prefilter_manager.get_handler_by_name('normal')
@@ -452,6 +696,7 @@
 
 
 class AutoMagicChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(700).tag(config=True)
 
@@ -460,7 +705,17 @@
         non-auto magic would already have been triggered via '%' in
         check_esc_chars. This just checks for automagic.  Also, before
         triggering the magic handler, make sure that there is nothing in the
-        user namespace which could shadow it."""
+        user namespace which could shadow it.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         if not self.shell.automagic or not self.shell.find_magic(line_info.ifun):
             return None
 
@@ -476,6 +731,7 @@
 
 
 class PythonOpsChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(900).tag(config=True)
 
@@ -483,7 +739,17 @@
         """If the 'rest' of the line begins with a function call or pretty much
         any python operator, we should simply execute the line (regardless of
         whether or not there's a possible autocall expansion).  This avoids
-        spurious (and very confusing) geattr() accesses."""
+        spurious (and very confusing) geattr() accesses.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         if line_info.the_rest and line_info.the_rest[0] in '!=()<>,+*/%^&|':
             return self.prefilter_manager.get_handler_by_name('normal')
         else:
@@ -491,6 +757,7 @@
 
 
 class AutocallChecker(PrefilterChecker):
+    """ """
 
     priority = Integer(1000).tag(config=True)
 
@@ -502,6 +769,17 @@
         ).tag(config=True)
 
     def check(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         "Check if the initial word/function is callable and autocall is on."
         if not self.shell.autocall:
             return None
@@ -530,6 +808,7 @@
 
 
 class PrefilterHandler(Configurable):
+    """ """
 
     handler_name = Unicode('normal')
     esc_strings = List([])
@@ -547,6 +826,17 @@
         )
 
     def handle(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         # print "normal: ", line_info
         """Handle normal input lines. Use as a template for handlers."""
 
@@ -571,9 +861,21 @@
 
 
 class MacroHandler(PrefilterHandler):
+    """ """
     handler_name = Unicode("macro")
 
     def handle(self, line_info):
+        """
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         obj = self.shell.user_ns.get(line_info.ifun)
         pre_space = line_info.pre_whitespace
         line_sep = "\n" + pre_space
@@ -581,12 +883,23 @@
 
 
 class MagicHandler(PrefilterHandler):
+    """ """
 
     handler_name = Unicode('magic')
     esc_strings = List([ESC_MAGIC])
 
     def handle(self, line_info):
-        """Execute magic functions."""
+        """Execute magic functions.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         ifun    = line_info.ifun
         the_rest = line_info.the_rest
         #Prepare arguments for get_ipython().run_line_magic(magic_name, magic_args)
@@ -598,12 +911,23 @@
 
 
 class AutoHandler(PrefilterHandler):
+    """ """
 
     handler_name = Unicode('auto')
     esc_strings = List([ESC_PAREN, ESC_QUOTE, ESC_QUOTE2])
 
     def handle(self, line_info):
-        """Handle lines which can be auto-executed, quoting if requested."""
+        """Handle lines which can be auto-executed, quoting if requested.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
         line    = line_info.line
         ifun    = line_info.ifun
         the_rest = line_info.the_rest
@@ -668,12 +992,23 @@
 
 
 class EmacsHandler(PrefilterHandler):
+    """ """
 
     handler_name = Unicode('emacs')
     esc_strings = List([])
 
     def handle(self, line_info):
-        """Handle input lines marked by python-mode."""
+        """Handle input lines marked by python-mode.
+
+        Parameters
+        ----------
+        line_info :
+            
+
+        Returns
+        -------
+
+        """
 
         # Currently, nothing is done.  Later more functionality can be added
         # here if needed.
