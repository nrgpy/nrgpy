# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/test_multilevel.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/test_multilevel.py
@@ -29,7 +29,19 @@
 
 
 class Base:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
 
         index = MultiIndex(
             levels=[["foo", "bar", "baz", "qux"], ["one", "two", "three"]],
@@ -70,7 +82,9 @@
 
 
 class TestMultiLevel(Base):
+    """ """
     def test_append(self):
+        """ """
         a, b = self.frame[:5], self.frame[5:]
 
         result = a.append(b)
@@ -80,6 +94,7 @@
         tm.assert_series_equal(result, self.frame["A"])
 
     def test_dataframe_constructor(self):
+        """ """
         multi = DataFrame(
             np.random.randn(4, 4),
             index=[np.array(["a", "a", "b", "b"]), np.array(["x", "y", "x", "y"])],
@@ -93,6 +108,7 @@
         assert isinstance(multi.columns, MultiIndex)
 
     def test_series_constructor(self):
+        """ """
         multi = Series(
             1.0, index=[np.array(["a", "a", "b", "b"]), np.array(["x", "y", "x", "y"])]
         )
@@ -105,6 +121,7 @@
         assert isinstance(multi.index, MultiIndex)
 
     def test_reindex_level(self):
+        """ """
         # axis=0
         month_sums = self.ymd.sum(level="month")
         result = month_sums.reindex(self.ymd.index, level=1)
@@ -124,7 +141,19 @@
         tm.assert_frame_equal(result, expected)
 
     def test_binops_level(self):
+        """ """
         def _check_op(opname):
+            """
+
+            Parameters
+            ----------
+            opname :
+                
+
+            Returns
+            -------
+
+            """
             op = getattr(DataFrame, opname)
             month_sums = self.ymd.sum(level="month")
             result = op(self.ymd, month_sums, level="month")
@@ -147,7 +176,19 @@
         _check_op("div")
 
     def test_pickle(self):
+        """ """
         def _test_roundtrip(frame):
+            """
+
+            Parameters
+            ----------
+            frame :
+                
+
+            Returns
+            -------
+
+            """
             unpickled = tm.round_trip_pickle(frame)
             tm.assert_frame_equal(frame, unpickled)
 
@@ -157,11 +198,13 @@
         _test_roundtrip(self.ymd.T)
 
     def test_reindex(self):
+        """ """
         expected = self.frame.iloc[[0, 3]]
         reindexed = self.frame.loc[[("foo", "one"), ("bar", "one")]]
         tm.assert_frame_equal(reindexed, expected)
 
     def test_reindex_preserve_levels(self):
+        """ """
         new_index = self.ymd.index[::10]
         chunk = self.ymd.reindex(new_index)
         assert chunk.index is new_index
@@ -177,6 +220,7 @@
         assert chunk.columns is new_index
 
     def test_repr_to_string(self):
+        """ """
         repr(self.frame)
         repr(self.ymd)
         repr(self.frame.T)
@@ -189,6 +233,7 @@
         self.ymd.T.to_string(buf=buf)
 
     def test_repr_name_coincide(self):
+        """ """
         index = MultiIndex.from_tuples(
             [("a", 0, "foo"), ("b", 1, "bar")], names=["a", "b", "c"]
         )
@@ -199,6 +244,7 @@
         assert lines[2].startswith("a 0 foo")
 
     def test_delevel_infer_dtype(self):
+        """ """
         tuples = list(product(["foo", "bar"], [10, 20], [1.0, 1.1]))
         index = MultiIndex.from_tuples(tuples, names=["prm0", "prm1", "prm2"])
         df = DataFrame(np.random.randn(8, 3), columns=["A", "B", "C"], index=index)
@@ -207,6 +253,7 @@
         assert is_float_dtype(deleveled["prm2"])
 
     def test_reset_index_with_drop(self):
+        """ """
         deleveled = self.ymd.reset_index(drop=True)
         assert len(deleveled.columns) == len(self.ymd.columns)
         assert deleveled.index.name == self.ymd.index.name
@@ -221,7 +268,21 @@
         assert deleveled.index.name == self.series.index.name
 
     def test_count_level(self):
+        """ """
         def _check_counts(frame, axis=0):
+            """
+
+            Parameters
+            ----------
+            frame :
+                
+            axis :
+                 (Default value = 0)
+
+            Returns
+            -------
+
+            """
             index = frame._get_axis(axis)
             for i in range(index.nlevels):
                 result = frame.count(axis=axis, level=i)
@@ -249,6 +310,7 @@
         tm.assert_index_equal(result.columns, Index(list("ABC"), name="exp"))
 
     def test_count_index_with_nan(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/21824
         df = DataFrame(
             {
@@ -277,6 +339,7 @@
         tm.assert_frame_equal(res, expected)
 
     def test_count_level_series(self):
+        """ """
         index = MultiIndex(
             levels=[["foo", "bar", "baz"], ["one", "two", "three", "four"]],
             codes=[[0, 0, 0, 2, 2], [2, 0, 1, 1, 2]],
@@ -297,6 +360,7 @@
         )
 
     def test_count_level_corner(self):
+        """ """
         s = self.frame["A"][:0]
         result = s.count(level=0)
         expected = Series(0, index=s.index.levels[0], name="A")
@@ -312,12 +376,14 @@
         tm.assert_frame_equal(result, expected)
 
     def test_get_level_number_out_of_bounds(self):
+        """ """
         with pytest.raises(IndexError, match="Too many levels"):
             self.frame.index._get_level_number(2)
         with pytest.raises(IndexError, match="not a valid level number"):
             self.frame.index._get_level_number(-3)
 
     def test_unstack(self):
+        """ """
         # just check that it works for now
         unstacked = self.ymd.unstack()
         unstacked.unstack()
@@ -354,6 +420,23 @@
     def test_unstack_partial(
         self, result_rows, result_columns, index_product, expected_row
     ):
+        """
+
+        Parameters
+        ----------
+        result_rows :
+            
+        result_columns :
+            
+        index_product :
+            
+        expected_row :
+            
+
+        Returns
+        -------
+
+        """
         # check for regressions on this issue:
         # https://github.com/pandas-dev/pandas/issues/19351
         # make sure DataFrame.unstack() works when its run on a subset of the DataFrame
@@ -372,6 +455,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_unstack_multiple_no_empty_columns(self):
+        """ """
         index = MultiIndex.from_tuples(
             [(0, "foo", 0), (0, "bar", 0), (1, "baz", 1), (1, "qux", 1)]
         )
@@ -383,6 +467,7 @@
         tm.assert_frame_equal(unstacked, expected)
 
     def test_stack(self):
+        """ """
         # regular roundtrip
         unstacked = self.ymd.unstack()
         restacked = unstacked.stack()
@@ -437,6 +522,19 @@
 
         # GH10417
         def check(left, right):
+            """
+
+            Parameters
+            ----------
+            left :
+                
+            right :
+                
+
+            Returns
+            -------
+
+            """
             tm.assert_series_equal(left, right)
             assert left.index.is_unique is False
             li, ri = left.index, right.index
@@ -480,18 +578,24 @@
         check(left, right)
 
     def test_unstack_odd_failure(self):
-        data = """day,time,smoker,sum,len
-Fri,Dinner,No,8.25,3.
-Fri,Dinner,Yes,27.03,9
-Fri,Lunch,No,3.0,1
-Fri,Lunch,Yes,13.68,6
-Sat,Dinner,No,139.63,45
-Sat,Dinner,Yes,120.77,42
-Sun,Dinner,No,180.57,57
-Sun,Dinner,Yes,66.82,19
-Thur,Dinner,No,3.0,1
-Thur,Lunch,No,117.32,44
-Thur,Lunch,Yes,51.51,17"""
+        """data = """day,time,smoker,sum,len
+        Fri,Dinner,No,8.25,3.
+        Fri,Dinner,Yes,27.03,9
+        Fri,Lunch,No,3.0,1
+        Fri,Lunch,Yes,13.68,6
+        Sat,Dinner,No,139.63,45
+        Sat,Dinner,Yes,120.77,42
+        Sun,Dinner,No,180.57,57
+        Sun,Dinner,Yes,66.82,19
+        Thur,Dinner,No,3.0,1
+        Thur,Lunch,No,117.32,44
+        Thur,Lunch,Yes,51.51,17
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         df = pd.read_csv(StringIO(data)).set_index(["day", "time", "smoker"])
 
@@ -502,6 +606,7 @@
         tm.assert_frame_equal(recons, df)
 
     def test_stack_mixed_dtype(self):
+        """ """
         df = self.frame.T
         df["foo", "four"] = "foo"
         df = df.sort_index(level=1, axis=1)
@@ -513,6 +618,7 @@
         assert stacked["bar"].dtype == np.float_
 
     def test_unstack_bug(self):
+        """ """
         df = DataFrame(
             {
                 "state": ["naive", "naive", "naive", "activ", "activ", "activ"],
@@ -530,6 +636,7 @@
         tm.assert_series_equal(restacked, result.reindex(restacked.index).astype(float))
 
     def test_stack_unstack_preserve_names(self):
+        """ """
         unstacked = self.frame.unstack()
         assert unstacked.index.name == "first"
         assert unstacked.columns.names == ["exp", "second"]
@@ -539,6 +646,17 @@
 
     @pytest.mark.parametrize("method", ["stack", "unstack"])
     def test_stack_unstack_wrong_level_name(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # GH 18303 - wrong level name should raise
 
         # A DataFrame with flat axes:
@@ -554,6 +672,7 @@
                 getattr(s, method)("mistake")
 
     def test_unused_level_raises(self):
+        """ """
         # GH 20410
         mi = MultiIndex(
             levels=[["a_lot", "onlyone", "notevenone"], [1970, ""]],
@@ -565,11 +684,13 @@
             df["notevenone"]
 
     def test_unstack_level_name(self):
+        """ """
         result = self.frame.unstack("second")
         expected = self.frame.unstack(level=1)
         tm.assert_frame_equal(result, expected)
 
     def test_stack_level_name(self):
+        """ """
         unstacked = self.frame.unstack("second")
         result = unstacked.stack("exp")
         expected = self.frame.unstack().stack(0)
@@ -580,6 +701,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_stack_unstack_multiple(self):
+        """ """
         unstacked = self.ymd.unstack(["year", "month"])
         expected = self.ymd.unstack("year").unstack("month")
         tm.assert_frame_equal(unstacked, expected)
@@ -607,6 +729,7 @@
         tm.assert_frame_equal(unstacked, expected.loc[:, unstacked.columns])
 
     def test_stack_names_and_numbers(self):
+        """ """
         unstacked = self.ymd.unstack(["year", "month"])
 
         # Can't use mixture of names and numbers to stack
@@ -614,6 +737,7 @@
             unstacked.stack([0, "month"])
 
     def test_stack_multiple_out_of_bounds(self):
+        """ """
         # nlevels == 3
         unstacked = self.ymd.unstack(["year", "month"])
 
@@ -623,6 +747,7 @@
             unstacked.stack([-4, -3])
 
     def test_unstack_period_series(self):
+        """ """
         # GH 4342
         idx1 = pd.PeriodIndex(
             ["2013-01", "2013-01", "2013-02", "2013-02", "2013-03", "2013-03"],
@@ -692,6 +817,7 @@
         tm.assert_frame_equal(result3, expected.T)
 
     def test_unstack_period_frame(self):
+        """ """
         # GH 4342
         idx1 = pd.PeriodIndex(
             ["2014-01", "2014-02", "2014-02", "2014-02", "2014-01", "2014-01"],
@@ -739,7 +865,7 @@
         tm.assert_frame_equal(result3, expected)
 
     def test_stack_multiple_bug(self):
-        """ bug when some uniques are not present in the data #3170"""
+        """bug when some uniques are not present in the data #3170"""
         id_col = ([1] * 3) + ([2] * 3)
         name = (["a"] * 3) + (["b"] * 3)
         date = pd.to_datetime(["2013-01-03", "2013-01-04", "2013-01-05"] * 2)
@@ -757,6 +883,7 @@
         tm.assert_frame_equal(rs, xp)
 
     def test_stack_dropna(self):
+        """ """
         # GH #3997
         df = DataFrame({"A": ["a1", "a2"], "B": ["b1", "b2"], "C": [1, 1]})
         df = df.set_index(["A", "B"])
@@ -768,6 +895,7 @@
         tm.assert_frame_equal(stacked, stacked.dropna())
 
     def test_unstack_multiple_hierarchical(self):
+        """ """
         df = DataFrame(
             index=[
                 [0, 0, 0, 0, 1, 1, 1, 1],
@@ -784,6 +912,7 @@
         df.unstack(["b", "c"])
 
     def test_groupby_transform(self):
+        """ """
         s = self.frame["A"]
         grouper = s.index.get_level_values(0)
 
@@ -795,6 +924,7 @@
         tm.assert_series_equal(result, expected, check_names=False)
 
     def test_unstack_sparse_keyspace(self):
+        """ """
         # memory problems with naive impl #2278
         # Generate Long File & Test Pivot
         NUM_ROWS = 1000
@@ -816,6 +946,7 @@
         idf.unstack("E")
 
     def test_unstack_unobserved_keys(self):
+        """ """
         # related to #2278 refactoring
         levels = [[0, 1], [0, 1, 2, 3]]
         codes = [[0, 0, 1, 1], [0, 2, 0, 2]]
@@ -832,6 +963,7 @@
 
     @pytest.mark.slow
     def test_unstack_number_of_levels_larger_than_int32(self):
+        """ """
         # GH 20601
         df = DataFrame(
             np.random.randn(2 ** 16, 2), index=[np.arange(2 ** 16), np.arange(2 ** 16)]
@@ -840,9 +972,27 @@
             df.unstack()
 
     def test_stack_order_with_unsorted_levels(self):
+        """ """
         # GH 16323
 
         def manual_compare_stacked(df, df_stacked, lev0, lev1):
+            """
+
+            Parameters
+            ----------
+            df :
+                
+            df_stacked :
+                
+            lev0 :
+                
+            lev1 :
+                
+
+            Returns
+            -------
+
+            """
             assert all(
                 df.loc[row, col] == df_stacked.loc[(row, col[lev0]), col[lev1]]
                 for row in df.index
@@ -873,6 +1023,7 @@
         manual_compare_stacked(df, df.stack(0), 0, 1)
 
     def test_stack_unstack_unordered_multiindex(self):
+        """ """
         # GH 18265
         values = np.arange(5)
         data = np.vstack(
@@ -898,6 +1049,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_groupby_corner(self):
+        """ """
         midx = MultiIndex(
             levels=[["foo"], ["bar"], ["baz"]],
             codes=[[0], [0], [0]],
@@ -908,6 +1060,7 @@
         df.groupby(level="three")
 
     def test_groupby_level_no_obs(self):
+        """ """
         # #1697
         midx = MultiIndex.from_tuples(
             [
@@ -927,6 +1080,7 @@
         assert (result.columns == ["f2", "f3"]).all()
 
     def test_join(self):
+        """ """
         a = self.frame.loc[self.frame.index[:5], ["A"]]
         b = self.frame.loc[self.frame.index[2:], ["B", "C"]]
 
@@ -940,6 +1094,7 @@
         tm.assert_frame_equal(joined, expected, check_names=False)
 
     def test_swaplevel(self):
+        """ """
         swapped = self.frame["A"].swaplevel()
         swapped2 = self.frame["A"].swaplevel(0)
         swapped3 = self.frame["A"].swaplevel(0, 1)
@@ -968,12 +1123,14 @@
             DataFrame(range(3)).swaplevel()
 
     def test_insert_index(self):
+        """ """
         df = self.ymd[:5].T
         df[2000, 1, 10] = df[2000, 1, 7]
         assert isinstance(df.columns, MultiIndex)
         assert (df[2000, 1, 10] == df[2000, 1, 7]).all()
 
     def test_alignment(self):
+        """ """
         x = Series(
             data=[1, 2, 3], index=MultiIndex.from_tuples([("A", 1), ("A", 2), ("B", 3)])
         )
@@ -994,6 +1151,7 @@
         tm.assert_series_equal(res, exp)
 
     def test_count(self):
+        """ """
         frame = self.frame.copy()
         frame.index.names = ["a", "b"]
 
@@ -1027,6 +1185,23 @@
     @pytest.mark.parametrize("skipna", [True, False])
     @pytest.mark.parametrize("sort", [True, False])
     def test_series_group_min_max(self, op, level, skipna, sort):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        level :
+            
+        skipna :
+            
+        sort :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17537
         grouped = self.series.groupby(level=level, sort=sort)
         # skipna=True
@@ -1042,6 +1217,25 @@
     @pytest.mark.parametrize("skipna", [True, False])
     @pytest.mark.parametrize("sort", [True, False])
     def test_frame_group_ops(self, op, level, axis, skipna, sort):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        level :
+            
+        axis :
+            
+        skipna :
+            
+        sort :
+            
+
+        Returns
+        -------
+
+        """
         # GH 17537
         self.frame.iloc[1, [1, 2]] = np.nan
         self.frame.iloc[7, [0, 1]] = np.nan
@@ -1058,6 +1252,17 @@
         pieces = []
 
         def aggf(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             pieces.append(x)
             return getattr(x, op)(skipna=skipna, axis=axis)
 
@@ -1076,6 +1281,7 @@
         tm.assert_frame_equal(leftside, rightside)
 
     def test_stat_op_corner(self):
+        """ """
         obj = Series([10.0], index=MultiIndex.from_tuples([(2, 3)]))
 
         result = obj.sum(level=0)
@@ -1083,6 +1289,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_frame_any_all_group(self):
+        """ """
         df = DataFrame(
             {"data": [False, False, True, False, True, False, True]},
             index=[
@@ -1100,6 +1307,7 @@
         tm.assert_frame_equal(result, ex)
 
     def test_series_any_timedelta(self):
+        """ """
         # GH 17667
         df = DataFrame(
             {
@@ -1117,6 +1325,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_std_var_pass_ddof(self):
+        """ """
         index = MultiIndex.from_arrays(
             [np.arange(5).repeat(10), np.tile(np.arange(10), 5)]
         )
@@ -1135,6 +1344,7 @@
             tm.assert_frame_equal(result, expected)
 
     def test_frame_series_agg_multiple_levels(self):
+        """ """
         result = self.ymd.sum(level=["year", "month"])
         expected = self.ymd.groupby(level=["year", "month"]).sum()
         tm.assert_frame_equal(result, expected)
@@ -1144,6 +1354,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_groupby_multilevel(self):
+        """ """
         result = self.ymd.groupby(level=[0, 1]).mean()
 
         k1 = self.ymd.index.get_level_values(0)
@@ -1159,9 +1370,11 @@
         tm.assert_frame_equal(result, result2)
 
     def test_groupby_multilevel_with_transform(self):
+        """ """
         pass
 
     def test_multilevel_consolidate(self):
+        """ """
         index = MultiIndex.from_tuples(
             [("foo", "one"), ("foo", "two"), ("bar", "one"), ("bar", "two")]
         )
@@ -1170,6 +1383,7 @@
         df = df._consolidate()
 
     def test_loc_preserve_names(self):
+        """ """
         result = self.ymd.loc[2000]
         result2 = self.ymd["A"].loc[2000]
         assert result.index.names == self.ymd.index.names[1:]
@@ -1181,6 +1395,7 @@
         assert result2.index.name == self.ymd.index.names[2]
 
     def test_unstack_preserve_types(self):
+        """ """
         # GH #403
         self.ymd["E"] = "foo"
         self.ymd["F"] = 2
@@ -1191,6 +1406,7 @@
         assert unstacked["F", 1].dtype == np.float64
 
     def test_unstack_group_index_overflow(self):
+        """ """
         codes = np.tile(np.arange(500), 2)
         level = np.arange(500)
 
@@ -1228,11 +1444,13 @@
         assert result.shape == (500, 2)
 
     def test_to_html(self):
+        """ """
         self.ymd.columns.name = "foo"
         self.ymd.to_html()
         self.ymd.T.to_html()
 
     def test_level_with_tuples(self):
+        """ """
         index = MultiIndex(
             levels=[[("foo", "bar", 0), ("foo", "baz", 0), ("foo", "qux", 0)], [0, 1]],
             codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
@@ -1281,6 +1499,7 @@
         tm.assert_frame_equal(result2, expected)
 
     def test_mixed_depth_pop(self):
+        """ """
         arrays = [
             ["a", "top", "top", "routine1", "routine1", "routine2"],
             ["", "OD", "OD", "result1", "result2", "result1"],
@@ -1306,6 +1525,7 @@
         tm.assert_frame_equal(df1, df2)
 
     def test_reindex_level_partial_selection(self):
+        """ """
         result = self.frame.reindex(["foo", "qux"], level=0)
         expected = self.frame.iloc[[0, 1, 2, 7, 8, 9]]
         tm.assert_frame_equal(result, expected)
@@ -1323,6 +1543,7 @@
         tm.assert_frame_equal(result, expected.T)
 
     def test_unicode_repr_level_names(self):
+        """ """
         index = MultiIndex.from_tuples([(0, 0), (1, 1)], names=["\u0394", "i1"])
 
         s = Series(range(2), index=index)
@@ -1331,6 +1552,7 @@
         repr(df)
 
     def test_join_segfault(self):
+        """ """
         # 1532
         df1 = DataFrame({"a": [1, 1], "b": [1, 2], "x": [1, 2]})
         df2 = DataFrame({"a": [2, 2], "b": [1, 2], "y": [1, 2]})
@@ -1341,6 +1563,7 @@
             df1.join(df2, how=how)
 
     def test_frame_dict_constructor_empty_series(self):
+        """ """
         s1 = Series(
             [1, 2, 3, 4], index=MultiIndex.from_tuples([(1, 2), (1, 3), (2, 2), (2, 4)])
         )
@@ -1355,6 +1578,17 @@
 
     @pytest.mark.parametrize("d", [4, "d"])
     def test_empty_frame_groupby_dtypes_consistency(self, d):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20888
         group_keys = ["a", "b", "c"]
         df = DataFrame({"a": [1], "b": [2], "c": [3], "d": [d]})
@@ -1368,6 +1602,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_multiindex_na_repr(self):
+        """ """
         # only an issue with long columns
         df3 = DataFrame(
             {
@@ -1384,6 +1619,7 @@
         repr(idf)
 
     def test_assign_index_sequences(self):
+        """ """
         # #2200
         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]}).set_index(
             ["a", "b"]
@@ -1399,6 +1635,7 @@
         repr(df)
 
     def test_duplicate_groupby_issues(self):
+        """ """
         idx_tp = [
             ("600809", "20061231"),
             ("600809", "20070331"),
@@ -1414,6 +1651,7 @@
         assert len(result) == 3
 
     def test_duplicate_mi(self):
+        """ """
         # GH 4516
         df = DataFrame(
             [
@@ -1436,6 +1674,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_multiindex_set_index(self):
+        """ """
         # segfault in #3308
         d = {"t1": [2, 2.5, 3], "t2": [4, 5, 6]}
         df = DataFrame(d)
@@ -1447,6 +1686,7 @@
         df.set_index(index)
 
     def test_set_index_datetime(self):
+        """ """
         # GH 3950
         df = DataFrame(
             {
@@ -1529,6 +1769,7 @@
         tm.assert_index_equal(df.index.get_level_values(2), idx3)
 
     def test_reset_index_datetime(self):
+        """ """
         # GH 3950
         for tz in ["UTC", "Asia/Tokyo", "US/Eastern"]:
             idx1 = pd.date_range("1/1/2011", periods=5, freq="D", tz=tz, name="idx1")
@@ -1622,6 +1863,7 @@
             tm.assert_frame_equal(df.reset_index(), expected)
 
     def test_reset_index_period(self):
+        """ """
         # GH 7746
         idx = MultiIndex.from_product(
             [pd.period_range("20130101", periods=3, freq="M"), list("abc")],
@@ -1646,6 +1888,7 @@
         tm.assert_frame_equal(df.reset_index(), expected)
 
     def test_reset_index_multiindex_columns(self):
+        """ """
         levels = [["A", ""], ["B", "b"]]
         df = DataFrame([[0, 2], [1, 3]], columns=MultiIndex.from_tuples(levels))
         result = df[["B"]].rename_axis("A").reset_index()
@@ -1698,6 +1941,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_set_index_period(self):
+        """ """
         # GH 6631
         df = DataFrame(np.random.random(6))
         idx1 = pd.period_range("2011-01-01", periods=3, freq="M")
@@ -1722,6 +1966,7 @@
         tm.assert_index_equal(df.index.get_level_values(2), idx3)
 
     def test_repeat(self):
+        """ """
         # GH 9361
         # fixed by # GH 7891
         m_idx = MultiIndex.from_tuples([(1, 2), (3, 4), (5, 6), (7, 8)])
@@ -1730,6 +1975,7 @@
         assert m_df.repeat(3).shape == (3 * len(data),)
 
     def test_subsets_multiindex_dtype(self):
+        """ """
         # GH 20757
         data = [["x", 1]]
         columns = [("a", "b", np.nan), ("a", "c", 0.0)]
@@ -1740,13 +1986,15 @@
 
 
 class TestSorted(Base):
-    """ everything you wanted to test about sorting """
+    """everything you wanted to test about sorting"""
 
     def test_sort_index_preserve_levels(self):
+        """ """
         result = self.frame.sort_index()
         assert result.index.names == self.frame.index.names
 
     def test_sorting_repr_8017(self):
+        """ """
 
         np.random.seed(0)
         data = np.random.randn(3, 4)
@@ -1804,6 +2052,7 @@
             tm.assert_frame_equal(result, expected)
 
     def test_sort_non_lexsorted(self):
+        """ """
         # degenerate case where we sort but don't
         # have a satisfying result :<
         # GH 15797
@@ -1843,6 +2092,21 @@
     )
     @pytest.mark.parametrize("dim", ["index", "columns"])
     def test_multilevel_index_loc_order(self, dim, keys, expected):
+        """
+
+        Parameters
+        ----------
+        dim :
+            
+        keys :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 22797
         # Try to respect order of keys given for MultiIndex.loc
         kwargs = {dim: [["c", "a", "a", "b", "b"], [1, 1, 2, 1, 2]]}
