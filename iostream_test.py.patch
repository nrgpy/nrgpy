# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/iostream_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/iostream_test.py
@@ -40,6 +40,7 @@
 
 
 def _server_ssl_options():
+    """ """
     return dict(
         certfile=os.path.join(os.path.dirname(__file__), "test.crt"),
         keyfile=os.path.join(os.path.dirname(__file__), "test.key"),
@@ -47,18 +48,34 @@
 
 
 class HelloHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.write("Hello")
 
 
 class TestIOStreamWebMixin(object):
+    """ """
     def _make_client_iostream(self):
+        """ """
         raise NotImplementedError()
 
     def get_app(self):
+        """ """
         return Application([("/", HelloHandler)])
 
     def test_connection_closed(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # When a server sends a response and then closes the connection,
         # the client must be allowed to read the data before the IOStream
         # closes itself.  Epoll reports closed connections with a separate
@@ -70,6 +87,17 @@
 
     @gen_test
     def test_read_until_close(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         stream = self._make_client_iostream()
         yield stream.connect(("127.0.0.1", self.get_http_port()))
         stream.write(b"GET / HTTP/1.0\r\n\r\n")
@@ -80,6 +108,17 @@
 
     @gen_test
     def test_read_zero_bytes(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         self.stream = self._make_client_iostream()
         yield self.stream.connect(("127.0.0.1", self.get_http_port()))
         self.stream.write(b"GET / HTTP/1.0\r\n\r\n")
@@ -100,6 +139,17 @@
 
     @gen_test
     def test_write_while_connecting(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         stream = self._make_client_iostream()
         connect_fut = stream.connect(("127.0.0.1", self.get_http_port()))
         # unlike the previous tests, try to write before the connection
@@ -122,7 +172,17 @@
 
     @gen_test
     def test_future_interface(self: typing.Any):
-        """Basic test of IOStream's ability to return Futures."""
+        """Basic test of IOStream's ability to return Futures.
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         stream = self._make_client_iostream()
         connect_result = yield stream.connect(("127.0.0.1", self.get_http_port()))
         self.assertIs(connect_result, stream)
@@ -139,6 +199,17 @@
 
     @gen_test
     def test_future_close_while_reading(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         stream = self._make_client_iostream()
         yield stream.connect(("127.0.0.1", self.get_http_port()))
         yield stream.write(b"GET / HTTP/1.0\r\n\r\n")
@@ -148,6 +219,17 @@
 
     @gen_test
     def test_future_read_until_close(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Ensure that the data comes through before the StreamClosedError.
         stream = self._make_client_iostream()
         yield stream.connect(("127.0.0.1", self.get_http_port()))
@@ -163,19 +245,41 @@
 
 
 class TestReadWriteMixin(object):
+    """ """
     # Tests where one stream reads and the other writes.
     # These should work for BaseIOStream implementations.
 
     def make_iostream_pair(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     def iostream_pair(self, **kwargs):
         """Like make_iostream_pair, but called by ``async with``.
-
+        
         In py37 this becomes simpler with contextlib.asynccontextmanager.
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
 
         class IOStreamPairContext:
+            """ """
             def __init__(self, test, kwargs):
                 self.test = test
                 self.kwargs = kwargs
@@ -192,6 +296,7 @@
 
     @gen_test
     def test_write_zero_bytes(self):
+        """ """
         # Attempting to write zero bytes should run the callback without
         # going into an infinite loop.
         rs, ws = yield self.make_iostream_pair()
@@ -201,6 +306,17 @@
 
     @gen_test
     def test_future_delayed_close_callback(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Same as test_delayed_close_callback, but with the future interface.
         rs, ws = yield self.make_iostream_pair()
 
@@ -217,6 +333,17 @@
 
     @gen_test
     def test_close_buffered_data(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Similar to the previous test, but with data stored in the OS's
         # socket buffers instead of the IOStream's read buffer.  Out-of-band
         # close notifications must be delayed until all data has been
@@ -243,6 +370,17 @@
 
     @gen_test
     def test_read_until_close_after_close(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Similar to test_delayed_close_callback, but read_until_close takes
         # a separate code path so test it separately.
         rs, ws = yield self.make_iostream_pair()
@@ -262,6 +400,17 @@
 
     @gen_test
     def test_large_read_until(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Performance test: read_until used to have a quadratic component
         # so a read_until of 4MB would take 8 seconds; now it takes 0.25
         # seconds.
@@ -325,6 +474,17 @@
 
     @gen_test
     def test_close_callback_with_pending_read(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Regression test for a bug that was introduced in 2.3
         # where the IOStream._close_callback would never be called
         # if there were pending reads.
@@ -349,6 +509,17 @@
 
     @gen_test
     def test_future_close_callback(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Regression test for interaction between the Future read interfaces
         # and IOStream._maybe_add_error_listener.
         rs, ws = yield self.make_iostream_pair()
@@ -356,6 +527,7 @@
         cond = Condition()
 
         def close_callback():
+            """ """
             closed[0] = True
             cond.notify()
 
@@ -374,6 +546,17 @@
 
     @gen_test
     def test_write_memoryview(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         try:
             fut = rs.read_bytes(4)
@@ -386,6 +569,17 @@
 
     @gen_test
     def test_read_bytes_partial(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         try:
             # Ask for more than is available with partial=True
@@ -411,6 +605,17 @@
 
     @gen_test
     def test_read_until_max_bytes(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -439,6 +644,17 @@
 
     @gen_test
     def test_read_until_max_bytes_inline(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -458,6 +674,17 @@
 
     @gen_test
     def test_read_until_max_bytes_ignores_extra(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -475,6 +702,17 @@
 
     @gen_test
     def test_read_until_regex_max_bytes(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -503,6 +741,17 @@
 
     @gen_test
     def test_read_until_regex_max_bytes_inline(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -521,6 +770,7 @@
 
     @gen_test
     def test_read_until_regex_max_bytes_ignores_extra(self):
+        """ """
         rs, ws = yield self.make_iostream_pair()
         closed = Event()
         rs.set_close_callback(closed.set)
@@ -538,6 +788,17 @@
 
     @gen_test
     def test_small_reads_from_large_buffer(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # 10KB buffer size, 100KB available to read.
         # Read 1KB at a time and make sure that the buffer is not eagerly
         # filled.
@@ -553,6 +814,17 @@
 
     @gen_test
     def test_small_read_untils_from_large_buffer(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # 10KB buffer size, 100KB available to read.
         # Read 1KB at a time and make sure that the buffer is not eagerly
         # filled.
@@ -568,6 +840,7 @@
 
     @gen_test
     def test_flow_control(self):
+        """ """
         MB = 1024 * 1024
         rs, ws = yield self.make_iostream_pair(max_buffer_size=5 * MB)
         try:
@@ -586,9 +859,21 @@
 
     @gen_test
     def test_read_into(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
 
         def sleep_some():
+            """ """
             self.io_loop.run_sync(lambda: gen.sleep(0.05))
 
         try:
@@ -628,6 +913,17 @@
 
     @gen_test
     def test_read_into_partial(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
 
         try:
@@ -657,6 +953,17 @@
 
     @gen_test
     def test_read_into_zero_bytes(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         rs, ws = yield self.make_iostream_pair()
         try:
             buf = bytearray()
@@ -668,6 +975,7 @@
 
     @gen_test
     def test_many_mixed_reads(self):
+        """ """
         # Stress buffer handling when going back and forth between
         # read_bytes() (using an internal buffer) and read_into()
         # (using a user-allocated buffer).
@@ -680,6 +988,7 @@
 
         @gen.coroutine
         def produce():
+            """ """
             remaining = nbytes
             while remaining > 0:
                 size = r.randint(1, min(1000, remaining))
@@ -691,6 +1000,7 @@
 
         @gen.coroutine
         def consume():
+            """ """
             remaining = nbytes
             while remaining > 0:
                 if r.random() > 0.5:
@@ -718,18 +1028,71 @@
 
 
 class TestIOStreamMixin(TestReadWriteMixin):
+    """ """
     def _make_server_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def _make_client_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     @gen.coroutine
     def make_iostream_pair(self: typing.Any, **kwargs):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         listener, port = bind_unused_port()
         server_stream_fut = Future()  # type: Future[IOStream]
 
         def accept_callback(connection, address):
+            """
+
+            Parameters
+            ----------
+            connection :
+                
+            address :
+                
+
+            Returns
+            -------
+
+            """
             server_stream_fut.set_result(
                 self._make_server_iostream(connection, **kwargs)
             )
@@ -744,6 +1107,17 @@
 
     @gen_test
     def test_connection_refused(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # When a connection is refused, the connect callback should not
         # be run.  (The kqueue IOLoop used to behave differently from the
         # epoll IOLoop in this respect)
@@ -761,6 +1135,17 @@
 
     @gen_test
     def test_gaierror(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # Test that IOStream sets its exc_info on getaddrinfo error.
         # It's difficult to reliably trigger a getaddrinfo error;
         # some resolvers own't even return errors for malformed names,
@@ -778,6 +1163,17 @@
 
     @gen_test
     def test_read_until_close_with_error(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         server, client = yield self.make_iostream_pair()
         try:
             with mock.patch(
@@ -794,6 +1190,17 @@
     @skipPypy3V58
     @gen_test
     def test_inline_read_error(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         # An error on an inline read is raised without logging (on the
         # assumption that it will eventually be noticed or logged further
         # up the stack).
@@ -825,6 +1232,7 @@
     @skipPypy3V58
     @gen_test
     def test_async_read_error_logging(self):
+        """ """
         # Socket errors on asynchronous reads should be logged (but only
         # once).
         server, client = yield self.make_iostream_pair()
@@ -837,6 +1245,7 @@
             # Stub out read_from_fd to make it fail.
 
             def fake_read_from_fd():
+                """ """
                 os.close(server.socket.fileno())
                 server.__class__.read_from_fd(server)
 
@@ -850,9 +1259,7 @@
 
     @gen_test
     def test_future_write(self):
-        """
-        Test that write() Futures are never orphaned.
-        """
+        """Test that write() Futures are never orphaned."""
         # Run concurrent writers that will write enough bytes so as to
         # clog the socket buffer and accumulate bytes in our write buffer.
         m, n = 5000, 1000
@@ -862,12 +1269,14 @@
 
         @gen.coroutine
         def produce():
+            """ """
             data = b"x" * m
             for i in range(n):
                 yield server.write(data)
 
         @gen.coroutine
         def consume():
+            """ """
             nread = 0
             while nread < total_bytes:
                 res = yield client.read_bytes(m)
@@ -881,25 +1290,70 @@
 
 
 class TestIOStreamWebHTTP(TestIOStreamWebMixin, AsyncHTTPTestCase):
+    """ """
     def _make_client_iostream(self):
+        """ """
         return IOStream(socket.socket())
 
 
 class TestIOStreamWebHTTPS(TestIOStreamWebMixin, AsyncHTTPSTestCase):
+    """ """
     def _make_client_iostream(self):
+        """ """
         return SSLIOStream(socket.socket(), ssl_options=dict(cert_reqs=ssl.CERT_NONE))
 
 
 class TestIOStream(TestIOStreamMixin, AsyncTestCase):
+    """ """
     def _make_server_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return IOStream(connection, **kwargs)
 
     def _make_client_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return IOStream(connection, **kwargs)
 
 
 class TestIOStreamSSL(TestIOStreamMixin, AsyncTestCase):
+    """ """
     def _make_server_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         connection = ssl.wrap_socket(
             connection,
             server_side=True,
@@ -909,6 +1363,19 @@
         return SSLIOStream(connection, **kwargs)
 
     def _make_client_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return SSLIOStream(
             connection, ssl_options=dict(cert_reqs=ssl.CERT_NONE), **kwargs
         )
@@ -918,7 +1385,21 @@
 # simplest way to make sure that it works to pass an SSLContext
 # instead of an ssl_options dict to the SSLIOStream constructor.
 class TestIOStreamSSLContext(TestIOStreamMixin, AsyncTestCase):
+    """ """
     def _make_server_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
         context.load_cert_chain(
             os.path.join(os.path.dirname(__file__), "test.crt"),
@@ -930,12 +1411,27 @@
         return SSLIOStream(connection, **kwargs)
 
     def _make_client_iostream(self, connection, **kwargs):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
         return SSLIOStream(connection, ssl_options=context, **kwargs)
 
 
 class TestIOStreamStartTLS(AsyncTestCase):
+    """ """
     def setUp(self):
+        """ """
         try:
             super().setUp()
             self.listener, self.port = bind_unused_port()
@@ -956,6 +1452,7 @@
             raise
 
     def tearDown(self):
+        """ """
         if self.server_stream is not None:
             self.server_stream.close()
         if self.client_stream is not None:
@@ -965,6 +1462,19 @@
         super().tearDown()
 
     def accept(self, connection, address):
+        """
+
+        Parameters
+        ----------
+        connection :
+            
+        address :
+            
+
+        Returns
+        -------
+
+        """
         if self.server_stream is not None:
             self.fail("should only get one connection")
         self.server_stream = IOStream(connection)
@@ -972,6 +1482,17 @@
 
     @gen.coroutine
     def client_send_line(self, line):
+        """
+
+        Parameters
+        ----------
+        line :
+            
+
+        Returns
+        -------
+
+        """
         assert self.client_stream is not None
         self.client_stream.write(line)
         assert self.server_stream is not None
@@ -980,6 +1501,17 @@
 
     @gen.coroutine
     def server_send_line(self, line):
+        """
+
+        Parameters
+        ----------
+        line :
+            
+
+        Returns
+        -------
+
+        """
         assert self.server_stream is not None
         self.server_stream.write(line)
         assert self.client_stream is not None
@@ -987,12 +1519,36 @@
         self.assertEqual(line, recv_line)
 
     def client_start_tls(self, ssl_options=None, server_hostname=None):
+        """
+
+        Parameters
+        ----------
+        ssl_options :
+             (Default value = None)
+        server_hostname :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         assert self.client_stream is not None
         client_stream = self.client_stream
         self.client_stream = None
         return client_stream.start_tls(False, ssl_options, server_hostname)
 
     def server_start_tls(self, ssl_options=None):
+        """
+
+        Parameters
+        ----------
+        ssl_options :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         assert self.server_stream is not None
         server_stream = self.server_stream
         self.server_stream = None
@@ -1000,6 +1556,7 @@
 
     @gen_test
     def test_start_tls_smtp(self):
+        """ """
         # This flow is simplified from RFC 3207 section 5.
         # We don't really need all of this, but it helps to make sure
         # that after realistic back-and-forth traffic the buffers end up
@@ -1021,6 +1578,7 @@
 
     @gen_test
     def test_handshake_fail(self):
+        """ """
         server_future = self.server_start_tls(_server_ssl_options())
         # Certificates are verified with the default configuration.
         with ExpectLog(gen_log, "SSL Error"):
@@ -1032,6 +1590,7 @@
 
     @gen_test
     def test_check_hostname(self):
+        """ """
         # Test that server_hostname parameter to start_tls is being used.
         # The check_hostname functionality is only available in python 2.7 and
         # up and in python 3.4 and up.
@@ -1049,8 +1608,20 @@
 
 
 class WaitForHandshakeTest(AsyncTestCase):
+    """ """
     @gen.coroutine
     def connect_to_server(self, server_cls):
+        """
+
+        Parameters
+        ----------
+        server_cls :
+            
+
+        Returns
+        -------
+
+        """
         server = client = None
         try:
             sock, port = bind_unused_port()
@@ -1077,16 +1648,42 @@
 
     @gen_test
     def test_wait_for_handshake_future(self):
+        """ """
         test = self
         handshake_future = Future()  # type: Future[None]
 
         class TestServer(TCPServer):
+            """ """
             def handle_stream(self, stream, address):
+                """
+
+                Parameters
+                ----------
+                stream :
+                    
+                address :
+                    
+
+                Returns
+                -------
+
+                """
                 test.assertIsNone(stream.socket.cipher())
                 test.io_loop.spawn_callback(self.handle_connection, stream)
 
             @gen.coroutine
             def handle_connection(self, stream):
+                """
+
+                Parameters
+                ----------
+                stream :
+                    
+
+                Returns
+                -------
+
+                """
                 yield stream.wait_for_handshake()
                 handshake_future.set_result(None)
 
@@ -1095,12 +1692,27 @@
 
     @gen_test
     def test_wait_for_handshake_already_waiting_error(self):
+        """ """
         test = self
         handshake_future = Future()  # type: Future[None]
 
         class TestServer(TCPServer):
+            """ """
             @gen.coroutine
             def handle_stream(self, stream, address):
+                """
+
+                Parameters
+                ----------
+                stream :
+                    
+                address :
+                    
+
+                Returns
+                -------
+
+                """
                 fut = stream.wait_for_handshake()
                 test.assertRaises(RuntimeError, stream.wait_for_handshake)
                 yield fut
@@ -1112,11 +1724,26 @@
 
     @gen_test
     def test_wait_for_handshake_already_connected(self):
+        """ """
         handshake_future = Future()  # type: Future[None]
 
         class TestServer(TCPServer):
+            """ """
             @gen.coroutine
             def handle_stream(self, stream, address):
+                """
+
+                Parameters
+                ----------
+                stream :
+                    
+                address :
+                    
+
+                Returns
+                -------
+
+                """
                 yield stream.wait_for_handshake()
                 yield stream.wait_for_handshake()
                 handshake_future.set_result(None)
@@ -1127,14 +1754,27 @@
 
 @skipIfNonUnix
 class TestPipeIOStream(TestReadWriteMixin, AsyncTestCase):
+    """ """
     @gen.coroutine
     def make_iostream_pair(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         r, w = os.pipe()
 
         return PipeIOStream(r, **kwargs), PipeIOStream(w, **kwargs)
 
     @gen_test
     def test_pipe_iostream(self):
+        """ """
         rs, ws = yield self.make_iostream_pair()
 
         ws.write(b"hel")
@@ -1155,6 +1795,7 @@
 
     @gen_test
     def test_pipe_iostream_big_write(self):
+        """ """
         rs, ws = yield self.make_iostream_pair()
 
         NUM_BYTES = 1048576
@@ -1170,14 +1811,24 @@
 
 
 class TestStreamBuffer(unittest.TestCase):
-    """
-    Unit tests for the private _StreamBuffer class.
-    """
+    """Unit tests for the private _StreamBuffer class."""
 
     def setUp(self):
+        """ """
         self.random = random.Random(42)
 
     def to_bytes(self, b):
+        """
+
+        Parameters
+        ----------
+        b :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(b, (bytes, bytearray)):
             return bytes(b)
         elif isinstance(b, memoryview):
@@ -1186,12 +1837,36 @@
             raise TypeError(b)
 
     def make_streambuffer(self, large_buf_threshold=10):
+        """
+
+        Parameters
+        ----------
+        large_buf_threshold :
+             (Default value = 10)
+
+        Returns
+        -------
+
+        """
         buf = _StreamBuffer()
         assert buf._large_buf_threshold
         buf._large_buf_threshold = large_buf_threshold
         return buf
 
     def check_peek(self, buf, expected):
+        """
+
+        Parameters
+        ----------
+        buf :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         size = 1
         while size < 2 * len(expected):
             got = self.to_bytes(buf.peek(size))
@@ -1201,6 +1876,21 @@
             size = (size * 3 + 1) // 2
 
     def check_append_all_then_skip_all(self, buf, objs, input_type):
+        """
+
+        Parameters
+        ----------
+        buf :
+            
+        objs :
+            
+        input_type :
+            
+
+        Returns
+        -------
+
+        """
         self.assertEqual(len(buf), 0)
 
         expected = b""
@@ -1221,6 +1911,7 @@
         self.assertEqual(len(buf), 0)
 
     def test_small(self):
+        """ """
         objs = [b"12", b"345", b"67", b"89a", b"bcde", b"fgh", b"ijklmn"]
 
         buf = self.make_streambuffer()
@@ -1247,6 +1938,7 @@
         self.assertEqual(len(buf), 0)
 
     def test_large(self):
+        """ """
         objs = [
             b"12" * 5,
             b"345" * 2,
