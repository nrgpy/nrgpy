# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/base/methods.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/base/methods.py
@@ -17,6 +17,19 @@
 
     @pytest.mark.parametrize("dropna", [True, False])
     def test_value_counts(self, all_data, dropna):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+        dropna :
+            
+
+        Returns
+        -------
+
+        """
         all_data = all_data[:10]
         if dropna:
             other = np.array(all_data[~all_data.isna()])
@@ -29,6 +42,17 @@
         self.assert_series_equal(result, expected)
 
     def test_value_counts_with_normalize(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH 33172
         data = data[:10].unique()
         values = np.array(data[~data.isna()])
@@ -41,12 +65,34 @@
         self.assert_series_equal(result, expected)
 
     def test_count(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": data_missing})
         result = df.count(axis="columns")
         expected = pd.Series([0, 1])
         self.assert_series_equal(result, expected)
 
     def test_series_count(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         # GH#26835
         ser = pd.Series(data_missing)
         result = ser.count()
@@ -54,15 +100,48 @@
         assert result == expected
 
     def test_apply_simple_series(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         result = pd.Series(data).apply(id)
         assert isinstance(result, pd.Series)
 
     def test_argsort(self, data_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         result = pd.Series(data_for_sorting).argsort()
         expected = pd.Series(np.array([2, 0, 1], dtype=np.int64))
         self.assert_series_equal(result, expected)
 
     def test_argsort_missing_array(self, data_missing_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         result = data_missing_for_sorting.argsort()
         expected = np.array([2, 0, 1], dtype=np.dtype("int"))
         # we don't care whether it's int32 or int64
@@ -71,11 +150,37 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_argsort_missing(self, data_missing_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         result = pd.Series(data_missing_for_sorting).argsort()
         expected = pd.Series(np.array([1, -1, 0], dtype=np.int64))
         self.assert_series_equal(result, expected)
 
     def test_argmin_argmax(self, data_for_sorting, data_missing_for_sorting, na_value):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        data_missing_for_sorting :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # GH 24382
 
         # data_for_sorting -> [B, C, A] with A < B < C
@@ -96,6 +201,19 @@
         "method", ["argmax", "argmin"],
     )
     def test_argmin_argmax_empty_array(self, method, data):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH 24382
         err_msg = "attempt to get"
         with pytest.raises(ValueError, match=err_msg):
@@ -105,6 +223,21 @@
         "method", ["argmax", "argmin"],
     )
     def test_argmin_argmax_all_na(self, method, data, na_value):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # all missing with skipna=True is the same as emtpy
         err_msg = "attempt to get"
         data_na = type(data)._from_sequence([na_value, na_value], dtype=data.dtype)
@@ -119,12 +252,42 @@
         ],
     )
     def test_nargsort(self, data_missing_for_sorting, na_position, expected):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+        na_position :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 25439
         result = nargsort(data_missing_for_sorting, na_position=na_position)
         tm.assert_numpy_array_equal(result, expected)
 
     @pytest.mark.parametrize("ascending", [True, False])
     def test_sort_values(self, data_for_sorting, ascending, sort_by_key):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        ascending :
+            
+        sort_by_key :
+            
+
+        Returns
+        -------
+
+        """
         ser = pd.Series(data_for_sorting)
         result = ser.sort_values(ascending=ascending, key=sort_by_key)
         expected = ser.iloc[[2, 0, 1]]
@@ -137,6 +300,21 @@
     def test_sort_values_missing(
         self, data_missing_for_sorting, ascending, sort_by_key
     ):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+        ascending :
+            
+        sort_by_key :
+            
+
+        Returns
+        -------
+
+        """
         ser = pd.Series(data_missing_for_sorting)
         result = ser.sort_values(ascending=ascending, key=sort_by_key)
         if ascending:
@@ -147,6 +325,19 @@
 
     @pytest.mark.parametrize("ascending", [True, False])
     def test_sort_values_frame(self, data_for_sorting, ascending):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        ascending :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 2, 1], "B": data_for_sorting})
         result = df.sort_values(["A", "B"])
         expected = pd.DataFrame(
@@ -157,6 +348,21 @@
     @pytest.mark.parametrize("box", [pd.Series, lambda x: x])
     @pytest.mark.parametrize("method", [lambda x: x.unique(), pd.unique])
     def test_unique(self, data, box, method):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        box :
+            
+        method :
+            
+
+        Returns
+        -------
+
+        """
         duplicated = box(data._from_sequence([data[0], data[0]]))
 
         result = method(duplicated)
@@ -167,6 +373,19 @@
 
     @pytest.mark.parametrize("na_sentinel", [-1, -2])
     def test_factorize(self, data_for_grouping, na_sentinel):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        na_sentinel :
+            
+
+        Returns
+        -------
+
+        """
         codes, uniques = pd.factorize(data_for_grouping, na_sentinel=na_sentinel)
         expected_codes = np.array(
             [0, 0, na_sentinel, na_sentinel, 1, 1, 0, 2], dtype=np.intp
@@ -178,6 +397,19 @@
 
     @pytest.mark.parametrize("na_sentinel", [-1, -2])
     def test_factorize_equivalence(self, data_for_grouping, na_sentinel):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        na_sentinel :
+            
+
+        Returns
+        -------
+
+        """
         codes_1, uniques_1 = pd.factorize(data_for_grouping, na_sentinel=na_sentinel)
         codes_2, uniques_2 = data_for_grouping.factorize(na_sentinel=na_sentinel)
 
@@ -187,6 +419,17 @@
         assert uniques_1.dtype == data_for_grouping.dtype
 
     def test_factorize_empty(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         codes, uniques = pd.factorize(data[:0])
         expected_codes = np.array([], dtype=np.intp)
         expected_uniques = type(data)._from_sequence([], dtype=data[:0].dtype)
@@ -195,6 +438,17 @@
         self.assert_extension_array_equal(uniques, expected_uniques)
 
     def test_fillna_copy_frame(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         arr = data_missing.take([1, 1])
         df = pd.DataFrame({"A": arr})
 
@@ -204,6 +458,17 @@
         assert df.A.values is not result.A.values
 
     def test_fillna_copy_series(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         arr = data_missing.take([1, 1])
         ser = pd.Series(arr)
 
@@ -214,11 +479,33 @@
         assert ser._values is arr
 
     def test_fillna_length_mismatch(self, data_missing):
+        """
+
+        Parameters
+        ----------
+        data_missing :
+            
+
+        Returns
+        -------
+
+        """
         msg = "Length of 'value' does not match."
         with pytest.raises(ValueError, match=msg):
             data_missing.fillna(data_missing.take([1]))
 
     def test_combine_le(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20825
         # Test that combine works when doing a <= (le) comparison
         orig_data1, orig_data2 = data_repeated(2)
@@ -236,6 +523,17 @@
         self.assert_series_equal(result, expected)
 
     def test_combine_add(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20825
         orig_data1, orig_data2 = data_repeated(2)
         s1 = pd.Series(orig_data1)
@@ -257,6 +555,17 @@
         self.assert_series_equal(result, expected)
 
     def test_combine_first(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/24147
         a = pd.Series(data[:3])
         b = pd.Series(data[2:5], index=[2, 3, 4])
@@ -270,6 +579,23 @@
         [(-2, [2, 3, 4, -1, -1]), (0, [0, 1, 2, 3, 4]), (2, [-1, -1, 0, 1, 2])],
     )
     def test_container_shift(self, data, frame, periods, indices):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        frame :
+            
+        periods :
+            
+        indices :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/22386
         subset = data[:5]
         data = pd.Series(subset, name="A")
@@ -288,6 +614,17 @@
         compare(result, expected)
 
     def test_shift_0_periods(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH#33856 shifting with periods=0 should return a copy, not same obj
         result = data.shift(0)
         assert data[0] != data[1]  # otherwise below is invalid
@@ -296,6 +633,19 @@
 
     @pytest.mark.parametrize("periods", [1, -2])
     def test_diff(self, data, periods):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        periods :
+            
+
+        Returns
+        -------
+
+        """
         data = data[:5]
         if is_bool_dtype(data.dtype):
             op = operator.xor
@@ -325,6 +675,21 @@
         [[-4, [-1, -1]], [-1, [1, -1]], [0, [0, 1]], [1, [-1, 0]], [4, [-1, -1]]],
     )
     def test_shift_non_empty_array(self, data, periods, indices):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        periods :
+            
+        indices :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/23911
         subset = data[:2]
         result = subset.shift(periods)
@@ -333,6 +698,19 @@
 
     @pytest.mark.parametrize("periods", [-4, -1, 0, 1, 4])
     def test_shift_empty_array(self, data, periods):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        periods :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/23911
         empty = data[:0]
         result = empty.shift(periods)
@@ -340,6 +718,17 @@
         self.assert_extension_array_equal(result, expected)
 
     def test_shift_zero_copies(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         result = data.shift(0)
         assert result is not data
 
@@ -347,6 +736,17 @@
         assert result is not data
 
     def test_shift_fill_value(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         arr = data[:4]
         fill_value = data[0]
         result = arr.shift(1, fill_value=fill_value)
@@ -358,11 +758,35 @@
         self.assert_extension_array_equal(result, expected)
 
     def test_not_hashable(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # We are in general mutable, so not hashable
         with pytest.raises(TypeError, match="unhashable type"):
             hash(data)
 
     def test_hash_pandas_object_works(self, data, as_frame):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        as_frame :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/23066
         data = pd.Series(data)
         if as_frame:
@@ -372,6 +796,19 @@
         self.assert_equal(a, b)
 
     def test_searchsorted(self, data_for_sorting, as_series):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        as_series :
+            
+
+        Returns
+        -------
+
+        """
         b, c, a = data_for_sorting
         arr = type(data_for_sorting)._from_sequence([a, b, c])
 
@@ -396,6 +833,21 @@
         assert data_for_sorting.searchsorted(a, sorter=sorter) == 0
 
     def test_where_series(self, data, na_value, as_frame):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_frame :
+            
+
+        Returns
+        -------
+
+        """
         assert data[0] != data[1]
         cls = type(data)
         a, b = data[:2]
@@ -430,6 +882,23 @@
 
     @pytest.mark.parametrize("repeats", [0, 1, 2, [1, 2, 3]])
     def test_repeat(self, data, repeats, as_series, use_numpy):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        repeats :
+            
+        as_series :
+            
+        use_numpy :
+            
+
+        Returns
+        -------
+
+        """
         arr = type(data)._from_sequence(data[:3], dtype=data.dtype)
         if as_series:
             arr = pd.Series(arr)
@@ -454,6 +923,27 @@
         ],
     )
     def test_repeat_raises(self, data, repeats, kwargs, error, msg, use_numpy):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        repeats :
+            
+        kwargs :
+            
+        error :
+            
+        msg :
+            
+        use_numpy :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(error, match=msg):
             if use_numpy:
                 np.repeat(data, repeats, **kwargs)
@@ -462,6 +952,23 @@
 
     @pytest.mark.parametrize("box", [pd.array, pd.Series, pd.DataFrame])
     def test_equals(self, data, na_value, as_series, box):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_series :
+            
+        box :
+            
+
+        Returns
+        -------
+
+        """
         data2 = type(data)._from_sequence([data[0]] * len(data), dtype=data.dtype)
         data_na = type(data)._from_sequence([na_value] * len(data), dtype=data.dtype)
 
