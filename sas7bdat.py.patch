# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/io/sas/sas7bdat.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/io/sas/sas7bdat.py
@@ -30,22 +30,25 @@
 
 
 def _convert_datetimes(sas_datetimes: pd.Series, unit: str) -> pd.Series:
-    """
-    Convert to Timestamp if possible, otherwise to datetime.datetime.
+    """Convert to Timestamp if possible, otherwise to datetime.datetime.
     SAS float64 lacks precision for more than ms resolution so the fit
     to datetime.datetime is ok.
 
     Parameters
     ----------
     sas_datetimes : {Series, Sequence[float]}
-       Dates or datetimes in SAS
+        Dates or datetimes in SAS
     unit : {str}
-       "d" if the floats represent dates, "s" for datetimes
+        "d" if the floats represent dates, "s" for datetimes
+    sas_datetimes: pd.Series :
+        
+    unit: str :
+        
 
     Returns
     -------
-    Series
-       Series of datetime64 dtype or datetime.datetime.
+
+    
     """
     try:
         return pd.to_datetime(sas_datetimes, unit=unit, origin="1960-01-01")
@@ -63,42 +66,18 @@
 
 
 class _subheader_pointer:
+    """ """
     pass
 
 
 class _column:
+    """ """
     pass
 
 
 # SAS7BDAT represents a SAS data file in SAS7BDAT format.
 class SAS7BDATReader(ReaderBase, abc.Iterator):
-    """
-    Read SAS files in SAS7BDAT format.
-
-    Parameters
-    ----------
-    path_or_buf : path name or buffer
-        Name of SAS file or file-like object pointing to SAS file
-        contents.
-    index : column identifier, defaults to None
-        Column to use as index.
-    convert_dates : boolean, defaults to True
-        Attempt to convert dates to Pandas datetime values.  Note that
-        some rarely used SAS date formats may be unsupported.
-    blank_missing : boolean, defaults to True
-        Convert empty strings to missing values (SAS uses blanks to
-        indicate missing character variables).
-    chunksize : int, defaults to None
-        Return SAS7BDATReader object for iterations, returns chunks
-        with given number of lines.
-    encoding : string, defaults to None
-        String encoding.
-    convert_text : bool, defaults to True
-        If False, text variables are left as raw bytes.
-    convert_header_text : bool, defaults to True
-        If False, header text, including column names, are left as raw
-        bytes.
-    """
+    """Read SAS files in SAS7BDAT format."""
 
     def __init__(
         self,
@@ -146,27 +125,35 @@
         self._parse_metadata()
 
     def column_data_lengths(self):
-        """Return a numpy int64 array of the column data lengths"""
+        """ """
         return np.asarray(self._column_data_lengths, dtype=np.int64)
 
     def column_data_offsets(self):
-        """Return a numpy int64 array of the column offsets"""
+        """ """
         return np.asarray(self._column_data_offsets, dtype=np.int64)
 
     def column_types(self):
-        """
-        Returns a numpy character array of the column types:
+        """Returns a numpy character array of the column types:
            s (string) or d (double)
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return np.asarray(self._column_types, dtype=np.dtype("S1"))
 
     def close(self):
+        """ """
         try:
             self.handle.close()
         except AttributeError:
             pass
 
     def _get_properties(self):
+        """ """
 
         # Check magic number
         self._path_or_buf.seek(0)
@@ -307,6 +294,19 @@
 
     # Read a single float of the given width (4 or 8).
     def _read_float(self, offset, width):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        width :
+            
+
+        Returns
+        -------
+
+        """
         if width not in (4, 8):
             self.close()
             raise ValueError("invalid float width")
@@ -316,6 +316,19 @@
 
     # Read a single signed integer of the given width (1, 2, 4 or 8).
     def _read_int(self, offset, width):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        width :
+            
+
+        Returns
+        -------
+
+        """
         if width not in (1, 2, 4, 8):
             self.close()
             raise ValueError("invalid int width")
@@ -325,6 +338,19 @@
         return iv
 
     def _read_bytes(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         if self._cached_page is None:
             self._path_or_buf.seek(offset)
             buf = self._path_or_buf.read(length)
@@ -340,6 +366,7 @@
             return self._cached_page[offset : offset + length]
 
     def _parse_metadata(self):
+        """ """
         done = False
         while not done:
             self._cached_page = self._path_or_buf.read(self._page_length)
@@ -351,6 +378,7 @@
             done = self._process_page_meta()
 
     def _process_page_meta(self):
+        """ """
         self._read_page_header()
         pt = [const.page_meta_type, const.page_amd_type] + const.page_mix_types
         if self._current_page_type in pt:
@@ -364,6 +392,7 @@
         )
 
     def _read_page_header(self):
+        """ """
         bit_offset = self._page_bit_offset
         tx = const.page_type_offset + bit_offset
         self._current_page_type = self._read_int(tx, const.page_type_length)
@@ -375,6 +404,7 @@
         )
 
     def _process_page_metadata(self):
+        """ """
         bit_offset = self._page_bit_offset
 
         for i in range(self._current_page_subheaders_count):
@@ -392,6 +422,21 @@
             self._process_subheader(subheader_index, pointer)
 
     def _get_subheader_index(self, signature, compression, ptype):
+        """
+
+        Parameters
+        ----------
+        signature :
+            
+        compression :
+            
+        ptype :
+            
+
+        Returns
+        -------
+
+        """
         index = const.subheader_signature_to_index.get(signature)
         if index is None:
             f1 = (compression == const.compressed_subheader_id) or (compression == 0)
@@ -404,6 +449,19 @@
         return index
 
     def _process_subheader_pointers(self, offset, subheader_pointer_index):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        subheader_pointer_index :
+            
+
+        Returns
+        -------
+
+        """
 
         subheader_pointer_length = self._subheader_pointer_length
         total_offset = offset + subheader_pointer_length * subheader_pointer_index
@@ -428,10 +486,34 @@
         return x
 
     def _read_subheader_signature(self, offset):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+
+        Returns
+        -------
+
+        """
         subheader_signature = self._read_bytes(offset, self._int_length)
         return subheader_signature
 
     def _process_subheader(self, subheader_index, pointer):
+        """
+
+        Parameters
+        ----------
+        subheader_index :
+            
+        pointer :
+            
+
+        Returns
+        -------
+
+        """
         offset = pointer.offset
         length = pointer.length
 
@@ -460,6 +542,19 @@
         processor(offset, length)
 
     def _process_rowsize_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
 
         int_len = self._int_length
         lcs_offset = offset
@@ -489,6 +584,19 @@
         self._lcp = self._read_int(lcp_offset, 2)
 
     def _process_columnsize_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         int_len = self._int_length
         offset += int_len
         self.column_count = self._read_int(offset, int_len)
@@ -500,9 +608,35 @@
 
     # Unknown purpose
     def _process_subheader_counts(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def _process_columntext_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
 
         offset += self._int_length
         text_block_size = self._read_int(offset, const.text_block_size_length)
@@ -555,6 +689,19 @@
                     )
 
     def _process_columnname_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         int_len = self._int_length
         offset += int_len
         column_name_pointers_count = (length - 2 * int_len - 12) // 8
@@ -587,6 +734,19 @@
             self.column_names.append(name_str[col_offset : col_offset + col_len])
 
     def _process_columnattributes_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         int_len = self._int_length
         column_attributes_vectors_count = (length - 2 * int_len - 12) // (int_len + 8)
         for i in range(column_attributes_vectors_count):
@@ -613,10 +773,36 @@
             self._column_types.append(b"d" if x == 1 else b"s")
 
     def _process_columnlist_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         # unknown purpose
         pass
 
     def _process_format_subheader(self, offset, length):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        length :
+            
+
+        Returns
+        -------
+
+        """
         int_len = self._int_length
         text_subheader_format = (
             offset + const.column_format_text_subheader_index_offset + 3 * int_len
@@ -665,6 +851,17 @@
         self.columns.append(col)
 
     def read(self, nrows=None):
+        """
+
+        Parameters
+        ----------
+        nrows :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if (nrows is None) and (self.chunksize is not None):
             nrows = self.chunksize
@@ -699,6 +896,7 @@
         return rslt
 
     def _read_next_page(self):
+        """ """
         self._current_page_data_subheader_pointers = []
         self._cached_page = self._path_or_buf.read(self._page_length)
         if len(self._cached_page) <= 0:
@@ -724,6 +922,7 @@
         return False
 
     def _chunk_to_dataframe(self):
+        """ """
 
         n = self._current_row_in_chunk_index
         m = self._current_row_in_file_index
