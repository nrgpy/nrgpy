# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/locale.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/locale.py
@@ -60,25 +60,43 @@
 
 def get(*locale_codes: str) -> "Locale":
     """Returns the closest match for the given locale codes.
-
+    
     We iterate over all given locale codes in order. If we have a tight
     or a loose match for the code (e.g., "en" for "en_US"), we return
     the locale. Otherwise we move to the next code in the list.
-
+    
     By default we return ``en_US`` if no translations are found for any of
     the specified locales. You can change the default locale with
     `set_default_locale()`.
+
+    Parameters
+    ----------
+    *locale_codes: str :
+        
+
+    Returns
+    -------
+
     """
     return Locale.get_closest(*locale_codes)
 
 
 def set_default_locale(code: str) -> None:
     """Sets the default locale.
-
+    
     The default locale is assumed to be the language used for all strings
     in the system. The translations loaded from disk are mappings from
     the default locale to the destination locale. Consequently, you don't
     need to create a translation file for the default locale.
+
+    Parameters
+    ----------
+    code: str :
+        
+
+    Returns
+    -------
+
     """
     global _default_locale
     global _supported_locales
@@ -88,10 +106,10 @@
 
 def load_translations(directory: str, encoding: Optional[str] = None) -> None:
     """Loads translations from CSV files in a directory.
-
+    
     Translations are strings with optional Python-style named placeholders
     (e.g., ``My name is %(name)s``) and their associated translations.
-
+    
     The directory should have translation files of the form ``LOCALE.csv``,
     e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,
     translation, and an optional plural indicator. Plural indicators should
@@ -102,24 +120,35 @@
     that string, one with plural indicator "singular", and one "plural".
     For strings with no verbs that would change on translation, simply
     use "unknown" or the empty string (or don't include the column at all).
-
+    
     The file is read using the `csv` module in the default "excel" dialect.
     In this format there should not be spaces after the commas.
-
+    
     If no ``encoding`` parameter is given, the encoding will be
     detected automatically (among UTF-8 and UTF-16) if the file
     contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM
     is present.
-
+    
     Example translation ``es_LA.csv``::
-
+    
         "I love you","Te amo"
         "%(name)s liked this","A %(name)s les gustó esto","plural"
         "%(name)s liked this","A %(name)s le gustó esto","singular"
-
+    
     .. versionchanged:: 4.3
        Added ``encoding`` parameter. Added support for BOM-based encoding
        detection, UTF-16, and UTF-8-with-BOM.
+
+    Parameters
+    ----------
+    directory: str :
+        
+    encoding: Optional[str] :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     global _translations
     global _supported_locales
@@ -175,24 +204,35 @@
 
 def load_gettext_translations(directory: str, domain: str) -> None:
     """Loads translations from `gettext`'s locale tree
-
+    
     Locale tree is similar to system's ``/usr/share/locale``, like::
-
+    
         {directory}/{lang}/LC_MESSAGES/{domain}.mo
-
+    
     Three steps are required to have your app translated:
-
+    
     1. Generate POT translation file::
-
+    
         xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html etc
-
+    
     2. Merge against existing POT file::
-
+    
         msgmerge old.po mydomain.po > new.po
-
+    
     3. Compile::
-
+    
         msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo
+
+    Parameters
+    ----------
+    directory: str :
+        
+    domain: str :
+        
+
+    Returns
+    -------
+
     """
     global _translations
     global _supported_locales
@@ -223,16 +263,33 @@
 
 class Locale(object):
     """Object representing a locale.
-
+    
     After calling one of `load_translations` or `load_gettext_translations`,
     call `get` or `get_closest` to get a Locale object.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     _cache = {}  # type: Dict[str, Locale]
 
     @classmethod
     def get_closest(cls, *locale_codes: str) -> "Locale":
-        """Returns the closest match for the given locale code."""
+        """Returns the closest match for the given locale code.
+
+        Parameters
+        ----------
+        *locale_codes: str :
+            
+
+        Returns
+        -------
+
+        """
         for code in locale_codes:
             if not code:
                 continue
@@ -251,8 +308,17 @@
     @classmethod
     def get(cls, code: str) -> "Locale":
         """Returns the Locale for the given locale code.
-
+        
         If it is not supported, we raise an exception.
+
+        Parameters
+        ----------
+        code: str :
+            
+
+        Returns
+        -------
+
         """
         if code not in cls._cache:
             assert code in _supported_locales
@@ -308,11 +374,24 @@
         count: Optional[int] = None,
     ) -> str:
         """Returns the translation for the given message for this locale.
-
+        
         If ``plural_message`` is given, you must also provide
         ``count``. We return ``plural_message`` when ``count != 1``,
         and we return the singular form for the given message when
         ``count == 1``.
+
+        Parameters
+        ----------
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
@@ -323,6 +402,23 @@
         plural_message: Optional[str] = None,
         count: Optional[int] = None,
     ) -> str:
+        """
+
+        Parameters
+        ----------
+        context: str :
+            
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def format_date(
@@ -334,15 +430,36 @@
         full_format: bool = False,
     ) -> str:
         """Formats the given date (which should be GMT).
-
+        
         By default, we return a relative time (e.g., "2 minutes ago"). You
         can return an absolute date string with ``relative=False``.
-
+        
         You can force a full format date ("July 10, 1980") with
         ``full_format=True``.
-
+        
         This method is primarily intended for dates in the past.
         For dates in the future, we fall back to full format.
+
+        Parameters
+        ----------
+        date: Union[int :
+            
+        float :
+            
+        datetime.datetime] :
+            
+        gmt_offset: int :
+             (Default value = 0)
+        relative: bool :
+             (Default value = True)
+        shorter: bool :
+             (Default value = False)
+        full_format: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         if isinstance(date, (int, float)):
             date = datetime.datetime.utcfromtimestamp(date)
@@ -429,9 +546,22 @@
         self, date: datetime.datetime, gmt_offset: int = 0, dow: bool = True
     ) -> bool:
         """Formats the given date as a day of week.
-
+        
         Example: "Monday, January 22". You can remove the day of week with
         ``dow=False``.
+
+        Parameters
+        ----------
+        date: datetime.datetime :
+            
+        gmt_offset: int :
+             (Default value = 0)
+        dow: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         local_date = date - datetime.timedelta(minutes=gmt_offset)
         _ = self.translate
@@ -449,9 +579,18 @@
 
     def list(self, parts: Any) -> str:
         """Returns a comma-separated list for the given list of parts.
-
+        
         The format is, e.g., "A, B and C", "A and B" or just "A" for lists
         of size 1.
+
+        Parameters
+        ----------
+        parts: Any :
+            
+
+        Returns
+        -------
+
         """
         _ = self.translate
         if len(parts) == 0:
@@ -465,7 +604,17 @@
         }
 
     def friendly_number(self, value: int) -> str:
-        """Returns a comma-separated number for the given integer."""
+        """Returns a comma-separated number for the given integer.
+
+        Parameters
+        ----------
+        value: int :
+            
+
+        Returns
+        -------
+
+        """
         if self.code not in ("en", "en_US"):
             return str(value)
         s = str(value)
@@ -489,6 +638,21 @@
         plural_message: Optional[str] = None,
         count: Optional[int] = None,
     ) -> str:
+        """
+
+        Parameters
+        ----------
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if plural_message is not None:
             assert count is not None
             if count != 1:
@@ -507,6 +671,23 @@
         plural_message: Optional[str] = None,
         count: Optional[int] = None,
     ) -> str:
+        """
+
+        Parameters
+        ----------
+        context: str :
+            
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if self.translations:
             gen_log.warning("pgettext is not supported by CSVLocale")
         return self.translate(message, plural_message, count)
@@ -528,6 +709,21 @@
         plural_message: Optional[str] = None,
         count: Optional[int] = None,
     ) -> str:
+        """
+
+        Parameters
+        ----------
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if plural_message is not None:
             assert count is not None
             return self.ngettext(message, plural_message, count)
@@ -542,23 +738,38 @@
         count: Optional[int] = None,
     ) -> str:
         """Allows to set context for translation, accepts plural forms.
-
+        
         Usage example::
-
+        
             pgettext("law", "right")
             pgettext("good", "right")
-
+        
         Plural message example::
-
+        
             pgettext("organization", "club", "clubs", len(clubs))
             pgettext("stick", "club", "clubs", len(clubs))
-
+        
         To generate POT file with context, add following options to step 1
         of `load_gettext_translations` sequence::
-
+        
             xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3
-
+        
         .. versionadded:: 4.2
+
+        Parameters
+        ----------
+        context: str :
+            
+        message: str :
+            
+        plural_message: Optional[str] :
+             (Default value = None)
+        count: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if plural_message is not None:
             assert count is not None
