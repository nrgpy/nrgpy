# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pexpect/spawnbase.py
+++ b/..//venv/lib/python3.8/site-packages/pexpect/spawnbase.py
@@ -14,17 +14,50 @@
     """Pass bytes through unchanged."""
     @staticmethod
     def encode(b, final=False):
+        """
+
+        Parameters
+        ----------
+        b :
+            
+        final :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return b
 
     @staticmethod
     def decode(b, final=False):
+        """
+
+        Parameters
+        ----------
+        b :
+            
+        final :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return b
 
 class SpawnBase(object):
     """A base class providing the backwards-compatible spawn API for Pexpect.
-
+    
     This should not be instantiated directly: use :class:`pexpect.spawn` or
     :class:`pexpect.fdpexpect.fdspawn`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     encoding = None
     pid = None
@@ -92,6 +125,17 @@
                 self.allowed_string_types = (bytes, str)
                 self.linesep = os.linesep.encode('ascii')
                 def write_to_stdout(b):
+                    """
+
+                    Parameters
+                    ----------
+                    b :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     try:
                         return sys.stdout.buffer.write(b)
                     except AttributeError:
@@ -125,6 +169,19 @@
         self._before = self.buffer_type()
 
     def _log(self, s, direction):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        direction :
+            
+
+        Returns
+        -------
+
+        """
         if self.logfile is not None:
             self.logfile.write(s)
             self.logfile.flush()
@@ -137,19 +194,53 @@
     # unicode is accepted for send and expect. Unicode mode is strictly unicode
     # only.
     def _coerce_expect_string(self, s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         if self.encoding is None and not isinstance(s, bytes):
             return s.encode('ascii')
         return s
 
     def _coerce_send_string(self, s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         if self.encoding is None and not isinstance(s, bytes):
             return s.encode('utf-8')
         return s
 
     def _get_buffer(self):
+        """ """
         return self._buffer.getvalue()
 
     def _set_buffer(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         self._buffer = self.buffer_type()
         self._buffer.write(value)
 
@@ -159,10 +250,21 @@
 
     def read_nonblocking(self, size=1, timeout=None):
         """This reads data from the file descriptor.
-
+        
         This is a simple implementation suitable for a regular file. Subclasses using ptys or pipes should override it.
-
+        
         The timeout parameter is ignored.
+
+        Parameters
+        ----------
+        size :
+             (Default value = 1)
+        timeout :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
 
         try:
@@ -183,6 +285,17 @@
         return s
 
     def _pattern_type_err(self, pattern):
+        """
+
+        Parameters
+        ----------
+        pattern :
+            
+
+        Returns
+        -------
+
+        """
         raise TypeError('got {badtype} ({badobj!r}) as pattern, must be one'
                         ' of: {goodtypes}, pexpect.EOF, pexpect.TIMEOUT'\
                         .format(badtype=type(pattern),
@@ -193,28 +306,36 @@
                         )
 
     def compile_pattern_list(self, patterns):
-        '''This compiles a pattern-string or a list of pattern-strings.
+        """This compiles a pattern-string or a list of pattern-strings.
         Patterns must be a StringType, EOF, TIMEOUT, SRE_Pattern, or a list of
         those. Patterns may also be None which results in an empty list (you
         might do this if waiting for an EOF or TIMEOUT condition without
         expecting any pattern).
-
+        
         This is used by expect() when calling expect_list(). Thus expect() is
         nothing more than::
-
+        
              cpl = self.compile_pattern_list(pl)
-             return self.expect_list(cpl, timeout)
-
-        If you are using expect() within a loop it may be more
-        efficient to compile the patterns first and then call expect_list().
-        This avoid calls in a loop to compile_pattern_list()::
-
-             cpl = self.compile_pattern_list(my_pattern)
-             while some_condition:
-                ...
-                i = self.expect_list(cpl, timeout)
-                ...
-        '''
+
+        Parameters
+        ----------
+        patterns :
+            
+
+        Returns
+        -------
+        type
+            If you are using expect() within a loop it may be more
+            efficient to compile the patterns first and then call expect_list().
+            This avoid calls in a loop to compile_pattern_list()::
+            
+            cpl = self.compile_pattern_list(my_pattern)
+            while some_condition:
+            ...
+            i = self.expect_list(cpl, timeout)
+            ...
+
+        """
 
         if patterns is None:
             return []
@@ -241,7 +362,7 @@
         return compiled_pattern_list
 
     def expect(self, pattern, timeout=-1, searchwindowsize=-1, async_=False, **kw):
-        '''This seeks through the stream until a pattern is matched. The
+        """This seeks through the stream until a pattern is matched. The
         pattern is overloaded and may take several types. The pattern can be a
         StringType, EOF, a compiled re, or a list of any of those types.
         Strings will be compiled to re types. This returns the index into the
@@ -250,23 +371,23 @@
         avoid the EOF or TIMEOUT exceptions add EOF or TIMEOUT to the pattern
         list. That will cause expect to match an EOF or TIMEOUT condition
         instead of raising an exception.
-
+        
         If you pass a list of patterns and more than one matches, the first
         match in the stream is chosen. If more than one pattern matches at that
         point, the leftmost in the pattern list is chosen. For example::
-
+        
             # the input is 'foobar'
             index = p.expect(['bar', 'foo', 'foobar'])
             # returns 1('foo') even though 'foobar' is a "better" match
-
+        
         Please note, however, that buffering can affect this behavior, since
         input arrives in unpredictable chunks. For example::
-
+        
             # the input is 'foobar'
             index = p.expect(['foobar', 'foo'])
             # returns 0('foobar') if all input is available at once,
             # but returns 1('foo') if parts of the final 'bar' arrive late
-
+        
         When a match is found for the given pattern, the class instance
         attribute *match* becomes an re.MatchObject result.  Should an EOF
         or TIMEOUT pattern match, then the match attribute will be an instance
@@ -275,65 +396,109 @@
         the matching pattern.  On general exception, class attribute
         *before* is all data received up to the exception, while *match* and
         *after* attributes are value None.
-
+        
         When the keyword argument timeout is -1 (default), then TIMEOUT will
         raise after the default value specified by the class timeout
         attribute. When None, TIMEOUT will not be raised and may block
         indefinitely until match.
-
+        
         When the keyword argument searchwindowsize is -1 (default), then the
         value specified by the class maxread attribute is used.
-
+        
         A list entry may be EOF or TIMEOUT instead of a string. This will
         catch these exceptions and return the index of the list entry instead
         of raising the exception. The attribute 'after' will be set to the
-        exception type. The attribute 'match' will be None. This allows you to
-        write code like this::
-
-                index = p.expect(['good', 'bad', pexpect.EOF, pexpect.TIMEOUT])
-                if index == 0:
-                    do_something()
-                elif index == 1:
-                    do_something_else()
-                elif index == 2:
-                    do_some_other_thing()
-                elif index == 3:
-                    do_something_completely_different()
-
-        instead of code like this::
-
-                try:
-                    index = p.expect(['good', 'bad'])
-                    if index == 0:
-                        do_something()
-                    elif index == 1:
-                        do_something_else()
-                except EOF:
-                    do_some_other_thing()
-                except TIMEOUT:
-                    do_something_completely_different()
-
-        These two forms are equivalent. It all depends on what you want. You
-        can also just expect the EOF if you are waiting for all output of a
-        child to finish. For example::
-
-                p = pexpect.spawn('/bin/ls')
-                p.expect(pexpect.EOF)
-                print p.before
-
-        If you are trying to optimize for speed then see expect_list().
-
-        On Python 3.4, or Python 3.3 with asyncio installed, passing
-        ``async_=True``  will make this return an :mod:`asyncio` coroutine,
-        which you can yield from to get the same result that this method would
-        normally give directly. So, inside a coroutine, you can replace this code::
-
-            index = p.expect(patterns)
-
-        With this non-blocking form::
-
-            index = yield from p.expect(patterns, async_=True)
-        '''
+
+        Parameters
+        ----------
+        pattern :
+            
+        timeout :
+             (Default value = -1)
+        searchwindowsize :
+             (Default value = -1)
+        async_ :
+             (Default value = False)
+        **kw :
+            
+
+        Returns
+        -------
+
+        Raises
+        ------
+        write
+            code like this
+        index
+            
+        if
+            index
+        do_something
+            
+        elif
+            index
+        do_something_else
+            
+        elif
+            index
+        do_some_other_thing
+            
+        elif
+            index
+        do_something_completely_different
+            
+        instead
+            of code like this
+        try
+            
+        index
+            
+        if
+            index
+        do_something
+            
+        elif
+            index
+        do_something_else
+            
+        except
+            EOF
+        do_some_other_thing
+            
+        except
+            TIMEOUT
+        do_something_completely_different
+            
+        These
+            two forms are equivalent
+        can
+            also just expect the EOF if you are waiting for all output of a
+        child
+            to finish
+        p
+            pexpect
+        p.expect
+            pexpect
+        print
+            
+        If
+            you are trying to optimize for speed then see expect_list
+        On
+            Python 3
+        async_
+            True
+        which
+            you can yield from to get the same result that this method would
+        normally
+            give directly
+        index
+            
+        With
+            this non
+        index
+            yield from p
+
+        """
         if 'async' in kw:
             async_ = kw.pop('async')
         if kw:
@@ -345,18 +510,35 @@
 
     def expect_list(self, pattern_list, timeout=-1, searchwindowsize=-1,
                     async_=False, **kw):
-        '''This takes a list of compiled regular expressions and returns the
+        """This takes a list of compiled regular expressions and returns the
         index into the pattern_list that matched the child output. The list may
         also contain EOF or TIMEOUT(which are not compiled regular
         expressions). This method is similar to the expect() method except that
         expect_list() does not recompile the pattern list on every call. This
         may help if you are trying to optimize for speed, otherwise just use
         the expect() method.  This is called by expect().
-
-
+        
+        
         Like :meth:`expect`, passing ``async_=True`` will make this return an
         asyncio coroutine.
-        '''
+
+        Parameters
+        ----------
+        pattern_list :
+            
+        timeout :
+             (Default value = -1)
+        searchwindowsize :
+             (Default value = -1)
+        async_ :
+             (Default value = False)
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         if timeout == -1:
             timeout = self.timeout
         if 'async' in kw:
@@ -374,21 +556,38 @@
     def expect_exact(self, pattern_list, timeout=-1, searchwindowsize=-1,
                      async_=False, **kw):
 
-        '''This is similar to expect(), but uses plain string matching instead
+        """This is similar to expect(), but uses plain string matching instead
         of compiled regular expressions in 'pattern_list'. The 'pattern_list'
         may be a string; a list or other sequence of strings; or TIMEOUT and
         EOF.
-
+        
         This call might be faster than expect() for two reasons: string
         searching is faster than RE matching and it is possible to limit the
         search to just the end of the input buffer.
-
+        
         This method is also useful when you don't want to have to worry about
         escaping regular expression characters that you want to match.
-
+        
         Like :meth:`expect`, passing ``async_=True`` will make this return an
         asyncio coroutine.
-        '''
+
+        Parameters
+        ----------
+        pattern_list :
+            
+        timeout :
+             (Default value = -1)
+        searchwindowsize :
+             (Default value = -1)
+        async_ :
+             (Default value = False)
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         if timeout == -1:
             timeout = self.timeout
         if 'async' in kw:
@@ -401,6 +600,17 @@
             pattern_list = [pattern_list]
 
         def prepare_pattern(pattern):
+            """
+
+            Parameters
+            ----------
+            pattern :
+                
+
+            Returns
+            -------
+
+            """
             if pattern in (TIMEOUT, EOF):
                 return pattern
             if isinstance(pattern, self.allowed_string_types):
@@ -421,21 +631,45 @@
             return exp.expect_loop(timeout)
 
     def expect_loop(self, searcher, timeout=-1, searchwindowsize=-1):
-        '''This is the common loop used inside expect. The 'searcher' should be
+        """This is the common loop used inside expect. The 'searcher' should be
         an instance of searcher_re or searcher_string, which describes how and
         what to search for in the input.
-
-        See expect() for other arguments, return value and exceptions. '''
+        
+        See expect() for other arguments, return value and exceptions.
+
+        Parameters
+        ----------
+        searcher :
+            
+        timeout :
+             (Default value = -1)
+        searchwindowsize :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         exp = Expecter(self, searcher, searchwindowsize)
         return exp.expect_loop(timeout)
 
     def read(self, size=-1):
-        '''This reads at most "size" bytes from the file (less if the read hits
+        """This reads at most "size" bytes from the file (less if the read hits
         EOF before obtaining size bytes). If the size argument is negative or
         omitted, read all data until EOF is reached. The bytes are returned as
         a string object. An empty string is returned when EOF is encountered
-        immediately. '''
+        immediately.
+
+        Parameters
+        ----------
+        size :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         if size == 0:
             return self.string_type()
@@ -460,16 +694,26 @@
         return self.before
 
     def readline(self, size=-1):
-        '''This reads and returns one entire line. The newline at the end of
+        """This reads and returns one entire line. The newline at the end of
         line is returned as part of the string, unless the file ends without a
         newline. An empty string is returned if EOF is encountered immediately.
         This looks for a newline as a CR/LF pair (\\r\\n) even on UNIX because
         this is what the pseudotty device returns. So contrary to what you may
         expect you will receive newlines as \\r\\n.
-
+        
         If the size argument is 0 then an empty string is returned. In all
         other cases the size argument is ignored, which is not standard
-        behavior for a file-like object. '''
+        behavior for a file-like object.
+
+        Parameters
+        ----------
+        size :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         if size == 0:
             return self.string_type()
@@ -486,12 +730,22 @@
         return iter(self.readline, self.string_type())
 
     def readlines(self, sizehint=-1):
-        '''This reads until EOF using readline() and returns a list containing
+        """This reads until EOF using readline() and returns a list containing
         the lines thus read. The optional 'sizehint' argument is ignored.
         Remember, because this reads until EOF that means the child
         process should have closed its stdout. If you run this method on
         a child that is still running with its stdout open then this
-        method will block until it timesout.'''
+        method will block until it timesout.
+
+        Parameters
+        ----------
+        sizehint :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         lines = []
         while True:
@@ -502,13 +756,20 @@
         return lines
 
     def fileno(self):
-        '''Expose file descriptor for a file-like interface
-        '''
+        """Expose file descriptor for a file-like interface"""
         return self.child_fd
 
     def flush(self):
-        '''This does nothing. It is here to support the interface for a
-        File-like object. '''
+        """This does nothing. It is here to support the interface for a
+        File-like object.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         pass
 
     def isatty(self):
