# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jsonschema/validators.py
+++ b/..//venv/lib/python3.8/site-packages/jsonschema/validators.py
@@ -39,11 +39,22 @@
 
 class _DontDoThat(Exception):
     """
-    Raised when a Validators with non-default type checker is misused.
-
-    Asking one for DEFAULT_TYPES doesn't make sense, since type checkers
-    exist for the unrepresentable cases where DEFAULT_TYPES can't
-    represent the type relationship.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    Asking
+        one for DEFAULT_TYPES doesn
+    exist
+        for the unrepresentable cases where DEFAULT_TYPES can
+    represent
+        the type relationship
+
     """
 
     def __str__(self):
@@ -55,25 +66,51 @@
 
 
 def _generate_legacy_type_checks(types=()):
-    """
-    Generate newer-style type checks out of JSON-type-name-to-type mappings.
-
-    Arguments:
-
-        types (dict):
-
-            A mapping of type names to their Python types
-
-    Returns:
-
+    """Generate newer-style type checks out of JSON-type-name-to-type mappings.
+
+    Parameters
+    ----------
+    types :
+        dict (Default value = ())
+    A :
+        mapping of type names to their Python types
+
+    Returns
+    -------
+    type
         A dictionary of definitions to pass to `TypeChecker`
+
     """
     types = dict(types)
 
     def gen_type_check(pytypes):
+        """
+
+        Parameters
+        ----------
+        pytypes :
+            
+
+        Returns
+        -------
+
+        """
         pytypes = _utils.flatten(pytypes)
 
         def type_check(checker, instance):
+            """
+
+            Parameters
+            ----------
+            checker :
+                
+            instance :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(instance, bool):
                 if bool not in pytypes:
                     return False
@@ -103,26 +140,29 @@
 
 
 def validates(version):
-    """
-    Register the decorated validator for a ``version`` of the specification.
-
+    """Register the decorated validator for a ``version`` of the specification.
+    
     Registered validators and their meta schemas will be considered when
     parsing ``$schema`` properties' URIs.
 
-    Arguments:
-
-        version (str):
-
-            An identifier to use as the version's name
-
-    Returns:
-
+    Parameters
+    ----------
+    version :
+        str
+    An :
+        identifier to use as the version
+
+    Returns
+    -------
+    type
         collections.Callable:
-
-            a class decorator to decorate the validator with the version
+        
+        a class decorator to decorate the validator with the version
+
     """
 
     def _validates(cls):
+        """ """
         validators[version] = cls
         meta_schema_id = cls.ID_OF(cls.META_SCHEMA)
         if meta_schema_id:
@@ -132,6 +172,7 @@
 
 
 def _DEFAULT_TYPES(self):
+    """ """
     if self._CREATED_WITH_DEFAULT_TYPES is None:
         raise _DontDoThat()
 
@@ -147,10 +188,22 @@
 
 
 class _DefaultTypesDeprecatingMetaClass(type):
+    """ """
     DEFAULT_TYPES = property(_DEFAULT_TYPES)
 
 
 def _id_of(schema):
+    """
+
+    Parameters
+    ----------
+    schema :
+        
+
+    Returns
+    -------
+
+    """
     if schema is True or schema is False:
         return u""
     return schema.get(u"$id", u"")
@@ -164,60 +217,74 @@
     type_checker=None,
     id_of=_id_of,
 ):
-    """
-    Create a new validator class.
-
-    Arguments:
-
-        meta_schema (collections.Mapping):
-
-            the meta schema for the new validator class
-
-        validators (collections.Mapping):
-
-            a mapping from names to callables, where each callable will
-            validate the schema property with the given name.
-
-            Each callable should take 4 arguments:
-
-                1. a validator instance,
-                2. the value of the property being validated within the
-                   instance
-                3. the instance
-                4. the schema
-
-        version (str):
-
-            an identifier for the version that this validator class will
-            validate. If provided, the returned validator class will
-            have its ``__name__`` set to include the version, and also
-            will have `jsonschema.validators.validates` automatically
-            called for the given version.
-
-        type_checker (jsonschema.TypeChecker):
-
-            a type checker, used when applying the :validator:`type` validator.
-
-            If unprovided, a `jsonschema.TypeChecker` will be created
-            with a set of default types typical of JSON Schema drafts.
-
-        default_types (collections.Mapping):
-
-            .. deprecated:: 3.0.0
-
-                Please use the type_checker argument instead.
-
-            If set, it provides mappings of JSON types to Python types
-            that will be converted to functions and redefined in this
-            object's `jsonschema.TypeChecker`.
-
-        id_of (collections.Callable):
-
-            A function that given a schema, returns its ID.
-
-    Returns:
-
+    """Create a new validator class.
+
+    Parameters
+    ----------
+    meta_schema :
+        collections
+    the :
+        meta schema for the new validator class
+    validators :
+        collections (Default value = ())
+    a :
+        mapping from names to callables
+    validate :
+        the schema property with the given name
+    Each :
+        callable should take 4 arguments
+    1 :
+        a validator instance
+    2 :
+        the value of the property being validated within the
+    instance :
+        
+    3 :
+        the instance
+    4 :
+        the schema
+    version :
+        str (Default value = None)
+    an :
+        identifier for the version that this validator class will
+    validate :
+        If provided
+    have :
+        its
+    will :
+        have
+    called :
+        for the given version
+    type_checker :
+        jsonschema (Default value = None)
+    a :
+        type checker
+    If :
+        unprovided
+    with :
+        a set of default types typical of JSON Schema drafts
+    default_types :
+        collections (Default value = None)
+    deprecated :
+        
+    Please :
+        use the type_checker argument instead
+    If :
+        set
+    that :
+        will be converted to functions and redefined in this
+    object :
+        s
+    id_of :
+        collections (Default value = _id_of)
+    A :
+        function that given a schema
+
+    Returns
+    -------
+    type
         a new `jsonschema.IValidator` class
+
     """
 
     if default_types is not None:
@@ -249,6 +316,7 @@
 
     @add_metaclass(_DefaultTypesDeprecatingMetaClass)
     class Validator(object):
+        """ """
 
         VALIDATORS = dict(validators)
         META_SCHEMA = dict(meta_schema)
@@ -290,10 +358,34 @@
 
         @classmethod
         def check_schema(cls, schema):
+            """
+
+            Parameters
+            ----------
+            schema :
+                
+
+            Returns
+            -------
+
+            """
             for error in cls(cls.META_SCHEMA).iter_errors(schema):
                 raise exceptions.SchemaError.create_from(error)
 
         def iter_errors(self, instance, _schema=None):
+            """
+
+            Parameters
+            ----------
+            instance :
+                
+            _schema :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             if _schema is None:
                 _schema = self.schema
 
@@ -341,6 +433,23 @@
                     self.resolver.pop_scope()
 
         def descend(self, instance, schema, path=None, schema_path=None):
+            """
+
+            Parameters
+            ----------
+            instance :
+                
+            schema :
+                
+            path :
+                 (Default value = None)
+            schema_path :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             for error in self.iter_errors(instance, schema):
                 if path is not None:
                     error.path.appendleft(path)
@@ -349,16 +458,55 @@
                 yield error
 
         def validate(self, *args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             for error in self.iter_errors(*args, **kwargs):
                 raise error
 
         def is_type(self, instance, type):
+            """
+
+            Parameters
+            ----------
+            instance :
+                
+            type :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 return self.TYPE_CHECKER.is_type(instance, type)
             except exceptions.UndefinedTypeCheck:
                 raise exceptions.UnknownType(type, instance, self.schema)
 
         def is_valid(self, instance, _schema=None):
+            """
+
+            Parameters
+            ----------
+            instance :
+                
+            _schema :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             error = next(self.iter_errors(instance, _schema), None)
             return error is None
 
@@ -370,56 +518,66 @@
 
 
 def extend(validator, validators=(), version=None, type_checker=None):
-    """
-    Create a new validator class by extending an existing one.
-
-    Arguments:
-
-        validator (jsonschema.IValidator):
-
-            an existing validator class
-
-        validators (collections.Mapping):
-
-            a mapping of new validator callables to extend with, whose
-            structure is as in `create`.
-
-            .. note::
-
-                Any validator callables with the same name as an
-                existing one will (silently) replace the old validator
-                callable entirely, effectively overriding any validation
-                done in the "parent" validator class.
-
-                If you wish to instead extend the behavior of a parent's
-                validator callable, delegate and call it directly in
-                the new validator function by retrieving it using
-                ``OldValidator.VALIDATORS["validator_name"]``.
-
-        version (str):
-
-            a version for the new validator class
-
-        type_checker (jsonschema.TypeChecker):
-
-            a type checker, used when applying the :validator:`type` validator.
-
-            If unprovided, the type checker of the extended
-            `jsonschema.IValidator` will be carried along.`
-
-    Returns:
-
+    """Create a new validator class by extending an existing one.
+
+    Parameters
+    ----------
+    validator :
+        jsonschema
+    an :
+        existing validator class
+    validators :
+        collections (Default value = ())
+    a :
+        mapping of new validator callables to extend with
+    structure :
+        is as in
+    note :
+        
+    Any :
+        validator callables with the same name as an
+    existing :
+        one will
+    callable :
+        entirely
+    done :
+        in the
+    If :
+        you wish to instead extend the behavior of a parent
+    validator :
+        callable
+    the :
+        new validator function by retrieving it using
+    OldValidator :
+        VALIDATORS
+    version :
+        str (Default value = None)
+    a :
+        version for the new validator class
+    type_checker :
+        jsonschema (Default value = None)
+    a :
+        type checker
+    If :
+        unprovided
+    jsonschema :
+        IValidator
+
+    Returns
+    -------
+    type
         a new `jsonschema.IValidator` class extending the one provided
-
-    .. note:: Meta Schemas
-
+        
+        .. note:: Meta Schemas
+        
         The new validator class will have its parent's meta schema.
-
+        
         If you wish to change or extend the meta schema in the new
         validator class, modify ``META_SCHEMA`` directly on the returned
         class. Note that no implicit copying is done, so a copy should
         likely be made before modifying it, in order to not affect the
         old validator.
+
     """
 
     all_validators = dict(validator.VALIDATORS)
@@ -590,47 +748,47 @@
 
 
 class RefResolver(object):
-    """
-    Resolve JSON References.
-
+    """Resolve JSON References.
+    
     Arguments:
-
+    
         base_uri (str):
-
+    
             The URI of the referring document
-
+    
         referrer:
-
+    
             The actual referring document
-
+    
         store (dict):
-
+    
             A mapping from URIs to documents to cache
-
+    
         cache_remote (bool):
-
+    
             Whether remote refs should be cached after first resolution
-
+    
         handlers (dict):
-
+    
             A mapping from URI schemes to functions that should be used
             to retrieve them
-
+    
         urljoin_cache (:func:`functools.lru_cache`):
-
+    
             A cache that will be used for caching the results of joining
             the resolution scope to subscopes.
-
+    
         remote_cache (:func:`functools.lru_cache`):
-
+    
             A cache that will be used for caching the results of
             resolved remote URLs.
 
-    Attributes:
-
-        cache_remote (bool):
-
-            Whether remote refs should be cached after first resolution
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -665,42 +823,64 @@
 
     @classmethod
     def from_schema(cls, schema, id_of=_id_of, *args, **kwargs):
+        """Construct a resolver from a JSON schema object.
+
+        Parameters
+        ----------
+        schema :
+            
+        the :
+            referring schema
+        id_of :
+             (Default value = _id_of)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+        type
+            `RefResolver`
+
         """
-        Construct a resolver from a JSON schema object.
-
-        Arguments:
-
-            schema:
-
-                the referring schema
-
-        Returns:
-
-            `RefResolver`
-        """
 
         return cls(base_uri=id_of(schema), referrer=schema, *args, **kwargs)
 
     def push_scope(self, scope):
-        """
-        Enter a given sub-scope.
-
+        """Enter a given sub-scope.
+        
         Treats further dereferences as being performed underneath the
         given scope.
+
+        Parameters
+        ----------
+        scope :
+            
+
+        Returns
+        -------
+
         """
         self._scopes_stack.append(
             self._urljoin_cache(self.resolution_scope, scope),
         )
 
     def pop_scope(self):
-        """
-        Exit the most recent entered scope.
-
+        """Exit the most recent entered scope.
+        
         Treats further dereferences as being performed underneath the
         original scope.
-
+        
         Don't call this method more times than `push_scope` has been
         called.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         try:
             self._scopes_stack.pop()
@@ -713,23 +893,27 @@
 
     @property
     def resolution_scope(self):
-        """
-        Retrieve the current resolution scope.
-        """
+        """Retrieve the current resolution scope."""
         return self._scopes_stack[-1]
 
     @property
     def base_uri(self):
-        """
-        Retrieve the current base URI, not including any fragment.
-        """
+        """Retrieve the current base URI, not including any fragment."""
         uri, _ = urldefrag(self.resolution_scope)
         return uri
 
     @contextlib.contextmanager
     def in_scope(self, scope):
-        """
-        Temporarily enter the given scope for the duration of the context.
+        """Temporarily enter the given scope for the duration of the context.
+
+        Parameters
+        ----------
+        scope :
+            
+
+        Returns
+        -------
+
         """
         self.push_scope(scope)
         try:
@@ -739,16 +923,20 @@
 
     @contextlib.contextmanager
     def resolving(self, ref):
-        """
-        Resolve the given ``ref`` and enter its resolution scope.
-
+        """Resolve the given ``ref`` and enter its resolution scope.
+        
         Exits the scope on exit of this context manager.
 
-        Arguments:
-
-            ref (str):
-
-                The reference to resolve
+        Parameters
+        ----------
+        ref :
+            str
+        The :
+            reference to resolve
+
+        Returns
+        -------
+
         """
 
         url, resolved = self.resolve(ref)
@@ -759,15 +947,31 @@
             self.pop_scope()
 
     def resolve(self, ref):
-        """
-        Resolve the given reference.
+        """Resolve the given reference.
+
+        Parameters
+        ----------
+        ref :
+            
+
+        Returns
+        -------
+
         """
         url = self._urljoin_cache(self.resolution_scope, ref)
         return url, self._remote_cache(url)
 
     def resolve_from_url(self, url):
-        """
-        Resolve the given remote URL.
+        """Resolve the given remote URL.
+
+        Parameters
+        ----------
+        url :
+            
+
+        Returns
+        -------
+
         """
         url, fragment = urldefrag(url)
         try:
@@ -781,18 +985,22 @@
         return self.resolve_fragment(document, fragment)
 
     def resolve_fragment(self, document, fragment):
-        """
-        Resolve a ``fragment`` within the referenced ``document``.
-
-        Arguments:
-
-            document:
-
-                The referent document
-
-            fragment (str):
-
-                a URI fragment to resolve within it
+        """Resolve a ``fragment`` within the referenced ``document``.
+
+        Parameters
+        ----------
+        document :
+            
+        The :
+            referent document
+        fragment :
+            str
+        a :
+            URI fragment to resolve within it
+
+        Returns
+        -------
+
         """
 
         fragment = fragment.lstrip(u"/")
@@ -817,33 +1025,35 @@
         return document
 
     def resolve_remote(self, uri):
-        """
-        Resolve a remote ``uri``.
-
+        """Resolve a remote ``uri``.
+        
         If called directly, does not check the store first, but after
         retrieving the document at the specified URI it will be saved in
         the store if :attr:`cache_remote` is True.
-
+        
         .. note::
-
+        
             If the requests_ library is present, ``jsonschema`` will use it to
             request the remote ``uri``, so that the correct encoding is
             detected and used.
-
+        
             If it isn't, or if the scheme of the ``uri`` is not ``http`` or
             ``https``, UTF-8 is assumed.
 
-        Arguments:
-
-            uri (str):
-
-                The URI to resolve
-
-        Returns:
-
+        Parameters
+        ----------
+        uri :
+            str
+        The :
+            URI to resolve
+
+        Returns
+        -------
+        type
             The retrieved document
-
-        .. _requests: https://pypi.org/project/requests/
+            
+            .. _requests: https://pypi.org/project/requests/
+
         """
         try:
             import requests
@@ -869,60 +1079,79 @@
 
 
 def validate(instance, schema, cls=None, *args, **kwargs):
-    """
-    Validate an instance under the given schema.
-
-        >>> validate([2, 3, 4], {"maxItems": 2})
-        Traceback (most recent call last):
-            ...
-        ValidationError: [2, 3, 4] is too long
-
+    """Validate an instance under the given schema.
+    
+    
     :func:`validate` will first verify that the provided schema is
     itself valid, since not doing so can lead to less obvious error
     messages and fail in less obvious or consistent ways.
-
+    
     If you know you have a valid schema already, especially if you
     intend to validate multiple instances with the same schema, you
     likely would prefer using the `IValidator.validate` method directly
     on a specific validator (e.g. ``Draft7Validator.validate``).
 
-
-    Arguments:
-
-        instance:
-
-            The instance to validate
-
-        schema:
-
-            The schema to validate with
-
-        cls (IValidator):
-
-            The class that will be used to validate the instance.
-
-    If the ``cls`` argument is not provided, two things will happen
-    in accordance with the specification. First, if the schema has a
-    :validator:`$schema` property containing a known meta-schema [#]_
-    then the proper validator will be used. The specification recommends
-    that all schemas contain :validator:`$schema` properties for this
-    reason. If no :validator:`$schema` property is found, the default
-    validator class is the latest released draft.
-
-    Any other provided positional and keyword arguments will be passed
-    on when instantiating the ``cls``.
-
-    Raises:
-
-        `jsonschema.exceptions.ValidationError` if the instance
-            is invalid
-
-        `jsonschema.exceptions.SchemaError` if the schema itself
-            is invalid
-
-    .. rubric:: Footnotes
-    .. [#] known by a validator registered with
-        `jsonschema.validators.validates`
+    Parameters
+    ----------
+    instance :
+        
+    The :
+        instance to validate
+    schema :
+        
+    The :
+        schema to validate with
+    cls :
+        IValidator (Default value = None)
+    The :
+        class that will be used to validate the instance
+    If :
+        the
+    in :
+        accordance with the specification
+    validator :
+        schema
+    then :
+        the proper validator will be used
+    that :
+        all schemas contain
+    reason :
+        If no
+    validator :
+        class is the latest released draft
+    Any :
+        other provided positional and keyword arguments will be passed
+    on :
+        when instantiating the
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    Raises
+    ------
+    jsonschema.exceptions.ValidationError
+        if the instance
+    is
+        invalid
+    jsonschema.exceptions.SchemaError
+        if the schema itself
+    is
+        invalid
+    rubric
+        Footnotes
+    known
+        by a validator registered with
+    jsonschema.validators
+        validates
+
+    >>> validate([2, 3, 4], {"maxItems": 2})
+        Traceback (most recent call last):
+            ...
+        ValidationError: [2, 3, 4] is too long
     """
     if cls is None:
         cls = validator_for(schema)
@@ -935,25 +1164,31 @@
 
 
 def validator_for(schema, default=_LATEST_VERSION):
-    """
-    Retrieve the validator class appropriate for validating the given schema.
-
+    """Retrieve the validator class appropriate for validating the given schema.
+    
     Uses the :validator:`$schema` property that should be present in the
     given schema to look up the appropriate validator class.
 
-    Arguments:
-
-        schema (collections.Mapping or bool):
-
-            the schema to look at
-
-        default:
-
-            the default to return if the appropriate validator class
-            cannot be determined.
-
-            If unprovided, the default is to return the latest supported
-            draft.
+    Parameters
+    ----------
+    schema :
+        collections
+    the :
+        schema to look at
+    default :
+         (Default value = _LATEST_VERSION)
+    the :
+        default to return if the appropriate validator class
+    cannot :
+        be determined
+    If :
+        unprovided
+    draft :
+        
+
+    Returns
+    -------
+
     """
     if schema is True or schema is False or u"$schema" not in schema:
         return default
