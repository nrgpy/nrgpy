# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/test_nanops.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/test_nanops.py
@@ -21,14 +21,34 @@
 
 @pytest.fixture(params=[True, False])
 def skipna(request):
-    """
-    Fixture to pass skipna to nanops functions.
+    """Fixture to pass skipna to nanops functions.
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
     """
     return request.param
 
 
 class TestnanopsDataFrame:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         np.random.seed(11235)
         nanops._USE_BOTTLENECK = False
 
@@ -93,9 +113,37 @@
         self.arr_nan_float1_1d = self.arr_nan_float1[:, 0]
 
     def teardown_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         nanops._USE_BOTTLENECK = use_bn
 
     def check_results(self, targ, res, axis, check_dtype=True):
+        """
+
+        Parameters
+        ----------
+        targ :
+            
+        res :
+            
+        axis :
+            
+        check_dtype :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         res = getattr(res, "asm8", res)
 
         if (
@@ -146,6 +194,31 @@
         empty_targfunc=None,
         **kwargs,
     ):
+        """
+
+        Parameters
+        ----------
+        testfunc :
+            
+        targfunc :
+            
+        testarval :
+            
+        targarval :
+            
+        skipna :
+            
+        check_dtype :
+             (Default value = True)
+        empty_targfunc :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         for axis in list(range(targarval.ndim)) + [None]:
             targartempval = targarval if skipna else testarval
             if skipna and empty_targfunc and isna(targartempval).all():
@@ -185,6 +258,27 @@
     def check_fun(
         self, testfunc, targfunc, testar, skipna, empty_targfunc=None, **kwargs
     ):
+        """
+
+        Parameters
+        ----------
+        testfunc :
+            
+        targfunc :
+            
+        testar :
+            
+        skipna :
+            
+        empty_targfunc :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         targar = testar
         if testar.endswith("_nan") and hasattr(self, testar[:-4]):
@@ -214,6 +308,33 @@
         allow_obj=True,
         **kwargs,
     ):
+        """
+
+        Parameters
+        ----------
+        testfunc :
+            
+        targfunc :
+            
+        skipna :
+            
+        allow_complex :
+             (Default value = True)
+        allow_all_nan :
+             (Default value = True)
+        allow_date :
+             (Default value = True)
+        allow_tdelta :
+             (Default value = True)
+        allow_obj :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         self.check_fun(testfunc, targfunc, "arr_float", skipna, **kwargs)
         self.check_fun(testfunc, targfunc, "arr_float_nan", skipna, **kwargs)
         self.check_fun(testfunc, targfunc, "arr_int", skipna, **kwargs)
@@ -260,6 +381,23 @@
             self.check_fun(testfunc, targfunc, "arr_obj", skipna, **kwargs)
 
     def _badobj_wrap(self, value, func, allow_complex=True, **kwargs):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        func :
+            
+        allow_complex :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if value.dtype.kind == "O":
             if allow_complex:
                 value = value.astype("c16")
@@ -271,9 +409,35 @@
         "nan_op,np_op", [(nanops.nanany, np.any), (nanops.nanall, np.all)]
     )
     def test_nan_funcs(self, nan_op, np_op, skipna):
+        """
+
+        Parameters
+        ----------
+        nan_op :
+            
+        np_op :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(nan_op, np_op, skipna, allow_all_nan=False, allow_date=False)
 
     def test_nansum(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(
             nanops.nansum,
             np.sum,
@@ -284,11 +448,23 @@
         )
 
     def test_nanmean(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(
             nanops.nanmean, np.mean, skipna, allow_obj=False, allow_date=False,
         )
 
     def test_nanmean_overflow(self):
+        """ """
         # GH 10155
         # In the previous implementation mean can overflow for int dtypes, it
         # is now consistent with numpy
@@ -313,6 +489,17 @@
         ],
     )
     def test_returned_dtype(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         if dtype is None:
             # no float128 available
             return
@@ -328,6 +515,17 @@
                 assert result.dtype == dtype
 
     def test_nanmedian(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         with warnings.catch_warnings(record=True):
             warnings.simplefilter("ignore", RuntimeWarning)
             self.check_funs(
@@ -341,6 +539,19 @@
 
     @pytest.mark.parametrize("ddof", range(3))
     def test_nanvar(self, ddof, skipna):
+        """
+
+        Parameters
+        ----------
+        ddof :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(
             nanops.nanvar,
             np.var,
@@ -353,6 +564,19 @@
 
     @pytest.mark.parametrize("ddof", range(3))
     def test_nanstd(self, ddof, skipna):
+        """
+
+        Parameters
+        ----------
+        ddof :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(
             nanops.nanstd,
             np.std,
@@ -366,6 +590,19 @@
     @td.skip_if_no_scipy
     @pytest.mark.parametrize("ddof", range(3))
     def test_nansem(self, ddof, skipna):
+        """
+
+        Parameters
+        ----------
+        ddof :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         from scipy.stats import sem
 
         with np.errstate(invalid="ignore"):
@@ -384,11 +621,41 @@
         "nan_op,np_op", [(nanops.nanmin, np.min), (nanops.nanmax, np.max)]
     )
     def test_nanops_with_warnings(self, nan_op, np_op, skipna):
+        """
+
+        Parameters
+        ----------
+        nan_op :
+            
+        np_op :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         with warnings.catch_warnings(record=True):
             warnings.simplefilter("ignore", RuntimeWarning)
             self.check_funs(nan_op, np_op, skipna, allow_obj=False)
 
     def _argminmax_wrap(self, value, axis=None, func=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        axis :
+             (Default value = None)
+        func :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         res = func(value, axis)
         nans = np.min(value, axis)
         nullnan = isna(nans)
@@ -404,18 +671,55 @@
         return res
 
     def test_nanargmax(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         with warnings.catch_warnings(record=True):
             warnings.simplefilter("ignore", RuntimeWarning)
             func = partial(self._argminmax_wrap, func=np.argmax)
             self.check_funs(nanops.nanargmax, func, skipna, allow_obj=False)
 
     def test_nanargmin(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         with warnings.catch_warnings(record=True):
             warnings.simplefilter("ignore", RuntimeWarning)
             func = partial(self._argminmax_wrap, func=np.argmin)
             self.check_funs(nanops.nanargmin, func, skipna, allow_obj=False)
 
     def _skew_kurt_wrap(self, values, axis=None, func=None):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        axis :
+             (Default value = None)
+        func :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if not isinstance(values.dtype.type, np.floating):
             values = values.astype("f8")
         result = func(values, axis=axis, bias=False)
@@ -429,6 +733,17 @@
 
     @td.skip_if_no_scipy
     def test_nanskew(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         from scipy.stats import skew
 
         func = partial(self._skew_kurt_wrap, func=skew)
@@ -444,6 +759,17 @@
 
     @td.skip_if_no_scipy
     def test_nankurt(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         from scipy.stats import kurtosis
 
         func1 = partial(kurtosis, fisher=True)
@@ -459,6 +785,17 @@
             )
 
     def test_nanprod(self, skipna):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         self.check_funs(
             nanops.nanprod,
             np.prod,
@@ -469,6 +806,23 @@
         )
 
     def check_nancorr_nancov_2d(self, checkfun, targ0, targ1, **kwargs):
+        """
+
+        Parameters
+        ----------
+        checkfun :
+            
+        targ0 :
+            
+        targ1 :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         res00 = checkfun(self.arr_float_2d, self.arr_float1_2d, **kwargs)
         res01 = checkfun(
             self.arr_float_2d,
@@ -514,6 +868,23 @@
         tm.assert_almost_equal(targ2, res25)
 
     def check_nancorr_nancov_1d(self, checkfun, targ0, targ1, **kwargs):
+        """
+
+        Parameters
+        ----------
+        checkfun :
+            
+        targ0 :
+            
+        targ1 :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         res00 = checkfun(self.arr_float_1d, self.arr_float1_1d, **kwargs)
         res01 = checkfun(
             self.arr_float_1d,
@@ -559,6 +930,7 @@
         tm.assert_almost_equal(targ2, res25)
 
     def test_nancorr(self):
+        """ """
         targ0 = np.corrcoef(self.arr_float_2d, self.arr_float1_2d)[0, 1]
         targ1 = np.corrcoef(self.arr_float_2d.flat, self.arr_float1_2d.flat)[0, 1]
         self.check_nancorr_nancov_2d(nanops.nancorr, targ0, targ1)
@@ -567,6 +939,7 @@
         self.check_nancorr_nancov_1d(nanops.nancorr, targ0, targ1, method="pearson")
 
     def test_nancorr_pearson(self):
+        """ """
         targ0 = np.corrcoef(self.arr_float_2d, self.arr_float1_2d)[0, 1]
         targ1 = np.corrcoef(self.arr_float_2d.flat, self.arr_float1_2d.flat)[0, 1]
         self.check_nancorr_nancov_2d(nanops.nancorr, targ0, targ1, method="pearson")
@@ -576,6 +949,7 @@
 
     @td.skip_if_no_scipy
     def test_nancorr_kendall(self):
+        """ """
         from scipy.stats import kendalltau
 
         targ0 = kendalltau(self.arr_float_2d, self.arr_float1_2d)[0]
@@ -587,6 +961,7 @@
 
     @td.skip_if_no_scipy
     def test_nancorr_spearman(self):
+        """ """
         from scipy.stats import spearmanr
 
         targ0 = spearmanr(self.arr_float_2d, self.arr_float1_2d)[0]
@@ -598,6 +973,7 @@
 
     @td.skip_if_no_scipy
     def test_invalid_method(self):
+        """ """
         targ0 = np.corrcoef(self.arr_float_2d, self.arr_float1_2d)[0, 1]
         targ1 = np.corrcoef(self.arr_float_2d.flat, self.arr_float1_2d.flat)[0, 1]
         msg = "Unknown method 'foo', expected one of 'kendall', 'spearman'"
@@ -605,6 +981,7 @@
             self.check_nancorr_nancov_1d(nanops.nancorr, targ0, targ1, method="foo")
 
     def test_nancov(self):
+        """ """
         targ0 = np.cov(self.arr_float_2d, self.arr_float1_2d)[0, 1]
         targ1 = np.cov(self.arr_float_2d.flat, self.arr_float1_2d.flat)[0, 1]
         self.check_nancorr_nancov_2d(nanops.nancov, targ0, targ1)
@@ -613,6 +990,19 @@
         self.check_nancorr_nancov_1d(nanops.nancov, targ0, targ1)
 
     def check_nancomp(self, checkfun, targ0):
+        """
+
+        Parameters
+        ----------
+        checkfun :
+            
+        targ0 :
+            
+
+        Returns
+        -------
+
+        """
         arr_float = self.arr_float
         arr_float1 = self.arr_float1
         arr_nan = self.arr_nan
@@ -658,10 +1048,38 @@
         ],
     )
     def test_nan_comparison(self, op, nanop):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        nanop :
+            
+
+        Returns
+        -------
+
+        """
         targ0 = op(self.arr_float, self.arr_float1)
         self.check_nancomp(nanop, targ0)
 
     def check_bool(self, func, value, correct):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        value :
+            
+        correct :
+            
+
+        Returns
+        -------
+
+        """
         while getattr(value, "ndim", True):
             res0 = func(value)
             if correct:
@@ -676,6 +1094,7 @@
             value = np.take(value, 0, axis=-1)
 
     def test__has_infs(self):
+        """ """
         pairs = [
             ("arr_complex", False),
             ("arr_int", False),
@@ -711,6 +1130,7 @@
             self.check_bool(nanops._has_infs, val.astype("f2"), correct)
 
     def test__bn_ok_dtype(self):
+        """ """
         assert nanops._bn_ok_dtype(self.arr_float.dtype, "test")
         assert nanops._bn_ok_dtype(self.arr_complex.dtype, "test")
         assert nanops._bn_ok_dtype(self.arr_int.dtype, "test")
@@ -723,7 +1143,9 @@
 
 
 class TestEnsureNumeric:
+    """ """
     def test_numeric_values(self):
+        """ """
         # Test integer
         assert nanops._ensure_numeric(1) == 1
 
@@ -734,6 +1156,7 @@
         assert nanops._ensure_numeric(1 + 2j) == 1 + 2j
 
     def test_ndarray(self):
+        """ """
         # Test numeric ndarray
         values = np.array([1, 2, 3])
         assert np.allclose(nanops._ensure_numeric(values), values)
@@ -753,11 +1176,13 @@
             nanops._ensure_numeric(s_values)
 
     def test_convertable_values(self):
+        """ """
         assert np.allclose(nanops._ensure_numeric("1"), 1.0)
         assert np.allclose(nanops._ensure_numeric("1.1"), 1.1)
         assert np.allclose(nanops._ensure_numeric("1+1j"), 1 + 1j)
 
     def test_non_convertable_values(self):
+        """ """
         msg = "Could not convert foo to numeric"
         with pytest.raises(TypeError, match=msg):
             nanops._ensure_numeric("foo")
@@ -771,20 +1196,34 @@
 
 
 class TestNanvarFixedValues:
+    """ """
 
     # xref GH10242
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # Samples from a normal distribution.
         self.variance = variance = 3.0
         self.samples = self.prng.normal(scale=variance ** 0.5, size=100000)
 
     def test_nanvar_all_finite(self):
+        """ """
         samples = self.samples
         actual_variance = nanops.nanvar(samples)
         tm.assert_almost_equal(actual_variance, self.variance, rtol=1e-2)
 
     def test_nanvar_nans(self):
+        """ """
         samples = np.nan * np.ones(2 * self.samples.shape[0])
         samples[::2] = self.samples
 
@@ -795,6 +1234,7 @@
         tm.assert_almost_equal(actual_variance, np.nan, rtol=1e-2)
 
     def test_nanstd_nans(self):
+        """ """
         samples = np.nan * np.ones(2 * self.samples.shape[0])
         samples[::2] = self.samples
 
@@ -805,6 +1245,7 @@
         tm.assert_almost_equal(actual_std, np.nan, rtol=1e-2)
 
     def test_nanvar_axis(self):
+        """ """
         # Generate some sample data.
         samples_norm = self.samples
         samples_unif = self.prng.uniform(size=samples_norm.shape[0])
@@ -816,6 +1257,7 @@
         )
 
     def test_nanvar_ddof(self):
+        """ """
         n = 5
         samples = self.prng.uniform(size=(10000, n + 1))
         samples[:, -1] = np.nan  # Force use of our own algorithm.
@@ -835,6 +1277,7 @@
         tm.assert_almost_equal(variance_2, (n - 1.0) / (n - 2.0) * var, rtol=1e-2)
 
     def test_ground_truth(self):
+        """ """
         # Test against values that were precomputed with Numpy.
         samples = np.empty((4, 4))
         samples[:3, :3] = np.array(
@@ -877,6 +1320,7 @@
                 assert np.isnan(std[3])
 
     def test_nanstd_roundoff(self):
+        """ """
         # Regression test for GH 10242 (test data taken from GH 10489). Ensure
         # that variance is stable.
         data = Series(766897346 * np.ones(10))
@@ -886,19 +1330,33 @@
 
     @property
     def prng(self):
+        """ """
         return np.random.RandomState(1234)
 
 
 class TestNanskewFixedValues:
+    """ """
 
     # xref GH 11974
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # Test data + skewness value (computed with scipy.stats.skew)
         self.samples = np.sin(np.linspace(0, 1, 200))
         self.actual_skew = -0.1875895205961754
 
     def test_constant_series(self):
+        """ """
         # xref GH 11974
         for val in [3075.2, 3075.3, 3075.5]:
             data = val * np.ones(300)
@@ -906,6 +1364,7 @@
             assert skew == 0.0
 
     def test_all_finite(self):
+        """ """
         alpha, beta = 0.3, 0.1
         left_tailed = self.prng.beta(alpha, beta, size=100)
         assert nanops.nanskew(left_tailed) < 0
@@ -915,39 +1374,57 @@
         assert nanops.nanskew(right_tailed) > 0
 
     def test_ground_truth(self):
+        """ """
         skew = nanops.nanskew(self.samples)
         tm.assert_almost_equal(skew, self.actual_skew)
 
     def test_axis(self):
+        """ """
         samples = np.vstack([self.samples, np.nan * np.ones(len(self.samples))])
         skew = nanops.nanskew(samples, axis=1)
         tm.assert_almost_equal(skew, np.array([self.actual_skew, np.nan]))
 
     def test_nans(self):
+        """ """
         samples = np.hstack([self.samples, np.nan])
         skew = nanops.nanskew(samples, skipna=False)
         assert np.isnan(skew)
 
     def test_nans_skipna(self):
+        """ """
         samples = np.hstack([self.samples, np.nan])
         skew = nanops.nanskew(samples, skipna=True)
         tm.assert_almost_equal(skew, self.actual_skew)
 
     @property
     def prng(self):
+        """ """
         return np.random.RandomState(1234)
 
 
 class TestNankurtFixedValues:
+    """ """
 
     # xref GH 11974
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # Test data + kurtosis value (computed with scipy.stats.kurtosis)
         self.samples = np.sin(np.linspace(0, 1, 200))
         self.actual_kurt = -1.2058303433799713
 
     def test_constant_series(self):
+        """ """
         # xref GH 11974
         for val in [3075.2, 3075.3, 3075.5]:
             data = val * np.ones(300)
@@ -955,6 +1432,7 @@
             assert kurt == 0.0
 
     def test_all_finite(self):
+        """ """
         alpha, beta = 0.3, 0.1
         left_tailed = self.prng.beta(alpha, beta, size=100)
         assert nanops.nankurt(left_tailed) < 0
@@ -964,34 +1442,51 @@
         assert nanops.nankurt(right_tailed) > 0
 
     def test_ground_truth(self):
+        """ """
         kurt = nanops.nankurt(self.samples)
         tm.assert_almost_equal(kurt, self.actual_kurt)
 
     def test_axis(self):
+        """ """
         samples = np.vstack([self.samples, np.nan * np.ones(len(self.samples))])
         kurt = nanops.nankurt(samples, axis=1)
         tm.assert_almost_equal(kurt, np.array([self.actual_kurt, np.nan]))
 
     def test_nans(self):
+        """ """
         samples = np.hstack([self.samples, np.nan])
         kurt = nanops.nankurt(samples, skipna=False)
         assert np.isnan(kurt)
 
     def test_nans_skipna(self):
+        """ """
         samples = np.hstack([self.samples, np.nan])
         kurt = nanops.nankurt(samples, skipna=True)
         tm.assert_almost_equal(kurt, self.actual_kurt)
 
     @property
     def prng(self):
+        """ """
         return np.random.RandomState(1234)
 
 
 class TestDatetime64NaNOps:
+    """ """
     @pytest.mark.parametrize("tz", [None, "UTC"])
     # Enabling mean changes the behavior of DataFrame.mean
     # See https://github.com/pandas-dev/pandas/issues/24752
     def test_nanmean(self, tz):
+        """
+
+        Parameters
+        ----------
+        tz :
+            
+
+        Returns
+        -------
+
+        """
         dti = pd.date_range("2016-01-01", periods=3, tz=tz)
         expected = dti[1]
 
@@ -1007,6 +1502,7 @@
 
 
 def test_use_bottleneck():
+    """ """
 
     if nanops._BOTTLENECK_INSTALLED:
 
@@ -1035,6 +1531,19 @@
     ],
 )
 def test_numpy_ops(numpy_op, expected):
+    """
+
+    Parameters
+    ----------
+    numpy_op :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     # GH8383
     result = numpy_op(pd.Series([1, 2, 3, 4]))
     assert result == expected
@@ -1061,6 +1570,17 @@
     ],
 )
 def test_nanops_independent_of_mask_param(operation):
+    """
+
+    Parameters
+    ----------
+    operation :
+        
+
+    Returns
+    -------
+
+    """
     # GH22764
     s = pd.Series([1, 2, np.nan, 3, np.nan, 4])
     mask = s.isna()
