# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/polynomial/hermite_e.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/polynomial/hermite_e.py
@@ -95,11 +95,10 @@
 
 
 def poly2herme(pol):
-    """
-    poly2herme(pol)
-
+    """poly2herme(pol)
+    
     Convert a polynomial to a Hermite series.
-
+    
     Convert an array representing the coefficients of a polynomial (relative
     to the "standard" basis) ordered from lowest degree to highest, to an
     array of the coefficients of the equivalent Hermite series, ordered
@@ -119,18 +118,15 @@
     See Also
     --------
     herme2poly
-
     Notes
     -----
     The easy way to do conversions between polynomial basis sets
     is to use the convert method of a class instance.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import poly2herme
     >>> poly2herme(np.arange(4))
     array([  2.,  10.,   2.,   3.])
-
     """
     [pol] = pu.as_series([pol])
     deg = len(pol) - 1
@@ -141,9 +137,8 @@
 
 
 def herme2poly(c):
-    """
-    Convert a Hermite series to a polynomial.
-
+    """Convert a Hermite series to a polynomial.
+    
     Convert an array representing the coefficients of a Hermite series,
     ordered from lowest degree to highest, to an array of the coefficients
     of the equivalent polynomial (relative to the "standard" basis) ordered
@@ -165,18 +160,15 @@
     See Also
     --------
     poly2herme
-
     Notes
     -----
     The easy way to do conversions between polynomial basis sets
     is to use the convert method of a class instance.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import herme2poly
     >>> herme2poly([  2.,  10.,   2.,   3.])
     array([0.,  1.,  2.,  3.])
-
     """
     from .polynomial import polyadd, polysub, polymulx
 
@@ -215,15 +207,16 @@
 
 
 def hermeline(off, scl):
-    """
-    Hermite series whose graph is a straight line.
-
-
+    """Hermite series whose graph is a straight line.
 
     Parameters
     ----------
     off, scl : scalars
         The specified line is given by ``off + scl*x``.
+    off :
+        
+    scl :
+        
 
     Returns
     -------
@@ -234,7 +227,6 @@
     See Also
     --------
     polyline, chebline
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeline
@@ -243,7 +235,6 @@
     3.0
     >>> hermeval(1,hermeline(3, 2))
     5.0
-
     """
     if scl != 0:
         return np.array([off, scl])
@@ -252,23 +243,22 @@
 
 
 def hermefromroots(roots):
-    """
-    Generate a HermiteE series with given roots.
-
+    """Generate a HermiteE series with given roots.
+    
     The function returns the coefficients of the polynomial
-
+    
     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
-
+    
     in HermiteE form, where the `r_n` are the roots specified in `roots`.
     If a zero has multiplicity n, then it must appear in `roots` n times.
     For instance, if 2 is a root of multiplicity three and 3 is a root of
     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
     roots can appear in any order.
-
+    
     If the returned coefficients are `c`, then
-
+    
     .. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)
-
+    
     The coefficient of the last term is not generally 1 for monic
     polynomials in HermiteE form.
 
@@ -288,7 +278,6 @@
     See Also
     --------
     polyfromroots, legfromroots, lagfromroots, hermfromroots, chebfromroots
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermefromroots, hermeval
@@ -298,15 +287,13 @@
     >>> coef = hermefromroots((-1j, 1j))
     >>> hermeval((-1j, 1j), coef)
     array([0.+0.j, 0.+0.j])
-
     """
     return pu._fromroots(hermeline, hermemul, roots)
 
 
 def hermeadd(c1, c2):
-    """
-    Add one Hermite series to another.
-
+    """Add one Hermite series to another.
+    
     Returns the sum of two Hermite series `c1` + `c2`.  The arguments
     are sequences of coefficients ordered from lowest order term to
     highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
@@ -316,6 +303,10 @@
     c1, c2 : array_like
         1-D arrays of Hermite series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -325,28 +316,24 @@
     See Also
     --------
     hermesub, hermemulx, hermemul, hermediv, hermepow
-
     Notes
     -----
     Unlike multiplication, division, etc., the sum of two Hermite series
     is a Hermite series (without having to "reproject" the result onto
     the basis set) so addition, just like that of "standard" polynomials,
     is simply "component-wise."
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeadd
     >>> hermeadd([1, 2, 3], [1, 2, 3, 4])
     array([2.,  4.,  6.,  4.])
-
     """
     return pu._add(c1, c2)
 
 
 def hermesub(c1, c2):
-    """
-    Subtract one Hermite series from another.
-
+    """Subtract one Hermite series from another.
+    
     Returns the difference of two Hermite series `c1` - `c2`.  The
     sequences of coefficients are from lowest order term to highest, i.e.,
     [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
@@ -356,6 +343,10 @@
     c1, c2 : array_like
         1-D arrays of Hermite series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -365,30 +356,26 @@
     See Also
     --------
     hermeadd, hermemulx, hermemul, hermediv, hermepow
-
     Notes
     -----
     Unlike multiplication, division, etc., the difference of two Hermite
     series is a Hermite series (without having to "reproject" the result
     onto the basis set) so subtraction, just like that of "standard"
     polynomials, is simply "component-wise."
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermesub
     >>> hermesub([1, 2, 3, 4], [1, 2, 3])
     array([0., 0., 0., 4.])
-
     """
     return pu._sub(c1, c2)
 
 
 def hermemulx(c):
     """Multiply a Hermite series by x.
-
+    
     Multiply the Hermite series `c` by x, where x is the independent
     variable.
-
 
     Parameters
     ----------
@@ -405,17 +392,15 @@
     -----
     The multiplication uses the recursion relationship for Hermite
     polynomials in the form
-
+    
     .. math::
-
+    
     xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermemulx
     >>> hermemulx([1, 2, 3])
     array([2.,  7.,  2.,  3.])
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -433,9 +418,8 @@
 
 
 def hermemul(c1, c2):
-    """
-    Multiply one Hermite series by another.
-
+    """Multiply one Hermite series by another.
+    
     Returns the product of two Hermite series `c1` * `c2`.  The arguments
     are sequences of coefficients, from lowest order "term" to highest,
     e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
@@ -445,6 +429,10 @@
     c1, c2 : array_like
         1-D arrays of Hermite series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -454,7 +442,6 @@
     See Also
     --------
     hermeadd, hermesub, hermemulx, hermediv, hermepow
-
     Notes
     -----
     In general, the (polynomial) product of two C-series results in terms
@@ -462,13 +449,11 @@
     the product as a Hermite series, it is necessary to "reproject" the
     product onto said basis set, which may produce "unintuitive" (but
     correct) results; see Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermemul
     >>> hermemul([1, 2, 3], [0, 1, 2])
     array([14.,  15.,  28.,   7.,   6.])
-
     """
     # s1, s2 are trimmed copies
     [c1, c2] = pu.as_series([c1, c2])
@@ -499,9 +484,8 @@
 
 
 def hermediv(c1, c2):
-    """
-    Divide one Hermite series by another.
-
+    """Divide one Hermite series by another.
+    
     Returns the quotient-with-remainder of two Hermite series
     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
     order "term" to highest, e.g., [1,2,3] represents the series
@@ -512,6 +496,10 @@
     c1, c2 : array_like
         1-D arrays of Hermite series coefficients ordered from low to
         high.
+    c1 :
+        
+    c2 :
+        
 
     Returns
     -------
@@ -522,7 +510,6 @@
     See Also
     --------
     hermeadd, hermesub, hermemulx, hermemul, hermepow
-
     Notes
     -----
     In general, the (polynomial) division of one Hermite series by another
@@ -531,7 +518,6 @@
     series, it is necessary to "reproject" the results onto the Hermite
     basis set, which may produce "unintuitive" (but correct) results; see
     Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermediv
@@ -539,14 +525,13 @@
     (array([1., 2., 3.]), array([0.]))
     >>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])
     (array([1., 2., 3.]), array([1., 2.]))
-
     """
     return pu._div(hermemul, c1, c2)
 
 
 def hermepow(c, pow, maxpower=16):
     """Raise a Hermite series to a power.
-
+    
     Returns the Hermite series `c` raised to the power `pow`. The
     argument `c` is a sequence of coefficients ordered from low to high.
     i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``
@@ -570,21 +555,18 @@
     See Also
     --------
     hermeadd, hermesub, hermemulx, hermemul, hermediv
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermepow
     >>> hermepow([1, 2, 3], 2)
     array([23.,  28.,  46.,  12.,   9.])
-
     """
     return pu._pow(hermemul, c, pow, maxpower)
 
 
 def hermeder(c, m=1, scl=1, axis=0):
-    """
-    Differentiate a Hermite_e series.
-
+    """Differentiate a Hermite_e series.
+    
     Returns the series coefficients `c` differentiated `m` times along
     `axis`.  At each iteration the result is multiplied by `scl` (the
     scaling factor is for use in a linear change of variable). The argument
@@ -608,7 +590,6 @@
         variable. (Default: 1)
     axis : int, optional
         Axis over which the derivative is taken. (Default: 0).
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -619,14 +600,12 @@
     See Also
     --------
     hermeint
-
     Notes
     -----
     In general, the result of differentiating a Hermite series does not
     resemble the same operation on a power series. Thus the result of this
     function may be "unintuitive," albeit correct; see Examples section
     below.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeder
@@ -634,7 +613,6 @@
     array([1.,  2.,  3.])
     >>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)
     array([1.,  2.,  3.])
-
     """
     c = np.array(c, ndmin=1, copy=True)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -665,9 +643,8 @@
 
 
 def hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
-    """
-    Integrate a Hermite_e series.
-
+    """Integrate a Hermite_e series.
+    
     Returns the Hermite_e series coefficients `c` integrated `m` times from
     `lbnd` along `axis`. At each iteration the resulting series is
     **multiplied** by `scl` and an integration constant, `k`, is added.
@@ -701,7 +678,6 @@
         before the integration constant is added. (Default: 1)
     axis : int, optional
         Axis over which the integral is taken. (Default: 0).
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -718,7 +694,6 @@
     See Also
     --------
     hermeder
-
     Notes
     -----
     Note that the result of each integration is *multiplied* by `scl`.
@@ -726,12 +701,11 @@
     variable :math:`u = ax + b` in an integral relative to `x`.  Then
     :math:`dx = du/a`, so one will need to set `scl` equal to
     :math:`1/a` - perhaps not what one would have first thought.
-
+    
     Also note that, in general, the result of integrating a C-series needs
     to be "reprojected" onto the C-series basis set.  Thus, typically,
     the result of this function is "unintuitive," albeit correct; see
     Examples section below.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeint
@@ -745,7 +719,6 @@
     array([-1.,  1.,  1.,  1.])
     >>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)
     array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary
-
     """
     c = np.array(c, ndmin=1, copy=True)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -787,24 +760,23 @@
 
 
 def hermeval(x, c, tensor=True):
-    """
-    Evaluate an HermiteE series at points x.
-
+    """Evaluate an HermiteE series at points x.
+    
     If `c` is of length `n + 1`, this function returns the value:
-
+    
     .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)
-
+    
     The parameter `x` is converted to an array only if it is a tuple or a
     list, otherwise it is treated as a scalar. In either case, either `x`
     or its elements must support multiplication and addition both with
     themselves and with the elements of `c`.
-
+    
     If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
     `c` is multidimensional, then the shape of the result depends on the
     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
     scalars have shape (,).
-
+    
     Trailing zeros in the coefficients will be used in the evaluation, so
     they should be avoided if efficiency is a concern.
 
@@ -828,7 +800,6 @@
         `c` is evaluated for every element of `x`. If False, `x` is broadcast
         over the columns of `c` for the evaluation.  This keyword is useful
         when `c` is multidimensional. The default value is True.
-
         .. versionadded:: 1.7.0
 
     Returns
@@ -839,11 +810,9 @@
     See Also
     --------
     hermeval2d, hermegrid2d, hermeval3d, hermegrid3d
-
     Notes
     -----
     The evaluation uses Clenshaw recursion, aka synthetic division.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeval
@@ -853,7 +822,6 @@
     >>> hermeval([[1,2],[3,4]], coef)
     array([[ 3., 14.],
            [31., 54.]])
-
     """
     c = np.array(c, ndmin=1, copy=False)
     if c.dtype.char in '?bBhHiIlLqQpP':
@@ -882,19 +850,18 @@
 
 
 def hermeval2d(x, y, c):
-    """
-    Evaluate a 2-D HermiteE series at points (x, y).
-
+    """Evaluate a 2-D HermiteE series at points (x, y).
+    
     This function returns the values:
-
+    
     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * He_i(x) * He_j(y)
-
+    
     The parameters `x` and `y` are converted to arrays only if they are
     tuples or a lists, otherwise they are treated as a scalars and they
     must have the same shape after conversion. In either case, either `x`
     and `y` or their elements must support multiplication and addition both
     with themselves and with the elements of `c`.
-
+    
     If `c` is a 1-D array a one is implicitly appended to its shape to make
     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
 
@@ -910,6 +877,10 @@
         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
         dimension greater than two the remaining indices enumerate multiple
         sets of coefficients.
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -920,33 +891,30 @@
     See Also
     --------
     hermeval, hermegrid2d, hermeval3d, hermegrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._valnd(hermeval, c, x, y)
 
 
 def hermegrid2d(x, y, c):
-    """
-    Evaluate a 2-D HermiteE series on the Cartesian product of x and y.
-
+    """Evaluate a 2-D HermiteE series on the Cartesian product of x and y.
+    
     This function returns the values:
-
+    
     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)
-
+    
     where the points `(a, b)` consist of all pairs formed by taking
     `a` from `x` and `b` from `y`. The resulting points form a grid with
     `x` in the first dimension and `y` in the second.
-
+    
     The parameters `x` and `y` are converted to arrays only if they are
     tuples or a lists, otherwise they are treated as a scalars. In either
     case, either `x` and `y` or their elements must support multiplication
     and addition both with themselves and with the elements of `c`.
-
+    
     If `c` has fewer than two dimensions, ones are implicitly appended to
     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
     x.shape.
@@ -963,6 +931,10 @@
         degree i,j are contained in ``c[i,j]``. If `c` has dimension
         greater than two the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -973,30 +945,27 @@
     See Also
     --------
     hermeval, hermeval2d, hermeval3d, hermegrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._gridnd(hermeval, c, x, y)
 
 
 def hermeval3d(x, y, z, c):
-    """
-    Evaluate a 3-D Hermite_e series at points (x, y, z).
-
+    """Evaluate a 3-D Hermite_e series at points (x, y, z).
+    
     This function returns the values:
-
+    
     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)
-
+    
     The parameters `x`, `y`, and `z` are converted to arrays only if
     they are tuples or a lists, otherwise they are treated as a scalars and
     they must have the same shape after conversion. In either case, either
     `x`, `y`, and `z` or their elements must support multiplication and
     addition both with themselves and with the elements of `c`.
-
+    
     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
     shape to make it 3-D. The shape of the result will be c.shape[3:] +
     x.shape.
@@ -1014,6 +983,12 @@
         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
         greater than 3 the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1024,35 +999,32 @@
     See Also
     --------
     hermeval, hermeval2d, hermegrid2d, hermegrid3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._valnd(hermeval, c, x, y, z)
 
 
 def hermegrid3d(x, y, z, c):
-    """
-    Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.
-
+    """Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.
+    
     This function returns the values:
-
+    
     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)
-
+    
     where the points `(a, b, c)` consist of all triples formed by taking
     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
     a grid with `x` in the first dimension, `y` in the second, and `z` in
     the third.
-
+    
     The parameters `x`, `y`, and `z` are converted to arrays only if they
     are tuples or a lists, otherwise they are treated as a scalars. In
     either case, either `x`, `y`, and `z` or their elements must support
     multiplication and addition both with themselves and with the elements
     of `c`.
-
+    
     If `c` has fewer than three dimensions, ones are implicitly appended to
     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
     x.shape + y.shape + z.shape.
@@ -1070,6 +1042,12 @@
         degree i,j are contained in ``c[i,j]``. If `c` has dimension
         greater than two the remaining indices enumerate multiple sets of
         coefficients.
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1080,27 +1058,25 @@
     See Also
     --------
     hermeval, hermeval2d, hermegrid2d, hermeval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._gridnd(hermeval, c, x, y, z)
 
 
 def hermevander(x, deg):
     """Pseudo-Vandermonde matrix of given degree.
-
+    
     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
     `x`. The pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., i] = He_i(x),
-
+    
     where `0 <= i <= deg`. The leading indices of `V` index the elements of
     `x` and the last index is the degree of the HermiteE polynomial.
-
+    
     If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
     array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
     ``hermeval(x, c)`` are the same up to roundoff. This equivalence is
@@ -1132,7 +1108,6 @@
     array([[ 1., -1.,  0.,  2.],
            [ 1.,  0., -1., -0.],
            [ 1.,  1.,  0., -2.]])
-
     """
     ideg = pu._deprecate_as_int(deg, "deg")
     if ideg < 0:
@@ -1152,22 +1127,22 @@
 
 def hermevander2d(x, y, deg):
     """Pseudo-Vandermonde matrix of given degrees.
-
+    
     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
     points `(x, y)`. The pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),
-
+    
     where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
     `V` index the points `(x, y)` and the last index encodes the degrees of
     the HermiteE polynomials.
-
+    
     If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
     correspond to the elements of a 2-D coefficient array `c` of shape
     (xdeg + 1, ydeg + 1) in the order
-
+    
     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
-
+    
     and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same
     up to roundoff. This equivalence is useful both for least squares
     fitting and for the evaluation of a large number of 2-D HermiteE
@@ -1182,6 +1157,10 @@
         1-D arrays.
     deg : list of ints
         List of maximum degrees of the form [x_deg, y_deg].
+    x :
+        
+    y :
+        
 
     Returns
     -------
@@ -1193,35 +1172,33 @@
     See Also
     --------
     hermevander, hermevander3d, hermeval2d, hermeval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._vander_nd_flat((hermevander, hermevander), (x, y), deg)
 
 
 def hermevander3d(x, y, z, deg):
     """Pseudo-Vandermonde matrix of given degrees.
-
+    
     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
     points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
     then Hehe pseudo-Vandermonde matrix is defined by
-
+    
     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),
-
+    
     where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
     indices of `V` index the points `(x, y, z)` and the last index encodes
     the degrees of the HermiteE polynomials.
-
+    
     If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
     of `V` correspond to the elements of a 3-D coefficient array `c` of
     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
-
+    
     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
-
+    
     and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the
     same up to roundoff. This equivalence is useful both for least squares
     fitting and for the evaluation of a large number of 3-D HermiteE
@@ -1236,6 +1213,12 @@
         arrays.
     deg : list of ints
         List of maximum degrees of the form [x_deg, y_deg, z_deg].
+    x :
+        
+    y :
+        
+    z :
+        
 
     Returns
     -------
@@ -1247,29 +1230,26 @@
     See Also
     --------
     hermevander, hermevander3d, hermeval2d, hermeval3d
-
-    Notes
-    -----
-
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     return pu._vander_nd_flat((hermevander, hermevander, hermevander), (x, y, z), deg)
 
 
 def hermefit(x, y, deg, rcond=None, full=False, w=None):
-    """
-    Least squares fit of Hermite series to data.
-
+    """Least squares fit of Hermite series to data.
+    
     Return the coefficients of a HermiteE series of degree `deg` that is
     the least squares fit to the data values `y` given at points `x`. If
     `y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D
     multiple fits are done, one for each column of `y`, and the resulting
     coefficients are stored in the corresponding columns of a 2-D return.
     The fitted polynomial(s) are in the form
-
+    
     .. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),
-
+    
     where `n` is `deg`.
 
     Parameters
@@ -1306,26 +1286,21 @@
         Hermite coefficients ordered from low to high. If `y` was 2-D,
         the coefficients for the data in column k  of `y` are in column
         `k`.
-
     [residuals, rank, singular_values, rcond] : list
         These values are only returned if `full` = True
-
         resid -- sum of squared residuals of the least squares fit
         rank -- the numerical rank of the scaled Vandermonde matrix
         sv -- singular values of the scaled Vandermonde matrix
         rcond -- value of `rcond`.
-
         For more details, see `linalg.lstsq`.
-
     Warns
-    -----
+        
+    -----
+        
     RankWarning
         The rank of the coefficient matrix in the least-squares fit is
         deficient. The warning is only raised if `full` = False.  The
         warnings can be turned off by
-
-        >>> import warnings
-        >>> warnings.simplefilter('ignore', np.RankWarning)
 
     See Also
     --------
@@ -1335,44 +1310,44 @@
     hermeweight : HermiteE weight function.
     linalg.lstsq : Computes a least-squares fit from the matrix.
     scipy.interpolate.UnivariateSpline : Computes spline fits.
-
     Notes
     -----
     The solution is the coefficients of the HermiteE series `p` that
     minimizes the sum of the weighted squared errors
-
+    
     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
-
+    
     where the :math:`w_j` are the weights. This problem is solved by
     setting up the (typically) overdetermined matrix equation
-
+    
     .. math:: V(x) * c = w * y,
-
+    
     where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`
     are the coefficients to be solved for, and the elements of `y` are the
     observed values.  This equation is then solved using the singular value
     decomposition of `V`.
-
+    
     If some of the singular values of `V` are so small that they are
     neglected, then a `RankWarning` will be issued. This means that the
     coefficient values may be poorly determined. Using a lower order fit
     will usually get rid of the warning.  The `rcond` parameter can also be
     set to a value smaller than its default, but the resulting fit may be
     spurious and have large contributions from roundoff error.
-
+    
     Fits using HermiteE series are probably most useful when the data can
     be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the HermiteE
     weight. In that case the weight ``sqrt(w(x[i]))`` should be used
     together with data values ``y[i]/sqrt(w(x[i]))``. The weight function is
     available as `hermeweight`.
-
     References
     ----------
     .. [1] Wikipedia, "Curve fitting",
            https://en.wikipedia.org/wiki/Curve_fitting
-
     Examples
     --------
+    >>> import warnings
+        >>> warnings.simplefilter('ignore', np.RankWarning)
+    
     >>> from numpy.polynomial.hermite_e import hermefit, hermeval
     >>> x = np.linspace(-10, 10)
     >>> np.random.seed(123)
@@ -1380,15 +1355,13 @@
     >>> y = hermeval(x, [1, 2, 3]) + err
     >>> hermefit(x, y, 2)
     array([ 1.01690445,  1.99951418,  2.99948696]) # may vary
-
     """
     return pu._fit(hermevander, x, y, deg, rcond, full, w)
 
 
 def hermecompanion(c):
-    """
-    Return the scaled companion matrix of c.
-
+    """Return the scaled companion matrix of c.
+    
     The basis polynomials are scaled so that the companion matrix is
     symmetric when `c` is an HermiteE basis polynomial. This provides
     better eigenvalue estimates than the unscaled case and for basis
@@ -1408,9 +1381,8 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.7.0
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -1432,11 +1404,10 @@
 
 
 def hermeroots(c):
-    """
-    Compute the roots of a HermiteE series.
-
+    """Compute the roots of a HermiteE series.
+    
     Return the roots (a.k.a. "zeros") of the polynomial
-
+    
     .. math:: p(x) = \\sum_i c[i] * He_i(x).
 
     Parameters
@@ -1453,7 +1424,6 @@
     See Also
     --------
     polyroots, legroots, lagroots, hermroots, chebroots
-
     Notes
     -----
     The root estimates are obtained as the eigenvalues of the companion
@@ -1463,10 +1433,9 @@
     errors as the value of the series near such points is relatively
     insensitive to errors in the roots. Isolated roots near the origin can
     be improved by a few iterations of Newton's method.
-
+    
     The HermiteE series basis polynomials aren't powers of `x` so the
     results of this function may seem unintuitive.
-
     Examples
     --------
     >>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots
@@ -1475,7 +1444,6 @@
     array([0., 2., 0., 1.])
     >>> hermeroots(coef)
     array([-1.,  0.,  1.]) # may vary
-
     """
     # c is a trimmed copy
     [c] = pu.as_series([c])
@@ -1492,12 +1460,10 @@
 
 
 def _normed_hermite_e_n(x, n):
-    """
-    Evaluate a normalized HermiteE polynomial.
-
+    """Evaluate a normalized HermiteE polynomial.
+    
     Compute the value of the normalized HermiteE polynomial of degree ``n``
     at the points ``x``.
-
 
     Parameters
     ----------
@@ -1514,11 +1480,10 @@
     Notes
     -----
     .. versionadded:: 1.10.0
-
+    
     This function is needed for finding the Gauss points and integration
     weights for high degrees. The values of the standard HermiteE functions
     overflow when n >= 207.
-
     """
     if n == 0:
         return np.full(x.shape, 1/np.sqrt(np.sqrt(2*np.pi)))
@@ -1535,9 +1500,8 @@
 
 
 def hermegauss(deg):
-    """
-    Gauss-HermiteE quadrature.
-
+    """Gauss-HermiteE quadrature.
+    
     Computes the sample points and weights for Gauss-HermiteE quadrature.
     These sample points and weights will correctly integrate polynomials of
     degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`
@@ -1557,18 +1521,17 @@
 
     Notes
     -----
-
+    
     .. versionadded:: 1.7.0
-
+    
     The results have only been tested up to degree 100, higher degrees may
     be problematic. The weights are determined by using the fact that
-
+    
     .. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))
-
+    
     where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
     is the k'th root of :math:`He_n`, and then scaling the results to get
     the right value when integrating 1.
-
     """
     ideg = pu._deprecate_as_int(deg, "deg")
     if ideg <= 0:
@@ -1603,7 +1566,7 @@
 
 def hermeweight(x):
     """Weight function of the Hermite_e polynomials.
-
+    
     The weight function is :math:`\\exp(-x^2/2)` and the interval of
     integration is :math:`[-\\inf, \\inf]`. the HermiteE polynomials are
     orthogonal, but not normalized, with respect to this weight function.
@@ -1611,18 +1574,17 @@
     Parameters
     ----------
     x : array_like
-       Values at which the weight function will be computed.
+        Values at which the weight function will be computed.
 
     Returns
     -------
     w : ndarray
-       The weight function at `x`.
-
-    Notes
-    -----
-
+        The weight function at `x`.
+
+    Notes
+    -----
+    
     .. versionadded:: 1.7.0
-
     """
     w = np.exp(-.5*x**2)
     return w
@@ -1634,25 +1596,18 @@
 
 class HermiteE(ABCPolyBase):
     """An HermiteE series class.
-
+    
     The HermiteE class provides the standard Python numerical methods
     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
     attributes and methods listed in the `ABCPolyBase` documentation.
 
     Parameters
     ----------
-    coef : array_like
-        HermiteE coefficients in order of increasing degree, i.e,
-        ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.
-    domain : (2,) array_like, optional
-        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
-        to the interval ``[window[0], window[1]]`` by shifting and scaling.
-        The default value is [-1, 1].
-    window : (2,) array_like, optional
-        Window, see `domain` for its use. The default value is [-1, 1].
-
-        .. versionadded:: 1.6.0
-
+
+    Returns
+    -------
+
+    
     """
     # Virtual Functions
     _add = staticmethod(hermeadd)
