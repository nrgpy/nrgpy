# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pexpect/pty_spawn.py
+++ b/..//venv/lib/python3.8/site-packages/pexpect/pty_spawn.py
@@ -27,8 +27,16 @@
 PY3 = (sys.version_info[0] >= 3)
 
 class spawn(SpawnBase):
-    '''This is the main class interface for Pexpect. Use this class to start
-    and control child applications. '''
+    """This is the main class interface for Pexpect. Use this class to start
+    and control child applications.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
 
     # This is purely informational now - changing it has no effect
     use_native_pty_fork = use_native_pty_fork
@@ -238,10 +246,26 @@
         return '\n'.join(s)
 
     def _spawn(self, command, args=[], preexec_fn=None, dimensions=None):
-        '''This starts the given command in a child process. This does all the
+        """This starts the given command in a child process. This does all the
         fork/exec type of stuff for a pty. This is called by __init__. If args
         is empty then command will be parsed (split on spaces) and args will be
-        set to parsed arguments. '''
+        set to parsed arguments.
+
+        Parameters
+        ----------
+        command :
+            
+        args :
+             (Default value = [])
+        preexec_fn :
+             (Default value = None)
+        dimensions :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         # The pid and child_fd of this object get set by this method.
         # Note that it is difficult for this method to fail.
@@ -286,6 +310,7 @@
         kwargs = {'echo': self.echo, 'preexec_fn': preexec_fn}
         if self.ignore_sighup:
             def preexec_wrapper():
+                """ """
                 "Set SIGHUP to be ignored, then call the real preexec_fn"
                 signal.signal(signal.SIGHUP, signal.SIG_IGN)
                 if preexec_fn is not None:
@@ -311,15 +336,37 @@
         self.closed = False
 
     def _spawnpty(self, args, **kwargs):
-        '''Spawn a pty and return an instance of PtyProcess.'''
+        """Spawn a pty and return an instance of PtyProcess.
+
+        Parameters
+        ----------
+        args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return ptyprocess.PtyProcess.spawn(args, **kwargs)
 
     def close(self, force=True):
-        '''This closes the connection with the child application. Note that
+        """This closes the connection with the child application. Note that
         calling close() more than once is valid. This emulates standard Python
         behavior with files. Set force to True if you want to make sure that
         the child is terminated (SIGKILL is sent if the child ignores SIGHUP
-        and SIGINT). '''
+        and SIGINT).
+
+        Parameters
+        ----------
+        force :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
 
         self.flush()
         with _wrap_ptyprocess_err():
@@ -331,32 +378,49 @@
         self.closed = True
 
     def isatty(self):
-        '''This returns True if the file descriptor is open and connected to a
+        """This returns True if the file descriptor is open and connected to a
         tty(-like) device, else False.
-
+        
         On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
         the child pty may not appear as a terminal device.  This means
         methods such as setecho(), setwinsize(), getwinsize() may raise an
-        IOError. '''
+        IOError.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         return os.isatty(self.child_fd)
 
     def waitnoecho(self, timeout=-1):
-        '''This waits until the terminal ECHO flag is set False. This returns
+        """This waits until the terminal ECHO flag is set False. This returns
         True if the echo mode is off. This returns False if the ECHO flag was
         not set False before the timeout. This can be used to detect when the
         child is waiting for a password. Usually a child application will turn
         off echo mode when it is waiting for the user to enter a password. For
         example, instead of expecting the "password:" prompt you can wait for
         the child to set ECHO off::
-
+        
             p = pexpect.spawn('ssh user@example.com')
             p.waitnoecho()
             p.sendline(mypassword)
-
+        
         If timeout==-1 then this method will use the value in self.timeout.
         If timeout==None then this method to block until ECHO flag is False.
-        '''
+
+        Parameters
+        ----------
+        timeout :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         if timeout == -1:
             timeout = self.timeout
@@ -372,19 +436,27 @@
             time.sleep(0.1)
 
     def getecho(self):
-        '''This returns the terminal echo mode. This returns True if echo is
+        """This returns the terminal echo mode. This returns True if echo is
         on or False if echo is off. Child applications that are expecting you
         to enter a password often set ECHO False. See waitnoecho().
-
-        Not supported on platforms where ``isatty()`` returns False.  '''
+        
+        Not supported on platforms where ``isatty()`` returns False.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         return self.ptyproc.getecho()
 
     def setecho(self, state):
-        '''This sets the terminal echo mode on or off. Note that anything the
+        """This sets the terminal echo mode on or off. Note that anything the
         child sent before the echo will be lost, so you should be sure that
         your input buffer is empty before you call setecho(). For example, the
         following will work as expected::
-
+        
             p = pexpect.spawn('cat') # Echo is on by default.
             p.sendline('1234') # We expect see this twice from the child...
             p.expect(['1234']) # ... once from the tty echo...
@@ -394,10 +466,10 @@
             p.sendline('wxyz') # We will set this only once (echoed by cat)
             p.expect(['abcd'])
             p.expect(['wxyz'])
-
+        
         The following WILL NOT WORK because the lines sent before the setecho
         will be lost::
-
+        
             p = pexpect.spawn('cat')
             p.sendline('1234')
             p.setecho(False) # Turn off tty echo
@@ -407,46 +479,89 @@
             p.expect(['1234'])
             p.expect(['abcd'])
             p.expect(['wxyz'])
-
-
+        
+        
         Not supported on platforms where ``isatty()`` returns False.
-        '''
+
+        Parameters
+        ----------
+        state :
+            
+
+        Returns
+        -------
+
+        """
         return self.ptyproc.setecho(state)
 
     def read_nonblocking(self, size=1, timeout=-1):
-        '''This reads at most size characters from the child application. It
+        """This reads at most size characters from the child application. It
         includes a timeout. If the read does not complete within the timeout
         period then a TIMEOUT exception is raised. If the end of file is read
         then an EOF exception will be raised.  If a logfile is specified, a
         copy is written to that log.
-
+        
         If timeout is None then the read may block indefinitely.
         If timeout is -1 then the self.timeout value is used. If timeout is 0
         then the child is polled and if there is no data immediately ready
         then this will raise a TIMEOUT exception.
-
+        
         The timeout refers only to the amount of time to read at least one
         character. This is not affected by the 'size' parameter, so if you call
         read_nonblocking(size=100, timeout=30) and only one character is
         available right away then one character will be returned immediately.
         It will not wait for 30 seconds for another 99 characters to come in.
-
+        
         On the other hand, if there are bytes available to read immediately,
         all those bytes will be read (up to the buffer size). So, if the
         buffer size is 1 megabyte and there is 1 megabyte of data available
         to read, the buffer will be filled, regardless of timeout.
-
+        
         This is a wrapper around os.read(). It uses select.select() or
-        select.poll() to implement the timeout. '''
+        select.poll() to implement the timeout.
+
+        Parameters
+        ----------
+        size :
+             (Default value = 1)
+        timeout :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         if self.closed:
             raise ValueError('I/O operation on closed file.')
 
         if self.use_poll:
             def select(timeout):
+                """
+
+                Parameters
+                ----------
+                timeout :
+                    
+
+                Returns
+                -------
+
+                """
                 return poll_ignore_interrupts([self.child_fd], timeout)
         else:
             def select(timeout):
+                """
+
+                Parameters
+                ----------
+                timeout :
+                    
+
+                Returns
+                -------
+
+                """
                 return select_ignore_interrupts([self.child_fd], [], [], timeout)[0]
 
         # If there is data available to read right now, read as much as
@@ -510,54 +625,81 @@
             raise TIMEOUT('Timeout exceeded.')
 
     def write(self, s):
-        '''This is similar to send() except that there is no return value.
-        '''
+        """This is similar to send() except that there is no return value.
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
 
         self.send(s)
 
     def writelines(self, sequence):
-        '''This calls write() for each element in the sequence. The sequence
+        """This calls write() for each element in the sequence. The sequence
         can be any iterable object producing strings, typically a list of
         strings. This does not add line separators. There is no return value.
-        '''
+
+        Parameters
+        ----------
+        sequence :
+            
+
+        Returns
+        -------
+
+        """
 
         for s in sequence:
             self.write(s)
 
     def send(self, s):
-        '''Sends string ``s`` to the child process, returning the number of
+        """Sends string ``s`` to the child process, returning the number of
         bytes written. If a logfile is specified, a copy is written to that
         log.
-
+        
         The default terminal input mode is canonical processing unless set
         otherwise by the child process. This allows backspace and other line
         processing to be performed prior to transmitting to the receiving
         program. As this is buffered, there is a limited size of such buffer.
-
+        
         On Linux systems, this is 4096 (defined by N_TTY_BUF_SIZE). All
         other systems honor the POSIX.1 definition PC_MAX_CANON -- 1024
         on OSX, 256 on OpenSolaris, and 1920 on FreeBSD.
-
+        
         This value may be discovered using fpathconf(3)::
-
-            >>> from os import fpathconf
-            >>> print(fpathconf(0, 'PC_MAX_CANON'))
-            256
-
+        
+        
         On such a system, only 256 bytes may be received per line. Any
         subsequent bytes received will be discarded. BEL (``'\a'``) is then
         sent to output if IMAXBEL (termios.h) is set by the tty driver.
         This is usually enabled by default.  Linux does not honor this as
         an option -- it behaves as though it is always set on.
-
+        
         Canonical input processing may be disabled altogether by executing
         a shell, then stty(1), before executing the final program::
 
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        >>> from os import fpathconf
+            >>> print(fpathconf(0, 'PC_MAX_CANON'))
+            256
+        
             >>> bash = pexpect.spawn('/bin/bash', echo=False)
             >>> bash.sendline('stty -icanon')
             >>> bash.sendline('base64')
             >>> bash.sendline('x' * 5000)
-        '''
+        """
 
         if self.delaybeforesend is not None:
             time.sleep(self.delaybeforesend)
@@ -569,71 +711,136 @@
         return os.write(self.child_fd, b)
 
     def sendline(self, s=''):
-        '''Wraps send(), sending string ``s`` to child process, with
+        """Wraps send(), sending string ``s`` to child process, with
         ``os.linesep`` automatically appended. Returns number of bytes
         written.  Only a limited number of bytes may be sent for each
         line in the default terminal mode, see docstring of :meth:`send`.
-        '''
+
+        Parameters
+        ----------
+        s :
+             (Default value = '')
+
+        Returns
+        -------
+
+        """
         s = self._coerce_send_string(s)
         return self.send(s + self.linesep)
 
     def _log_control(self, s):
-        """Write control characters to the appropriate log files"""
+        """Write control characters to the appropriate log files
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         if self.encoding is not None:
             s = s.decode(self.encoding, 'replace')
         self._log(s, 'send')
 
     def sendcontrol(self, char):
-        '''Helper method that wraps send() with mnemonic access for sending control
+        """Helper method that wraps send() with mnemonic access for sending control
         character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
         Ctrl-G (ASCII 7, bell, '\a')::
-
+        
             child.sendcontrol('g')
-
+        
         See also, sendintr() and sendeof().
-        '''
+
+        Parameters
+        ----------
+        char :
+            
+
+        Returns
+        -------
+
+        """
         n, byte = self.ptyproc.sendcontrol(char)
         self._log_control(byte)
         return n
 
     def sendeof(self):
-        '''This sends an EOF to the child. This sends a character which causes
+        """This sends an EOF to the child. This sends a character which causes
         the pending parent output buffer to be sent to the waiting child
         program without waiting for end-of-line. If it is the first character
         of the line, the read() in the user program returns 0, which signifies
         end-of-file. This means to work as expected a sendeof() has to be
         called at the beginning of a line. This method does not send a newline.
         It is the responsibility of the caller to ensure the eof is sent at the
-        beginning of a line. '''
+        beginning of a line.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         n, byte = self.ptyproc.sendeof()
         self._log_control(byte)
 
     def sendintr(self):
-        '''This sends a SIGINT to the child. It does not require
-        the SIGINT to be the first character on a line. '''
+        """This sends a SIGINT to the child. It does not require
+        the SIGINT to be the first character on a line.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         n, byte = self.ptyproc.sendintr()
         self._log_control(byte)
 
     @property
     def flag_eof(self):
+        """ """
         return self.ptyproc.flag_eof
 
     @flag_eof.setter
     def flag_eof(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         self.ptyproc.flag_eof = value
 
     def eof(self):
-        '''This returns True if the EOF exception was ever raised.
-        '''
+        """This returns True if the EOF exception was ever raised."""
         return self.flag_eof
 
     def terminate(self, force=False):
-        '''This forces a child process to terminate. It starts nicely with
+        """This forces a child process to terminate. It starts nicely with
         SIGHUP and SIGINT. If "force" is True then moves onto SIGKILL. This
         returns True if the child was terminated. This returns False if the
-        child could not be terminated. '''
+        child could not be terminated.
+
+        Parameters
+        ----------
+        force :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
 
         if not self.isalive():
             return True
@@ -670,16 +877,23 @@
                 return False
 
     def wait(self):
-        '''This waits until the child exits. This is a blocking call. This will
+        """This waits until the child exits. This is a blocking call. This will
         not read any data from the child, so this will block forever if the
         child has unread output and has terminated. In other words, the child
         may have printed output then called exit(), but, the child is
         technically still alive until its output is read by the parent.
-
+        
         This method is non-blocking if :meth:`wait` has already been called
         previously or :meth:`isalive` method returns False.  It simply returns
         the previously determined exit status.
-        '''
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         ptyproc = self.ptyproc
         with _wrap_ptyprocess_err():
@@ -694,11 +908,19 @@
         return exitstatus
 
     def isalive(self):
-        '''This tests if the child process is running or not. This is
+        """This tests if the child process is running or not. This is
         non-blocking. If the child was terminated then this will read the
         exitstatus or signalstatus of the child. This returns True if the child
         process appears to be running or False if not. It can take literally
-        SECONDS for Solaris to return the right status. '''
+        SECONDS for Solaris to return the right status.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         ptyproc = self.ptyproc
         with _wrap_ptyprocess_err():
@@ -714,32 +936,62 @@
 
     def kill(self, sig):
 
-        '''This sends the given signal to the child application. In keeping
+        """This sends the given signal to the child application. In keeping
         with UNIX tradition it has a misleading name. It does not necessarily
-        kill the child unless you send the right signal. '''
+        kill the child unless you send the right signal.
+
+        Parameters
+        ----------
+        sig :
+            
+
+        Returns
+        -------
+
+        """
 
         # Same as os.kill, but the pid is given for you.
         if self.isalive():
             os.kill(self.pid, sig)
 
     def getwinsize(self):
-        '''This returns the terminal window size of the child tty. The return
-        value is a tuple of (rows, cols). '''
+        """This returns the terminal window size of the child tty. The return
+        value is a tuple of (rows, cols).
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         return self.ptyproc.getwinsize()
 
     def setwinsize(self, rows, cols):
-        '''This sets the terminal window size of the child tty. This will cause
+        """This sets the terminal window size of the child tty. This will cause
         a SIGWINCH signal to be sent to the child. This does not change the
         physical window size. It changes the size reported to TTY-aware
         applications like vi or curses -- applications that respond to the
-        SIGWINCH signal. '''
+        SIGWINCH signal.
+
+        Parameters
+        ----------
+        rows :
+            
+        cols :
+            
+
+        Returns
+        -------
+
+        """
         return self.ptyproc.setwinsize(rows, cols)
 
 
     def interact(self, escape_character=chr(29),
             input_filter=None, output_filter=None):
 
-        '''This gives control of the child process to the interactive user (the
+        """This gives control of the child process to the interactive user (the
         human at the keyboard). Keystrokes are sent to the child process, and
         the stdout and stderr output of the child process is printed. This
         simply echos the child stdout and child stderr to the real stdout and
@@ -748,25 +1000,25 @@
         will not be transmitted.  The default for escape_character is
         entered as ``Ctrl - ]``, the very same as BSD telnet. To prevent
         escaping, escape_character may be set to None.
-
+        
         If a logfile is specified, then the data sent and received from the
         child process in interact mode is duplicated to the given log.
-
+        
         You may pass in optional input and output filter functions. These
         functions should take bytes array and return bytes array too. Even
         with ``encoding='utf-8'`` support, meth:`interact` will always pass
         input_filter and output_filter bytes. You may need to wrap your
         function to decode and encode back to UTF-8.
-
+        
         The output_filter will be passed all the output from the child process.
         The input_filter will be passed all the keyboard input from the user.
         The input_filter is run BEFORE the check for the escape_character.
-
+        
         Note that if you change the window size of the parent the SIGWINCH
         signal will not be passed through to the child. If you want the child
         window size to change when the parent's window size changes then do
         something like the following example::
-
+        
             import pexpect, struct, fcntl, termios, signal, sys
             def sigwinch_passthrough (sig, data):
                 s = struct.pack("HHHH", 0, 0, 0, 0)
@@ -774,12 +1026,25 @@
                     termios.TIOCGWINSZ , s))
                 if not p.closed:
                     p.setwinsize(a[0],a[1])
-
+        
             # Note this 'p' is global and used in sigwinch_passthrough.
             p = pexpect.spawn('/bin/bash')
             signal.signal(signal.SIGWINCH, sigwinch_passthrough)
             p.interact()
-        '''
+
+        Parameters
+        ----------
+        escape_character :
+             (Default value = chr(29))
+        input_filter :
+             (Default value = None)
+        output_filter :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         # Flush the buffer.
         self.write_to_stdout(self.buffer)
@@ -855,6 +1120,18 @@
 
 
 def spawnu(*args, **kwargs):
-    """Deprecated: pass encoding to spawn() instead."""
+    """Deprecated: pass encoding to spawn() instead.
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     kwargs.setdefault('encoding', 'utf-8')
     return spawn(*args, **kwargs)
