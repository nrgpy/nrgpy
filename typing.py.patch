# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/typing.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/typing.py
@@ -37,10 +37,13 @@
 
 
 class TypingModuleName(NameWrapper):
+    """ """
     def infer(self):
+        """ """
         return ValueSet(self._remap())
 
     def _remap(self):
+        """ """
         name = self.string_name
         inference_state = self.parent_context.inference_state
         try:
@@ -98,11 +101,14 @@
 
 
 class TypingModuleFilterWrapper(FilterWrapper):
+    """ """
     name_wrapper_class = TypingModuleName
 
 
 class ProxyWithGenerics(BaseTypingClassWithGenerics):
+    """ """
     def execute_annotation(self):
+        """ """
         string_name = self._tree_name.value
 
         if string_name == 'Union':
@@ -136,9 +142,21 @@
         )])
 
     def gather_annotation_classes(self):
+        """ """
         return ValueSet.from_sets(self._generics_manager.to_tuple())
 
     def _create_instance_with_generics(self, generics_manager):
+        """
+
+        Parameters
+        ----------
+        generics_manager :
+            
+
+        Returns
+        -------
+
+        """
         return ProxyWithGenerics(
             self.parent_context,
             self._tree_name,
@@ -146,6 +164,17 @@
         )
 
     def infer_type_vars(self, value_set):
+        """
+
+        Parameters
+        ----------
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         annotation_generics = self.get_generics()
 
         if not annotation_generics:
@@ -165,9 +194,21 @@
 
 
 class ProxyTypingValue(BaseTypingValue):
+    """ """
     index_class = ProxyWithGenerics
 
     def with_generics(self, generics_tuple):
+        """
+
+        Parameters
+        ----------
+        generics_tuple :
+            
+
+        Returns
+        -------
+
+        """
         return self.index_class.create_cached(
             self.inference_state,
             self.parent_context,
@@ -176,6 +217,19 @@
         )
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet(
             self.index_class.create_cached(
                 self.inference_state,
@@ -190,21 +244,37 @@
 
 
 class _TypingClassMixin(ClassMixin):
+    """ """
     def py__bases__(self):
+        """ """
         return [LazyKnownValues(
             self.inference_state.builtins_module.py__getattribute__('object')
         )]
 
     def get_metaclasses(self):
+        """ """
         return []
 
     @property
     def name(self):
+        """ """
         return ValueName(self, self._tree_name)
 
 
 class TypingClassWithGenerics(ProxyWithGenerics, _TypingClassMixin):
+    """ """
     def infer_type_vars(self, value_set):
+        """
+
+        Parameters
+        ----------
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         type_var_dict = {}
         annotation_generics = self.get_generics()
 
@@ -233,6 +303,17 @@
         return type_var_dict
 
     def _create_instance_with_generics(self, generics_manager):
+        """
+
+        Parameters
+        ----------
+        generics_manager :
+            
+
+        Returns
+        -------
+
+        """
         return TypingClassWithGenerics(
             self.parent_context,
             self._tree_name,
@@ -241,10 +322,12 @@
 
 
 class ProxyTypingClassValue(ProxyTypingValue, _TypingClassMixin):
+    """ """
     index_class = TypingClassWithGenerics
 
 
 class TypeAlias(LazyValueWrapper):
+    """ """
     def __init__(self, parent_context, origin_tree_name, actual):
         self.inference_state = parent_context.inference_state
         self.parent_context = parent_context
@@ -253,15 +336,18 @@
 
     @property
     def name(self):
+        """ """
         return ValueName(self, self._origin_tree_name)
 
     def py__name__(self):
+        """ """
         return self.name.string_name
 
     def __repr__(self):
         return '<%s: %s>' % (self.__class__.__name__, self._actual)
 
     def _get_wrapped_value(self):
+        """ """
         module_name, class_name = self._actual.split('.')
         if self.inference_state.environment.version_info.major == 2 and module_name == 'builtins':
             module_name = '__builtin__'
@@ -278,13 +364,23 @@
         return cls
 
     def gather_annotation_classes(self):
+        """ """
         return ValueSet([self._get_wrapped_value()])
 
 
 class Callable(BaseTypingInstance):
+    """ """
     def py__call__(self, arguments):
-        """
-            def x() -> Callable[[Callable[..., _T]], _T]: ...
+        """def x() -> Callable[[Callable[..., _T]], _T]: ...
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
         """
         # The 0th index are the arguments.
         try:
@@ -299,12 +395,25 @@
 
 
 class Tuple(BaseTypingInstance):
+    """ """
     def _is_homogenous(self):
+        """ """
         # To specify a variable-length tuple of homogeneous type, Tuple[T, ...]
         # is used.
         return self._generics_manager.is_homogenous_tuple()
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if self._is_homogenous():
             return self._generics_manager.get_index_and_execute(0)
         else:
@@ -315,6 +424,17 @@
             return NO_VALUES
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if self._is_homogenous():
             yield LazyKnownValues(self._generics_manager.get_index_and_execute(0))
         else:
@@ -322,6 +442,19 @@
                 yield LazyKnownValues(v.execute_annotation())
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         if self._is_homogenous():
             return self._generics_manager.get_index_and_execute(0)
 
@@ -330,15 +463,28 @@
         ).execute_annotation()
 
     def _get_wrapped_value(self):
+        """ """
         tuple_, = self.inference_state.builtins_module \
             .py__getattribute__('tuple').execute_annotation()
         return tuple_
 
     @property
     def name(self):
+        """ """
         return self._wrapped_value.name
 
     def infer_type_vars(self, value_set):
+        """
+
+        Parameters
+        ----------
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         # Circular
         from jedi.inference.gradual.annotation import merge_pairwise_generics, merge_type_var_dicts
 
@@ -380,28 +526,56 @@
 
 
 class Generic(BaseTypingInstance):
+    """ """
     pass
 
 
 class Protocol(BaseTypingInstance):
+    """ """
     pass
 
 
 class AnyClass(BaseTypingValue):
+    """ """
     def execute_annotation(self):
+        """ """
         debug.warning('Used Any - returned no results')
         return NO_VALUES
 
 
 class OverloadFunction(BaseTypingValue):
+    """ """
     @repack_with_argument_clinic('func, /')
     def py__call__(self, func_value_set):
+        """
+
+        Parameters
+        ----------
+        func_value_set :
+            
+
+        Returns
+        -------
+
+        """
         # Just pass arguments through.
         return func_value_set
 
 
 class NewTypeFunction(BaseTypingValue):
+    """ """
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         ordered_args = arguments.unpack()
         next(ordered_args, (None, None))
         _, second_arg = next(ordered_args, (None, None))
@@ -417,34 +591,68 @@
 
 
 class NewType(Value):
+    """ """
     def __init__(self, inference_state, parent_context, tree_node, type_value_set):
         super(NewType, self).__init__(inference_state, parent_context)
         self._type_value_set = type_value_set
         self.tree_node = tree_node
 
     def py__class__(self):
+        """ """
         c, = self._type_value_set.py__class__()
         return c
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return self._type_value_set.execute_annotation()
 
     @property
     def name(self):
+        """ """
         from jedi.inference.compiled.value import CompiledValueName
         return CompiledValueName(self, 'NewType')
 
 
 class CastFunction(BaseTypingValue):
+    """ """
     @repack_with_argument_clinic('type, object, /')
     def py__call__(self, type_value_set, object_value_set):
+        """
+
+        Parameters
+        ----------
+        type_value_set :
+            
+        object_value_set :
+            
+
+        Returns
+        -------
+
+        """
         return type_value_set.execute_annotation()
 
 
 class TypedDictClass(BaseTypingValue):
-    """
-    This class has no responsibilities and is just here to make sure that typed
+    """This class has no responsibilities and is just here to make sure that typed
     dicts can be identified.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
 
@@ -458,9 +666,21 @@
 
     @property
     def name(self):
+        """ """
         return ValueName(self, self.tree_node.name)
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(index, unicode):
             return ValueSet.from_sets(
                 name.infer()
@@ -470,6 +690,7 @@
         return NO_VALUES
 
     def get_key_values(self):
+        """ """
         filtered_values = itertools.chain.from_iterable((
             f.values()
             for f in self._definition_class.get_filters(is_instance=True)
@@ -480,6 +701,7 @@
         })
 
     def _get_wrapped_value(self):
+        """ """
         d, = self.inference_state.builtins_module.py__getattribute__('dict')
         result, = d.execute_with_values()
         return result
