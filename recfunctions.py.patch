# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/recfunctions.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/recfunctions.py
@@ -30,13 +30,25 @@
 
 
 def _recursive_fill_fields_dispatcher(input, output):
+    """
+
+    Parameters
+    ----------
+    input :
+        
+    output :
+        
+
+    Returns
+    -------
+
+    """
     return (input, output)
 
 
 @array_function_dispatch(_recursive_fill_fields_dispatcher)
 def recursive_fill_fields(input, output):
-    """
-    Fills fields from output with fields from input,
+    """Fills fields from output with fields from input,
     with support for nested structures.
 
     Parameters
@@ -46,10 +58,12 @@
     output : ndarray
         Output array.
 
+    Returns
+    -------
+
     Notes
     -----
     * `output` should be at least the same size as `input`
-
     Examples
     --------
     >>> from numpy.lib import recfunctions as rfn
@@ -57,7 +71,6 @@
     >>> b = np.zeros((3,), dtype=a.dtype)
     >>> rfn.recursive_fill_fields(a, b)
     array([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A', '<i8'), ('B', '<f8')])
-
     """
     newdtype = output.dtype
     for field in newdtype.names:
@@ -73,14 +86,21 @@
 
 
 def _get_fieldspec(dtype):
-    """
-    Produce a list of name/dtype pairs corresponding to the dtype fields
-
+    """Produce a list of name/dtype pairs corresponding to the dtype fields
+    
     Similar to dtype.descr, but the second item of each tuple is a dtype, not a
     string. As a result, this handles subarray dtypes
-
+    
     Can be passed to the dtype constructor to reconstruct the dtype, noting that
     this (deliberately) discards field offsets.
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
 
     Examples
     --------
@@ -89,7 +109,6 @@
     [(('a', 'A'), '<i8'), ('b', '<f8', (3,))]
     >>> _get_fieldspec(dt)
     [(('a', 'A'), dtype('int64')), ('b', dtype(('<f8', (3,))))]
-
     """
     if dtype.names is None:
         # .descr returns a nameless field, so we should too
@@ -104,13 +123,15 @@
 
 
 def get_names(adtype):
-    """
-    Returns the field names of the input datatype as a tuple.
+    """Returns the field names of the input datatype as a tuple.
 
     Parameters
     ----------
     adtype : dtype
         Input datatype
+
+    Returns
+    -------
 
     Examples
     --------
@@ -119,7 +140,7 @@
     Traceback (most recent call last):
         ...
     AttributeError: 'numpy.ndarray' object has no attribute 'names'
-
+    
     >>> rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)]))
     Traceback (most recent call last):
         ...
@@ -140,14 +161,16 @@
 
 
 def get_names_flat(adtype):
-    """
-    Returns the field names of the input datatype as a tuple. Nested structure
+    """Returns the field names of the input datatype as a tuple. Nested structure
     are flattened beforehand.
 
     Parameters
     ----------
     adtype : dtype
         Input datatype
+
+    Returns
+    -------
 
     Examples
     --------
@@ -175,8 +198,15 @@
 
 
 def flatten_descr(ndtype):
-    """
-    Flatten a structured data-type description.
+    """Flatten a structured data-type description.
+
+    Parameters
+    ----------
+    ndtype :
+        
+
+    Returns
+    -------
 
     Examples
     --------
@@ -184,7 +214,6 @@
     >>> ndtype = np.dtype([('a', '<i4'), ('b', [('ba', '<f8'), ('bb', '<i4')])])
     >>> rfn.flatten_descr(ndtype)
     (('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))
-
     """
     names = ndtype.names
     if names is None:
@@ -201,6 +230,19 @@
 
 
 def _zip_dtype(seqarrays, flatten=False):
+    """
+
+    Parameters
+    ----------
+    seqarrays :
+        
+    flatten :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     newdtype = []
     if flatten:
         for a in seqarrays:
@@ -217,23 +259,26 @@
 
 
 def _zip_descr(seqarrays, flatten=False):
-    """
-    Combine the dtype description of a series of arrays.
-
-    Parameters
-    ----------
-    seqarrays : sequence of arrays
-        Sequence of arrays
-    flatten : {boolean}, optional
-        Whether to collapse nested descriptions.
+    """Combine the dtype description of a series of arrays.
+
+    Parameters
+    ----------
+    seqarrays :
+        
+    flatten :
+         (Default value = False)
+
+    Returns
+    -------
+
+    
     """
     return _zip_dtype(seqarrays, flatten=flatten).descr
 
 
 def get_fieldstructure(adtype, lastname=None, parents=None,):
-    """
-    Returns a dictionary with fields indexing lists of their parent fields.
-
+    """Returns a dictionary with fields indexing lists of their parent fields.
+    
     This function is used to simplify access to fields nested in other fields.
 
     Parameters
@@ -241,9 +286,12 @@
     adtype : np.dtype
         Input datatype
     lastname : optional
-        Last processed field name (used internally during recursion).
+        Last processed field name (used internally during recursion). (Default value = None)
     parents : dictionary
-        Dictionary of parent fields (used interbally during recursion).
+        Dictionary of parent fields (used interbally during recursion). (Default value = None)
+
+    Returns
+    -------
 
     Examples
     --------
@@ -254,7 +302,6 @@
     >>> rfn.get_fieldstructure(ndtype)
     ... # XXX: possible regression, order of BBA and BBB is swapped
     {'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}
-
     """
     if parents is None:
         parents = {}
@@ -278,9 +325,16 @@
 
 
 def _izip_fields_flat(iterable):
-    """
-    Returns an iterator of concatenated fields from a sequence of arrays,
+    """Returns an iterator of concatenated fields from a sequence of arrays,
     collapsing any nested structure.
+
+    Parameters
+    ----------
+    iterable :
+        
+
+    Returns
+    -------
 
     """
     for element in iterable:
@@ -291,8 +345,15 @@
 
 
 def _izip_fields(iterable):
-    """
-    Returns an iterator of concatenated fields from a sequence of arrays.
+    """Returns an iterator of concatenated fields from a sequence of arrays.
+
+    Parameters
+    ----------
+    iterable :
+        
+
+    Returns
+    -------
 
     """
     for element in iterable:
@@ -307,17 +368,21 @@
 
 
 def _izip_records(seqarrays, fill_value=None, flatten=True):
-    """
-    Returns an iterator of concatenated items from a sequence of arrays.
-
-    Parameters
-    ----------
-    seqarrays : sequence of arrays
-        Sequence of arrays.
-    fill_value : {None, integer}
-        Value used to pad shorter iterables.
-    flatten : {True, False},
-        Whether to
+    """Returns an iterator of concatenated items from a sequence of arrays.
+
+    Parameters
+    ----------
+    seqarrays :
+        
+    fill_value :
+         (Default value = None)
+    flatten :
+         (Default value = True)
+
+    Returns
+    -------
+
+    
     """
 
     # Should we flatten the items, or just use a nested approach
@@ -331,9 +396,21 @@
 
 
 def _fix_output(output, usemask=True, asrecarray=False):
-    """
-    Private function: return a recarray, a ndarray, a MaskedArray
+    """Private function: return a recarray, a ndarray, a MaskedArray
     or a MaskedRecords depending on the input parameters
+
+    Parameters
+    ----------
+    output :
+        
+    usemask :
+         (Default value = True)
+    asrecarray :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     if not isinstance(output, MaskedArray):
         usemask = False
@@ -348,9 +425,19 @@
 
 
 def _fix_defaults(output, defaults=None):
-    """
-    Update the fill_value and masked data of `output`
+    """Update the fill_value and masked data of `output`
     from the default given in a dictionary defaults.
+
+    Parameters
+    ----------
+    output :
+        
+    defaults :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     names = output.dtype.names
     (data, mask, fill_value) = (output.data, output.mask, output.fill_value)
@@ -363,35 +450,68 @@
 
 def _merge_arrays_dispatcher(seqarrays, fill_value=None, flatten=None,
                              usemask=None, asrecarray=None):
+    """
+
+    Parameters
+    ----------
+    seqarrays :
+        
+    fill_value :
+         (Default value = None)
+    flatten :
+         (Default value = None)
+    usemask :
+         (Default value = None)
+    asrecarray :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return seqarrays
 
 
 @array_function_dispatch(_merge_arrays_dispatcher)
 def merge_arrays(seqarrays, fill_value=-1, flatten=False,
                  usemask=False, asrecarray=False):
-    """
-    Merge arrays field by field.
+    """Merge arrays field by field.
 
     Parameters
     ----------
     seqarrays : sequence of ndarrays
         Sequence of arrays
     fill_value : {float}, optional
-        Filling value used to pad missing data on the shorter arrays.
+        Filling value used to pad missing data on the shorter arrays. (Default value = -1)
     flatten : {False, True}, optional
-        Whether to collapse nested fields.
+        Whether to collapse nested fields. (Default value = False)
     usemask : {False, True}, optional
-        Whether to return a masked array or not.
+        Whether to return a masked array or not. (Default value = False)
     asrecarray : {False, True}, optional
-        Whether to return a recarray (MaskedRecords) or not.
+        Whether to return a recarray (MaskedRecords) or not. (Default value = False)
+
+    Returns
+    -------
 
     Examples
     --------
+    
+    Notes
+    -----
+    * Without a mask, the missing value will be filled with something,
+      depending on what its corresponding type:
+    
+      * ``-1``      for integers
+      * ``-1.0``    for floating point numbers
+      * ``'-'``     for characters
+      * ``'-1'``    for strings
+      * ``True``    for boolean values
+    * XXX: I just obtained these values empirically
     >>> from numpy.lib import recfunctions as rfn
     >>> rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))
     array([( 1, 10.), ( 2, 20.), (-1, 30.)],
           dtype=[('f0', '<i8'), ('f1', '<f8')])
-
+    
     >>> rfn.merge_arrays((np.array([1, 2], dtype=np.int64),
     ...         np.array([10., 20., 30.])), usemask=False)
      array([(1, 10.0), (2, 20.0), (-1, 30.0)],
@@ -401,18 +521,6 @@
     ...              usemask=False, asrecarray=True)
     rec.array([( 1, 10.), ( 2, 20.), (-1, 30.)],
               dtype=[('a', '<i8'), ('f1', '<f8')])
-
-    Notes
-    -----
-    * Without a mask, the missing value will be filled with something,
-      depending on what its corresponding type:
-
-      * ``-1``      for integers
-      * ``-1.0``    for floating point numbers
-      * ``'-'``     for characters
-      * ``'-1'``    for strings
-      * ``True``    for boolean values
-    * XXX: I just obtained these values empirically
     """
     # Only one item in the input sequence ?
     if (len(seqarrays) == 1):
@@ -503,16 +611,32 @@
 
 
 def _drop_fields_dispatcher(base, drop_names, usemask=None, asrecarray=None):
+    """
+
+    Parameters
+    ----------
+    base :
+        
+    drop_names :
+        
+    usemask :
+         (Default value = None)
+    asrecarray :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (base,)
 
 
 @array_function_dispatch(_drop_fields_dispatcher)
 def drop_fields(base, drop_names, usemask=True, asrecarray=False):
-    """
-    Return a new array with fields in `drop_names` dropped.
-
+    """Return a new array with fields in `drop_names` dropped.
+    
     Nested fields are supported.
-
+    
     ..versionchanged: 1.18.0
         `drop_fields` returns an array with 0 fields if all fields are dropped,
         rather than returning ``None`` as it did previously.
@@ -525,11 +649,14 @@
         String or sequence of strings corresponding to the names of the
         fields to drop.
     usemask : {False, True}, optional
-        Whether to return a masked array or not.
+        Whether to return a masked array or not. (Default value = True)
     asrecarray : string or sequence, optional
         Whether to return a recarray or a mrecarray (`asrecarray=True`) or
         a plain ndarray or masked array with flexible dtype. The default
         is False.
+
+    Returns
+    -------
 
     Examples
     --------
@@ -550,6 +677,19 @@
         drop_names = set(drop_names)
 
     def _drop_descr(ndtype, drop_names):
+        """
+
+        Parameters
+        ----------
+        ndtype :
+            
+        drop_names :
+            
+
+        Returns
+        -------
+
+        """
         names = ndtype.names
         newdtype = []
         for name in names:
@@ -572,23 +712,24 @@
 
 
 def _keep_fields(base, keep_names, usemask=True, asrecarray=False):
-    """
-    Return a new array keeping only the fields in `keep_names`,
+    """Return a new array keeping only the fields in `keep_names`,
     and preserving the order of those fields.
 
     Parameters
     ----------
-    base : array
-        Input array
-    keep_names : string or sequence
-        String or sequence of strings corresponding to the names of the
-        fields to keep. Order of the names will be preserved.
-    usemask : {False, True}, optional
-        Whether to return a masked array or not.
-    asrecarray : string or sequence, optional
-        Whether to return a recarray or a mrecarray (`asrecarray=True`) or
-        a plain ndarray or masked array with flexible dtype. The default
-        is False.
+    base :
+        
+    keep_names :
+        
+    usemask :
+         (Default value = True)
+    asrecarray :
+         (Default value = False)
+
+    Returns
+    -------
+
+    
     """
     newdtype = [(n, base.dtype[n]) for n in keep_names]
     output = np.empty(base.shape, dtype=newdtype)
@@ -597,26 +738,61 @@
 
 
 def _rec_drop_fields_dispatcher(base, drop_names):
+    """
+
+    Parameters
+    ----------
+    base :
+        
+    drop_names :
+        
+
+    Returns
+    -------
+
+    """
     return (base,)
 
 
 @array_function_dispatch(_rec_drop_fields_dispatcher)
 def rec_drop_fields(base, drop_names):
-    """
-    Returns a new numpy.recarray with fields in `drop_names` dropped.
+    """Returns a new numpy.recarray with fields in `drop_names` dropped.
+
+    Parameters
+    ----------
+    base :
+        
+    drop_names :
+        
+
+    Returns
+    -------
+
     """
     return drop_fields(base, drop_names, usemask=False, asrecarray=True)
 
 
 def _rename_fields_dispatcher(base, namemapper):
+    """
+
+    Parameters
+    ----------
+    base :
+        
+    namemapper :
+        
+
+    Returns
+    -------
+
+    """
     return (base,)
 
 
 @array_function_dispatch(_rename_fields_dispatcher)
 def rename_fields(base, namemapper):
-    """
-    Rename the fields from a flexible-datatype ndarray or recarray.
-
+    """Rename the fields from a flexible-datatype ndarray or recarray.
+    
     Nested fields are supported.
 
     Parameters
@@ -625,6 +801,9 @@
         Input array whose fields must be modified.
     namemapper : dictionary
         Dictionary mapping old field names to their new version.
+
+    Returns
+    -------
 
     Examples
     --------
@@ -634,9 +813,21 @@
     >>> rfn.rename_fields(a, {'a':'A', 'bb':'BB'})
     array([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))],
           dtype=[('A', '<i8'), ('b', [('ba', '<f8'), ('BB', '<f8', (2,))])])
-
     """
     def _recursive_rename_fields(ndtype, namemapper):
+        """
+
+        Parameters
+        ----------
+        ndtype :
+            
+        namemapper :
+            
+
+        Returns
+        -------
+
+        """
         newdtype = []
         for name in ndtype.names:
             newname = namemapper.get(name, name)
@@ -654,6 +845,29 @@
 
 def _append_fields_dispatcher(base, names, data, dtypes=None,
                               fill_value=None, usemask=None, asrecarray=None):
+    """
+
+    Parameters
+    ----------
+    base :
+        
+    names :
+        
+    data :
+        
+    dtypes :
+         (Default value = None)
+    fill_value :
+         (Default value = None)
+    usemask :
+         (Default value = None)
+    asrecarray :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     yield base
     yield from data
 
@@ -661,9 +875,8 @@
 @array_function_dispatch(_append_fields_dispatcher)
 def append_fields(base, names, data, dtypes=None,
                   fill_value=-1, usemask=True, asrecarray=False):
-    """
-    Add new fields to an existing array.
-
+    """Add new fields to an existing array.
+    
     The names of the fields are given with the `names` arguments,
     the corresponding values with the `data` arguments.
     If a single field is appended, `names`, `data` and `dtypes` do not have
@@ -671,23 +884,25 @@
 
     Parameters
     ----------
-    base : array
-        Input array to extend.
-    names : string, sequence
-        String or sequence of strings corresponding to the names
-        of the new fields.
-    data : array or sequence of arrays
-        Array or sequence of arrays storing the fields to add to the base.
-    dtypes : sequence of datatypes, optional
-        Datatype or sequence of datatypes.
-        If None, the datatypes are estimated from the `data`.
-    fill_value : {float}, optional
-        Filling value used to pad missing data on the shorter arrays.
-    usemask : {False, True}, optional
-        Whether to return a masked array or not.
-    asrecarray : {False, True}, optional
-        Whether to return a recarray (MaskedRecords) or not.
-
+    base :
+        
+    names :
+        
+    data :
+        
+    dtypes :
+         (Default value = None)
+    fill_value :
+         (Default value = -1)
+    usemask :
+         (Default value = True)
+    asrecarray :
+         (Default value = False)
+
+    Returns
+    -------
+
+    
     """
     # Check the names
     if isinstance(names, (tuple, list)):
@@ -730,15 +945,31 @@
 
 
 def _rec_append_fields_dispatcher(base, names, data, dtypes=None):
+    """
+
+    Parameters
+    ----------
+    base :
+        
+    names :
+        
+    data :
+        
+    dtypes :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     yield base
     yield from data
 
 
 @array_function_dispatch(_rec_append_fields_dispatcher)
 def rec_append_fields(base, names, data, dtypes=None):
-    """
-    Add new fields to an existing array.
-
+    """Add new fields to an existing array.
+    
     The names of the fields are given with the `names` arguments,
     the corresponding values with the `data` arguments.
     If a single field is appended, `names`, `data` and `dtypes` do not have
@@ -755,41 +986,54 @@
         Array or sequence of arrays storing the fields to add to the base.
     dtypes : sequence of datatypes, optional
         Datatype or sequence of datatypes.
-        If None, the datatypes are estimated from the `data`.
+        If None, the datatypes are estimated from the `data`. (Default value = None)
+
+    Returns
+    -------
 
     See Also
     --------
     append_fields
-
-    Returns
-    -------
-    appended_array : np.recarray
     """
     return append_fields(base, names, data=data, dtypes=dtypes,
                          asrecarray=True, usemask=False)
 
 
 def _repack_fields_dispatcher(a, align=None, recurse=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    align :
+         (Default value = None)
+    recurse :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_repack_fields_dispatcher)
 def repack_fields(a, align=False, recurse=False):
-    """
-    Re-pack the fields of a structured array or dtype in memory.
-
+    """Re-pack the fields of a structured array or dtype in memory.
+    
     The memory layout of structured datatypes allows fields at arbitrary
     byte offsets. This means the fields can be separated by padding bytes,
     their offsets can be non-monotonically increasing, and they can overlap.
-
+    
     This method removes any overlaps and reorders the fields in memory so they
     have increasing byte offsets, and adds or removes padding bytes depending
     on the `align` option, which behaves like the `align` option to `np.dtype`.
-
+    
     If `align=False`, this method produces a "packed" memory layout in which
     each field starts at the byte the previous field ended, and any padding
     bytes are removed.
-
+    
     If `align=True`, this methods produces an "aligned" memory layout in which
     each field's offset is a multiple of its alignment, and the total itemsize
     is a multiple of the largest alignment, by adding padding bytes as needed.
@@ -797,21 +1041,20 @@
     Parameters
     ----------
     a : ndarray or dtype
-       array or dtype for which to repack the fields.
+        array or dtype for which to repack the fields.
     align : boolean
-       If true, use an "aligned" memory layout, otherwise use a "packed" layout.
+        If true, use an "aligned" memory layout, otherwise use a "packed" layout. (Default value = False)
     recurse : boolean
-       If True, also repack nested structures.
+        If True, also repack nested structures. (Default value = False)
 
     Returns
     -------
     repacked : ndarray or dtype
-       Copy of `a` with fields repacked, or `a` itself if no repacking was
-       needed.
+        Copy of `a` with fields repacked, or `a` itself if no repacking was
+        needed.
 
     Examples
     --------
-
     >>> from numpy.lib import recfunctions as rfn
     >>> def print_offsets(d):
     ...     print("offsets:", [d.fields[name][1] for name in d.names])
@@ -829,7 +1072,6 @@
     >>> print_offsets(packed_dt)
     offsets: [0, 1, 9]
     itemsize: 17
-
     """
     if not isinstance(a, np.dtype):
         dt = repack_fields(a.dtype, align=align, recurse=recurse)
@@ -855,15 +1097,36 @@
     return np.dtype((a.type, dt))
 
 def _get_fields_and_offsets(dt, offset=0):
-    """
-    Returns a flat list of (dtype, count, offset) tuples of all the
+    """Returns a flat list of (dtype, count, offset) tuples of all the
     scalar fields in the dtype "dt", including nested fields, in left
     to right order.
+
+    Parameters
+    ----------
+    dt :
+        
+    offset :
+         (Default value = 0)
+
+    Returns
+    -------
+
     """
 
     # counts up elements in subarrays, including nested subarrays, and returns
     # base dtype and count
     def count_elem(dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         count = 1
         while dt.shape != ():
             for size in dt.shape:
@@ -894,42 +1157,57 @@
 
 def _structured_to_unstructured_dispatcher(arr, dtype=None, copy=None,
                                            casting=None):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    dtype :
+         (Default value = None)
+    copy :
+         (Default value = None)
+    casting :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (arr,)
 
 @array_function_dispatch(_structured_to_unstructured_dispatcher)
 def structured_to_unstructured(arr, dtype=None, copy=False, casting='unsafe'):
-    """
-    Converts and n-D structured array into an (n+1)-D unstructured array.
-
+    """Converts and n-D structured array into an (n+1)-D unstructured array.
+    
     The new array will have a new last dimension equal in size to the
     number of field-elements of the input array. If not supplied, the output
     datatype is determined from the numpy type promotion rules applied to all
     the field datatypes.
-
+    
     Nested fields, as well as each element of any subarray fields, all count
     as a single field-elements.
 
     Parameters
     ----------
     arr : ndarray
-       Structured array or dtype to convert. Cannot contain object datatype.
+        Structured array or dtype to convert. Cannot contain object datatype.
     dtype : dtype, optional
-       The dtype of the output unstructured array.
+        The dtype of the output unstructured array. (Default value = None)
     copy : bool, optional
         See copy argument to `ndarray.astype`. If true, always return a copy.
-        If false, and `dtype` requirements are satisfied, a view is returned.
+        If false, and `dtype` requirements are satisfied, a view is returned. (Default value = False)
     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
         See casting argument of `ndarray.astype`. Controls what kind of data
-        casting may occur.
+        casting may occur. (Default value = 'unsafe')
 
     Returns
     -------
     unstructured : ndarray
-       Unstructured array with one more dimension.
+        Unstructured array with one more dimension.
 
     Examples
     --------
-
     >>> from numpy.lib import recfunctions as rfn
     >>> a = np.zeros(4, dtype=[('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])
     >>> a
@@ -941,12 +1219,11 @@
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]])
-
+    
     >>> b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],
     ...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])
     >>> np.mean(rfn.structured_to_unstructured(b[['x', 'z']]), axis=-1)
     array([ 3. ,  5.5,  9. , 11. ])
-
     """
     if arr.dtype.names is None:
         raise ValueError('arr must be a structured array')
@@ -990,49 +1267,68 @@
 
 def _unstructured_to_structured_dispatcher(arr, dtype=None, names=None,
                                            align=None, copy=None, casting=None):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    dtype :
+         (Default value = None)
+    names :
+         (Default value = None)
+    align :
+         (Default value = None)
+    copy :
+         (Default value = None)
+    casting :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (arr,)
 
 @array_function_dispatch(_unstructured_to_structured_dispatcher)
 def unstructured_to_structured(arr, dtype=None, names=None, align=False,
                                copy=False, casting='unsafe'):
-    """
-    Converts and n-D unstructured array into an (n-1)-D structured array.
-
+    """Converts and n-D unstructured array into an (n-1)-D structured array.
+    
     The last dimension of the input array is converted into a structure, with
     number of field-elements equal to the size of the last dimension of the
     input array. By default all output fields have the input array's dtype, but
     an output structured dtype with an equal number of fields-elements can be
     supplied instead.
-
+    
     Nested fields, as well as each element of any subarray fields, all count
     towards the number of field-elements.
 
     Parameters
     ----------
     arr : ndarray
-       Unstructured array or dtype to convert.
+        Unstructured array or dtype to convert.
     dtype : dtype, optional
-       The structured dtype of the output array
+        The structured dtype of the output array (Default value = None)
     names : list of strings, optional
-       If dtype is not supplied, this specifies the field names for the output
-       dtype, in order. The field dtypes will be the same as the input array.
+        If dtype is not supplied, this specifies the field names for the output
+        dtype, in order. The field dtypes will be the same as the input array. (Default value = None)
     align : boolean, optional
-       Whether to create an aligned memory layout.
+        Whether to create an aligned memory layout. (Default value = False)
     copy : bool, optional
         See copy argument to `ndarray.astype`. If true, always return a copy.
-        If false, and `dtype` requirements are satisfied, a view is returned.
+        If false, and `dtype` requirements are satisfied, a view is returned. (Default value = False)
     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
         See casting argument of `ndarray.astype`. Controls what kind of data
-        casting may occur.
+        casting may occur. (Default value = 'unsafe')
 
     Returns
     -------
     structured : ndarray
-       Structured array with fewer dimensions.
+        Structured array with fewer dimensions.
 
     Examples
     --------
-
     >>> from numpy.lib import recfunctions as rfn
     >>> dt = np.dtype([('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])
     >>> a = np.arange(20).reshape((4,5))
@@ -1045,7 +1341,6 @@
     array([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]),
            (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])],
           dtype=[('a', '<i4'), ('b', [('f0', '<f4'), ('f1', '<u2')]), ('c', '<f4', (2,))])
-
     """
     if arr.shape == ():
         raise ValueError('arr must have at least one dimension')
@@ -1097,13 +1392,25 @@
     return arr.view(out_dtype)[..., 0]
 
 def _apply_along_fields_dispatcher(func, arr):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+    arr :
+        
+
+    Returns
+    -------
+
+    """
     return (arr,)
 
 @array_function_dispatch(_apply_along_fields_dispatcher)
 def apply_along_fields(func, arr):
-    """
-    Apply function 'func' as a reduction across fields of a structured array.
-
+    """Apply function 'func' as a reduction across fields of a structured array.
+    
     This is similar to `apply_along_axis`, but treats the fields of a
     structured array as an extra axis. The fields are all first cast to a
     common type following the type-promotion rules from `numpy.result_type`
@@ -1112,19 +1419,18 @@
     Parameters
     ----------
     func : function
-       Function to apply on the "field" dimension. This function must
-       support an `axis` argument, like np.mean, np.sum, etc.
+        Function to apply on the "field" dimension. This function must
+        support an `axis` argument, like np.mean, np.sum, etc.
     arr : ndarray
-       Structured array for which to apply func.
+        Structured array for which to apply func.
 
     Returns
     -------
     out : ndarray
-       Result of the recution operation
+        Result of the recution operation
 
     Examples
     --------
-
     >>> from numpy.lib import recfunctions as rfn
     >>> b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],
     ...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])
@@ -1132,7 +1438,6 @@
     array([ 2.66666667,  5.33333333,  8.66666667, 11.        ])
     >>> rfn.apply_along_fields(np.mean, b[['x', 'z']])
     array([ 3. ,  5.5,  9. , 11. ])
-
     """
     if arr.dtype.names is None:
         raise ValueError('arr must be a structured array')
@@ -1143,17 +1448,31 @@
     #return np.apply_along_axis(func, -1, uarr)
 
 def _assign_fields_by_name_dispatcher(dst, src, zero_unassigned=None):
+    """
+
+    Parameters
+    ----------
+    dst :
+        
+    src :
+        
+    zero_unassigned :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return dst, src
 
 @array_function_dispatch(_assign_fields_by_name_dispatcher)
 def assign_fields_by_name(dst, src, zero_unassigned=True):
-    """
-    Assigns values from one structured array to another by field name.
-
+    """Assigns values from one structured array to another by field name.
+    
     Normally in numpy >= 1.14, assignment of one structured array to another
     copies fields "by position", meaning that the first field from the src is
     copied to the first field of the dst, and so on, regardless of field name.
-
+    
     This function instead copies "by field name", such that fields in the dst
     are assigned from the identically named field in the src. This applies
     recursively for nested structures. This is how structure assignment worked
@@ -1161,14 +1480,17 @@
 
     Parameters
     ----------
-    dst : ndarray
-    src : ndarray
-        The source and destination arrays during assignment.
-    zero_unassigned : bool, optional
-        If True, fields in the dst for which there was no matching
-        field in the src are filled with the value 0 (zero). This
-        was the behavior of numpy <= 1.13. If False, those fields
-        are not modified.
+    dst :
+        
+    src :
+        
+    zero_unassigned :
+         (Default value = True)
+
+    Returns
+    -------
+
+    
     """
 
     if dst.dtype.names is None:
@@ -1184,27 +1506,41 @@
                                   zero_unassigned)
 
 def _require_fields_dispatcher(array, required_dtype):
+    """
+
+    Parameters
+    ----------
+    array :
+        
+    required_dtype :
+        
+
+    Returns
+    -------
+
+    """
     return (array,)
 
 @array_function_dispatch(_require_fields_dispatcher)
 def require_fields(array, required_dtype):
-    """
-    Casts a structured array to a new dtype using assignment by field-name.
-
+    """Casts a structured array to a new dtype using assignment by field-name.
+    
     This function assigns from the old to the new array by name, so the
     value of a field in the output array is the value of the field with the
     same name in the source array. This has the effect of creating a new
     ndarray containing only the fields "required" by the required_dtype.
-
+    
     If a field name in the required_dtype does not exist in the
     input array, that field is created and set to 0 in the output array.
 
     Parameters
     ----------
     a : ndarray
-       array to cast
+        array to cast
     required_dtype : dtype
-       datatype for output array
+        datatype for output array
+    array :
+        
 
     Returns
     -------
@@ -1214,7 +1550,6 @@
 
     Examples
     --------
-
     >>> from numpy.lib import recfunctions as rfn
     >>> a = np.ones(4, dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'u1')])
     >>> rfn.require_fields(a, [('b', 'f4'), ('c', 'u1')])
@@ -1223,7 +1558,6 @@
     >>> rfn.require_fields(a, [('b', 'f4'), ('newf', 'u1')])
     array([(1., 0), (1., 0), (1., 0), (1., 0)],
       dtype=[('b', '<f4'), ('newf', 'u1')])
-
     """
     out = np.empty(array.shape, dtype=required_dtype)
     assign_fields_by_name(out, array)
@@ -1232,14 +1566,32 @@
 
 def _stack_arrays_dispatcher(arrays, defaults=None, usemask=None,
                              asrecarray=None, autoconvert=None):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    defaults :
+         (Default value = None)
+    usemask :
+         (Default value = None)
+    asrecarray :
+         (Default value = None)
+    autoconvert :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return arrays
 
 
 @array_function_dispatch(_stack_arrays_dispatcher)
 def stack_arrays(arrays, defaults=None, usemask=True, asrecarray=False,
                  autoconvert=False):
-    """
-    Superposes arrays fields by fields
+    """Superposes arrays fields by fields
 
     Parameters
     ----------
@@ -1249,12 +1601,15 @@
         Dictionary mapping field names to the corresponding default values.
     usemask : {True, False}, optional
         Whether to return a MaskedArray (or MaskedRecords is
-        `asrecarray==True`) or a ndarray.
+        `asrecarray==True`) or a ndarray. (Default value = True)
     asrecarray : {False, True}, optional
         Whether to return a recarray (or MaskedRecords if `usemask==True`)
-        or just a flexible-type ndarray.
+        or just a flexible-type ndarray. (Default value = False)
     autoconvert : {False, True}, optional
-        Whether automatically cast the type of the field to the maximum.
+        Whether automatically cast the type of the field to the maximum. (Default value = False)
+
+    Returns
+    -------
 
     Examples
     --------
@@ -1274,7 +1629,6 @@
                        (False, False, False)],
            fill_value=(b'N/A', 1.e+20, 1.e+20),
                 dtype=[('A', 'S3'), ('B', '<f8'), ('C', '<f8')])
-
     """
     if isinstance(arrays, ndarray):
         return arrays
@@ -1325,13 +1679,29 @@
 
 def _find_duplicates_dispatcher(
         a, key=None, ignoremask=None, return_index=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    key :
+         (Default value = None)
+    ignoremask :
+         (Default value = None)
+    return_index :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_find_duplicates_dispatcher)
 def find_duplicates(a, key=None, ignoremask=True, return_index=False):
-    """
-    Find the duplicates in a structured array along a given key
+    """Find the duplicates in a structured array along a given key
 
     Parameters
     ----------
@@ -1339,11 +1709,14 @@
         Input array
     key : {string, None}, optional
         Name of the fields along which to check the duplicates.
-        If None, the search is performed by records
+        If None, the search is performed by records (Default value = None)
     ignoremask : {True, False}, optional
-        Whether masked data should be discarded or considered as duplicates.
+        Whether masked data should be discarded or considered as duplicates. (Default value = True)
     return_index : {False, True}, optional
-        Whether to return the indices of the duplicated values.
+        Whether to return the indices of the duplicated values. (Default value = False)
+
+    Returns
+    -------
 
     Examples
     --------
@@ -1389,15 +1762,41 @@
 def _join_by_dispatcher(
         key, r1, r2, jointype=None, r1postfix=None, r2postfix=None,
         defaults=None, usemask=None, asrecarray=None):
+    """
+
+    Parameters
+    ----------
+    key :
+        
+    r1 :
+        
+    r2 :
+        
+    jointype :
+         (Default value = None)
+    r1postfix :
+         (Default value = None)
+    r2postfix :
+         (Default value = None)
+    defaults :
+         (Default value = None)
+    usemask :
+         (Default value = None)
+    asrecarray :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (r1, r2)
 
 
 @array_function_dispatch(_join_by_dispatcher)
 def join_by(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2',
             defaults=None, usemask=True, asrecarray=False):
-    """
-    Join arrays `r1` and `r2` on key `key`.
-
+    """Join arrays `r1` and `r2` on key `key`.
+    
     The key should be either a string or a sequence of string corresponding
     to the fields used to join the array.  An exception is raised if the
     `key` field cannot be found in the two input arrays.  Neither `r1` nor
@@ -1417,21 +1816,28 @@
         If 'outer', returns the common elements as well as the elements of
         r1 not in r2 and the elements of not in r2.
         If 'leftouter', returns the common elements and the elements of r1
-        not in r2.
+        not in r2. (Default value = 'inner')
     r1postfix : string, optional
         String appended to the names of the fields of r1 that are present
-        in r2 but absent of the key.
+        in r2 but absent of the key. (Default value = '1')
     r2postfix : string, optional
         String appended to the names of the fields of r2 that are present
-        in r1 but absent of the key.
+        in r1 but absent of the key. (Default value = '2')
     defaults : {dictionary}, optional
         Dictionary mapping field names to the corresponding default values.
     usemask : {True, False}, optional
         Whether to return a MaskedArray (or MaskedRecords is
-        `asrecarray==True`) or a ndarray.
+        `asrecarray==True`) or a ndarray. (Default value = True)
     asrecarray : {False, True}, optional
         Whether to return a recarray (or MaskedRecords if `usemask==True`)
-        or just a flexible-type ndarray.
+        or just a flexible-type ndarray. (Default value = False)
+    r1 :
+        
+    r2 :
+        
+
+    Returns
+    -------
 
     Notes
     -----
@@ -1441,7 +1847,6 @@
       sorted, and the common entries selected. The output is constructed by
       filling the fields with the selected entries. Matching is not
       preserved if there are some duplicates...
-
     """
     # Check jointype
     if jointype not in ('inner', 'outer', 'leftouter'):
@@ -1575,15 +1980,57 @@
 def _rec_join_dispatcher(
         key, r1, r2, jointype=None, r1postfix=None, r2postfix=None,
         defaults=None):
+    """
+
+    Parameters
+    ----------
+    key :
+        
+    r1 :
+        
+    r2 :
+        
+    jointype :
+         (Default value = None)
+    r1postfix :
+         (Default value = None)
+    r2postfix :
+         (Default value = None)
+    defaults :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (r1, r2)
 
 
 @array_function_dispatch(_rec_join_dispatcher)
 def rec_join(key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2',
              defaults=None):
-    """
-    Join arrays `r1` and `r2` on keys.
+    """Join arrays `r1` and `r2` on keys.
     Alternative to join_by, that always returns a np.recarray.
+
+    Parameters
+    ----------
+    key :
+        
+    r1 :
+        
+    r2 :
+        
+    jointype :
+         (Default value = 'inner')
+    r1postfix :
+         (Default value = '1')
+    r2postfix :
+         (Default value = '2')
+    defaults :
+         (Default value = None)
+
+    Returns
+    -------
 
     See Also
     --------
