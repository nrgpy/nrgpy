# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pycparser/ply/yacc.py
+++ b/..//venv/lib/python3.8/site-packages/pycparser/ply/yacc.py
@@ -107,24 +107,71 @@
 # it into PLY.
 
 class PlyLogger(object):
+    """ """
     def __init__(self, f):
         self.f = f
 
     def debug(self, msg, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         self.f.write((msg % args) + '\n')
 
     info = debug
 
     def warning(self, msg, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         self.f.write('WARNING: ' + (msg % args) + '\n')
 
     def error(self, msg, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         self.f.write('ERROR: ' + (msg % args) + '\n')
 
     critical = debug
 
 # Null logger is used when no output is generated. Does nothing.
 class NullLogger(object):
+    """ """
     def __getattribute__(self, name):
         return self
 
@@ -133,10 +180,22 @@
 
 # Exception raised for yacc-related errors
 class YaccError(Exception):
+    """ """
     pass
 
 # Format the result message that the parser produces when running in debug mode.
 def format_result(r):
+    """
+
+    Parameters
+    ----------
+    r :
+        
+
+    Returns
+    -------
+
+    """
     repr_str = repr(r)
     if '\n' in repr_str:
         repr_str = repr(repr_str)
@@ -147,6 +206,17 @@
 
 # Format stack entries when the parser is running in debug mode
 def format_stack_entry(r):
+    """
+
+    Parameters
+    ----------
+    r :
+        
+
+    Returns
+    -------
+
+    """
     repr_str = repr(r)
     if '\n' in repr_str:
         repr_str = repr(repr_str)
@@ -165,6 +235,17 @@
 Instead, invoke the methods on the associated parser instance:
 
     def p_error(p):
+        """
+
+        Parameters
+        ----------
+        p :
+            
+
+        Returns
+        -------
+
+        """
         ...
         # Use parser.errok(), parser.token(), parser.restart()
         ...
@@ -173,19 +254,37 @@
 '''
 
 def errok():
+    """ """
     warnings.warn(_warnmsg)
     return _errok()
 
 def restart():
+    """ """
     warnings.warn(_warnmsg)
     return _restart()
 
 def token():
+    """ """
     warnings.warn(_warnmsg)
     return _token()
 
 # Utility function to call the p_error() function with some deprecation hacks
 def call_errorfunc(errorfunc, token, parser):
+    """
+
+    Parameters
+    ----------
+    errorfunc :
+        
+    token :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     global _errok, _token, _restart
     _errok = parser.errok
     _token = parser.token
@@ -215,6 +314,7 @@
 #        .endlexpos  = Ending lex position (optional, set automatically)
 
 class YaccSymbol:
+    """ """
     def __str__(self):
         return self.type
 
@@ -231,6 +331,7 @@
 # representing the range of positional information for a symbol.
 
 class YaccProduction:
+    """ """
     def __init__(self, s, stack=None):
         self.slice = s
         self.stack = stack
@@ -255,25 +356,83 @@
         return len(self.slice)
 
     def lineno(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         return getattr(self.slice[n], 'lineno', 0)
 
     def set_lineno(self, n, lineno):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+        lineno :
+            
+
+        Returns
+        -------
+
+        """
         self.slice[n].lineno = lineno
 
     def linespan(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         startline = getattr(self.slice[n], 'lineno', 0)
         endline = getattr(self.slice[n], 'endlineno', startline)
         return startline, endline
 
     def lexpos(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         return getattr(self.slice[n], 'lexpos', 0)
 
     def lexspan(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         startpos = getattr(self.slice[n], 'lexpos', 0)
         endpos = getattr(self.slice[n], 'endlexpos', startpos)
         return startpos, endpos
 
     def error(self):
+        """ """
         raise SyntaxError
 
 # -----------------------------------------------------------------------------
@@ -283,6 +442,7 @@
 # -----------------------------------------------------------------------------
 
 class LRParser:
+    """ """
     def __init__(self, lrtab, errorf):
         self.productions = lrtab.lr_productions
         self.action = lrtab.lr_action
@@ -292,9 +452,11 @@
         self.errorok = True
 
     def errok(self):
+        """ """
         self.errorok = True
 
     def restart(self):
+        """ """
         del self.statestack[:]
         del self.symstack[:]
         sym = YaccSymbol()
@@ -311,6 +473,7 @@
     #
     # See:  https://www.gnu.org/software/bison/manual/html_node/Default-Reductions.html#Default-Reductions
     def set_defaulted_states(self):
+        """ """
         self.defaulted_states = {}
         for state, actions in self.action.items():
             rules = list(actions.values())
@@ -318,9 +481,29 @@
                 self.defaulted_states[state] = rules[0]
 
     def disable_defaulted_states(self):
+        """ """
         self.defaulted_states = {}
 
     def parse(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
+        """
+
+        Parameters
+        ----------
+        input :
+             (Default value = None)
+        lexer :
+             (Default value = None)
+        debug :
+             (Default value = False)
+        tracking :
+             (Default value = False)
+        tokenfunc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if debug or yaccdevel:
             if isinstance(debug, int):
                 debug = PlyLogger(sys.stderr)
@@ -346,6 +529,25 @@
     # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
     def parsedebug(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
+        """
+
+        Parameters
+        ----------
+        input :
+             (Default value = None)
+        lexer :
+             (Default value = None)
+        debug :
+             (Default value = False)
+        tracking :
+             (Default value = False)
+        tokenfunc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         #--! parsedebug-start
         lookahead = None                         # Current lookahead symbol
         lookaheadstack = []                      # Stack of lookahead symbols
@@ -693,6 +895,25 @@
     # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
     def parseopt(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
+        """
+
+        Parameters
+        ----------
+        input :
+             (Default value = None)
+        lexer :
+             (Default value = None)
+        debug :
+             (Default value = False)
+        tracking :
+             (Default value = False)
+        tokenfunc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         #--! parseopt-start
         lookahead = None                         # Current lookahead symbol
         lookaheadstack = []                      # Stack of lookahead symbols
@@ -999,6 +1220,25 @@
     # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
     def parseopt_notrack(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):
+        """
+
+        Parameters
+        ----------
+        input :
+             (Default value = None)
+        lexer :
+             (Default value = None)
+        debug :
+             (Default value = False)
+        tracking :
+             (Default value = False)
+        tokenfunc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         #--! parseopt-notrack-start
         lookahead = None                         # Current lookahead symbol
         lookaheadstack = []                      # Stack of lookahead symbols
@@ -1307,6 +1547,7 @@
 # -----------------------------------------------------------------------------
 
 class Production(object):
+    """ """
     reduced = 0
     def __init__(self, number, name, prod, precedence=('right', 0), func=None, file='', line=0):
         self.name     = name
@@ -1355,6 +1596,17 @@
 
     # Return the nth lr_item from the production (or None if at the end)
     def lr_item(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         if n > len(self.prod):
             return None
         p = LRItem(self, n)
@@ -1371,6 +1623,17 @@
 
     # Bind the production function name to a callable
     def bind(self, pdict):
+        """
+
+        Parameters
+        ----------
+        pdict :
+            
+
+        Returns
+        -------
+
+        """
         if self.func:
             self.callable = pdict[self.func]
 
@@ -1379,6 +1642,7 @@
 # actually used by the LR parsing engine, plus some additional
 # debugging information.
 class MiniProduction(object):
+    """ """
     def __init__(self, str, name, len, func, file, line):
         self.name     = name
         self.len      = len
@@ -1396,6 +1660,17 @@
 
     # Bind the production function name to a callable
     def bind(self, pdict):
+        """
+
+        Parameters
+        ----------
+        pdict :
+            
+
+        Returns
+        -------
+
+        """
         if self.func:
             self.callable = pdict[self.func]
 
@@ -1425,6 +1700,7 @@
 # -----------------------------------------------------------------------------
 
 class LRItem(object):
+    """ """
     def __init__(self, p, n):
         self.name       = p.name
         self.prod       = list(p.prod)
@@ -1452,6 +1728,19 @@
 # Return the rightmost terminal from a list of symbols.  Used in add_production()
 # -----------------------------------------------------------------------------
 def rightmost_terminal(symbols, terminals):
+    """
+
+    Parameters
+    ----------
+    symbols :
+        
+    terminals :
+        
+
+    Returns
+    -------
+
+    """
     i = len(symbols) - 1
     while i >= 0:
         if symbols[i] in terminals:
@@ -1468,9 +1757,11 @@
 # -----------------------------------------------------------------------------
 
 class GrammarError(YaccError):
+    """ """
     pass
 
 class Grammar(object):
+    """ """
     def __init__(self, terminals):
         self.Productions  = [None]  # A list of all of the productions.  The first
                                     # entry is always reserved for the purpose of
@@ -1522,6 +1813,21 @@
     # -----------------------------------------------------------------------------
 
     def set_precedence(self, term, assoc, level):
+        """
+
+        Parameters
+        ----------
+        term :
+            
+        assoc :
+            
+        level :
+            
+
+        Returns
+        -------
+
+        """
         assert self.Productions == [None], 'Must call set_precedence() before add_production()'
         if term in self.Precedence:
             raise GrammarError('Precedence already specified for terminal %r' % term)
@@ -1547,6 +1853,25 @@
     # -----------------------------------------------------------------------------
 
     def add_production(self, prodname, syms, func=None, file='', line=0):
+        """
+
+        Parameters
+        ----------
+        prodname :
+            
+        syms :
+            
+        func :
+             (Default value = None)
+        file :
+             (Default value = '')
+        line :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
 
         if prodname in self.Terminals:
             raise GrammarError('%s:%d: Illegal rule name %r. Already defined as a token' % (file, line, prodname))
@@ -1631,6 +1956,17 @@
     # -----------------------------------------------------------------------------
 
     def set_start(self, start=None):
+        """
+
+        Parameters
+        ----------
+        start :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if not start:
             start = self.Productions[1].name
         if start not in self.Nonterminals:
@@ -1647,9 +1983,21 @@
     # -----------------------------------------------------------------------------
 
     def find_unreachable(self):
+        """ """
 
         # Mark all symbols that are reachable from a symbol s
         def mark_reachable_from(s):
+            """
+
+            Parameters
+            ----------
+            s :
+                
+
+            Returns
+            -------
+
+            """
             if s in reachable:
                 return
             reachable.add(s)
@@ -1670,6 +2018,7 @@
     # -----------------------------------------------------------------------------
 
     def infinite_cycles(self):
+        """ """
         terminates = {}
 
         # Terminals:
@@ -1734,6 +2083,7 @@
     # and prod is the production where the symbol was used.
     # -----------------------------------------------------------------------------
     def undefined_symbols(self):
+        """ """
         result = []
         for p in self.Productions:
             if not p:
@@ -1751,6 +2101,7 @@
     # a list of all symbols.
     # -----------------------------------------------------------------------------
     def unused_terminals(self):
+        """ """
         unused_tok = []
         for s, v in self.Terminals.items():
             if s != 'error' and not v:
@@ -1766,6 +2117,7 @@
     # ------------------------------------------------------------------------------
 
     def unused_rules(self):
+        """ """
         unused_prod = []
         for s, v in self.Nonterminals.items():
             if not v:
@@ -1783,6 +2135,7 @@
     # -----------------------------------------------------------------------------
 
     def unused_precedence(self):
+        """ """
         unused = []
         for termname in self.Precedence:
             if not (termname in self.Terminals or termname in self.UsedPrecedence):
@@ -1799,6 +2152,17 @@
     # Afterward (e.g., when called from compute_follow()), it will be complete.
     # -------------------------------------------------------------------------
     def _first(self, beta):
+        """
+
+        Parameters
+        ----------
+        beta :
+            
+
+        Returns
+        -------
+
+        """
 
         # We are computing First(x1,x2,x3,...,xn)
         result = []
@@ -1834,6 +2198,7 @@
     # Compute the value of FIRST1(X) for all symbols
     # -------------------------------------------------------------------------
     def compute_first(self):
+        """ """
         if self.First:
             return self.First
 
@@ -1871,6 +2236,17 @@
     # non-terminal.  See the Dragon book, 2nd Ed. p. 189.
     # ---------------------------------------------------------------------
     def compute_follow(self, start=None):
+        """
+
+        Parameters
+        ----------
+        start :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # If already computed, return the result
         if self.Follow:
             return self.Follow
@@ -1930,6 +2306,7 @@
     # -----------------------------------------------------------------------------
 
     def build_lritems(self):
+        """ """
         for p in self.Productions:
             lastlri = p
             i = 0
@@ -1966,9 +2343,11 @@
 # -----------------------------------------------------------------------------
 
 class VersionError(YaccError):
+    """ """
     pass
 
 class LRTable(object):
+    """ """
     def __init__(self):
         self.lr_action = None
         self.lr_goto = None
@@ -1976,6 +2355,17 @@
         self.lr_method = None
 
     def read_table(self, module):
+        """
+
+        Parameters
+        ----------
+        module :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(module, types.ModuleType):
             parsetab = module
         else:
@@ -1996,6 +2386,17 @@
         return parsetab._lr_signature
 
     def read_pickle(self, filename):
+        """
+
+        Parameters
+        ----------
+        filename :
+            
+
+        Returns
+        -------
+
+        """
         try:
             import cPickle as pickle
         except ImportError:
@@ -2024,6 +2425,17 @@
 
     # Bind all production function names to callable objects in pdict
     def bind_callables(self, pdict):
+        """
+
+        Parameters
+        ----------
+        pdict :
+            
+
+        Returns
+        -------
+
+        """
         for p in self.lr_productions:
             p.bind(pdict)
 
@@ -2053,6 +2465,21 @@
 # ------------------------------------------------------------------------------
 
 def digraph(X, R, FP):
+    """
+
+    Parameters
+    ----------
+    X :
+        
+    R :
+        
+    FP :
+        
+
+    Returns
+    -------
+
+    """
     N = {}
     for x in X:
         N[x] = 0
@@ -2064,6 +2491,29 @@
     return F
 
 def traverse(x, N, stack, F, X, R, FP):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    N :
+        
+    stack :
+        
+    F :
+        
+    X :
+        
+    R :
+        
+    FP :
+        
+
+    Returns
+    -------
+
+    """
     stack.append(x)
     d = len(stack)
     N[x] = d
@@ -2087,6 +2537,7 @@
             element = stack.pop()
 
 class LALRError(YaccError):
+    """ """
     pass
 
 # -----------------------------------------------------------------------------
@@ -2097,6 +2548,7 @@
 # -----------------------------------------------------------------------------
 
 class LRGeneratedTable(LRTable):
+    """ """
     def __init__(self, grammar, method='LALR', log=None):
         if method not in ['SLR', 'LALR']:
             raise LALRError('Unsupported method %s' % method)
@@ -2135,6 +2587,17 @@
     # Compute the LR(0) closure operation on I, where I is a set of LR(0) items.
 
     def lr0_closure(self, I):
+        """
+
+        Parameters
+        ----------
+        I :
+            
+
+        Returns
+        -------
+
+        """
         self._add_count += 1
 
         # Add everything in I to J
@@ -2161,6 +2624,19 @@
     # id(obj) instead of element-wise comparison.
 
     def lr0_goto(self, I, x):
+        """
+
+        Parameters
+        ----------
+        I :
+            
+        x :
+            
+
+        Returns
+        -------
+
+        """
         # First we look for a previously cached entry
         g = self.lr_goto_cache.get((id(I), x))
         if g:
@@ -2196,6 +2672,7 @@
 
     # Compute the LR(0) sets of item function
     def lr0_items(self):
+        """ """
         C = [self.lr0_closure([self.grammar.Productions[0].lr_next])]
         i = 0
         for I in C:
@@ -2252,6 +2729,7 @@
     # -----------------------------------------------------------------------------
 
     def compute_nullable_nonterminals(self):
+        """ """
         nullable = set()
         num_nullable = 0
         while True:
@@ -2281,6 +2759,17 @@
     # -----------------------------------------------------------------------------
 
     def find_nonterminal_transitions(self, C):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+
+        Returns
+        -------
+
+        """
         trans = []
         for stateno, state in enumerate(C):
             for p in state:
@@ -2301,6 +2790,21 @@
     # -----------------------------------------------------------------------------
 
     def dr_relation(self, C, trans, nullable):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+        trans :
+            
+        nullable :
+            
+
+        Returns
+        -------
+
+        """
         dr_set = {}
         state, N = trans
         terms = []
@@ -2326,6 +2830,21 @@
     # -----------------------------------------------------------------------------
 
     def reads_relation(self, C, trans, empty):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+        trans :
+            
+        empty :
+            
+
+        Returns
+        -------
+
+        """
         # Look for empty transitions
         rel = []
         state, N = trans
@@ -2369,6 +2888,21 @@
     # -----------------------------------------------------------------------------
 
     def compute_lookback_includes(self, C, trans, nullable):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+        trans :
+            
+        nullable :
+            
+
+        Returns
+        -------
+
+        """
         lookdict = {}          # Dictionary of lookback relations
         includedict = {}       # Dictionary of include relations
 
@@ -2449,6 +2983,21 @@
     # -----------------------------------------------------------------------------
 
     def compute_read_sets(self, C, ntrans, nullable):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+        ntrans :
+            
+        nullable :
+            
+
+        Returns
+        -------
+
+        """
         FP = lambda x: self.dr_relation(C, x, nullable)
         R =  lambda x: self.reads_relation(C, x, nullable)
         F = digraph(ntrans, R, FP)
@@ -2471,6 +3020,21 @@
     # -----------------------------------------------------------------------------
 
     def compute_follow_sets(self, ntrans, readsets, inclsets):
+        """
+
+        Parameters
+        ----------
+        ntrans :
+            
+        readsets :
+            
+        inclsets :
+            
+
+        Returns
+        -------
+
+        """
         FP = lambda x: readsets[x]
         R  = lambda x: inclsets.get(x, [])
         F = digraph(ntrans, R, FP)
@@ -2489,6 +3053,19 @@
     # -----------------------------------------------------------------------------
 
     def add_lookaheads(self, lookbacks, followset):
+        """
+
+        Parameters
+        ----------
+        lookbacks :
+            
+        followset :
+            
+
+        Returns
+        -------
+
+        """
         for trans, lb in lookbacks.items():
             # Loop over productions in lookback
             for state, p in lb:
@@ -2507,6 +3084,17 @@
     # -----------------------------------------------------------------------------
 
     def add_lalr_lookaheads(self, C):
+        """
+
+        Parameters
+        ----------
+        C :
+            
+
+        Returns
+        -------
+
+        """
         # Determine all of the nullable nonterminals
         nullable = self.compute_nullable_nonterminals()
 
@@ -2531,6 +3119,7 @@
     # This function constructs the parse tables for SLR or LALR
     # -----------------------------------------------------------------------------
     def lr_parse_table(self):
+        """ """
         Productions = self.grammar.Productions
         Precedence  = self.grammar.Precedence
         goto   = self.lr_goto         # Goto array
@@ -2724,6 +3313,21 @@
     # -----------------------------------------------------------------------------
 
     def write_table(self, tabmodule, outputdir='', signature=''):
+        """
+
+        Parameters
+        ----------
+        tabmodule :
+            
+        outputdir :
+             (Default value = '')
+        signature :
+             (Default value = '')
+
+        Returns
+        -------
+
+        """
         if isinstance(tabmodule, types.ModuleType):
             raise IOError("Won't overwrite existing tabmodule")
 
@@ -2846,6 +3450,19 @@
     # -----------------------------------------------------------------------------
 
     def pickle_table(self, filename, signature=''):
+        """
+
+        Parameters
+        ----------
+        filename :
+            
+        signature :
+             (Default value = '')
+
+        Returns
+        -------
+
+        """
         try:
             import cPickle as pickle
         except ImportError:
@@ -2881,6 +3498,17 @@
 # -----------------------------------------------------------------------------
 
 def get_caller_module_dict(levels):
+    """
+
+    Parameters
+    ----------
+    levels :
+        
+
+    Returns
+    -------
+
+    """
     f = sys._getframe(levels)
     ldict = f.f_globals.copy()
     if f.f_globals != f.f_locals:
@@ -2893,6 +3521,21 @@
 # This takes a raw grammar rule string and parses it into production data
 # -----------------------------------------------------------------------------
 def parse_grammar(doc, file, line):
+    """
+
+    Parameters
+    ----------
+    doc :
+        
+    file :
+        
+    line :
+        
+
+    Returns
+    -------
+
+    """
     grammar = []
     # Split the doc string into lines
     pstrings = doc.splitlines()
@@ -2934,6 +3577,7 @@
 # etc.
 # -----------------------------------------------------------------------------
 class ParserReflect(object):
+    """ """
     def __init__(self, pdict, log=None):
         self.pdict      = pdict
         self.start      = None
@@ -2950,6 +3594,7 @@
 
     # Get all of the basic information
     def get_all(self):
+        """ """
         self.get_start()
         self.get_error_func()
         self.get_tokens()
@@ -2958,6 +3603,7 @@
 
     # Validate all of the information
     def validate_all(self):
+        """ """
         self.validate_start()
         self.validate_error_func()
         self.validate_tokens()
@@ -2968,6 +3614,7 @@
 
     # Compute a signature over the grammar
     def signature(self):
+        """ """
         parts = []
         try:
             if self.start:
@@ -2995,6 +3642,7 @@
     # -----------------------------------------------------------------------------
 
     def validate_modules(self):
+        """ """
         # Match def p_funcname(
         fre = re.compile(r'\s*def\s+(p_[a-zA-Z_0-9]*)\(')
 
@@ -3020,20 +3668,24 @@
 
     # Get the start symbol
     def get_start(self):
+        """ """
         self.start = self.pdict.get('start')
 
     # Validate the start symbol
     def validate_start(self):
+        """ """
         if self.start is not None:
             if not isinstance(self.start, string_types):
                 self.log.error("'start' must be a string")
 
     # Look for error handler
     def get_error_func(self):
+        """ """
         self.error_func = self.pdict.get('p_error')
 
     # Validate the error function
     def validate_error_func(self):
+        """ """
         if self.error_func:
             if isinstance(self.error_func, types.FunctionType):
                 ismethod = 0
@@ -3056,6 +3708,7 @@
 
     # Get the tokens map
     def get_tokens(self):
+        """ """
         tokens = self.pdict.get('tokens')
         if not tokens:
             self.log.error('No token list is defined')
@@ -3076,6 +3729,7 @@
 
     # Validate the tokens
     def validate_tokens(self):
+        """ """
         # Validate the tokens.
         if 'error' in self.tokens:
             self.log.error("Illegal token name 'error'. Is a reserved word")
@@ -3090,10 +3744,12 @@
 
     # Get the precedence map (if any)
     def get_precedence(self):
+        """ """
         self.prec = self.pdict.get('precedence')
 
     # Validate and parse the precedence map
     def validate_precedence(self):
+        """ """
         preclist = []
         if self.prec:
             if not isinstance(self.prec, (list, tuple)):
@@ -3125,6 +3781,7 @@
 
     # Get all p_functions from the grammar
     def get_pfunctions(self):
+        """ """
         p_functions = []
         for name, item in self.pdict.items():
             if not name.startswith('p_') or name == 'p_error':
@@ -3146,6 +3803,7 @@
 
     # Validate all of the p_functions
     def validate_pfunctions(self):
+        """ """
         grammar = []
         # Check for non-empty symbols
         if len(self.pfuncs) == 0:
@@ -3214,6 +3872,41 @@
 def yacc(method='LALR', debug=yaccdebug, module=None, tabmodule=tab_module, start=None,
          check_recursion=True, optimize=False, write_tables=True, debugfile=debug_file,
          outputdir=None, debuglog=None, errorlog=None, picklefile=None):
+    """
+
+    Parameters
+    ----------
+    method :
+         (Default value = 'LALR')
+    debug :
+         (Default value = yaccdebug)
+    module :
+         (Default value = None)
+    tabmodule :
+         (Default value = tab_module)
+    start :
+         (Default value = None)
+    check_recursion :
+         (Default value = True)
+    optimize :
+         (Default value = False)
+    write_tables :
+         (Default value = True)
+    debugfile :
+         (Default value = debug_file)
+    outputdir :
+         (Default value = None)
+    debuglog :
+         (Default value = None)
+    errorlog :
+         (Default value = None)
+    picklefile :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
 
     if tabmodule is None:
         tabmodule = tab_module
