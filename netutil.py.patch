# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/netutil.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/netutil.py
@@ -61,27 +61,46 @@
     reuse_port: bool = False,
 ) -> List[socket.socket]:
     """Creates listening sockets bound to the given port and address.
-
+    
     Returns a list of socket objects (multiple sockets are returned if
     the given address maps to multiple IP addresses, which is most common
     for mixed IPv4 and IPv6 use).
-
+    
     Address may be either an IP address or hostname.  If it's a hostname,
     the server will listen on all IP addresses associated with the
     name.  Address may be an empty string or None to listen on all
     available interfaces.  Family may be set to either `socket.AF_INET`
     or `socket.AF_INET6` to restrict to IPv4 or IPv6 addresses, otherwise
     both will be used if available.
-
+    
     The ``backlog`` argument has the same meaning as for
     `socket.listen() <socket.socket.listen>`.
-
+    
     ``flags`` is a bitmask of AI_* flags to `~socket.getaddrinfo`, like
     ``socket.AI_PASSIVE | socket.AI_NUMERICHOST``.
-
+    
     ``reuse_port`` option sets ``SO_REUSEPORT`` option for every socket
     in the list. If your platform doesn't support this option ValueError will
     be raised.
+
+    Parameters
+    ----------
+    port: int :
+        
+    address: Optional[str] :
+         (Default value = None)
+    family: socket.AddressFamily :
+         (Default value = socket.AF_UNSPEC)
+    backlog: int :
+         (Default value = _DEFAULT_BACKLOG)
+    flags: Optional[int] :
+         (Default value = None)
+    reuse_port: bool :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     if reuse_port and not hasattr(socket, "SO_REUSEPORT"):
         raise ValueError("the platform doesn't support SO_REUSEPORT")
@@ -192,13 +211,24 @@
         file: str, mode: int = 0o600, backlog: int = _DEFAULT_BACKLOG
     ) -> socket.socket:
         """Creates a listening unix socket.
-
+        
         If a socket with the given name already exists, it will be deleted.
         If any other file with that name exists, an exception will be
-        raised.
-
-        Returns a socket object (not a list of socket objects like
-        `bind_sockets`)
+
+        Parameters
+        ----------
+        file: str :
+            
+        mode: int :
+             (Default value = 0o600)
+        backlog: int :
+             (Default value = _DEFAULT_BACKLOG)
+
+        Returns
+        -------
+        type
+            `bind_sockets`)
+
         """
         sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
         try:
@@ -227,26 +257,54 @@
     sock: socket.socket, callback: Callable[[socket.socket, Any], None]
 ) -> Callable[[], None]:
     """Adds an `.IOLoop` event handler to accept new connections on ``sock``.
-
+    
     When a connection is accepted, ``callback(connection, address)`` will
     be run (``connection`` is a socket object, and ``address`` is the
     address of the other end of the connection).  Note that this signature
     is different from the ``callback(fd, events)`` signature used for
     `.IOLoop` handlers.
-
+    
     A callable is returned which, when called, will remove the `.IOLoop`
     event handler and stop processing further incoming connections.
-
+    
     .. versionchanged:: 5.0
        The ``io_loop`` argument (deprecated since version 4.1) has been removed.
-
+    
     .. versionchanged:: 5.0
        A callable is returned (``None`` was returned before).
+
+    Parameters
+    ----------
+    sock: socket.socket :
+        
+    callback: Callable[[socket.socket :
+        
+    Any] :
+        
+    None] :
+        
+
+    Returns
+    -------
+
     """
     io_loop = IOLoop.current()
     removed = [False]
 
     def accept_handler(fd: socket.socket, events: int) -> None:
+        """
+
+        Parameters
+        ----------
+        fd: socket.socket :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
+        """
         # More connections may come in while we're handling callbacks;
         # to prevent starvation of other tasks we must limit the number
         # of connections we accept at a time.  Ideally we would accept
@@ -276,6 +334,7 @@
             callback(connection, address)
 
     def remove_handler() -> None:
+        """ """
         io_loop.remove_handler(sock)
         removed[0] = True
 
@@ -285,8 +344,17 @@
 
 def is_valid_ip(ip: str) -> bool:
     """Returns ``True`` if the given string is a well-formed IP address.
-
+    
     Supports IPv4 and IPv6.
+
+    Parameters
+    ----------
+    ip: str :
+        
+
+    Returns
+    -------
+
     """
     if not ip or "\x00" in ip:
         # getaddrinfo resolves empty strings to localhost, and truncates
@@ -306,44 +374,53 @@
 
 class Resolver(Configurable):
     """Configurable asynchronous DNS resolver interface.
-
+    
     By default, a blocking implementation is used (which simply calls
     `socket.getaddrinfo`).  An alternative implementation can be
     chosen with the `Resolver.configure <.Configurable.configure>`
     class method::
-
+    
         Resolver.configure('tornado.netutil.ThreadedResolver')
-
+    
     The implementations of this interface included with Tornado are
-
+    
     * `tornado.netutil.DefaultExecutorResolver`
     * `tornado.netutil.BlockingResolver` (deprecated)
     * `tornado.netutil.ThreadedResolver` (deprecated)
     * `tornado.netutil.OverrideResolver`
     * `tornado.platform.twisted.TwistedResolver`
     * `tornado.platform.caresresolver.CaresResolver`
-
+    
     .. versionchanged:: 5.0
        The default implementation has changed from `BlockingResolver` to
        `DefaultExecutorResolver`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     @classmethod
     def configurable_base(cls) -> Type["Resolver"]:
+        """ """
         return Resolver
 
     @classmethod
     def configurable_default(cls) -> Type["Resolver"]:
+        """ """
         return DefaultExecutorResolver
 
     def resolve(
         self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC
     ) -> Awaitable[List[Tuple[int, Any]]]:
         """Resolves an address.
-
+        
         The ``host`` argument is a string which may be a hostname or a
         literal IP address.
-
+        
         Returns a `.Future` whose result is a list of (family,
         address) pairs, where address is a tuple suitable to pass to
         `socket.connect <socket.socket.connect>` (i.e. a ``(host,
@@ -351,21 +428,42 @@
         IPv6). If a ``callback`` is passed, it will be run with the
         result as an argument when it is complete.
 
-        :raises IOError: if the address cannot be resolved.
-
-        .. versionchanged:: 4.4
-           Standardized all implementations to raise `IOError`.
-
-        .. versionchanged:: 6.0 The ``callback`` argument was removed.
-           Use the returned awaitable object instead.
+        Parameters
+        ----------
+        host: str :
+            
+        port: int :
+            
+        family: socket.AddressFamily :
+             (Default value = socket.AF_UNSPEC)
+
+        Returns
+        -------
+
+        Raises
+        ------
+        IOError
+            if the address cannot be resolved.
+            
+            .. versionchanged:: 4.4
+            Standardized all implementations to raise `IOError`.
+            
+            .. versionchanged:: 6.0 The ``callback`` argument was removed.
+            Use the returned awaitable object instead.
 
         """
         raise NotImplementedError()
 
     def close(self) -> None:
         """Closes the `Resolver`, freeing any resources used.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         pass
@@ -374,6 +472,21 @@
 def _resolve_addr(
     host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC
 ) -> List[Tuple[int, Any]]:
+    """
+
+    Parameters
+    ----------
+    host: str :
+        
+    port: int :
+        
+    family: socket.AddressFamily :
+         (Default value = socket.AF_UNSPEC)
+
+    Returns
+    -------
+
+    """
     # On Solaris, getaddrinfo fails if the given port is not found
     # in /etc/services and no socket type is given, so we must pass
     # one here.  The socket type used here doesn't seem to actually
@@ -388,8 +501,15 @@
 
 class DefaultExecutorResolver(Resolver):
     """Resolver implementation using `.IOLoop.run_in_executor`.
-
+    
     .. versionadded:: 5.0
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     async def resolve(
@@ -403,20 +523,27 @@
 
 class ExecutorResolver(Resolver):
     """Resolver implementation using a `concurrent.futures.Executor`.
-
+    
     Use this instead of `ThreadedResolver` when you require additional
     control over the executor being used.
-
+    
     The executor will be shut down when the resolver is closed unless
     ``close_resolver=False``; use this if you want to reuse the same
     executor elsewhere.
-
+    
     .. versionchanged:: 5.0
        The ``io_loop`` argument (deprecated since version 4.1) has been removed.
-
+    
     .. deprecated:: 5.0
        The default `Resolver` now uses `.IOLoop.run_in_executor`; use that instead
        of this class.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(
@@ -424,6 +551,19 @@
         executor: Optional[concurrent.futures.Executor] = None,
         close_executor: bool = True,
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        executor: Optional[concurrent.futures.Executor] :
+             (Default value = None)
+        close_executor: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         self.io_loop = IOLoop.current()
         if executor is not None:
             self.executor = executor
@@ -433,6 +573,7 @@
             self.close_executor = False
 
     def close(self) -> None:
+        """ """
         if self.close_executor:
             self.executor.shutdown()
         self.executor = None  # type: ignore
@@ -441,49 +582,90 @@
     def resolve(
         self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC
     ) -> List[Tuple[int, Any]]:
+        """
+
+        Parameters
+        ----------
+        host: str :
+            
+        port: int :
+            
+        family: socket.AddressFamily :
+             (Default value = socket.AF_UNSPEC)
+
+        Returns
+        -------
+
+        """
         return _resolve_addr(host, port, family)
 
 
 class BlockingResolver(ExecutorResolver):
     """Default `Resolver` implementation, using `socket.getaddrinfo`.
-
+    
     The `.IOLoop` will be blocked during the resolution, although the
     callback will not be run until the next `.IOLoop` iteration.
-
+    
     .. deprecated:: 5.0
        The default `Resolver` now uses `.IOLoop.run_in_executor`; use that instead
        of this class.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(self) -> None:  # type: ignore
+        """ """
         super().initialize()
 
 
 class ThreadedResolver(ExecutorResolver):
     """Multithreaded non-blocking `Resolver` implementation.
-
+    
     Requires the `concurrent.futures` package to be installed
     (available in the standard library since Python 3.2,
     installable with ``pip install futures`` in older versions).
-
+    
     The thread pool size can be configured with::
-
+    
         Resolver.configure('tornado.netutil.ThreadedResolver',
                            num_threads=10)
-
+    
     .. versionchanged:: 3.1
        All ``ThreadedResolvers`` share a single thread pool, whose
        size is set by the first one to be created.
-
+    
     .. deprecated:: 5.0
        The default `Resolver` now uses `.IOLoop.run_in_executor`; use that instead
        of this class.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     _threadpool = None  # type: ignore
     _threadpool_pid = None  # type: int
 
     def initialize(self, num_threads: int = 10) -> None:  # type: ignore
+        """
+
+        Parameters
+        ----------
+        num_threads: int :
+             (Default value = 10)
+
+        Returns
+        -------
+
+        """
         threadpool = ThreadedResolver._create_threadpool(num_threads)
         super().initialize(executor=threadpool, close_executor=False)
 
@@ -491,6 +673,17 @@
     def _create_threadpool(
         cls, num_threads: int
     ) -> concurrent.futures.ThreadPoolExecutor:
+        """
+
+        Parameters
+        ----------
+        num_threads: int :
+            
+
+        Returns
+        -------
+
+        """
         pid = os.getpid()
         if cls._threadpool_pid != pid:
             # Threads cannot survive after a fork, so if our pid isn't what it
@@ -504,37 +697,73 @@
 
 class OverrideResolver(Resolver):
     """Wraps a resolver with a mapping of overrides.
-
+    
     This can be used to make local DNS changes (e.g. for testing)
     without modifying system-wide settings.
-
+    
     The mapping can be in three formats::
-
+    
         {
             # Hostname to host or ip
             "example.com": "127.0.1.1",
-
+    
             # Host+port to host+port
             ("login.example.com", 443): ("localhost", 1443),
-
+    
             # Host+port+address family to host+port
             ("login.example.com", 443, socket.AF_INET6): ("::1", 1443),
         }
-
+    
     .. versionchanged:: 5.0
        Added support for host-port-family triplets.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(self, resolver: Resolver, mapping: dict) -> None:
+        """
+
+        Parameters
+        ----------
+        resolver: Resolver :
+            
+        mapping: dict :
+            
+
+        Returns
+        -------
+
+        """
         self.resolver = resolver
         self.mapping = mapping
 
     def close(self) -> None:
+        """ """
         self.resolver.close()
 
     def resolve(
         self, host: str, port: int, family: socket.AddressFamily = socket.AF_UNSPEC
     ) -> Awaitable[List[Tuple[int, Any]]]:
+        """
+
+        Parameters
+        ----------
+        host: str :
+            
+        port: int :
+            
+        family: socket.AddressFamily :
+             (Default value = socket.AF_UNSPEC)
+
+        Returns
+        -------
+
+        """
         if (host, port, family) in self.mapping:
             host, port = self.mapping[(host, port, family)]
         elif (host, port) in self.mapping:
@@ -557,13 +786,26 @@
 ) -> ssl.SSLContext:
     """Try to convert an ``ssl_options`` dictionary to an
     `~ssl.SSLContext` object.
-
+    
     The ``ssl_options`` dictionary contains keywords to be passed to
     `ssl.wrap_socket`.  In Python 2.7.9+, `ssl.SSLContext` objects can
     be used instead.  This function converts the dict form to its
     `~ssl.SSLContext` equivalent, and may be used when a component which
     accepts both forms needs to upgrade to the `~ssl.SSLContext` version
     to use features like SNI or NPN.
+
+    Parameters
+    ----------
+    ssl_options: Union[Dict[str :
+        
+    Any] :
+        
+    ssl.SSLContext] :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(ssl_options, ssl.SSLContext):
         return ssl_options
@@ -598,12 +840,31 @@
     **kwargs: Any
 ) -> ssl.SSLSocket:
     """Returns an ``ssl.SSLSocket`` wrapping the given socket.
-
+    
     ``ssl_options`` may be either an `ssl.SSLContext` object or a
     dictionary (as accepted by `ssl_options_to_context`).  Additional
     keyword arguments are passed to ``wrap_socket`` (either the
     `~ssl.SSLContext` method or the `ssl` module function as
     appropriate).
+
+    Parameters
+    ----------
+    socket: socket.socket :
+        
+    ssl_options: Union[Dict[str :
+        
+    Any] :
+        
+    ssl.SSLContext] :
+        
+    server_hostname: Optional[str] :
+         (Default value = None)
+    **kwargs: Any :
+        
+
+    Returns
+    -------
+
     """
     context = ssl_options_to_context(ssl_options)
     if ssl.HAS_SNI:
