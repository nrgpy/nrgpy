# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/fft/tests/test_pocketfft.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/fft/tests/test_pocketfft.py
@@ -9,6 +9,17 @@
 
 
 def fft1(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     L = len(x)
     phase = -2j*np.pi*(np.arange(L)/float(L))
     phase = np.arange(L).reshape(-1, 1) * phase
@@ -16,14 +27,18 @@
 
 
 class TestFFTShift:
+    """ """
 
     def test_fft_n(self):
+        """ """
         assert_raises(ValueError, np.fft.fft, [1, 2, 3], 0)
 
 
 class TestFFT1D:
+    """ """
 
     def test_identity(self):
+        """ """
         maxlen = 512
         x = random(maxlen) + 1j*random(maxlen)
         xr = random(maxlen)
@@ -34,6 +49,7 @@
                             xr[0:i], atol=1e-12)
 
     def test_fft(self):
+        """ """
         x = random(30) + 1j*random(30)
         assert_allclose(fft1(x), np.fft.fft(x), atol=1e-6)
         assert_allclose(fft1(x) / np.sqrt(30),
@@ -41,6 +57,17 @@
 
     @pytest.mark.parametrize('norm', (None, 'ortho'))
     def test_ifft(self, norm):
+        """
+
+        Parameters
+        ----------
+        norm :
+            
+
+        Returns
+        -------
+
+        """
         x = random(30) + 1j*random(30)
         assert_allclose(
             x, np.fft.ifft(np.fft.fft(x, norm=norm), norm=norm),
@@ -51,6 +78,7 @@
             np.fft.ifft([], norm=norm)
 
     def test_fft2(self):
+        """ """
         x = random((30, 20)) + 1j*random((30, 20))
         assert_allclose(np.fft.fft(np.fft.fft(x, axis=1), axis=0),
                         np.fft.fft2(x), atol=1e-6)
@@ -58,6 +86,7 @@
                         np.fft.fft2(x, norm="ortho"), atol=1e-6)
 
     def test_ifft2(self):
+        """ """
         x = random((30, 20)) + 1j*random((30, 20))
         assert_allclose(np.fft.ifft(np.fft.ifft(x, axis=1), axis=0),
                         np.fft.ifft2(x), atol=1e-6)
@@ -65,6 +94,7 @@
                         np.fft.ifft2(x, norm="ortho"), atol=1e-6)
 
     def test_fftn(self):
+        """ """
         x = random((30, 20, 10)) + 1j*random((30, 20, 10))
         assert_allclose(
             np.fft.fft(np.fft.fft(np.fft.fft(x, axis=2), axis=1), axis=0),
@@ -73,6 +103,7 @@
                         np.fft.fftn(x, norm="ortho"), atol=1e-6)
 
     def test_ifftn(self):
+        """ """
         x = random((30, 20, 10)) + 1j*random((30, 20, 10))
         assert_allclose(
             np.fft.ifft(np.fft.ifft(np.fft.ifft(x, axis=2), axis=1), axis=0),
@@ -81,6 +112,7 @@
                         np.fft.ifftn(x, norm="ortho"), atol=1e-6)
 
     def test_rfft(self):
+        """ """
         x = random(30)
         for n in [x.size, 2*x.size]:
             for norm in [None, 'ortho']:
@@ -92,36 +124,42 @@
                 np.fft.rfft(x, n=n, norm="ortho"), atol=1e-6)
 
     def test_irfft(self):
+        """ """
         x = random(30)
         assert_allclose(x, np.fft.irfft(np.fft.rfft(x)), atol=1e-6)
         assert_allclose(
             x, np.fft.irfft(np.fft.rfft(x, norm="ortho"), norm="ortho"), atol=1e-6)
 
     def test_rfft2(self):
+        """ """
         x = random((30, 20))
         assert_allclose(np.fft.fft2(x)[:, :11], np.fft.rfft2(x), atol=1e-6)
         assert_allclose(np.fft.rfft2(x) / np.sqrt(30 * 20),
                         np.fft.rfft2(x, norm="ortho"), atol=1e-6)
 
     def test_irfft2(self):
+        """ """
         x = random((30, 20))
         assert_allclose(x, np.fft.irfft2(np.fft.rfft2(x)), atol=1e-6)
         assert_allclose(
             x, np.fft.irfft2(np.fft.rfft2(x, norm="ortho"), norm="ortho"), atol=1e-6)
 
     def test_rfftn(self):
+        """ """
         x = random((30, 20, 10))
         assert_allclose(np.fft.fftn(x)[:, :, :6], np.fft.rfftn(x), atol=1e-6)
         assert_allclose(np.fft.rfftn(x) / np.sqrt(30 * 20 * 10),
                         np.fft.rfftn(x, norm="ortho"), atol=1e-6)
 
     def test_irfftn(self):
+        """ """
         x = random((30, 20, 10))
         assert_allclose(x, np.fft.irfftn(np.fft.rfftn(x)), atol=1e-6)
         assert_allclose(
             x, np.fft.irfftn(np.fft.rfftn(x, norm="ortho"), norm="ortho"), atol=1e-6)
 
     def test_hfft(self):
+        """ """
         x = random(14) + 1j*random(14)
         x_herm = np.concatenate((random(1), x, random(1)))
         x = np.concatenate((x_herm, x[::-1].conj()))
@@ -130,6 +168,7 @@
                         np.fft.hfft(x_herm, norm="ortho"), atol=1e-6)
 
     def test_ihttf(self):
+        """ """
         x = random(14) + 1j*random(14)
         x_herm = np.concatenate((random(1), x, random(1)))
         x = np.concatenate((x_herm, x[::-1].conj()))
@@ -141,6 +180,17 @@
     @pytest.mark.parametrize("op", [np.fft.fftn, np.fft.ifftn,
                                     np.fft.rfftn, np.fft.irfftn])
     def test_axes(self, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         x = random((30, 20, 10))
         axes = [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]
         for a in axes:
@@ -149,6 +199,7 @@
             assert_allclose(op_tr, tr_op, atol=1e-6)
 
     def test_all_1d_norm_preserving(self):
+        """ """
         # verify that round-trip transforms are norm-preserving
         x = random(30)
         x_norm = np.linalg.norm(x)
@@ -170,6 +221,17 @@
     @pytest.mark.parametrize("dtype", [np.half, np.single, np.double,
                                        np.longdouble])
     def test_dtypes(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # make sure that all input precisions are accepted and internally
         # converted to 64bit
         x = random(30).astype(dtype)
@@ -186,6 +248,21 @@
         [np.fft.fft, np.fft.fft2, np.fft.fftn,
          np.fft.ifft, np.fft.ifft2, np.fft.ifftn])
 def test_fft_with_order(dtype, order, fft):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+    order :
+        
+    fft :
+        
+
+    Returns
+    -------
+
+    """
     # Check that FFT/IFFT produces identical results for C, Fortran and
     # non contiguous arrays
     rng = np.random.RandomState(42)
@@ -217,11 +294,38 @@
 
 
 class TestFFTThreadSafe:
+    """ """
     threads = 16
     input_shape = (800, 200)
 
     def _test_mtsame(self, func, *args):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        *args :
+            
+
+        Returns
+        -------
+
+        """
         def worker(args, q):
+            """
+
+            Parameters
+            ----------
+            args :
+                
+            q :
+                
+
+            Returns
+            -------
+
+            """
             q.put(func(*args))
 
         q = queue.Queue()
@@ -239,17 +343,21 @@
                 'Function returned wrong value in multithreaded context')
 
     def test_fft(self):
+        """ """
         a = np.ones(self.input_shape) * 1+0j
         self._test_mtsame(np.fft.fft, a)
 
     def test_ifft(self):
+        """ """
         a = np.ones(self.input_shape) * 1+0j
         self._test_mtsame(np.fft.ifft, a)
 
     def test_rfft(self):
+        """ """
         a = np.ones(self.input_shape)
         self._test_mtsame(np.fft.rfft, a)
 
     def test_irfft(self):
+        """ """
         a = np.ones(self.input_shape) * 1+0j
         self._test_mtsame(np.fft.irfft, a)
