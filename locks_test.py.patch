# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/locks_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/locks_test.py
@@ -21,14 +21,39 @@
 
 
 class ConditionTest(AsyncTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.history = []  # type: typing.List[typing.Union[int, str]]
 
     def record_done(self, future, key):
-        """Record the resolution of a Future returned by Condition.wait."""
+        """Record the resolution of a Future returned by Condition.wait.
+
+        Parameters
+        ----------
+        future :
+            
+        key :
+            
+
+        Returns
+        -------
+
+        """
 
         def callback(_):
+            """
+
+            Parameters
+            ----------
+            _ :
+                
+
+            Returns
+            -------
+
+            """
             if not future.result():
                 # wait() resolved to False, meaning it timed out.
                 self.history.append("timeout")
@@ -39,15 +64,23 @@
 
     def loop_briefly(self):
         """Run all queued callbacks on the IOLoop.
-
+        
         In these tests, this method is used after calling notify() to
         preserve the pre-5.0 behavior in which callbacks ran
         synchronously.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.io_loop.add_callback(self.stop)
         self.wait()
 
     def test_repr(self):
+        """ """
         c = locks.Condition()
         self.assertIn("Condition", repr(c))
         self.assertNotIn("waiters", repr(c))
@@ -56,11 +89,13 @@
 
     @gen_test
     def test_notify(self):
+        """ """
         c = locks.Condition()
         self.io_loop.call_later(0.01, c.notify)
         yield c.wait()
 
     def test_notify_1(self):
+        """ """
         c = locks.Condition()
         self.record_done(c.wait(), "wait1")
         self.record_done(c.wait(), "wait2")
@@ -73,6 +108,7 @@
         self.assertEqual(["wait1", "notify1", "wait2", "notify2"], self.history)
 
     def test_notify_n(self):
+        """ """
         c = locks.Condition()
         for i in range(6):
             self.record_done(c.wait(), i)
@@ -90,6 +126,7 @@
         self.assertEqual(list(range(6)), self.history)
 
     def test_notify_all(self):
+        """ """
         c = locks.Condition()
         for i in range(4):
             self.record_done(c.wait(), i)
@@ -103,6 +140,7 @@
 
     @gen_test
     def test_wait_timeout(self):
+        """ """
         c = locks.Condition()
         wait = c.wait(timedelta(seconds=0.01))
         self.io_loop.call_later(0.02, c.notify)  # Too late.
@@ -111,6 +149,7 @@
 
     @gen_test
     def test_wait_timeout_preempted(self):
+        """ """
         c = locks.Condition()
 
         # This fires before the wait times out.
@@ -121,6 +160,7 @@
 
     @gen_test
     def test_notify_n_with_timeout(self):
+        """ """
         # Register callbacks 0, 1, 2, and 3. Callback 1 has a timeout.
         # Wait for that timeout to expire, then do notify(2) and make
         # sure everyone runs. Verifies that a timed-out callback does
@@ -145,6 +185,7 @@
 
     @gen_test
     def test_notify_all_with_timeout(self):
+        """ """
         c = locks.Condition()
         self.record_done(c.wait(), 0)
         self.record_done(c.wait(timedelta(seconds=0.01)), 1)
@@ -160,6 +201,7 @@
 
     @gen_test
     def test_nested_notify(self):
+        """ """
         # Ensure no notifications lost, even if notify() is reentered by a
         # waiter calling notify().
         c = locks.Condition()
@@ -176,6 +218,7 @@
 
     @gen_test
     def test_garbage_collection(self):
+        """ """
         # Test that timed-out waiters are occasionally cleaned from the queue.
         c = locks.Condition()
         for _ in range(101):
@@ -195,7 +238,9 @@
 
 
 class EventTest(AsyncTestCase):
+    """ """
     def test_repr(self):
+        """ """
         event = locks.Event()
         self.assertTrue("clear" in str(event))
         self.assertFalse("set" in str(event))
@@ -204,6 +249,7 @@
         self.assertTrue("set" in str(event))
 
     def test_event(self):
+        """ """
         e = locks.Event()
         future_0 = asyncio.ensure_future(e.wait())
         e.set()
@@ -217,6 +263,7 @@
 
     @gen_test
     def test_event_timeout(self):
+        """ """
         e = locks.Event()
         with self.assertRaises(TimeoutError):
             yield e.wait(timedelta(seconds=0.01))
@@ -226,12 +273,14 @@
         yield e.wait(timedelta(seconds=1))
 
     def test_event_set_multiple(self):
+        """ """
         e = locks.Event()
         e.set()
         e.set()
         self.assertTrue(e.is_set())
 
     def test_event_wait_clear(self):
+        """ """
         e = locks.Event()
         f0 = asyncio.ensure_future(e.wait())
         e.clear()
@@ -242,10 +291,13 @@
 
 
 class SemaphoreTest(AsyncTestCase):
+    """ """
     def test_negative_value(self):
+        """ """
         self.assertRaises(ValueError, locks.Semaphore, value=-1)
 
     def test_repr(self):
+        """ """
         sem = locks.Semaphore()
         self.assertIn("Semaphore", repr(sem))
         self.assertIn("unlocked,value:1", repr(sem))
@@ -256,6 +308,7 @@
         self.assertIn("waiters", repr(sem))
 
     def test_acquire(self):
+        """ """
         sem = locks.Semaphore()
         f0 = asyncio.ensure_future(sem.acquire())
         self.assertTrue(f0.done())
@@ -277,6 +330,7 @@
 
     @gen_test
     def test_acquire_timeout(self):
+        """ """
         sem = locks.Semaphore(2)
         yield sem.acquire()
         yield sem.acquire()
@@ -294,6 +348,7 @@
 
     @gen_test
     def test_acquire_timeout_preempted(self):
+        """ """
         sem = locks.Semaphore(1)
         yield sem.acquire()
 
@@ -304,6 +359,7 @@
         yield acquire  # No TimeoutError.
 
     def test_release_unacquired(self):
+        """ """
         # Unbounded releases are allowed, and increment the semaphore's value.
         sem = locks.Semaphore()
         sem.release()
@@ -317,6 +373,7 @@
 
     @gen_test
     def test_garbage_collection(self):
+        """ """
         # Test that timed-out waiters are occasionally cleaned from the queue.
         sem = locks.Semaphore(value=0)
         futures = [
@@ -342,8 +399,10 @@
 
 
 class SemaphoreContextManagerTest(AsyncTestCase):
+    """ """
     @gen_test
     def test_context_manager(self):
+        """ """
         sem = locks.Semaphore()
         with (yield sem.acquire()) as yielded:
             self.assertTrue(yielded is None)
@@ -353,6 +412,7 @@
 
     @gen_test
     def test_context_manager_async_await(self):
+        """ """
         # Repeat the above test using 'async with'.
         sem = locks.Semaphore()
 
@@ -367,6 +427,7 @@
 
     @gen_test
     def test_context_manager_exception(self):
+        """ """
         sem = locks.Semaphore()
         with self.assertRaises(ZeroDivisionError):
             with (yield sem.acquire()):
@@ -377,6 +438,7 @@
 
     @gen_test
     def test_context_manager_timeout(self):
+        """ """
         sem = locks.Semaphore()
         with (yield sem.acquire(timedelta(seconds=0.01))):
             pass
@@ -386,6 +448,7 @@
 
     @gen_test
     def test_context_manager_timeout_error(self):
+        """ """
         sem = locks.Semaphore(value=0)
         with self.assertRaises(gen.TimeoutError):
             with (yield sem.acquire(timedelta(seconds=0.01))):
@@ -396,11 +459,23 @@
 
     @gen_test
     def test_context_manager_contended(self):
+        """ """
         sem = locks.Semaphore()
         history = []
 
         @gen.coroutine
         def f(index):
+            """
+
+            Parameters
+            ----------
+            index :
+                
+
+            Returns
+            -------
+
+            """
             with (yield sem.acquire()):
                 history.append("acquired %d" % index)
                 yield gen.sleep(0.01)
@@ -416,6 +491,7 @@
 
     @gen_test
     def test_yield_sem(self):
+        """ """
         # Ensure we catch a "with (yield sem)", which should be
         # "with (yield sem.acquire())".
         with self.assertRaises(gen.BadYieldError):
@@ -423,6 +499,7 @@
                 pass
 
     def test_context_manager_misuse(self):
+        """ """
         # Ensure we catch a "with sem", which should be
         # "with (yield sem.acquire())".
         with self.assertRaises(RuntimeError):
@@ -431,7 +508,9 @@
 
 
 class BoundedSemaphoreTest(AsyncTestCase):
+    """ """
     def test_release_unacquired(self):
+        """ """
         sem = locks.BoundedSemaphore()
         self.assertRaises(ValueError, sem.release)
         # Value is 0.
@@ -447,7 +526,9 @@
 
 
 class LockTests(AsyncTestCase):
+    """ """
     def test_repr(self):
+        """ """
         lock = locks.Lock()
         # No errors.
         repr(lock)
@@ -455,6 +536,7 @@
         repr(lock)
 
     def test_acquire_release(self):
+        """ """
         lock = locks.Lock()
         self.assertTrue(asyncio.ensure_future(lock.acquire()).done())
         future = asyncio.ensure_future(lock.acquire())
@@ -464,6 +546,7 @@
 
     @gen_test
     def test_acquire_fifo(self):
+        """ """
         lock = locks.Lock()
         self.assertTrue(asyncio.ensure_future(lock.acquire()).done())
         N = 5
@@ -471,6 +554,17 @@
 
         @gen.coroutine
         def f(idx):
+            """
+
+            Parameters
+            ----------
+            idx :
+                
+
+            Returns
+            -------
+
+            """
             with (yield lock.acquire()):
                 history.append(idx)
 
@@ -482,6 +576,7 @@
 
     @gen_test
     def test_acquire_fifo_async_with(self):
+        """ """
         # Repeat the above test using `async with lock:`
         # instead of `with (yield lock.acquire()):`.
         lock = locks.Lock()
@@ -500,6 +595,7 @@
 
     @gen_test
     def test_acquire_timeout(self):
+        """ """
         lock = locks.Lock()
         lock.acquire()
         with self.assertRaises(gen.TimeoutError):
@@ -509,6 +605,7 @@
         self.assertFalse(asyncio.ensure_future(lock.acquire()).done())
 
     def test_multi_release(self):
+        """ """
         lock = locks.Lock()
         self.assertRaises(RuntimeError, lock.release)
         lock.acquire()
@@ -517,6 +614,7 @@
 
     @gen_test
     def test_yield_lock(self):
+        """ """
         # Ensure we catch a "with (yield lock)", which should be
         # "with (yield lock.acquire())".
         with self.assertRaises(gen.BadYieldError):
@@ -524,6 +622,7 @@
                 pass
 
     def test_context_manager_misuse(self):
+        """ """
         # Ensure we catch a "with lock", which should be
         # "with (yield lock.acquire())".
         with self.assertRaises(RuntimeError):
