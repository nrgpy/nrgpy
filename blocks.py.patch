# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/internals/blocks.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/internals/blocks.py
@@ -85,11 +85,17 @@
 
 
 class Block(PandasObject):
-    """
-    Canonical n-dimensional unit of homogeneous dtype contained in a pandas
+    """Canonical n-dimensional unit of homogeneous dtype contained in a pandas
     data structure
-
+    
     Index-ignorant; let the container take care of that
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     __slots__ = ["_mgr_locs", "values", "ndim"]
@@ -112,8 +118,20 @@
     def _simple_new(
         cls, values: ArrayLike, placement: BlockPlacement, ndim: int
     ) -> "Block":
-        """
-        Fastpath constructor, does *no* validation
+        """Fastpath constructor, does *no* validation
+
+        Parameters
+        ----------
+        values: ArrayLike :
+            
+        placement: BlockPlacement :
+            
+        ndim: int :
+            
+
+        Returns
+        -------
+
         """
         obj = object.__new__(cls)
         obj.ndim = ndim
@@ -133,9 +151,8 @@
             )
 
     def _check_ndim(self, values, ndim):
-        """
-        ndim inference and validation.
-
+        """ndim inference and validation.
+        
         Infers ndim from 'values' if not provided to __init__.
         Validates that values.ndim and ndim are consistent if and only if
         the class variable '_validate_ndim' is True.
@@ -143,15 +160,16 @@
         Parameters
         ----------
         values : array-like
+            
         ndim : int or None
+            
 
         Returns
         -------
         ndim : int
-
-        Raises
-        ------
-        ValueError : the number of dimensions do not match
+            
+
+        
         """
         if ndim is None:
             ndim = values.ndim
@@ -165,86 +183,125 @@
 
     @property
     def _holder(self):
-        """
-        The array-like that can hold the underlying values.
-
+        """The array-like that can hold the underlying values.
+        
         None for 'Block', overridden by subclasses that don't
         use an ndarray.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     @property
     def _consolidate_key(self):
+        """ """
         return (self._can_consolidate, self.dtype.name)
 
     @property
     def is_view(self) -> bool:
-        """ return a boolean if I am possibly a view """
+        """ """
         return self.values.base is not None
 
     @property
     def is_datelike(self) -> bool:
-        """ return True if I am a non-datelike """
+        """ """
         return self.is_datetime or self.is_timedelta
 
     def external_values(self):
-        """
-        The array that Series.values returns (public attribute).
-
+        """The array that Series.values returns (public attribute).
+        
         This has some historical constraints, and is overridden in block
         subclasses to return the correct array (e.g. period returns
         object ndarray and datetimetz a datetime64[ns] ndarray instead of
         proper extension array).
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.values
 
     def internal_values(self):
-        """
-        The array that Series._values returns (internal values).
-        """
+        """The array that Series._values returns (internal values)."""
         return self.values
 
     def array_values(self) -> ExtensionArray:
-        """
-        The array that Series.array returns. Always an ExtensionArray.
-        """
+        """The array that Series.array returns. Always an ExtensionArray."""
         return PandasArray(self.values)
 
     def get_values(self, dtype=None):
         """
-        return an internal format, currently just the ndarray
-        this is often overridden to handle to_dense like operations
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            this is often overridden to handle to_dense like operations
+
         """
         if is_object_dtype(dtype):
             return self.values.astype(object)
         return self.values
 
     def get_block_values_for_json(self) -> np.ndarray:
-        """
-        This is used in the JSON C code.
-        """
+        """This is used in the JSON C code."""
         # TODO(EA2D): reshape will be unnecessary with 2D EAs
         return np.asarray(self.values).reshape(self.shape)
 
     @property
     def fill_value(self):
+        """ """
         return np.nan
 
     @property
     def mgr_locs(self):
+        """ """
         return self._mgr_locs
 
     @mgr_locs.setter
     def mgr_locs(self, new_mgr_locs):
+        """
+
+        Parameters
+        ----------
+        new_mgr_locs :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(new_mgr_locs, libinternals.BlockPlacement):
             new_mgr_locs = libinternals.BlockPlacement(new_mgr_locs)
 
         self._mgr_locs = new_mgr_locs
 
     def make_block(self, values, placement=None) -> "Block":
-        """
-        Create a new block, with type inference propagate any values that are
+        """Create a new block, with type inference propagate any values that are
         not specified
+
+        Parameters
+        ----------
+        values :
+            
+        placement :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if placement is None:
             placement = self.mgr_locs
@@ -254,7 +311,21 @@
         return make_block(values, placement=placement, ndim=self.ndim)
 
     def make_block_same_class(self, values, placement=None, ndim=None):
-        """ Wrap given values in a block of same type as self. """
+        """Wrap given values in a block of same type as self.
+
+        Parameters
+        ----------
+        values :
+            
+        placement :
+             (Default value = None)
+        ndim :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if placement is None:
             placement = self.mgr_locs
         if ndim is None:
@@ -285,15 +356,37 @@
         self.ndim = self.values.ndim
 
     def _slice(self, slicer):
-        """ return a slice of my values """
+        """
+
+        Parameters
+        ----------
+        slicer :
+            
+
+        Returns
+        -------
+        type
+            
+
+        """
 
         return self.values[slicer]
 
     def getitem_block(self, slicer, new_mgr_locs=None):
-        """
-        Perform __getitem__-like, return result as block.
-
+        """Perform __getitem__-like, return result as block.
+        
         As of now, only supports slices that preserve dimensionality.
+
+        Parameters
+        ----------
+        slicer :
+            
+        new_mgr_locs :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if new_mgr_locs is None:
             axis0_slicer = slicer[0] if isinstance(slicer, tuple) else slicer
@@ -310,18 +403,40 @@
 
     @property
     def shape(self):
+        """ """
         return self.values.shape
 
     @property
     def dtype(self):
+        """ """
         return self.values.dtype
 
     def iget(self, i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         return self.values[i]
 
     def set(self, locs, values):
-        """
-        Modify block values in-place with new item value.
+        """Modify block values in-place with new item value.
+
+        Parameters
+        ----------
+        locs :
+            
+        values :
+            
+
+        Returns
+        -------
 
         Notes
         -----
@@ -331,16 +446,34 @@
         self.values[locs] = values
 
     def delete(self, loc) -> None:
-        """
-        Delete given loc(-s) from block in-place.
+        """Delete given loc(-s) from block in-place.
+
+        Parameters
+        ----------
+        loc :
+            
+
+        Returns
+        -------
+
         """
         self.values = np.delete(self.values, loc, 0)
         self.mgr_locs = self.mgr_locs.delete(loc)
 
     def apply(self, func, **kwargs) -> List["Block"]:
-        """
-        apply the function to my values; return a block if we are not
+        """apply the function to my values; return a block if we are not
         one
+
+        Parameters
+        ----------
+        func :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         with np.errstate(all="ignore"):
             result = func(self.values, **kwargs)
@@ -348,6 +481,17 @@
         return self._split_op_result(result)
 
     def _split_op_result(self, result) -> List["Block"]:
+        """
+
+        Parameters
+        ----------
+        result :
+            
+
+        Returns
+        -------
+
+        """
         # See also: split_and_operate
         if is_extension_array_dtype(result) and result.ndim > 1:
             # TODO(EA2D): unnecessary with 2D EAs
@@ -367,9 +511,23 @@
     def fillna(
         self, value, limit=None, inplace: bool = False, downcast=None
     ) -> List["Block"]:
-        """
-        fillna on the block with the value. If we fail, then convert to
+        """fillna on the block with the value. If we fail, then convert to
         ObjectBlock and try again
+
+        Parameters
+        ----------
+        value :
+            
+        limit :
+             (Default value = None)
+        inplace: bool :
+             (Default value = False)
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         inplace = validate_bool_kwarg(inplace, "inplace")
 
@@ -395,6 +553,21 @@
 
         # operate column-by-column
         def f(mask, val, idx):
+            """
+
+            Parameters
+            ----------
+            mask :
+                
+            val :
+                
+            idx :
+                
+
+            Returns
+            -------
+
+            """
             block = self.coerce_to_target_dtype(value)
 
             # slice out our block
@@ -406,20 +579,25 @@
         return self.split_and_operate(None, f, inplace)
 
     def split_and_operate(self, mask, f, inplace: bool) -> List["Block"]:
-        """
-        split the block per-column, and apply the callable f
+        """split the block per-column, and apply the callable f
         per-column, return a new block for each. Handle
         masking which will not change a block unless needed.
 
         Parameters
         ----------
         mask : 2-d boolean mask
+            
         f : callable accepting (1d-mask, 1d values, indexer)
+            
         inplace : boolean
-
-        Returns
-        -------
-        list of blocks
+            
+        inplace: bool :
+            
+
+        Returns
+        -------
+
+        
         """
         if mask is None:
             mask = np.broadcast_to(True, shape=self.shape)
@@ -427,6 +605,19 @@
         new_values = self.values
 
         def make_a_block(nv, ref_loc):
+            """
+
+            Parameters
+            ----------
+            nv :
+                
+            ref_loc :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(nv, list):
                 assert len(nv) == 1, nv
                 assert isinstance(nv[0], Block)
@@ -465,6 +656,19 @@
         return new_blocks
 
     def _maybe_downcast(self, blocks: List["Block"], downcast=None) -> List["Block"]:
+        """
+
+        Parameters
+        ----------
+        blocks: List["Block"] :
+            
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         # no need to downcast our float
         # unless indicated
@@ -476,7 +680,17 @@
         return _extend_blocks([b.downcast(downcast) for b in blocks])
 
     def downcast(self, dtypes=None):
-        """ try to downcast each item to the dict of dtypes if present """
+        """try to downcast each item to the dict of dtypes if present
+
+        Parameters
+        ----------
+        dtypes :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # turn it off completely
         if dtypes is False:
             return self
@@ -506,27 +720,47 @@
         # operate column-by-column
         # this is expensive as it splits the blocks items-by-item
         def f(mask, val, idx):
+            """
+
+            Parameters
+            ----------
+            mask :
+                
+            val :
+                
+            idx :
+                
+
+            Returns
+            -------
+
+            """
             val = maybe_downcast_to_dtype(val, dtype="infer")
             return val
 
         return self.split_and_operate(None, f, False)
 
     def astype(self, dtype, copy: bool = False, errors: str = "raise"):
-        """
-        Coerce to the new dtype.
+        """Coerce to the new dtype.
 
         Parameters
         ----------
         dtype : str, dtype convertible
+            
         copy : bool, default False
             copy if indicated
         errors : str, {'raise', 'ignore'}, default 'ignore'
             - ``raise`` : allow exceptions to be raised
             - ``ignore`` : suppress exceptions. On error return original object
-
-        Returns
-        -------
-        Block
+        copy: bool :
+             (Default value = False)
+        errors: str :
+             (Default value = "raise")
+
+        Returns
+        -------
+
+        
         """
         errors_legal_values = ("raise", "ignore")
 
@@ -624,15 +858,41 @@
         timedelta: bool = True,
         coerce: bool = False,
     ):
-        """
-        attempt to coerce any object types to better types return a copy
+        """attempt to coerce any object types to better types return a copy
         of the block (if copy = True) by definition we are not an ObjectBlock
         here!
+
+        Parameters
+        ----------
+        copy: bool :
+             (Default value = True)
+        datetime: bool :
+             (Default value = True)
+        numeric: bool :
+             (Default value = True)
+        timedelta: bool :
+             (Default value = True)
+        coerce: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         return self.copy() if copy else self
 
     def _can_hold_element(self, element: Any) -> bool:
-        """ require the same dtype as ourselves """
+        """require the same dtype as ourselves
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         dtype = self.values.dtype.type
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
@@ -640,21 +900,38 @@
         return isinstance(element, dtype)
 
     def should_store(self, value: ArrayLike) -> bool:
-        """
-        Should we set self.values[indexer] = value inplace or do we need to cast?
+        """Should we set self.values[indexer] = value inplace or do we need to cast?
 
         Parameters
         ----------
         value : np.ndarray or ExtensionArray
-
-        Returns
-        -------
-        bool
+            
+        value: ArrayLike :
+            
+
+        Returns
+        -------
+
+        
         """
         return is_dtype_equal(value.dtype, self.dtype)
 
     def to_native_types(self, na_rep="nan", quoting=None, **kwargs):
-        """ convert to our native types format """
+        """convert to our native types format
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "nan")
+        quoting :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         values = self.values
 
         mask = isna(values)
@@ -673,7 +950,17 @@
 
     # block actions #
     def copy(self, deep: bool = True):
-        """ copy constructor """
+        """copy constructor
+
+        Parameters
+        ----------
+        deep: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         values = self.values
         if deep:
             values = values.copy()
@@ -687,10 +974,26 @@
         regex: bool = False,
         convert: bool = True,
     ):
-        """
-        replace the to_replace value with value, possible to create new
+        """replace the to_replace value with value, possible to create new
         blocks here this is just a call to putmask. regex is not used here.
         It is used in ObjectBlocks.  It is here for API compatibility.
+
+        Parameters
+        ----------
+        to_replace :
+            
+        value :
+            
+        inplace: bool :
+             (Default value = False)
+        regex: bool :
+             (Default value = False)
+        convert: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         inplace = validate_bool_kwarg(inplace, "inplace")
         original_to_replace = to_replace
@@ -776,12 +1079,23 @@
         return blocks
 
     def _replace_single(self, *args, **kwargs):
-        """ no-op on a non-ObjectBlock """
+        """no-op on a non-ObjectBlock
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self if kwargs["inplace"] else self.copy()
 
     def setitem(self, indexer, value):
-        """
-        Attempt self.values[indexer] = value, possibly creating a new array.
+        """Attempt self.values[indexer] = value, possibly creating a new array.
 
         Parameters
         ----------
@@ -793,6 +1107,7 @@
         Returns
         -------
         Block
+            
 
         Notes
         -----
@@ -898,25 +1213,34 @@
     def putmask(
         self, mask, new, inplace: bool = False, axis: int = 0, transpose: bool = False,
     ) -> List["Block"]:
-        """
-        putmask the data to the block; it is possible that we may create a
+        """putmask the data to the block; it is possible that we may create a
         new dtype of block
-
+        
         Return the resulting block(s).
 
         Parameters
         ----------
         mask : np.ndarray[bool], SparseArray[bool], or BooleanArray
+            
         new : a ndarray/object
+            
         inplace : bool, default False
             Perform inplace modification.
         axis : int
+            
         transpose : bool, default False
             Set to True if self is stored with axes reversed.
-
-        Returns
-        -------
-        List[Block]
+        inplace: bool :
+             (Default value = False)
+        axis: int :
+             (Default value = 0)
+        transpose: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         mask = _extract_bool_array(mask)
         assert not isinstance(new, (ABCIndexClass, ABCSeries, ABCDataFrame))
@@ -989,6 +1313,21 @@
 
             # operate column-by-column
             def f(mask, val, idx):
+                """
+
+                Parameters
+                ----------
+                mask :
+                    
+                val :
+                    
+                idx :
+                    
+
+                Returns
+                -------
+
+                """
 
                 if idx is None:
                     # ndim==1 case.
@@ -1023,12 +1362,20 @@
         return [self.make_block(new_values)]
 
     def coerce_to_target_dtype(self, other):
-        """
-        coerce the current block to a dtype compat for other
+        """coerce the current block to a dtype compat for other
         we will return a block, possibly object, and not raise
-
+        
         we can also safely try to coerce to the same dtype
         and will receive the same block
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
         """
         # if we cannot then coerce to object
         dtype, _ = infer_dtype_from(other, pandas_dtype=True)
@@ -1099,6 +1446,37 @@
         downcast: Optional[str] = None,
         **kwargs,
     ):
+        """
+
+        Parameters
+        ----------
+        method: str :
+             (Default value = "pad")
+        axis: int :
+             (Default value = 0)
+        index: Optional["Index"] :
+             (Default value = None)
+        inplace: bool :
+             (Default value = False)
+        limit: Optional[int] :
+             (Default value = None)
+        limit_direction: str :
+             (Default value = "forward")
+        limit_area: Optional[str] :
+             (Default value = None)
+        fill_value: Optional[Any] :
+             (Default value = None)
+        coerce: bool :
+             (Default value = False)
+        downcast: Optional[str] :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         inplace = validate_bool_kwarg(inplace, "inplace")
 
@@ -1150,7 +1528,29 @@
         coerce: bool = False,
         downcast: Optional[str] = None,
     ) -> List["Block"]:
-        """ fillna but using the interpolate machinery """
+        """fillna but using the interpolate machinery
+
+        Parameters
+        ----------
+        method: str :
+             (Default value = "pad")
+        axis: int :
+             (Default value = 0)
+        inplace: bool :
+             (Default value = False)
+        limit: Optional[int] :
+             (Default value = None)
+        fill_value: Optional[Any] :
+             (Default value = None)
+        coerce: bool :
+             (Default value = False)
+        downcast: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         inplace = validate_bool_kwarg(inplace, "inplace")
 
         # if we are coercing, then don't force the conversion
@@ -1192,7 +1592,35 @@
         downcast: Optional[str] = None,
         **kwargs,
     ) -> List["Block"]:
-        """ interpolate using scipy wrappers """
+        """interpolate using scipy wrappers
+
+        Parameters
+        ----------
+        method: str :
+            
+        index: "Index" :
+            
+        fill_value: Optional[Any] :
+             (Default value = None)
+        axis: int :
+             (Default value = 0)
+        limit: Optional[int] :
+             (Default value = None)
+        limit_direction: str :
+             (Default value = "forward")
+        limit_area: Optional[str] :
+             (Default value = None)
+        inplace: bool :
+             (Default value = False)
+        downcast: Optional[str] :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         inplace = validate_bool_kwarg(inplace, "inplace")
         data = self.values if inplace else self.values.copy()
 
@@ -1213,6 +1641,17 @@
         # process 1-d slices in the axis direction
 
         def func(yvalues: np.ndarray) -> np.ndarray:
+            """
+
+            Parameters
+            ----------
+            yvalues: np.ndarray :
+                
+
+            Returns
+            -------
+
+            """
 
             # process a 1-d slice, returning it
             # should the axis argument be handled below in apply_along_axis?
@@ -1236,8 +1675,21 @@
         return self._maybe_downcast(blocks, downcast)
 
     def take_nd(self, indexer, axis: int, new_mgr_locs=None, fill_value=lib.no_default):
-        """
-        Take values according to indexer and return them as a block.bb
+        """Take values according to indexer and return them as a block.bb
+
+        Parameters
+        ----------
+        indexer :
+            
+        axis: int :
+            
+        new_mgr_locs :
+             (Default value = None)
+        fill_value :
+             (Default value = lib.no_default)
+
+        Returns
+        -------
 
         """
         # algos.take_nd dispatches for DatetimeTZBlock, CategoricalBlock
@@ -1268,12 +1720,40 @@
             return self.make_block_same_class(new_values, new_mgr_locs)
 
     def diff(self, n: int, axis: int = 1) -> List["Block"]:
-        """ return block for the diff of the values """
+        """
+
+        Parameters
+        ----------
+        n: int :
+            
+        axis: int :
+             (Default value = 1)
+
+        Returns
+        -------
+        type
+            
+
+        """
         new_values = algos.diff(self.values, n, axis=axis, stacklevel=7)
         return [self.make_block(values=new_values)]
 
     def shift(self, periods: int, axis: int = 0, fill_value=None):
-        """ shift the block by periods, possibly upcast """
+        """shift the block by periods, possibly upcast
+
+        Parameters
+        ----------
+        periods: int :
+            
+        axis: int :
+             (Default value = 0)
+        fill_value :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # convert integer to float if necessary. need to do a lot more than
         # that, handle boolean etc also
         new_values, fill_value = maybe_upcast(self.values, fill_value)
@@ -1285,21 +1765,28 @@
     def where(
         self, other, cond, errors="raise", try_cast: bool = False, axis: int = 0,
     ) -> List["Block"]:
-        """
-        evaluate the block; return result block(s) from the result
+        """evaluate the block; return result block(s) from the result
 
         Parameters
         ----------
         other : a ndarray/object
+            
         cond : np.ndarray[bool], SparseArray[bool], or BooleanArray
+            
         errors : str, {'raise', 'ignore'}, default 'raise'
             - ``raise`` : allow exceptions to be raised
-            - ``ignore`` : suppress exceptions. On error return original object
+            - ``ignore`` : suppress exceptions. On error return original object (Default value = "raise")
         axis : int, default 0
-
-        Returns
-        -------
-        List[Block]
+            
+        try_cast: bool :
+             (Default value = False)
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        
         """
         import pandas.core.computation.expressions as expressions
 
@@ -1326,6 +1813,21 @@
             raise ValueError("where must have a condition that is ndarray like")
 
         def where_func(cond, values, other):
+            """
+
+            Parameters
+            ----------
+            cond :
+                
+            values :
+                
+            other :
+                
+
+            Returns
+            -------
+
+            """
 
             if not (
                 (self.is_integer or self.is_bool)
@@ -1384,21 +1886,21 @@
         return result_blocks
 
     def _unstack(self, unstacker, fill_value, new_placement):
-        """
-        Return a list of unstacked blocks of self
+        """Return a list of unstacked blocks of self
 
         Parameters
         ----------
         unstacker : reshape._Unstacker
+            
         fill_value : int
             Only used in ExtensionBlock._unstack
-
-        Returns
-        -------
-        blocks : list of Block
-            New blocks of unstacked values.
-        mask : array_like of bool
-            The mask of columns of `blocks` we should keep.
+        new_placement :
+            
+
+        Returns
+        -------
+
+        
         """
         new_values, mask = unstacker.get_new_values(
             self.values.T, fill_value=fill_value
@@ -1414,18 +1916,23 @@
         return blocks, mask
 
     def quantile(self, qs, interpolation="linear", axis: int = 0):
-        """
-        compute the quantiles of the
-
-        Parameters
-        ----------
-        qs: a scalar or list of the quantiles to be computed
-        interpolation: type of interpolation, default 'linear'
-        axis: axis to compute, default 0
-
-        Returns
-        -------
-        Block
+        """compute the quantiles of the
+
+        Parameters
+        ----------
+        qs : a scalar or list of the quantiles to be computed
+            
+        interpolation : type of interpolation, default 'linear'
+             (Default value = "linear")
+        axis : axis to compute, default 0
+            
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        
         """
         # We should always have ndim == 2 because Series dispatches to DataFrame
         assert self.ndim == 2
@@ -1478,8 +1985,7 @@
         convert: bool = False,
         mask=None,
     ):
-        """
-        Replace value corresponding to the given boolean array with another
+        """Replace value corresponding to the given boolean array with another
         value.
 
         Parameters
@@ -1495,11 +2001,18 @@
         convert : bool, default True
             If true, try to coerce any object types to better types.
         mask : array-like of bool, optional
-            True indicate corresponding element is ignored.
-
-        Returns
-        -------
-        A new block if there is anything to replace or the original block.
+            True indicate corresponding element is ignored. (Default value = None)
+        inplace: bool :
+             (Default value = True)
+        regex: bool :
+             (Default value = False)
+        convert: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         if mask.any():
             if not regex:
@@ -1518,16 +2031,7 @@
 
 
 class ExtensionBlock(Block):
-    """
-    Block for holding extension types.
-
-    Notes
-    -----
-    This holds all 3rd-party extension array types. It's also the immediate
-    parent class for our internal extension types' blocks, CategoricalBlock.
-
-    ExtensionArrays are limited to 1-D.
-    """
+    """Block for holding extension types."""
 
     _can_consolidate = False
     _validate_ndim = False
@@ -1563,12 +2067,24 @@
 
     @property
     def shape(self):
+        """ """
         # TODO(EA2D): override unnecessary with 2D EAs
         if self.ndim == 1:
             return ((len(self.values)),)
         return (len(self.mgr_locs), len(self.values))
 
     def iget(self, col):
+        """
+
+        Parameters
+        ----------
+        col :
+            
+
+        Returns
+        -------
+
+        """
 
         if self.ndim == 2 and isinstance(col, tuple):
             # TODO(EA2D): unnecessary with 2D EAs
@@ -1586,20 +2102,57 @@
             return self.values
 
     def should_store(self, value: ArrayLike) -> bool:
-        """
-        Can we set the given array-like value inplace?
+        """Can we set the given array-like value inplace?
+
+        Parameters
+        ----------
+        value: ArrayLike :
+            
+
+        Returns
+        -------
+
         """
         return isinstance(value, self._holder)
 
     def set(self, locs, values):
+        """
+
+        Parameters
+        ----------
+        locs :
+            
+        values :
+            
+
+        Returns
+        -------
+
+        """
         assert locs.tolist() == [0]
         self.values = values
 
     def putmask(
         self, mask, new, inplace: bool = False, axis: int = 0, transpose: bool = False,
     ) -> List["Block"]:
-        """
-        See Block.putmask.__doc__
+        """See Block.putmask.__doc__
+
+        Parameters
+        ----------
+        mask :
+            
+        new :
+            
+        inplace: bool :
+             (Default value = False)
+        axis: int :
+             (Default value = 0)
+        transpose: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         inplace = validate_bool_kwarg(inplace, "inplace")
 
@@ -1616,34 +2169,38 @@
         return [self.make_block(values=new_values)]
 
     def _maybe_coerce_values(self, values):
-        """
-        Unbox to an extension array.
-
+        """Unbox to an extension array.
+        
         This will unbox an ExtensionArray stored in an Index or Series.
         ExtensionArrays pass through. No dtype coercion is done.
 
         Parameters
         ----------
         values : Index, Series, ExtensionArray
-
-        Returns
-        -------
-        ExtensionArray
+            
+
+        Returns
+        -------
+
+        
         """
         return extract_array(values)
 
     @property
     def _holder(self):
+        """ """
         # For extension blocks, the holder is values-dependent.
         return type(self.values)
 
     @property
     def fill_value(self):
+        """ """
         # Used in reindex_indexer
         return self.values.dtype.na_value
 
     @property
     def _can_hold_na(self):
+        """ """
         # The default ExtensionArray._can_hold_na is True
         return self._holder._can_hold_na
 
@@ -1654,12 +2211,12 @@
 
     @property
     def is_numeric(self):
+        """ """
         return self.values.dtype._is_numeric
 
     def setitem(self, indexer, value):
-        """
-        Attempt self.values[indexer] = value, possibly creating a new array.
-
+        """Attempt self.values[indexer] = value, possibly creating a new array.
+        
         This differs from Block.setitem by not allowing setitem to change
         the dtype of the Block.
 
@@ -1673,6 +2230,7 @@
         Returns
         -------
         Block
+            
 
         Notes
         -----
@@ -1689,15 +2247,41 @@
         return self
 
     def get_values(self, dtype=None):
+        """
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # ExtensionArrays must be iterable, so this works.
         # TODO(EA2D): reshape not needed with 2D EAs
         return np.asarray(self.values).reshape(self.shape)
 
     def array_values(self) -> ExtensionArray:
+        """ """
         return self.values
 
     def to_native_types(self, na_rep="nan", quoting=None, **kwargs):
-        """override to use ExtensionArray astype for the conversion"""
+        """override to use ExtensionArray astype for the conversion
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "nan")
+        quoting :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         values = self.values
         mask = isna(values)
 
@@ -1711,8 +2295,22 @@
     def take_nd(
         self, indexer, axis: int = 0, new_mgr_locs=None, fill_value=lib.no_default
     ):
-        """
-        Take values according to indexer and return them as a block.
+        """Take values according to indexer and return them as a block.
+
+        Parameters
+        ----------
+        indexer :
+            
+        axis: int :
+             (Default value = 0)
+        new_mgr_locs :
+             (Default value = None)
+        fill_value :
+             (Default value = lib.no_default)
+
+        Returns
+        -------
+
         """
         if fill_value is lib.no_default:
             fill_value = None
@@ -1732,13 +2330,23 @@
         return self.make_block_same_class(new_values, new_mgr_locs)
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: We may need to think about pushing this onto the array.
         # We're doing the same as CategoricalBlock here.
         return True
 
     def _slice(self, slicer):
-        """
-        Return a slice of my values.
+        """Return a slice of my values.
 
         Parameters
         ----------
@@ -1747,7 +2355,8 @@
 
         Returns
         -------
-        np.ndarray or ExtensionArray
+
+        
         """
         # return same dims as we currently have
         if not isinstance(slicer, tuple) and self.ndim == 2:
@@ -1775,6 +2384,23 @@
         return self.values[slicer]
 
     def fillna(self, value, limit=None, inplace=False, downcast=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        limit :
+             (Default value = None)
+        inplace :
+             (Default value = False)
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         values = self.values if inplace else self.values.copy()
         values = values.fillna(value=value, limit=limit)
         return [
@@ -1786,6 +2412,27 @@
     def interpolate(
         self, method="pad", axis=0, inplace=False, limit=None, fill_value=None, **kwargs
     ):
+        """
+
+        Parameters
+        ----------
+        method :
+             (Default value = "pad")
+        axis :
+             (Default value = 0)
+        inplace :
+             (Default value = False)
+        limit :
+             (Default value = None)
+        fill_value :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         values = self.values if inplace else self.values.copy()
         return self.make_block_same_class(
@@ -1794,6 +2441,19 @@
         )
 
     def diff(self, n: int, axis: int = 1) -> List["Block"]:
+        """
+
+        Parameters
+        ----------
+        n: int :
+            
+        axis: int :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         if axis == 0 and n != 0:
             # n==0 case will be a no-op so let is fall through
             # Since we only have one column, the result will be all-NA.
@@ -1809,11 +2469,23 @@
     def shift(
         self, periods: int, axis: int = 0, fill_value: Any = None,
     ) -> List["ExtensionBlock"]:
-        """
-        Shift the block by `periods`.
-
+        """Shift the block by `periods`.
+        
         Dispatches to underlying ExtensionArray and re-boxes in an
         ExtensionBlock.
+
+        Parameters
+        ----------
+        periods: int :
+            
+        axis: int :
+             (Default value = 0)
+        fill_value: Any :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         return [
             self.make_block_same_class(
@@ -1826,6 +2498,25 @@
     def where(
         self, other, cond, errors="raise", try_cast: bool = False, axis: int = 0,
     ) -> List["Block"]:
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        cond :
+            
+        errors :
+             (Default value = "raise")
+        try_cast: bool :
+             (Default value = False)
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
 
         cond = _extract_bool_array(cond)
         assert not isinstance(other, (ABCIndexClass, ABCSeries, ABCDataFrame))
@@ -1873,6 +2564,21 @@
         return [self.make_block_same_class(result, placement=self.mgr_locs)]
 
     def _unstack(self, unstacker, fill_value, new_placement):
+        """
+
+        Parameters
+        ----------
+        unstacker :
+            
+        fill_value :
+            
+        new_placement :
+            
+
+        Returns
+        -------
+
+        """
         # ExtensionArray-safe unstack.
         # We override ObjectBlock._unstack, which unstacks directly on the
         # values of the array. For EA-backed blocks, this would require
@@ -1897,32 +2603,53 @@
 
 
 class ObjectValuesExtensionBlock(ExtensionBlock):
-    """
-    Block providing backwards-compatibility for `.values`.
-
+    """Block providing backwards-compatibility for `.values`.
+    
     Used by PeriodArray and IntervalArray to ensure that
     Series[T].values is an ndarray of objects.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def external_values(self):
+        """ """
         return self.values.astype(object)
 
 
 class NumericBlock(Block):
+    """ """
     __slots__ = ()
     is_numeric = True
     _can_hold_na = True
 
 
 class FloatOrComplexBlock(NumericBlock):
+    """ """
     __slots__ = ()
 
 
 class FloatBlock(FloatOrComplexBlock):
+    """ """
     __slots__ = ()
     is_float = True
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             return issubclass(tipo.type, (np.floating, np.integer)) and not issubclass(
@@ -1938,7 +2665,25 @@
     def to_native_types(
         self, na_rep="", float_format=None, decimal=".", quoting=None, **kwargs,
     ):
-        """ convert to our native types format """
+        """convert to our native types format
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "")
+        float_format :
+             (Default value = None)
+        decimal :
+             (Default value = ".")
+        quoting :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         values = self.values
 
         # see gh-13418: no special formatting is desired at the
@@ -1969,10 +2714,22 @@
 
 
 class ComplexBlock(FloatOrComplexBlock):
+    """ """
     __slots__ = ()
     is_complex = True
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             return issubclass(tipo.type, (np.floating, np.integer, np.complexfloating))
@@ -1981,15 +2738,38 @@
         ) and not isinstance(element, (bool, np.bool_))
 
     def should_store(self, value: ArrayLike) -> bool:
+        """
+
+        Parameters
+        ----------
+        value: ArrayLike :
+            
+
+        Returns
+        -------
+
+        """
         return issubclass(value.dtype.type, np.complexfloating)
 
 
 class IntBlock(NumericBlock):
+    """ """
     __slots__ = ()
     is_integer = True
     _can_hold_na = False
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             return (
@@ -2007,15 +2787,27 @@
 
     @property
     def _holder(self):
+        """ """
         return DatetimeArray
 
     @property
     def fill_value(self):
+        """ """
         return np.datetime64("NaT", "ns")
 
     def get_values(self, dtype=None):
         """
-        return object dtype as boxed values, such as Timestamps/Timedelta
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            
+
         """
         if is_object_dtype(dtype):
             # DTA/TDA constructor and astype can handle 2D
@@ -2023,18 +2815,46 @@
         return self.values
 
     def internal_values(self):
+        """ """
         # Override to return DatetimeArray and TimedeltaArray
         return self.array_values()
 
     def array_values(self):
+        """ """
         return self._holder._simple_new(self.values)
 
     def iget(self, key):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        """
         # GH#31649 we need to wrap scalars in Timestamp/Timedelta
         # TODO(EA2D): this can be removed if we ever have 2D EA
         return self.array_values().reshape(self.shape)[key]
 
     def shift(self, periods, axis=0, fill_value=None):
+        """
+
+        Parameters
+        ----------
+        periods :
+            
+        axis :
+             (Default value = 0)
+        fill_value :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # TODO(EA2D) this is unnecessary if these blocks are backed by 2D EAs
         values = self.array_values()
         new_values = values.shift(periods, fill_value=fill_value, axis=axis)
@@ -2042,6 +2862,7 @@
 
 
 class DatetimeBlock(DatetimeLikeBlockMixin, Block):
+    """ """
     __slots__ = ()
     is_datetime = True
 
@@ -2051,11 +2872,11 @@
 
     @property
     def _can_hold_na(self):
+        """ """
         return True
 
     def _maybe_coerce_values(self, values):
-        """
-        Input validation for values passed to __init__. Ensure that
+        """Input validation for values passed to __init__. Ensure that
         we have datetime64ns, coercing if necessary.
 
         Parameters
@@ -2065,9 +2886,8 @@
 
         Returns
         -------
-        values : ndarray[datetime64ns]
-
-        Overridden by DatetimeTZBlock.
+
+        
         """
         if values.dtype != DT64NS_DTYPE:
             values = conversion.ensure_datetime64ns(values)
@@ -2079,9 +2899,20 @@
         return values
 
     def astype(self, dtype, copy: bool = False, errors: str = "raise"):
-        """
-        these automatically copy, so copy=True has no effect
-        raise on an except if raise == True
+        """these automatically copy, so copy=True has no effect
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy: bool :
+             (Default value = False)
+        errors: str :
+             (Default value = "raise")
+
+        Returns
+        -------
+
         """
         dtype = pandas_dtype(dtype)
 
@@ -2100,6 +2931,17 @@
         return super().astype(dtype=dtype, copy=copy, errors=errors)
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             if self.is_datetimetz:
@@ -2120,7 +2962,21 @@
         return is_valid_nat_for_dtype(element, self.dtype)
 
     def to_native_types(self, na_rep="NaT", date_format=None, **kwargs):
-        """ convert to our native types format """
+        """convert to our native types format
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "NaT")
+        date_format :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         dta = self.array_values()
 
         result = dta._format_native_types(
@@ -2129,8 +2985,18 @@
         return np.atleast_2d(result)
 
     def set(self, locs, values):
-        """
-        See Block.set.__doc__
+        """See Block.set.__doc__
+
+        Parameters
+        ----------
+        locs :
+            
+        values :
+            
+
+        Returns
+        -------
+
         """
         values = conversion.ensure_datetime64ns(values, copy=False)
 
@@ -2138,7 +3004,7 @@
 
 
 class DatetimeTZBlock(ExtensionBlock, DatetimeBlock):
-    """ implement a datetime64 block with a tz attribute """
+    """implement a datetime64 block with a tz attribute"""
 
     __slots__ = ()
     is_datetimetz = True
@@ -2153,11 +3019,11 @@
 
     @property
     def _holder(self):
+        """ """
         return DatetimeArray
 
     def _maybe_coerce_values(self, values):
-        """
-        Input validation for values passed to __init__. Ensure that
+        """Input validation for values passed to __init__. Ensure that
         we have datetime64TZ, coercing if necessary.
 
         Parameters
@@ -2167,7 +3033,8 @@
 
         Returns
         -------
-        values : DatetimeArray
+
+        
         """
         if not isinstance(values, self._holder):
             values = self._holder(values)
@@ -2179,30 +3046,23 @@
 
     @property
     def is_view(self) -> bool:
-        """ return a boolean if I am possibly a view """
+        """ """
         # check the ndarray values of the DatetimeIndex values
         return self.values._data.base is not None
 
     def get_values(self, dtype=None):
-        """
-        Returns an ndarray of values.
+        """Returns an ndarray of values.
 
         Parameters
         ----------
         dtype : np.dtype
             Only `object`-like dtypes are respected here (not sure
-            why).
-
-        Returns
-        -------
-        values : ndarray
-            When ``dtype=object``, then and object-dtype ndarray of
-            boxed values is returned. Otherwise, an M8[ns] ndarray
-            is returned.
-
-            DatetimeArray is always 1-d. ``get_values`` will reshape
-            the return value to be the same dimensionality as the
-            block.
+            why). (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         values = self.values
         if is_object_dtype(dtype):
@@ -2215,13 +3075,13 @@
         return np.asarray(values).reshape(self.shape)
 
     def external_values(self):
+        """ """
         # NB: this is different from np.asarray(self.values), since that
         #  return an object-dtype ndarray of Timestamps.
         return np.asarray(self.values.astype("datetime64[ns]", copy=False))
 
     def diff(self, n: int, axis: int = 0) -> List["Block"]:
-        """
-        1st discrete difference.
+        """1st discrete difference.
 
         Parameters
         ----------
@@ -2229,10 +3089,15 @@
             Number of periods to diff.
         axis : int, default 0
             Axis to diff upon.
+        n: int :
+            
+        axis: int :
+             (Default value = 0)
 
         Returns
         -------
         A list with a new TimeDeltaBlock.
+            
 
         Notes
         -----
@@ -2257,6 +3122,23 @@
         return [TimeDeltaBlock(new_values, placement=self.mgr_locs.indexer)]
 
     def fillna(self, value, limit=None, inplace=False, downcast=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        limit :
+             (Default value = None)
+        inplace :
+             (Default value = False)
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # We support filling a DatetimeTZ with a `value` whose timezone
         # is different by coercing to object.
         if self._can_hold_element(value):
@@ -2268,6 +3150,19 @@
         )
 
     def setitem(self, indexer, value):
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+        value :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/24020
         # Need a dedicated setitem until #24020 (type promotion in setitem
         # for extension arrays) is designed and implemented.
@@ -2283,6 +3178,21 @@
         return newb.setitem(indexer, value)
 
     def quantile(self, qs, interpolation="linear", axis=0):
+        """
+
+        Parameters
+        ----------
+        qs :
+            
+        interpolation :
+             (Default value = "linear")
+        axis :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         naive = self.values.view("M8[ns]")
 
         # TODO(EA2D): kludge for 2D block with 1D values
@@ -2297,6 +3207,7 @@
 
 
 class TimeDeltaBlock(DatetimeLikeBlockMixin, IntBlock):
+    """ """
     __slots__ = ()
     is_timedelta = True
     _can_hold_na = True
@@ -2314,9 +3225,21 @@
 
     @property
     def _holder(self):
+        """ """
         return TimedeltaArray
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             return issubclass(tipo.type, np.timedelta64)
@@ -2327,6 +3250,19 @@
         return is_valid_nat_for_dtype(element, self.dtype)
 
     def fillna(self, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         # allow filling with integers to be
         # interpreted as nanoseconds
@@ -2340,23 +3276,66 @@
         return super().fillna(value, **kwargs)
 
     def to_native_types(self, na_rep="NaT", **kwargs):
-        """ convert to our native types format """
+        """convert to our native types format
+
+        Parameters
+        ----------
+        na_rep :
+             (Default value = "NaT")
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         tda = self.array_values()
         return tda._format_native_types(na_rep, **kwargs)
 
 
 class BoolBlock(NumericBlock):
+    """ """
     __slots__ = ()
     is_bool = True
     _can_hold_na = False
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         tipo = maybe_infer_dtype_type(element)
         if tipo is not None:
             return issubclass(tipo.type, np.bool_)
         return isinstance(element, (bool, np.bool_))
 
     def replace(self, to_replace, value, inplace=False, regex=False, convert=True):
+        """
+
+        Parameters
+        ----------
+        to_replace :
+            
+        value :
+            
+        inplace :
+             (Default value = False)
+        regex :
+             (Default value = False)
+        convert :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         inplace = validate_bool_kwarg(inplace, "inplace")
         to_replace_values = np.atleast_1d(to_replace)
         if not np.can_cast(to_replace_values, bool):
@@ -2367,6 +3346,7 @@
 
 
 class ObjectBlock(Block):
+    """ """
     __slots__ = ()
     is_object = True
     _can_hold_na = True
@@ -2379,9 +3359,15 @@
 
     @property
     def is_bool(self):
-        """
-        we can be a bool if we have only bool values but are of type
+        """we can be a bool if we have only bool values but are of type
         object
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return lib.is_bool_array(self.values.ravel("K"))
 
@@ -2393,14 +3379,45 @@
         timedelta: bool = True,
         coerce: bool = False,
     ):
-        """
-        attempt to coerce any object types to better types return a copy of
+        """attempt to coerce any object types to better types return a copy of
         the block (if copy = True) by definition we ARE an ObjectBlock!!!!!
-
+        
         can return multiple blocks!
+
+        Parameters
+        ----------
+        copy: bool :
+             (Default value = True)
+        datetime: bool :
+             (Default value = True)
+        numeric: bool :
+             (Default value = True)
+        timedelta: bool :
+             (Default value = True)
+        coerce: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         # operate column-by-column
         def f(mask, val, idx):
+            """
+
+            Parameters
+            ----------
+            mask :
+                
+            val :
+                
+            idx :
+                
+
+            Returns
+            -------
+
+            """
             shape = val.shape
             values = soft_convert_objects(
                 val.ravel(),
@@ -2425,6 +3442,19 @@
         return blocks
 
     def _maybe_downcast(self, blocks: List["Block"], downcast=None) -> List["Block"]:
+        """
+
+        Parameters
+        ----------
+        blocks: List["Block"] :
+            
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if downcast is not None:
             return blocks
@@ -2433,9 +3463,39 @@
         return _extend_blocks([b.convert(datetime=True, numeric=False) for b in blocks])
 
     def _can_hold_element(self, element: Any) -> bool:
+        """
+
+        Parameters
+        ----------
+        element: Any :
+            
+
+        Returns
+        -------
+
+        """
         return True
 
     def replace(self, to_replace, value, inplace=False, regex=False, convert=True):
+        """
+
+        Parameters
+        ----------
+        to_replace :
+            
+        value :
+            
+        inplace :
+             (Default value = False)
+        regex :
+             (Default value = False)
+        convert :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         to_rep_is_list = is_list_like(to_replace)
         value_is_list = is_list_like(value)
         both_lists = to_rep_is_list and value_is_list
@@ -2481,8 +3541,7 @@
     def _replace_single(
         self, to_replace, value, inplace=False, regex=False, convert=True, mask=None,
     ):
-        """
-        Replace elements by the given value.
+        """Replace elements by the given value.
 
         Parameters
         ----------
@@ -2491,17 +3550,18 @@
         value : object
             Replacement object.
         inplace : bool, default False
-            Perform inplace modification.
+            Perform inplace modification. (Default value = False)
         regex : bool, default False
-            If true, perform regular expression substitution.
+            If true, perform regular expression substitution. (Default value = False)
         convert : bool, default True
-            If true, try to coerce any object types to better types.
+            If true, try to coerce any object types to better types. (Default value = True)
         mask : array-like of bool, optional
-            True indicate corresponding element is ignored.
-
-        Returns
-        -------
-        a new block, the result after replacing
+            True indicate corresponding element is ignored. (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         inplace = validate_bool_kwarg(inplace, "inplace")
 
@@ -2546,6 +3606,17 @@
         if isna(value) or not isinstance(value, str):
 
             def re_replacer(s):
+                """
+
+                Parameters
+                ----------
+                s :
+                    
+
+                Returns
+                -------
+
+                """
                 if is_re(rx) and isinstance(s, str):
                     return value if rx.search(s) is not None else s
                 else:
@@ -2555,6 +3626,17 @@
             # value is guaranteed to be a string here, s can be either a string
             # or null if it's null it gets returned
             def re_replacer(s):
+                """
+
+                Parameters
+                ----------
+                s :
+                    
+
+                Returns
+                -------
+
+                """
                 if is_re(rx) and isinstance(s, str):
                     return rx.sub(value, s)
                 else:
@@ -2576,8 +3658,7 @@
     def _replace_coerce(
         self, to_replace, value, inplace=True, regex=False, convert=False, mask=None
     ):
-        """
-        Replace value corresponding to the given boolean array with another
+        """Replace value corresponding to the given boolean array with another
         value.
 
         Parameters
@@ -2587,17 +3668,18 @@
         value : object
             Replacement object.
         inplace : bool, default False
-            Perform inplace modification.
+            Perform inplace modification. (Default value = True)
         regex : bool, default False
-            If true, perform regular expression substitution.
+            If true, perform regular expression substitution. (Default value = False)
         convert : bool, default True
-            If true, try to coerce any object types to better types.
+            If true, try to coerce any object types to better types. (Default value = False)
         mask : array-like of bool, optional
-            True indicate corresponding element is ignored.
-
-        Returns
-        -------
-        A new block if there is anything to replace or the original block.
+            True indicate corresponding element is ignored. (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if mask.any():
             block = super()._replace_coerce(
@@ -2617,6 +3699,7 @@
 
 
 class CategoricalBlock(ExtensionBlock):
+    """ """
     __slots__ = ()
     is_categorical = True
     _can_hold_na = True
@@ -2631,6 +3714,7 @@
 
     @property
     def _holder(self):
+        """ """
         return Categorical
 
     def replace(
@@ -2641,6 +3725,25 @@
         regex: bool = False,
         convert: bool = True,
     ):
+        """
+
+        Parameters
+        ----------
+        to_replace :
+            
+        value :
+            
+        inplace: bool :
+             (Default value = False)
+        regex: bool :
+             (Default value = False)
+        convert: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         inplace = validate_bool_kwarg(inplace, "inplace")
         result = self if inplace else self.copy()
 
@@ -2653,17 +3756,19 @@
 
 
 def get_block_type(values, dtype=None):
-    """
-    Find the appropriate Block subclass to use for the given values and dtype.
+    """Find the appropriate Block subclass to use for the given values and dtype.
 
     Parameters
     ----------
     values : ndarray-like
+        
     dtype : numpy or pandas dtype
+         (Default value = None)
 
     Returns
     -------
-    cls : class, subclass of Block
+
+    
     """
     dtype = dtype or values.dtype
     vtype = dtype.type
@@ -2699,6 +3804,25 @@
 
 
 def make_block(values, placement, klass=None, ndim=None, dtype=None):
+    """
+
+    Parameters
+    ----------
+    values :
+        
+    placement :
+        
+    klass :
+         (Default value = None)
+    ndim :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     # Ensure that we don't allow PandasArray / PandasDtype in internals.
     # For now, blocks should be backed by ndarrays when possible.
     if isinstance(values, ABCPandasArray):
@@ -2726,7 +3850,21 @@
 
 
 def _extend_blocks(result, blocks=None):
-    """ return a new extended blocks, given the result """
+    """
+
+    Parameters
+    ----------
+    result :
+        
+    blocks :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        
+
+    """
     if blocks is None:
         blocks = []
     if isinstance(result, list):
@@ -2742,7 +3880,19 @@
 
 
 def _block_shape(values: ArrayLike, ndim: int = 1) -> ArrayLike:
-    """ guarantee the shape of the values to be at least 1 d """
+    """guarantee the shape of the values to be at least 1 d
+
+    Parameters
+    ----------
+    values: ArrayLike :
+        
+    ndim: int :
+         (Default value = 1)
+
+    Returns
+    -------
+
+    """
     if values.ndim < ndim:
         shape = values.shape
         if not is_extension_array_dtype(values.dtype):
@@ -2754,10 +3904,9 @@
 
 
 def _safe_reshape(arr, new_shape):
-    """
-    If possible, reshape `arr` to have shape `new_shape`,
+    """If possible, reshape `arr` to have shape `new_shape`,
     with a couple of exceptions (see gh-13012):
-
+    
     1) If `arr` is a ExtensionArray or Index, `arr` will be
        returned as is.
     2) If `arr` is a Series, the `_values` attribute will
@@ -2765,8 +3914,15 @@
 
     Parameters
     ----------
-    arr : array-like, object to be reshaped
-    new_shape : int or tuple of ints, the new shape
+    arr :
+        
+    new_shape :
+        
+
+    Returns
+    -------
+
+    
     """
     if isinstance(arr, ABCSeries):
         arr = arr._values
@@ -2778,8 +3934,7 @@
 
 
 def _putmask_smart(v: np.ndarray, mask: np.ndarray, n) -> np.ndarray:
-    """
-    Return a new ndarray, try to preserve dtype if possible.
+    """Return a new ndarray, try to preserve dtype if possible.
 
     Parameters
     ----------
@@ -2788,6 +3943,11 @@
     mask : np.ndarray[bool]
         Applies to both sides (array like).
     n : `new values` either scalar or an array like aligned with `values`
+        
+    v: np.ndarray :
+        
+    mask: np.ndarray :
+        
 
     Returns
     -------
@@ -2839,6 +3999,19 @@
     n = np.asarray(n)
 
     def _putmask_preserve(nv, n):
+        """
+
+        Parameters
+        ----------
+        nv :
+            
+        n :
+            
+
+        Returns
+        -------
+
+        """
         try:
             nv[mask] = n[mask]
         except (IndexError, ValueError):
@@ -2858,8 +4031,16 @@
 
 
 def _extract_bool_array(mask: ArrayLike) -> np.ndarray:
-    """
-    If we have a SparseArray or BooleanArray, convert it to ndarray[bool].
+    """If we have a SparseArray or BooleanArray, convert it to ndarray[bool].
+
+    Parameters
+    ----------
+    mask: ArrayLike :
+        
+
+    Returns
+    -------
+
     """
     if isinstance(mask, ExtensionArray):
         # We could have BooleanArray, Sparse[bool], ...
