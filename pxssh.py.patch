# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pexpect/pxssh.py
+++ b/..//venv/lib/python3.8/site-packages/pexpect/pxssh.py
@@ -30,8 +30,7 @@
 
 # Exception classes used by this module.
 class ExceptionPxssh(ExceptionPexpect):
-    '''Raised for pxssh exceptions.
-    '''
+    """ """
 
 if sys.version_info > (3, 0):
     from shlex import quote
@@ -39,7 +38,19 @@
     _find_unsafe = re.compile(r'[^\w@%+=:,./-]').search
 
     def quote(s):
-        """Return a shell-escaped version of the string *s*."""
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+        type
+            
+
+        """
         if not s:
             return "''"
         if _find_unsafe(s) is None:
@@ -50,20 +61,20 @@
         return "'" + s.replace("'", "'\"'\"'") + "'"
 
 class pxssh (spawn):
-    '''This class extends pexpect.spawn to specialize setting up SSH
+    """This class extends pexpect.spawn to specialize setting up SSH
     connections. This adds methods for login, logout, and expecting the shell
     prompt. It does various tricky things to handle many situations in the SSH
     login process. For example, if the session is your first login, then pxssh
     automatically accepts the remote certificate; or if you have public key
     authentication setup then pxssh won't wait for the password prompt.
-
+    
     pxssh uses the shell prompt to synchronize output from the remote host. In
     order to make this more robust it sets the shell prompt to something more
     unique than just $ or #. This should work on most Borne/Bash or Csh style
     shells.
-
+    
     Example that runs a few commands on a remote server and prints the result::
-
+    
         from pexpect import pxssh
         import getpass
         try:
@@ -85,15 +96,15 @@
         except pxssh.ExceptionPxssh as e:
             print("pxssh failed on login.")
             print(e)
-
+    
     Example showing how to specify SSH options::
-
+    
         from pexpect import pxssh
         s = pxssh.pxssh(options={
                             "StrictHostKeyChecking": "no",
                             "UserKnownHostsFile": "/dev/null"})
         ...
-
+    
     Note that if you have ssh-agent running while doing development with pxssh
     then this can lead to a lot of confusion. Many X display managers (xdm,
     gdm, kdm, etc.) will automatically start a GUI agent. You may see a GUI
@@ -102,18 +113,25 @@
     off public key authentication. This will only work if the remote SSH server
     is configured to allow password logins. Example of using 'force_password'
     attribute::
-
+    
             s = pxssh.pxssh()
             s.force_password = True
             hostname = raw_input('hostname: ')
             username = raw_input('username: ')
             password = getpass.getpass('password: ')
             s.login (hostname, username, password)
-
+    
     `debug_command_string` is only for the test suite to confirm that the string
     generated for SSH is correct, using this will not allow you to do
     anything other than get a string back from `pxssh.pxssh.login()`.
-    '''
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
 
     def __init__ (self, timeout=30, maxread=2000, searchwindowsize=None,
                     logfile=None, cwd=None, env=None, ignore_sighup=True, echo=True,
@@ -162,8 +180,19 @@
         self.options = options
 
     def levenshtein_distance(self, a, b):
-        '''This calculates the Levenshtein distance between a and b.
-        '''
+        """This calculates the Levenshtein distance between a and b.
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
+        """
 
         n, m = len(a), len(b)
         if n > m:
@@ -181,12 +210,21 @@
         return current[n]
 
     def try_read_prompt(self, timeout_multiplier):
-        '''This facilitates using communication timeouts to perform
+        """This facilitates using communication timeouts to perform
         synchronization as quickly as possible, while supporting high latency
         connections with a tunable worst case performance. Fast connections
         should be read almost immediately. Worst case performance for this
         method is timeout_multiplier * 3 seconds.
-        '''
+
+        Parameters
+        ----------
+        timeout_multiplier :
+            
+
+        Returns
+        -------
+
+        """
 
         # maximum time allowed to read the first response
         first_char_timeout = timeout_multiplier * 0.5
@@ -213,13 +251,23 @@
         return prompt
 
     def sync_original_prompt (self, sync_multiplier=1.0):
-        '''This attempts to find the prompt. Basically, press enter and record
+        """This attempts to find the prompt. Basically, press enter and record
         the response; press enter again and record the response; if the two
         responses are similar then assume we are at the original prompt.
         This can be a slow function. Worst case with the default sync_multiplier
         can take 12 seconds. Low latency connections are more likely to fail
         with a low sync_multiplier. Best case sync time gets worse with a
-        high sync multiplier (500 ms with default). '''
+        high sync multiplier (500 ms with default).
+
+        Parameters
+        ----------
+        sync_multiplier :
+             (Default value = 1.0)
+
+        Returns
+        -------
+
+        """
 
         # All of these timing pace values are magic.
         # I came up with these based on what seemed reliable for
@@ -260,8 +308,8 @@
                 password_regex=r'(?i)(?:password:)|(?:passphrase for key)',
                 ssh_tunnels={}, spawn_local_ssh=True,
                 sync_original_prompt=True, ssh_config=None, cmd='ssh'):
-        '''This logs the user into the given server.
-
+        """This logs the user into the given server.
+        
         It uses 'original_prompt' to try to find the prompt right after login.
         When it finds the prompt it immediately tries to reset the prompt to
         something more easily matched. The default 'original_prompt' is very
@@ -276,37 +324,80 @@
         to guess when we have reached the prompt. Then we hope for the best and
         blindly try to reset the prompt to something more unique. If that fails
         then login() raises an :class:`ExceptionPxssh` exception.
-
+        
         In some situations it is not possible or desirable to reset the
         original prompt. In this case, pass ``auto_prompt_reset=False`` to
         inhibit setting the prompt to the UNIQUE_PROMPT. Remember that pxssh
         uses a unique prompt in the :meth:`prompt` method. If the original prompt is
         not reset then this will disable the :meth:`prompt` method unless you
         manually set the :attr:`PROMPT` attribute.
-
+        
         Set ``password_regex`` if there is a MOTD message with `password` in it.
         Changing this is like playing in traffic, don't (p)expect it to match straight
         away.
-
+        
         If you require to connect to another SSH server from the your original SSH
         connection set ``spawn_local_ssh`` to `False` and this will use your current
         session to do so. Setting this option to `False` and not having an active session
         will trigger an error.
-
+        
         Set ``ssh_key`` to a file path to an SSH private key to use that SSH key
         for the session authentication.
         Set ``ssh_key`` to `True` to force passing the current SSH authentication socket
         to the desired ``hostname``.
-
+        
         Set ``ssh_config`` to a file path string of an SSH client config file to pass that
         file to the client to handle itself. You may set any options you wish in here, however
         doing so will require you to post extra information that you may not want to if you
         run into issues.
-
+        
         Alter the ``cmd`` to change the ssh client used, or to prepend it with network
         namespaces. For example ```cmd="ip netns exec vlan2 ssh"``` to execute the ssh in
         network namespace named ```vlan```.
-        '''
+
+        Parameters
+        ----------
+        server :
+            
+        username :
+             (Default value = None)
+        password :
+             (Default value = '')
+        terminal_type :
+             (Default value = 'ansi')
+        original_prompt :
+             (Default value = r"[#$]")
+        login_timeout :
+             (Default value = 10)
+        port :
+             (Default value = None)
+        auto_prompt_reset :
+             (Default value = True)
+        ssh_key :
+             (Default value = None)
+        quiet :
+             (Default value = True)
+        sync_multiplier :
+             (Default value = 1)
+        check_local_ip :
+             (Default value = True)
+        password_regex :
+             (Default value = r'(?i)(?:password:)|(?:passphrase for key)')
+        ssh_tunnels :
+             (Default value = {})
+        spawn_local_ssh :
+             (Default value = True)
+        sync_original_prompt :
+             (Default value = True)
+        ssh_config :
+             (Default value = None)
+        cmd :
+             (Default value = 'ssh')
+
+        Returns
+        -------
+
+        """
 
         session_regex_array = ["(?i)are you sure you want to continue connecting", original_prompt, password_regex, "(?i)permission denied", "(?i)terminal type", TIMEOUT]
         session_init_regex_array = []
@@ -473,10 +564,17 @@
         return True
 
     def logout (self):
-        '''Sends exit to the remote shell.
-
+        """Sends exit to the remote shell.
+        
         If there are stopped jobs then this automatically sends exit twice.
-        '''
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         self.sendline("exit")
         index = self.expect([EOF, "(?i)there are stopped jobs"])
         if index==1:
@@ -485,21 +583,30 @@
         self.close()
 
     def prompt(self, timeout=-1):
-        '''Match the next shell prompt.
-
+        """Match the next shell prompt.
+        
         This is little more than a short-cut to the :meth:`~pexpect.spawn.expect`
         method. Note that if you called :meth:`login` with
         ``auto_prompt_reset=False``, then before calling :meth:`prompt` you must
         set the :attr:`PROMPT` attribute to a regex that it will use for
         matching the prompt.
-
+        
         Calling :meth:`prompt` will erase the contents of the :attr:`before`
         attribute even if no prompt is ever matched. If timeout is not given or
         it is set to -1 then self.timeout is used.
-
+        
         :return: True if the shell prompt was matched, False if the timeout was
                  reached.
-        '''
+
+        Parameters
+        ----------
+        timeout :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
 
         if timeout == -1:
             timeout = self.timeout
@@ -509,7 +616,7 @@
         return True
 
     def set_unique_prompt(self):
-        '''This sets the remote prompt to something more unique than ``#`` or ``$``.
+        """This sets the remote prompt to something more unique than ``#`` or ``$``.
         This makes it easier for the :meth:`prompt` method to match the shell prompt
         unambiguously. This method is called automatically by the :meth:`login`
         method, but you may want to call it manually if you somehow reset the
@@ -517,12 +624,19 @@
         will need to manually reset the prompt. This sends shell commands to
         the remote host to set the prompt, so this assumes the remote host is
         ready to receive commands.
-
+        
         Alternatively, you may use your own prompt pattern. In this case you
         should call :meth:`login` with ``auto_prompt_reset=False``; then set the
         :attr:`PROMPT` attribute to a regular expression. After that, the
         :meth:`prompt` method will try to match your prompt pattern.
-        '''
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         self.sendline("unset PROMPT_COMMAND")
         self.sendline(self.PROMPT_SET_SH) # sh-style
