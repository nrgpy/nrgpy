# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/_internal.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/_internal.py
@@ -23,6 +23,19 @@
     _nbo = '>'
 
 def _makenames_list(adict, align):
+    """
+
+    Parameters
+    ----------
+    adict :
+        
+    align :
+        
+
+    Returns
+    -------
+
+    """
     allfields = []
     fnames = list(adict.keys())
     for fname in fnames:
@@ -54,6 +67,19 @@
 #  a dictionary without "names" and "formats"
 #  fields is used as a data-type descriptor.
 def _usefields(adict, align):
+    """
+
+    Parameters
+    ----------
+    adict :
+        
+    align :
+        
+
+    Returns
+    -------
+
+    """
     try:
         names = adict[-1]
     except KeyError:
@@ -86,6 +112,17 @@
 #  a simple typestring
 
 def _array_descr(descriptor):
+    """
+
+    Parameters
+    ----------
+    descriptor :
+        
+
+    Returns
+    -------
+
+    """
     fields = descriptor.fields
     if fields is None:
         subdtype = descriptor.subdtype
@@ -138,6 +175,21 @@
 # so don't remove the name here, or you'll
 # break backward compatibility.
 def _reconstruct(subtype, shape, dtype):
+    """
+
+    Parameters
+    ----------
+    subtype :
+        
+    shape :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return ndarray.__new__(subtype, shape, dtype)
 
 
@@ -155,6 +207,17 @@
 _convorder = {'=': _nbo}
 
 def _commastring(astr):
+    """
+
+    Parameters
+    ----------
+    astr :
+        
+
+    Returns
+    -------
+
+    """
     startindex = 0
     result = []
     while startindex < len(astr):
@@ -202,6 +265,7 @@
     return result
 
 class dummy_ctype:
+    """ """
     def __init__(self, cls):
         self._cls = cls
     def __mul__(self, other):
@@ -214,6 +278,7 @@
         return self._cls != other._cls
 
 def _getintp_ctype():
+    """ """
     val = _getintp_ctype.cache
     if val is not None:
         return val
@@ -237,15 +302,31 @@
 # Used for .ctypes attribute of ndarray
 
 class _missing_ctypes:
+    """ """
     def cast(self, num, obj):
+        """
+
+        Parameters
+        ----------
+        num :
+            
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         return num.value
 
     class c_void_p:
+        """ """
         def __init__(self, ptr):
             self.value = ptr
 
 
 class _ctypes:
+    """ """
     def __init__(self, array, ptr=None):
         self._arr = array
 
@@ -265,13 +346,22 @@
 
     def data_as(self, obj):
         """
-        Return the data pointer cast to a particular c-types object.
-        For example, calling ``self._as_parameter_`` is equivalent to
-        ``self.data_as(ctypes.c_void_p)``. Perhaps you want to use the data as a
-        pointer to a ctypes array of floating-point data:
-        ``self.data_as(ctypes.POINTER(ctypes.c_double))``.
-
-        The returned pointer will keep a reference to the array.
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+        type
+            For example, calling ``self._as_parameter_`` is equivalent to
+            ``self.data_as(ctypes.c_void_p)``. Perhaps you want to use the data as a
+            pointer to a ctypes array of floating-point data:
+            ``self.data_as(ctypes.POINTER(ctypes.c_double))``.
+            
+            The returned pointer will keep a reference to the array.
+
         """
         # _ctypes.cast function causes a circular reference of self._data in
         # self._data._objects. Attributes of self._data cannot be released
@@ -284,8 +374,17 @@
 
     def shape_as(self, obj):
         """
-        Return the shape tuple as an array of some other c-types
-        type. For example: ``self.shape_as(ctypes.c_short)``.
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+        type
+            type. For example: ``self.shape_as(ctypes.c_short)``.
+
         """
         if self._zerod:
             return None
@@ -293,8 +392,17 @@
 
     def strides_as(self, obj):
         """
-        Return the strides tuple as an array of some other
-        c-types type. For example: ``self.strides_as(ctypes.c_longlong)``.
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+        type
+            c-types type. For example: ``self.strides_as(ctypes.c_longlong)``.
+
         """
         if self._zerod:
             return None
@@ -302,51 +410,75 @@
 
     @property
     def data(self):
-        """
-        A pointer to the memory area of the array as a Python integer.
+        """A pointer to the memory area of the array as a Python integer.
         This memory area may contain data that is not aligned, or not in correct
         byte-order. The memory area may not even be writeable. The array
         flags and data-type of this array should be respected when passing this
         attribute to arbitrary C-code to avoid trouble that can include Python
         crashing. User Beware! The value of this attribute is exactly the same
         as ``self._array_interface_['data'][0]``.
-
+        
         Note that unlike ``data_as``, a reference will not be kept to the array:
         code like ``ctypes.c_void_p((a + b).ctypes.data)`` will result in a
         pointer to a deallocated array, and should be spelt
         ``(a + b).ctypes.data_as(ctypes.c_void_p)``
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._data.value
 
     @property
     def shape(self):
-        """
-        (c_intp*self.ndim): A ctypes array of length self.ndim where
+        """(c_intp*self.ndim): A ctypes array of length self.ndim where
         the basetype is the C-integer corresponding to ``dtype('p')`` on this
         platform. This base-type could be `ctypes.c_int`, `ctypes.c_long`, or
         `ctypes.c_longlong` depending on the platform.
         The c_intp type is defined accordingly in `numpy.ctypeslib`.
         The ctypes array contains the shape of the underlying array.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.shape_as(_getintp_ctype())
 
     @property
     def strides(self):
-        """
-        (c_intp*self.ndim): A ctypes array of length self.ndim where
+        """(c_intp*self.ndim): A ctypes array of length self.ndim where
         the basetype is the same as for the shape attribute. This ctypes array
         contains the strides information from the underlying array. This strides
         information is important for showing how many bytes must be jumped to
         get to the next element in the array.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.strides_as(_getintp_ctype())
 
     @property
     def _as_parameter_(self):
-        """
-        Overrides the ctypes semi-magic method
-
+        """Overrides the ctypes semi-magic method
+        
         Enables `c_func(some_array.ctypes)`
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.data_as(ctypes.c_void_p)
 
@@ -358,9 +490,19 @@
 
 
 def _newnames(datatype, order):
-    """
-    Given a datatype and an order object, return a new names tuple, with the
+    """Given a datatype and an order object, return a new names tuple, with the
     order indicated
+
+    Parameters
+    ----------
+    datatype :
+        
+    order :
+        
+
+    Returns
+    -------
+
     """
     oldnames = datatype.names
     nameslist = list(oldnames)
@@ -386,12 +528,12 @@
     Parameters
     ----------
     ary : ndarray
-       Structured array from which to remove padding bytes
-
-    Returns
-    -------
-    ary_copy : ndarray
-       Copy of ary with padding bytes removed
+        Structured array from which to remove padding bytes
+
+    Returns
+    -------
+
+    
     """
     dt = ary.dtype
     copy_dtype = {'names': dt.names,
@@ -399,8 +541,8 @@
     return array(ary, dtype=copy_dtype, copy=True)
 
 def _getfield_is_safe(oldtype, newtype, offset):
-    """ Checks safety of getfield for object arrays.
-
+    """Checks safety of getfield for object arrays.
+    
     As in _view_is_safe, we need to check that memory containing objects is not
     reinterpreted as a non-object datatype and vice versa.
 
@@ -413,11 +555,10 @@
     offset : int
         Offset of the field being accessed by ndarray.getfield
 
-    Raises
-    ------
-    TypeError
-        If the field access is invalid
-
+    Returns
+    -------
+
+    
     """
     if newtype.hasobject or oldtype.hasobject:
         if offset == 0 and newtype == oldtype:
@@ -431,9 +572,9 @@
     return
 
 def _view_is_safe(oldtype, newtype):
-    """ Checks safety of a view involving object arrays, for example when
+    """Checks safety of a view involving object arrays, for example when
     doing::
-
+    
         np.zeros(10, dtype=oldtype).view(newtype)
 
     Parameters
@@ -443,11 +584,10 @@
     newtype : data-type
         Data type of the view
 
-    Raises
-    ------
-    TypeError
-        If the new type is incompatible with the old type.
-
+    Returns
+    -------
+
+    
     """
 
     # if the types are equivalent, there is no problem.
@@ -522,22 +662,56 @@
 }
 
 class _Stream:
+    """ """
     def __init__(self, s):
         self.s = s
         self.byteorder = '@'
 
     def advance(self, n):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+
+        Returns
+        -------
+
+        """
         res = self.s[:n]
         self.s = self.s[n:]
         return res
 
     def consume(self, c):
+        """
+
+        Parameters
+        ----------
+        c :
+            
+
+        Returns
+        -------
+
+        """
         if self.s[:len(c)] == c:
             self.advance(len(c))
             return True
         return False
 
     def consume_until(self, c):
+        """
+
+        Parameters
+        ----------
+        c :
+            
+
+        Returns
+        -------
+
+        """
         if callable(c):
             i = 0
             while i < len(self.s) and not c(self.s[i]):
@@ -551,6 +725,7 @@
 
     @property
     def next(self):
+        """ """
         return self.s[0]
 
     def __bool__(self):
@@ -558,6 +733,17 @@
 
 
 def _dtype_from_pep3118(spec):
+    """
+
+    Parameters
+    ----------
+    spec :
+        
+
+    Returns
+    -------
+
+    """
     stream = _Stream(spec)
     dtype, align = __dtype_from_pep3118(stream, is_subdtype=False)
     return dtype
@@ -708,7 +894,17 @@
     return ret, common_alignment
 
 def _fix_names(field_spec):
-    """ Replace names which are None with the next unused f%d name """
+    """Replace names which are None with the next unused f%d name
+
+    Parameters
+    ----------
+    field_spec :
+        
+
+    Returns
+    -------
+
+    """
     names = field_spec['names']
     for i, name in enumerate(names):
         if name is not None:
@@ -723,7 +919,19 @@
         names[i] = name
 
 def _add_trailing_padding(value, padding):
-    """Inject the specified number of padding bytes at the end of a dtype"""
+    """Inject the specified number of padding bytes at the end of a dtype
+
+    Parameters
+    ----------
+    value :
+        
+    padding :
+        
+
+    Returns
+    -------
+
+    """
     if value.fields is None:
         field_spec = dict(
             names=['f0'],
@@ -745,22 +953,76 @@
     return dtype(field_spec)
 
 def _prod(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     p = 1
     for x in a:
         p *= x
     return p
 
 def _gcd(a, b):
-    """Calculate the greatest common divisor of a and b"""
+    """Calculate the greatest common divisor of a and b
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     while b:
         a, b = b, a % b
     return a
 
 def _lcm(a, b):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     return a // _gcd(a, b) * b
 
 def array_ufunc_errmsg_formatter(dummy, ufunc, method, *inputs, **kwargs):
-    """ Format the error message for when __array_ufunc__ gives up. """
+    """Format the error message for when __array_ufunc__ gives up.
+
+    Parameters
+    ----------
+    dummy :
+        
+    ufunc :
+        
+    method :
+        
+    *inputs :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     args_string = ', '.join(['{!r}'.format(arg) for arg in inputs] +
                             ['{}={!r}'.format(k, v)
                              for k, v in kwargs.items()])
@@ -772,17 +1034,37 @@
 
 
 def array_function_errmsg_formatter(public_api, types):
-    """ Format the error message for when __array_ufunc__ gives up. """
+    """Format the error message for when __array_ufunc__ gives up.
+
+    Parameters
+    ----------
+    public_api :
+        
+    types :
+        
+
+    Returns
+    -------
+
+    """
     func_name = '{}.{}'.format(public_api.__module__, public_api.__name__)
     return ("no implementation found for '{}' on types that implement "
             '__array_function__: {}'.format(func_name, list(types)))
 
 
 def _ufunc_doc_signature_formatter(ufunc):
-    """
-    Builds a signature string which resembles PEP 457
-
+    """Builds a signature string which resembles PEP 457
+    
     This is used to construct the first line of the docstring
+
+    Parameters
+    ----------
+    ufunc :
+        
+
+    Returns
+    -------
+
     """
 
     # input arguments are simple
@@ -825,6 +1107,7 @@
 
 
 def npy_ctypes_check(cls):
+    """ """
     # determine if a class comes from ctypes, in order to work around
     # a bug in the buffer protocol for those objects, bpo-10746
     try:
@@ -843,30 +1126,35 @@
 
 
 class recursive:
-    '''
-    A decorator class for recursive nested functions.
+    """A decorator class for recursive nested functions.
     Naive recursive nested functions hold a reference to themselves:
-
+    
     def outer(*args):
         def stringify_leaky(arg0, *arg1):
             if len(arg1) > 0:
                 return stringify_leaky(*arg1)  # <- HERE
             return str(arg0)
         stringify_leaky(*args)
-
+    
     This design pattern creates a reference cycle that is difficult for a
     garbage collector to resolve. The decorator class prevents the
     cycle by passing the nested function in as an argument `self`:
-
+    
     def outer(*args):
         @recursive
         def stringify(self, arg0, *arg1):
             if len(arg1) > 0:
                 return self(*arg1)
-            return str(arg0)
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
         stringify(*args)
 
-    '''
+    """
     def __init__(self, func):
         self.func = func
     def __call__(self, *args, **kwargs):
