# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/chardet/chardistribution.py
+++ b/..//venv/lib/python3.8/site-packages/chardet/chardistribution.py
@@ -38,6 +38,7 @@
 
 
 class CharDistributionAnalysis(object):
+    """ """
     ENOUGH_DATA_THRESHOLD = 1024
     SURE_YES = 0.99
     SURE_NO = 0.01
@@ -68,7 +69,19 @@
         self._freq_chars = 0
 
     def feed(self, char, char_len):
-        """feed a character with known length"""
+        """feed a character with known length
+
+        Parameters
+        ----------
+        char :
+            
+        char_len :
+            
+
+        Returns
+        -------
+
+        """
         if char_len == 2:
             # we only care about 2-bytes character in our distribution analysis
             order = self.get_order(char)
@@ -82,7 +95,7 @@
                     self._freq_chars += 1
 
     def get_confidence(self):
-        """return confidence based on existing data"""
+        """ """
         # if we didn't receive any character in our consideration range,
         # return negative answer
         if self._total_chars <= 0 or self._freq_chars <= self.MINIMUM_DATA_THRESHOLD:
@@ -98,11 +111,23 @@
         return self.SURE_YES
 
     def got_enough_data(self):
+        """ """
         # It is not necessary to receive all data to draw conclusion.
         # For charset detection, certain amount of data is enough
         return self._total_chars > self.ENOUGH_DATA_THRESHOLD
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # We do not handle characters based on the original encoding string,
         # but convert this encoding string to a number, here called order.
         # This allows multiple encodings of a language to share one frequency
@@ -111,6 +136,7 @@
 
 
 class EUCTWDistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(EUCTWDistributionAnalysis, self).__init__()
         self._char_to_freq_order = EUCTW_CHAR_TO_FREQ_ORDER
@@ -118,6 +144,17 @@
         self.typical_distribution_ratio = EUCTW_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for euc-TW encoding, we are interested
         #   first  byte range: 0xc4 -- 0xfe
         #   second byte range: 0xa1 -- 0xfe
@@ -130,6 +167,7 @@
 
 
 class EUCKRDistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(EUCKRDistributionAnalysis, self).__init__()
         self._char_to_freq_order = EUCKR_CHAR_TO_FREQ_ORDER
@@ -137,6 +175,17 @@
         self.typical_distribution_ratio = EUCKR_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for euc-KR encoding, we are interested
         #   first  byte range: 0xb0 -- 0xfe
         #   second byte range: 0xa1 -- 0xfe
@@ -149,6 +198,7 @@
 
 
 class GB2312DistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(GB2312DistributionAnalysis, self).__init__()
         self._char_to_freq_order = GB2312_CHAR_TO_FREQ_ORDER
@@ -156,6 +206,17 @@
         self.typical_distribution_ratio = GB2312_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for GB2312 encoding, we are interested
         #  first  byte range: 0xb0 -- 0xfe
         #  second byte range: 0xa1 -- 0xfe
@@ -168,6 +229,7 @@
 
 
 class Big5DistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(Big5DistributionAnalysis, self).__init__()
         self._char_to_freq_order = BIG5_CHAR_TO_FREQ_ORDER
@@ -175,6 +237,17 @@
         self.typical_distribution_ratio = BIG5_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for big5 encoding, we are interested
         #   first  byte range: 0xa4 -- 0xfe
         #   second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe
@@ -190,6 +263,7 @@
 
 
 class SJISDistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(SJISDistributionAnalysis, self).__init__()
         self._char_to_freq_order = JIS_CHAR_TO_FREQ_ORDER
@@ -197,6 +271,17 @@
         self.typical_distribution_ratio = JIS_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for sjis encoding, we are interested
         #   first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe
         #   second byte range: 0x40 -- 0x7e,  0x81 -- oxfe
@@ -215,6 +300,7 @@
 
 
 class EUCJPDistributionAnalysis(CharDistributionAnalysis):
+    """ """
     def __init__(self):
         super(EUCJPDistributionAnalysis, self).__init__()
         self._char_to_freq_order = JIS_CHAR_TO_FREQ_ORDER
@@ -222,6 +308,17 @@
         self.typical_distribution_ratio = JIS_TYPICAL_DISTRIBUTION_RATIO
 
     def get_order(self, byte_str):
+        """
+
+        Parameters
+        ----------
+        byte_str :
+            
+
+        Returns
+        -------
+
+        """
         # for euc-JP encoding, we are interested
         #   first  byte range: 0xa0 -- 0xfe
         #   second byte range: 0xa1 -- 0xfe
