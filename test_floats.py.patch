# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexing/test_floats.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexing/test_floats.py
@@ -14,6 +14,19 @@
 
 
 def gen_obj(klass, index):
+    """
+
+    Parameters
+    ----------
+    klass :
+        
+    index :
+        
+
+    Returns
+    -------
+
+    """
     if klass is Series:
         obj = Series(np.arange(len(index)), index=index)
     else:
@@ -24,11 +37,26 @@
 
 
 class TestFloatIndexers:
+    """ """
     def check(self, result, original, indexer, getitem):
-        """
-        comparator for results
+        """comparator for results
         we need to take care if we are indexing on a
         Series or a frame
+
+        Parameters
+        ----------
+        result :
+            
+        original :
+            
+        indexer :
+            
+        getitem :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(original, Series):
             expected = original.iloc[indexer]
@@ -41,6 +69,17 @@
         tm.assert_almost_equal(result, expected)
 
     def test_scalar_error(self, series_with_simple_index):
+        """
+
+        Parameters
+        ----------
+        series_with_simple_index :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH 4892
         # float_indexers should raise exceptions
@@ -71,6 +110,19 @@
     )
     @pytest.mark.parametrize("klass", [Series, DataFrame])
     def test_scalar_non_numeric(self, index_func, klass):
+        """
+
+        Parameters
+        ----------
+        index_func :
+            
+        klass :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH 4892
         # float_indexers should raise exceptions
@@ -134,6 +186,17 @@
         ],
     )
     def test_scalar_non_numeric_series_fallback(self, index_func):
+        """
+
+        Parameters
+        ----------
+        index_func :
+            
+
+        Returns
+        -------
+
+        """
         # fallsback to position selection, series only
         i = index_func(5)
         s = Series(np.arange(len(i)), index=i)
@@ -142,6 +205,7 @@
             s[3.0]
 
     def test_scalar_with_mixed(self):
+        """ """
 
         s2 = Series([1, 2, 3], index=["a", "b", "c"])
         s3 = Series([1, 2, 3], index=["a", "b", 1.5])
@@ -186,6 +250,19 @@
     )
     @pytest.mark.parametrize("klass", [Series, DataFrame])
     def test_scalar_integer(self, index_func, klass):
+        """
+
+        Parameters
+        ----------
+        index_func :
+            
+        klass :
+            
+
+        Returns
+        -------
+
+        """
 
         # test how scalar float indexers work on int indexes
 
@@ -205,6 +282,19 @@
             if isinstance(obj, Series):
 
                 def compare(x, y):
+                    """
+
+                    Parameters
+                    ----------
+                    x :
+                        
+                    y :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     assert x == y
 
                 expected = 100
@@ -230,6 +320,17 @@
 
     @pytest.mark.parametrize("klass", [Series, DataFrame])
     def test_scalar_float(self, klass):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
+        """
 
         # scalar float indexers work on a float index
         index = Index(np.arange(5.0))
@@ -285,6 +386,21 @@
     @pytest.mark.parametrize("l", [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)])
     @pytest.mark.parametrize("klass", [Series, DataFrame])
     def test_slice_non_numeric(self, index_func, l, klass):
+        """
+
+        Parameters
+        ----------
+        index_func :
+            
+        l :
+            
+        klass :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH 4892
         # float_indexers should raise exceptions
@@ -328,6 +444,7 @@
                 idxr(s)[l] = 0
 
     def test_slice_integer(self):
+        """ """
 
         # same as above, but for Integer based indexes
         # these coerce to a like integer
@@ -405,8 +522,17 @@
 
     @pytest.mark.parametrize("l", [slice(2, 4.0), slice(2.0, 4), slice(2.0, 4.0)])
     def test_integer_positional_indexing(self, l):
-        """ make sure that we are raising on positional indexing
+        """make sure that we are raising on positional indexing
         w.r.t. an integer index
+
+        Parameters
+        ----------
+        l :
+            
+
+        Returns
+        -------
+
         """
         s = Series(range(2, 6), index=range(2, 6))
 
@@ -429,6 +555,17 @@
         "index_func", [tm.makeIntIndex, tm.makeRangeIndex],
     )
     def test_slice_integer_frame_getitem(self, index_func):
+        """
+
+        Parameters
+        ----------
+        index_func :
+            
+
+        Returns
+        -------
+
+        """
 
         # similar to above, but on the getitem dim (of a DataFrame)
         index = index_func(5)
@@ -490,6 +627,19 @@
         "index_func", [tm.makeIntIndex, tm.makeRangeIndex],
     )
     def test_float_slice_getitem_with_integer_index_raises(self, l, index_func):
+        """
+
+        Parameters
+        ----------
+        l :
+            
+        index_func :
+            
+
+        Returns
+        -------
+
+        """
 
         # similar to above, but on the getitem dim (of a DataFrame)
         index = index_func(5)
@@ -517,6 +667,19 @@
     @pytest.mark.parametrize("l", [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)])
     @pytest.mark.parametrize("klass", [Series, DataFrame])
     def test_slice_float(self, l, klass):
+        """
+
+        Parameters
+        ----------
+        l :
+            
+        klass :
+            
+
+        Returns
+        -------
+
+        """
 
         # same as above, but for floats
         index = Index(np.arange(5.0)) + 0.1
@@ -537,6 +700,7 @@
             assert (result == 0).all()
 
     def test_floating_index_doc_example(self):
+        """ """
 
         index = Index([1.5, 2, 3, 4.5, 5])
         s = Series(range(5), index=index)
@@ -546,6 +710,7 @@
         assert s.iloc[3] == 3
 
     def test_floating_misc(self):
+        """ """
 
         # related 236
         # scalar/slicing of a float index
@@ -663,6 +828,7 @@
         tm.assert_series_equal(result1, Series([1], index=[2.5]))
 
     def test_floating_tuples(self):
+        """ """
         # see gh-13509
         s = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.1, 0.2], name="foo")
 
@@ -676,6 +842,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_float64index_slicing_bug(self):
+        """ """
         # GH 5557, related to slicing a float index
         ser = {
             256: 2321.0,
