# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/helpers.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/helpers.py
@@ -11,6 +11,17 @@
 
 
 def is_stdlib_path(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     # Python standard library paths look like this:
     # /usr/lib/python3.5/...
     # TODO The implementation below is probably incorrect and not complete.
@@ -22,8 +33,16 @@
 
 
 def deep_ast_copy(obj):
-    """
-    Much, much faster than copy.deepcopy, but just for parser tree nodes.
+    """Much, much faster than copy.deepcopy, but just for parser tree nodes.
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
     """
     # If it's already in the cache, just return it.
     new_obj = copy.copy(obj)
@@ -44,23 +63,35 @@
 
 
 def infer_call_of_leaf(context, leaf, cut_own_trailer=False):
-    """
-    Creates a "call" node that consist of all ``trailer`` and ``power``
+    """Creates a "call" node that consist of all ``trailer`` and ``power``
     objects.  E.g. if you call it with ``append``::
-
+    
         list([]).append(3) or None
-
+    
     You would get a node with the content ``list([]).append`` back.
-
+    
     This generates a copy of the original ast node.
-
+    
     If you're using the leaf, e.g. the bracket `)` it will return ``list([])``.
-
+    
     We use this function for two purposes. Given an expression ``bar.foo``,
     we may want to
       - infer the type of ``foo`` to offer completions after foo
       - infer the type of ``bar`` to be able to jump to the definition of foo
     The option ``cut_own_trailer`` must be set to true for the second purpose.
+
+    Parameters
+    ----------
+    context :
+        
+    leaf :
+        
+    cut_own_trailer :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     trailer = leaf.parent
     if trailer.type == 'fstring':
@@ -110,6 +141,17 @@
 
 
 def get_names_of_node(node):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
+    """
     try:
         children = node.children
     except AttributeError:
@@ -122,6 +164,17 @@
 
 
 def is_string(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     if value.inference_state.environment.version_info.major == 2:
         str_classes = (unicode, bytes)
     else:
@@ -130,33 +183,102 @@
 
 
 def is_literal(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return is_number(value) or is_string(value)
 
 
 def _get_safe_value_or_none(value, accept):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    accept :
+        
+
+    Returns
+    -------
+
+    """
     value = value.get_safe_value(default=None)
     if isinstance(value, accept):
         return value
 
 
 def get_int_or_none(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return _get_safe_value_or_none(value, int)
 
 
 def get_str_or_none(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return _get_safe_value_or_none(value, (bytes, unicode))
 
 
 def is_number(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return _get_safe_value_or_none(value, (int, float)) is not None
 
 
 class SimpleGetItemNotFound(Exception):
+    """ """
     pass
 
 
 @contextmanager
 def reraise_getitem_errors(*exception_classes):
+    """
+
+    Parameters
+    ----------
+    *exception_classes :
+        
+
+    Returns
+    -------
+
+    """
     try:
         yield
     except exception_classes as e:
@@ -164,6 +286,21 @@
 
 
 def parse_dotted_names(nodes, is_import_from, until_node=None):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+    is_import_from :
+        
+    until_node :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     level = 0
     names = []
     for node in nodes[1:]:
@@ -193,10 +330,34 @@
 
 
 def values_from_qualified_names(inference_state, *names):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    *names :
+        
+
+    Returns
+    -------
+
+    """
     return inference_state.import_module(names[:-1]).py__getattribute__(names[-1])
 
 
 def is_big_annoying_library(context):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+
+    Returns
+    -------
+
+    """
     string_names = context.get_root_context().string_names
     if string_names is None:
         return False
