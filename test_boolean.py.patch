# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_boolean.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/test_boolean.py
@@ -23,52 +23,122 @@
 
 
 def make_data():
+    """ """
     return [True, False] * 4 + [np.nan] + [True, False] * 44 + [np.nan] + [True, False]
 
 
 @pytest.fixture
 def dtype():
+    """ """
     return BooleanDtype()
 
 
 @pytest.fixture
 def data(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return pd.array(make_data(), dtype=dtype)
 
 
 @pytest.fixture
 def data_for_twos(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return pd.array(np.ones(100), dtype=dtype)
 
 
 @pytest.fixture
 def data_missing(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return pd.array([np.nan, True], dtype=dtype)
 
 
 @pytest.fixture
 def data_for_sorting(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return pd.array([True, True, False], dtype=dtype)
 
 
 @pytest.fixture
 def data_missing_for_sorting(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return pd.array([True, np.nan, False], dtype=dtype)
 
 
 @pytest.fixture
 def na_cmp():
+    """ """
     # we are pd.NA
     return lambda x, y: x is pd.NA and y is pd.NA
 
 
 @pytest.fixture
 def na_value():
+    """ """
     return pd.NA
 
 
 @pytest.fixture
 def data_for_grouping(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     b = True
     a = False
     na = np.nan
@@ -76,37 +146,80 @@
 
 
 class TestDtype(base.BaseDtypeTests):
+    """ """
     pass
 
 
 class TestInterface(base.BaseInterfaceTests):
+    """ """
     pass
 
 
 class TestConstructors(base.BaseConstructorsTests):
+    """ """
     pass
 
 
 class TestGetitem(base.BaseGetitemTests):
+    """ """
     pass
 
 
 class TestSetitem(base.BaseSetitemTests):
+    """ """
     pass
 
 
 class TestMissing(base.BaseMissingTests):
+    """ """
     pass
 
 
 class TestArithmeticOps(base.BaseArithmeticOpsTests):
+    """ """
     implements = {"__sub__", "__rsub__"}
 
     def check_opname(self, s, op_name, other, exc=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        other :
+            
+        exc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # overwriting to indicate ops don't raise an error
         super().check_opname(s, op_name, other, exc=None)
 
     def _check_op(self, s, op, other, op_name, exc=NotImplementedError):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        op_name :
+            
+        exc :
+             (Default value = NotImplementedError)
+
+        Returns
+        -------
+
+        """
         if exc is None:
             if op_name in self.implements:
                 msg = r"numpy boolean subtract"
@@ -140,15 +253,60 @@
                 op(s, other)
 
     def _check_divmod_op(self, s, op, other, exc=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        exc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # override to not raise an error
         super()._check_divmod_op(s, op, other, None)
 
     @pytest.mark.skip(reason="BooleanArray does not error on ops")
     def test_error(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         # other specific errors tested in the boolean array specific tests
         pass
 
     def test_arith_frame_with_scalar(self, data, all_arithmetic_operators, request):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+        request :
+            
+
+        Returns
+        -------
+
+        """
         # frame & scalar
         op_name = all_arithmetic_operators
         if op_name not in self.implements:
@@ -158,29 +316,105 @@
 
 
 class TestComparisonOps(base.BaseComparisonOpsTests):
+    """ """
     def check_opname(self, s, op_name, other, exc=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        other :
+            
+        exc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # overwriting to indicate ops don't raise an error
         super().check_opname(s, op_name, other, exc=None)
 
     def _compare_other(self, s, data, op_name, other):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        data :
+            
+        op_name :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         self.check_opname(s, op_name, other)
 
     @pytest.mark.skip(reason="Tested in tests/arrays/test_boolean.py")
     def test_compare_scalar(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @pytest.mark.skip(reason="Tested in tests/arrays/test_boolean.py")
     def test_compare_array(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
 
 class TestReshaping(base.BaseReshapingTests):
+    """ """
     pass
 
 
 class TestMethods(base.BaseMethodsTests):
+    """ """
     @pytest.mark.parametrize("na_sentinel", [-1, -2])
     def test_factorize(self, data_for_grouping, na_sentinel):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        na_sentinel :
+            
+
+        Returns
+        -------
+
+        """
         # override because we only have 2 unique values
         labels, uniques = pd.factorize(data_for_grouping, na_sentinel=na_sentinel)
         expected_labels = np.array(
@@ -192,6 +426,17 @@
         self.assert_extension_array_equal(uniques, expected_uniques)
 
     def test_combine_le(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         # override because expected needs to be boolean instead of bool dtype
         orig_data1, orig_data2 = data_repeated(2)
         s1 = pd.Series(orig_data1)
@@ -209,6 +454,19 @@
         self.assert_series_equal(result, expected)
 
     def test_searchsorted(self, data_for_sorting, as_series):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        as_series :
+            
+
+        Returns
+        -------
+
+        """
         # override because we only have 2 unique values
         data_for_sorting = pd.array([True, False], dtype="boolean")
         b, a = data_for_sorting
@@ -233,9 +491,35 @@
 
     @pytest.mark.skip(reason="uses nullable integer")
     def test_value_counts(self, all_data, dropna):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+        dropna :
+            
+
+        Returns
+        -------
+
+        """
         return super().test_value_counts(all_data, dropna)
 
     def test_argmin_argmax(self, data_for_sorting, data_missing_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        data_missing_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         # override because there are only 2 unique values
 
         # data_for_sorting -> [B, C, A] with A < B < C -> here True, True, False
@@ -254,16 +538,34 @@
 
 
 class TestCasting(base.BaseCastingTests):
+    """ """
     pass
 
 
 class TestGroupby(base.BaseGroupbyTests):
-    """
-    Groupby-specific tests are overridden because boolean only has 2
+    """Groupby-specific tests are overridden because boolean only has 2
     unique values, base tests uses 3 groups.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def test_grouping_grouper(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame(
             {"A": ["B", "B", None, None, "A", "A", "B"], "B": data_for_grouping}
         )
@@ -275,6 +577,19 @@
 
     @pytest.mark.parametrize("as_index", [True, False])
     def test_groupby_extension_agg(self, as_index, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        as_index :
+            
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1], "B": data_for_grouping})
         result = df.groupby("B", as_index=as_index).A.mean()
         _, index = pd.factorize(data_for_grouping, sort=True)
@@ -288,6 +603,17 @@
             self.assert_frame_equal(result, expected)
 
     def test_groupby_extension_no_sort(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1], "B": data_for_grouping})
         result = df.groupby("B", sort=False).A.mean()
         _, index = pd.factorize(data_for_grouping, sort=False)
@@ -297,6 +623,17 @@
         self.assert_series_equal(result, expected)
 
     def test_groupby_extension_transform(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         valid = data_for_grouping[~data_for_grouping.isna()]
         df = pd.DataFrame({"A": [1, 1, 3, 3, 1], "B": valid})
 
@@ -306,6 +643,19 @@
         self.assert_series_equal(result, expected)
 
     def test_groupby_extension_apply(self, data_for_grouping, groupby_apply_op):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        groupby_apply_op :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1], "B": data_for_grouping})
         df.groupby("B").apply(groupby_apply_op)
         df.groupby("B").A.apply(groupby_apply_op)
@@ -313,6 +663,17 @@
         df.groupby("A").B.apply(groupby_apply_op)
 
     def test_groupby_apply_identity(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1], "B": data_for_grouping})
         result = df.groupby("A").B.apply(lambda x: x.array)
         expected = pd.Series(
@@ -327,6 +688,17 @@
         self.assert_series_equal(result, expected)
 
     def test_in_numeric_groupby(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame(
             {
                 "A": [1, 1, 2, 2, 3, 3, 1],
@@ -345,6 +717,19 @@
 
     @pytest.mark.parametrize("min_count", [0, 10])
     def test_groupby_sum_mincount(self, data_for_grouping, min_count):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+        min_count :
+            
+
+        Returns
+        -------
+
+        """
         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1], "B": data_for_grouping})
         result = df.groupby("A").sum(min_count=min_count)
         if min_count == 0:
@@ -362,7 +747,23 @@
 
 
 class TestNumericReduce(base.BaseNumericReduceTests):
+    """ """
     def check_reduce(self, s, op_name, skipna):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         result = getattr(s, op_name)(skipna=skipna)
         expected = getattr(s.astype("float64"), op_name)(skipna=skipna)
         # override parent function to cast to bool for min/max
@@ -374,16 +775,20 @@
 
 
 class TestBooleanReduce(base.BaseBooleanReduceTests):
+    """ """
     pass
 
 
 class TestPrinting(base.BasePrintingTests):
+    """ """
     pass
 
 
 class TestUnaryOps(base.BaseUnaryOpsTests):
+    """ """
     pass
 
 
 class TestParsing(base.BaseParsingTests):
-    pass
+    """ """
+    pass
