# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/io/parser/test_c_parser_only.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/io/parser/test_c_parser_only.py
@@ -26,6 +26,19 @@
     ids=["words pointer", "stream pointer", "lines pointer"],
 )
 def test_buffer_overflow(c_parser_only, malformed):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+    malformed :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-9205: test certain malformed input files that cause
     # buffer overflows in tokenizer.c
     msg = "Buffer overflow caught - possible malformed input file."
@@ -36,6 +49,17 @@
 
 
 def test_buffer_rd_bytes(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-12098: src->buffer in the C parser can be freed twice leading
     # to a segfault if a corrupt gzip file is read with 'read_csv', and the
     # buffer is filled more than once before gzip raises an Exception.
@@ -56,6 +80,17 @@
 
 
 def test_delim_whitespace_custom_terminator(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # See gh-12912
     data = "a b c~1 2 3~4 5 6~7 8 9"
     parser = c_parser_only
@@ -66,6 +101,17 @@
 
 
 def test_dtype_and_names_error(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-8833: passing both dtype and names
     # resulting in an error reporting issue
     parser = c_parser_only
@@ -134,6 +180,21 @@
     ids=["dt64-0", "dt64-1", "td64", "<U8"],
 )
 def test_unsupported_dtype(c_parser_only, match, kwargs):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+    match :
+        
+    kwargs :
+        
+
+    Returns
+    -------
+
+    """
     parser = c_parser_only
     df = DataFrame(
         np.random.rand(5, 2), columns=list("AB"), index=["1A", "1B", "1C", "1D", "1E"]
@@ -148,6 +209,17 @@
 
 @td.skip_if_32bit
 def test_precise_conversion(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     from decimal import Decimal
 
     parser = c_parser_only
@@ -170,6 +242,17 @@
         actual_val = Decimal(text[2:])
 
         def error(val):
+            """
+
+            Parameters
+            ----------
+            val :
+                
+
+            Returns
+            -------
+
+            """
             return abs(Decimal(f"{val:.100}") - actual_val)
 
         normal_errors.append(error(normal_val))
@@ -183,6 +266,17 @@
 
 
 def test_usecols_dtypes(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     parser = c_parser_only
     data = """\
 1,2,3
@@ -212,6 +306,17 @@
 
 
 def test_disable_bool_parsing(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-2090
 
     parser = c_parser_only
@@ -229,6 +334,17 @@
 
 
 def test_custom_lineterminator(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     parser = c_parser_only
     data = "a,b,c~1,2,3~4,5,6"
 
@@ -239,6 +355,17 @@
 
 
 def test_parse_ragged_csv(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     parser = c_parser_only
     data = """1,2,3
 1,2,3,4
@@ -273,6 +400,17 @@
 
 
 def test_tokenize_CR_with_quoting(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-3453
     parser = c_parser_only
     data = ' a,b,c\r"a,b","e,d","f,f"'
@@ -287,6 +425,17 @@
 
 
 def test_grow_boundary_at_cap(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # See gh-12494
     #
     # Cause of error was that the C parser
@@ -298,6 +447,17 @@
     parser = c_parser_only
 
     def test_empty_header_read(count):
+        """
+
+        Parameters
+        ----------
+        count :
+            
+
+        Returns
+        -------
+
+        """
         s = StringIO("," * count)
         expected = DataFrame(columns=[f"Unnamed: {i}" for i in range(count + 1)])
         df = parser.read_csv(s)
@@ -308,6 +468,17 @@
 
 
 def test_parse_trim_buffers(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # This test is part of a bugfix for gh-13703. It attempts to
     # to stress the system memory allocator, to cause it to move the
     # stream buffer and either let the OS reclaim the region, or let
@@ -396,6 +567,17 @@
 
 
 def test_internal_null_byte(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-14012
     #
     # The null byte ('\x00') should not be used as a
@@ -416,6 +598,17 @@
 
 
 def test_read_nrows_large(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # gh-7626 - Read only nrows of data in for large inputs (>262144b)
     parser = c_parser_only
     header_narrow = "\t".join(["COL_HEADER_" + str(i) for i in range(10)]) + "\n"
@@ -430,6 +623,17 @@
 
 
 def test_float_precision_round_trip_with_text(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-15140
     parser = c_parser_only
     df = parser.read_csv(StringIO("a"), header=None, float_precision="round_trip")
@@ -437,6 +641,17 @@
 
 
 def test_large_difference_in_columns(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-14125
     parser = c_parser_only
 
@@ -453,6 +668,17 @@
 
 
 def test_data_after_quote(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-15910
     parser = c_parser_only
 
@@ -464,6 +690,19 @@
 
 
 def test_comment_whitespace_delimited(c_parser_only, capsys):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+    capsys :
+        
+
+    Returns
+    -------
+
+    """
     parser = c_parser_only
     test_input = """\
 1 2
@@ -493,11 +732,23 @@
 
 
 def test_file_like_no_next(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # gh-16530: the file-like need not have a "next" or "__next__"
     # attribute despite having an "__iter__" attribute.
     #
     # NOTE: This is only true for the C engine, not Python engine.
     class NoNextBuffer(StringIO):
+        """ """
         def __next__(self):
             raise AttributeError("No next method")
 
@@ -513,6 +764,17 @@
 
 
 def test_buffer_rd_bytes_bad_unicode(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-22748
     t = BytesIO(b"\xB0")
     t = TextIOWrapper(t, encoding="ascii", errors="surrogateescape")
@@ -523,6 +785,21 @@
 
 @pytest.mark.parametrize("tar_suffix", [".tar", ".tar.gz"])
 def test_read_tarfile(c_parser_only, csv_dir_path, tar_suffix):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+    csv_dir_path :
+        
+    tar_suffix :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-16530
     #
     # Unfortunately, Python's CSV library can't handle
@@ -541,6 +818,17 @@
 
 @pytest.mark.high_memory
 def test_bytes_exceed_2gb(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-16798
     #
     # Read from a "CSV" that has a column larger than 2GB.
@@ -555,6 +843,17 @@
 
 
 def test_chunk_whitespace_on_boundary(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-9735: this issue is C parser-specific (bug when
     # parsing whitespace and characters at chunk boundary)
     #
@@ -570,6 +869,19 @@
 
 
 def test_file_handles_mmap(c_parser_only, csv1):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+    csv1 :
+        
+
+    Returns
+    -------
+
+    """
     # gh-14418
     #
     # Don't close user provided file handles.
@@ -584,6 +896,17 @@
 
 
 def test_file_binary_mode(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-23779
     parser = c_parser_only
     expected = DataFrame([[1, 2, 3], [4, 5, 6]])
@@ -598,6 +921,17 @@
 
 
 def test_unix_style_breaks(c_parser_only):
+    """
+
+    Parameters
+    ----------
+    c_parser_only :
+        
+
+    Returns
+    -------
+
+    """
     # GH 11020
     parser = c_parser_only
     with tm.ensure_clean() as path:
