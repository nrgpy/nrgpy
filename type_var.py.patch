# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/type_var.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/type_var.py
@@ -5,7 +5,19 @@
 
 
 class TypeVarClass(BaseTypingValue):
+    """ """
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         unpacked = arguments.unpack()
 
         key, lazy_value = next(unpacked, (None, None))
@@ -24,6 +36,17 @@
         )])
 
     def _find_string_name(self, lazy_value):
+        """
+
+        Parameters
+        ----------
+        lazy_value :
+            
+
+        Returns
+        -------
+
+        """
         if lazy_value is None:
             return None
 
@@ -49,6 +72,7 @@
 
 
 class TypeVar(BaseTypingValue):
+    """ """
     def __init__(self, parent_context, tree_name, var_name, unpacked_args):
         super(TypeVar, self).__init__(parent_context, tree_name)
         self._var_name = var_name
@@ -71,12 +95,27 @@
                     debug.warning('Invalid TypeVar param name %s', key)
 
     def py__name__(self):
+        """ """
         return self._var_name
 
     def get_filters(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return iter([])
 
     def _get_classes(self):
+        """ """
         if self._bound_lazy_value is not None:
             return self._bound_lazy_value.infer()
         if self._constraints_lazy_values:
@@ -85,16 +124,39 @@
         return NO_VALUES
 
     def is_same_class(self, other):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         # Everything can match an undefined type var.
         return True
 
     @property
     def constraints(self):
+        """ """
         return ValueSet.from_sets(
             lazy.infer() for lazy in self._constraints_lazy_values
         )
 
     def define_generics(self, type_var_dict):
+        """
+
+        Parameters
+        ----------
+        type_var_dict :
+            
+
+        Returns
+        -------
+
+        """
         try:
             found = type_var_dict[self.py__name__()]
         except KeyError:
@@ -105,10 +167,23 @@
         return ValueSet({self})
 
     def execute_annotation(self):
+        """ """
         return self._get_classes().execute_annotation()
 
     def infer_type_vars(self, value_set):
+        """
+
+        Parameters
+        ----------
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         def iterate():
+            """ """
             for v in value_set:
                 cls = v.py__class__()
                 if v.is_function() or v.is_class():
@@ -123,9 +198,11 @@
 
 
 class TypeWrapper(ValueWrapper):
+    """ """
     def __init__(self, wrapped_value, original_value):
         super(TypeWrapper, self).__init__(wrapped_value)
         self._original_value = original_value
 
     def execute_annotation(self):
+        """ """
         return ValueSet({self._original_value})
