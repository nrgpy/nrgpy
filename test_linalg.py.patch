# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/linalg/tests/test_linalg.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/linalg/tests/test_linalg.py
@@ -24,6 +24,19 @@
 
 
 def consistent_subclass(out, in_):
+    """
+
+    Parameters
+    ----------
+    out :
+        
+    in_ :
+        
+
+    Returns
+    -------
+
+    """
     # For ndarray subclass input, our output should have the same subclass
     # (non-ndarray input gets converted to ndarray).
     return type(out) is (type(in_) if isinstance(in_, np.ndarray)
@@ -34,6 +47,25 @@
 
 
 def assert_almost_equal(a, b, single_decimal=6, double_decimal=12, **kw):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+    single_decimal :
+         (Default value = 6)
+    double_decimal :
+         (Default value = 12)
+    **kw :
+        
+
+    Returns
+    -------
+
+    """
     if asarray(a).dtype.type in (single, csingle):
         decimal = single_decimal
     else:
@@ -42,16 +74,49 @@
 
 
 def get_real_dtype(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return {single: single, double: double,
             csingle: single, cdouble: double}[dtype]
 
 
 def get_complex_dtype(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return {single: csingle, double: cdouble,
             csingle: csingle, cdouble: cdouble}[dtype]
 
 
 def get_rtol(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     # Choose a safe rtol
     if dtype in (single, csingle):
         return 1e-5
@@ -68,10 +133,16 @@
 
 class LinalgCase:
     def __init__(self, name, a, b, tags=set()):
-        """
-        A bundle of arguments to be passed to a test case, with an identifying
+    """A bundle of arguments to be passed to a test case, with an identifying
         name, the operands a and b, and a set of tags to filter the tests
-        """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
         assert_(isinstance(name, str))
         self.name = name
         self.a = a
@@ -79,8 +150,16 @@
         self.tags = frozenset(tags)  # prevent shared tags
 
     def check(self, do):
-        """
-        Run the function `do` on this test case, expanding arguments
+        """Run the function `do` on this test case, expanding arguments
+
+        Parameters
+        ----------
+        do :
+            
+
+        Returns
+        -------
+
         """
         do(self.a, self.b, tags=self.tags)
 
@@ -89,9 +168,19 @@
 
 
 def apply_tag(tag, cases):
-    """
-    Add the given tag (a string) to each of the cases (a list of LinalgCase
+    """Add the given tag (a string) to each of the cases (a list of LinalgCase
     objects)
+
+    Parameters
+    ----------
+    tag :
+        
+    cases :
+        
+
+    Returns
+    -------
+
     """
     assert tag in all_tags, "Invalid tag"
     for case in cases:
@@ -233,6 +322,7 @@
 # Gufunc test cases
 #
 def _make_generalized_cases():
+    """ """
     new_cases = []
 
     for case in CASES:
@@ -267,8 +357,16 @@
 # Generate stride combination variations of the above
 #
 def _stride_comb_iter(x):
-    """
-    Generate cartesian product of strides for all axes
+    """Generate cartesian product of strides for all axes
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
     """
 
     if not isinstance(x, np.ndarray):
@@ -315,6 +413,7 @@
 
 
 def _make_strided_cases():
+    """ """
     new_cases = []
     for case in CASES:
         for a, a_label in _stride_comb_iter(case.a):
@@ -332,12 +431,23 @@
 # Test different routines against the above cases
 #
 class LinalgTestCase:
+    """ """
     TEST_CASES = CASES
 
     def check_cases(self, require=set(), exclude=set()):
-        """
-        Run func on each of the cases with all of the tags in require, and none
+        """Run func on each of the cases with all of the tags in require, and none
         of the tags in exclude
+
+        Parameters
+        ----------
+        require :
+             (Default value = set())
+        exclude :
+             (Default value = set())
+
+        Returns
+        -------
+
         """
         for case in self.TEST_CASES:
             # filter by require and exclude
@@ -355,76 +465,107 @@
 
 
 class LinalgSquareTestCase(LinalgTestCase):
+    """ """
 
     def test_sq_cases(self):
+        """ """
         self.check_cases(require={'square'},
                          exclude={'generalized', 'size-0'})
 
     def test_empty_sq_cases(self):
+        """ """
         self.check_cases(require={'square', 'size-0'},
                          exclude={'generalized'})
 
 
 class LinalgNonsquareTestCase(LinalgTestCase):
+    """ """
 
     def test_nonsq_cases(self):
+        """ """
         self.check_cases(require={'nonsquare'},
                          exclude={'generalized', 'size-0'})
 
     def test_empty_nonsq_cases(self):
+        """ """
         self.check_cases(require={'nonsquare', 'size-0'},
                          exclude={'generalized'})
 
 
 class HermitianTestCase(LinalgTestCase):
+    """ """
 
     def test_herm_cases(self):
+        """ """
         self.check_cases(require={'hermitian'},
                          exclude={'generalized', 'size-0'})
 
     def test_empty_herm_cases(self):
+        """ """
         self.check_cases(require={'hermitian', 'size-0'},
                          exclude={'generalized'})
 
 
 class LinalgGeneralizedSquareTestCase(LinalgTestCase):
+    """ """
 
     @pytest.mark.slow
     def test_generalized_sq_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'square'},
                          exclude={'size-0'})
 
     @pytest.mark.slow
     def test_generalized_empty_sq_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'square', 'size-0'})
 
 
 class LinalgGeneralizedNonsquareTestCase(LinalgTestCase):
+    """ """
 
     @pytest.mark.slow
     def test_generalized_nonsq_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'nonsquare'},
                          exclude={'size-0'})
 
     @pytest.mark.slow
     def test_generalized_empty_nonsq_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'nonsquare', 'size-0'})
 
 
 class HermitianGeneralizedTestCase(LinalgTestCase):
+    """ """
 
     @pytest.mark.slow
     def test_generalized_herm_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'hermitian'},
                          exclude={'size-0'})
 
     @pytest.mark.slow
     def test_generalized_empty_herm_cases(self):
+        """ """
         self.check_cases(require={'generalized', 'hermitian', 'size-0'},
                          exclude={'none'})
 
 
 def dot_generalized(a, b):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
+    """
     a = asarray(a)
     if a.ndim >= 3:
         if a.ndim == b.ndim:
@@ -444,6 +585,17 @@
 
 
 def identity_like_generalized(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     a = asarray(a)
     if a.ndim >= 3:
         r = np.empty(a.shape, dtype=a.dtype)
@@ -454,21 +606,51 @@
 
 
 class SolveCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
     # kept apart from TestSolve for use for testing with matrices.
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         x = linalg.solve(a, b)
         assert_almost_equal(b, dot_generalized(a, x))
         assert_(consistent_subclass(x, b))
 
 
 class TestSolve(SolveCases):
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         assert_equal(linalg.solve(x, x).dtype, dtype)
 
     def test_0_size(self):
+        """ """
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         # Test system of 0x0 matrices
         a = np.arange(8).reshape(2, 2, 2)
@@ -501,8 +683,10 @@
         assert_raises(ValueError, linalg.solve, a[:, 0:0, 0:0], b)
 
     def test_0_size_k(self):
+        """ """
         # test zero multiple equation (K=0) case.
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.arange(4).reshape(1, 2, 2)
         b = np.arange(6).reshape(3, 2, 1).view(ArraySubclass)
@@ -520,8 +704,24 @@
 
 
 class InvCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         a_inv = linalg.inv(a)
         assert_almost_equal(dot_generalized(a, a_inv),
                             identity_like_generalized(a))
@@ -529,14 +729,28 @@
 
 
 class TestInv(InvCases):
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         assert_equal(linalg.inv(x).dtype, dtype)
 
     def test_0_size(self):
+        """ """
         # Check that all kinds of 0-sized arrays work
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res = linalg.inv(a)
@@ -552,24 +766,54 @@
 
 
 class EigvalsCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         ev = linalg.eigvals(a)
         evalues, evectors = linalg.eig(a)
         assert_almost_equal(ev, evalues)
 
 
 class TestEigvals(EigvalsCases):
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         assert_equal(linalg.eigvals(x).dtype, dtype)
         x = np.array([[1, 0.5], [-1, 1]], dtype=dtype)
         assert_equal(linalg.eigvals(x).dtype, get_complex_dtype(dtype))
 
     def test_0_size(self):
+        """ """
         # Check that all kinds of 0-sized arrays work
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res = linalg.eigvals(a)
@@ -587,8 +831,24 @@
 
 
 class EigCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         evalues, evectors = linalg.eig(a)
         assert_allclose(dot_generalized(a, evectors),
                         np.asarray(evectors) * np.asarray(evalues)[..., None, :],
@@ -597,8 +857,20 @@
 
 
 class TestEig(EigCases):
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         w, v = np.linalg.eig(x)
         assert_equal(w.dtype, dtype)
@@ -610,8 +882,10 @@
         assert_equal(v.dtype, get_complex_dtype(dtype))
 
     def test_0_size(self):
+        """ """
         # Check that all kinds of 0-sized arrays work
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res, res_v = linalg.eig(a)
@@ -633,10 +907,22 @@
 
 
 class SVDBaseTests:
+    """ """
     hermitian = False
 
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         u, s, vh = linalg.svd(x)
         assert_equal(u.dtype, dtype)
@@ -647,8 +933,24 @@
 
 
 class SVDCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         u, s, vt = linalg.svd(a, False)
         assert_allclose(a, dot_generalized(np.asarray(u) * np.asarray(s)[..., None, :],
                                            np.asarray(vt)),
@@ -658,8 +960,9 @@
 
 
 class TestSVD(SVDCases, SVDBaseTests):
+    """ """
     def test_empty_identity(self):
-        """ Empty input should put an identity matrix in u or vh """
+        """Empty input should put an identity matrix in u or vh"""
         x = np.empty((4, 0))
         u, s, vh = linalg.svd(x, compute_uv=True, hermitian=self.hermitian)
         assert_equal(u.shape, (4, 4))
@@ -674,13 +977,40 @@
 
 
 class SVDHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         u, s, vt = linalg.svd(a, False, hermitian=True)
         assert_allclose(a, dot_generalized(np.asarray(u) * np.asarray(s)[..., None, :],
                                            np.asarray(vt)),
                         rtol=get_rtol(u.dtype))
         def hermitian(mat):
+            """
+
+            Parameters
+            ----------
+            mat :
+                
+
+            Returns
+            -------
+
+            """
             axes = list(range(mat.ndim))
             axes[-1], axes[-2] = axes[-2], axes[-1]
             return np.conj(np.transpose(mat, axes=axes))
@@ -693,13 +1023,30 @@
 
 
 class TestSVDHermitian(SVDHermitianCases, SVDBaseTests):
+    """ """
     hermitian = True
 
 
 class CondCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
     # cond(x, p) for p in (None, 2, -2)
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         c = asarray(a)  # a might be a matrix
         if 'size-0' in tags:
             assert_raises(LinAlgError, linalg.cond, c)
@@ -743,7 +1090,9 @@
 
 
 class TestCond(CondCases):
+    """ """
     def test_basic_nonsvd(self):
+        """ """
         # Smoketest the non-svd norms
         A = array([[1., 0, 1], [0, -2., 0], [0, 0, 3.]])
         assert_almost_equal(linalg.cond(A, inf), 4)
@@ -753,6 +1102,7 @@
         assert_almost_equal(linalg.cond(A, 'fro'), np.sqrt(265 / 12))
 
     def test_singular(self):
+        """ """
         # Singular matrices have infinite condition number for
         # positive norms, and negative norms shouldn't raise
         # exceptions
@@ -767,6 +1117,7 @@
             linalg.cond(A, p)
 
     def test_nan(self):
+        """ """
         # nans should be passed through, not converted to infs
         ps = [None, 1, -1, 2, -2, 'fro']
         p_pos = [None, 1, 2, 'fro']
@@ -791,6 +1142,7 @@
                 assert_(not np.isnan(c[2]))
 
     def test_stacked_singular(self):
+        """ """
         # Check behavior when only some of the stacked matrices are
         # singular
         np.random.seed(1234)
@@ -810,8 +1162,24 @@
                 LinalgNonsquareTestCase,
                 LinalgGeneralizedSquareTestCase,
                 LinalgGeneralizedNonsquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         a_ginv = linalg.pinv(a)
         # `a @ a_ginv == I` does not hold if a is singular
         dot = dot_generalized
@@ -820,12 +1188,29 @@
 
 
 class TestPinv(PinvCases):
+    """ """
     pass
 
 
 class PinvHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         a_ginv = linalg.pinv(a, hermitian=True)
         # `a @ a_ginv == I` does not hold if a is singular
         dot = dot_generalized
@@ -834,12 +1219,29 @@
 
 
 class TestPinvHermitian(PinvHermitianCases):
+    """ """
     pass
 
 
 class DetCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         d = linalg.det(a)
         (s, ld) = linalg.slogdet(a)
         if asarray(a).dtype.type in (single, double):
@@ -858,7 +1260,9 @@
 
 
 class TestDet(DetCases):
+    """ """
     def test_zero(self):
+        """ """
         assert_equal(linalg.det([[0.0]]), 0.0)
         assert_equal(type(linalg.det([[0.0]])), double)
         assert_equal(linalg.det([[0.0j]]), 0.0)
@@ -873,6 +1277,17 @@
 
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         assert_equal(np.linalg.det(x).dtype, dtype)
         ph, s = np.linalg.slogdet(x)
@@ -880,6 +1295,7 @@
         assert_equal(ph.dtype, dtype)
 
     def test_0_size(self):
+        """ """
         a = np.zeros((0, 0), dtype=np.complex64)
         res = linalg.det(a)
         assert_equal(res, 1.)
@@ -900,8 +1316,24 @@
 
 
 class LstsqCases(LinalgSquareTestCase, LinalgNonsquareTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         arr = np.asarray(a)
         m, n = arr.shape
         u, s, vt = linalg.svd(a, False)
@@ -930,7 +1362,9 @@
 
 
 class TestLstsq(LstsqCases):
+    """ """
     def test_future_rcond(self):
+        """ """
         a = np.array([[0., 1.,  0.,  1.,  2.,  0.],
                       [0., 2.,  0.,  0.,  1.,  0.],
                       [1., 0.,  1.,  0.,  0.,  4.],
@@ -958,6 +1392,21 @@
         (0, 0, 0)
     ])
     def test_empty_a_b(self, m, n, n_rhs):
+        """
+
+        Parameters
+        ----------
+        m :
+            
+        n :
+            
+        n_rhs :
+            
+
+        Returns
+        -------
+
+        """
         a = np.arange(m * n).reshape(m, n)
         b = np.ones((m, n_rhs))
         x, residuals, rank, s = linalg.lstsq(a, b, rcond=None)
@@ -973,6 +1422,7 @@
         assert_equal(s.shape, (min(m, n),))
 
     def test_incompatible_dims(self):
+        """ """
         # use modified version of docstring example
         x = np.array([0, 1, 2, 3])
         y = np.array([-1, 0.2, 0.9, 2.1, 3.3])
@@ -983,6 +1433,7 @@
 
 @pytest.mark.parametrize('dt', [np.dtype(c) for c in '?bBhHiIqQefdgFDGO']) 
 class TestMatrixPower:
+    """ """
 
     rshft_0 = np.eye(4)
     rshft_1 = rshft_0[[3, 0, 1, 2]]
@@ -995,6 +1446,17 @@
     dtnoinv = [object, np.dtype('e'), np.dtype('g'), np.dtype('G')]
 
     def test_large_power(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         rshft = self.rshft_1.astype(dt)
         assert_equal(
             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 0), self.rshft_0)
@@ -1006,7 +1468,29 @@
             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 3), self.rshft_3)
 
     def test_power_is_zero(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         def tz(M):
+            """
+
+            Parameters
+            ----------
+            M :
+                
+
+            Returns
+            -------
+
+            """
             mz = matrix_power(M, 0)
             assert_equal(mz, identity_like_generalized(M))
             assert_equal(mz.dtype, M.dtype)
@@ -1017,7 +1501,29 @@
                 tz(self.stacked.astype(dt))
 
     def test_power_is_one(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         def tz(mat):
+            """
+
+            Parameters
+            ----------
+            mat :
+                
+
+            Returns
+            -------
+
+            """
             mz = matrix_power(mat, 1)
             assert_equal(mz, mat)
             assert_equal(mz.dtype, mat.dtype)
@@ -1028,7 +1534,29 @@
                 tz(self.stacked.astype(dt))
 
     def test_power_is_two(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         def tz(mat):
+            """
+
+            Parameters
+            ----------
+            mat :
+                
+
+            Returns
+            -------
+
+            """
             mz = matrix_power(mat, 2)
             mmul = matmul if mat.dtype != object else dot
             assert_equal(mz, mmul(mat, mat))
@@ -1040,7 +1568,29 @@
                 tz(self.stacked.astype(dt))
 
     def test_power_is_minus_one(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         def tz(mat):
+            """
+
+            Parameters
+            ----------
+            mat :
+                
+
+            Returns
+            -------
+
+            """
             invmat = matrix_power(mat, -1)
             mmul = matmul if mat.dtype != object else dot
             assert_almost_equal(
@@ -1051,16 +1601,49 @@
                 tz(mat.astype(dt))
 
     def test_exceptions_bad_power(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         mat = self.rshft_0.astype(dt)
         assert_raises(TypeError, matrix_power, mat, 1.5)
         assert_raises(TypeError, matrix_power, mat, [1])
 
     def test_exceptions_non_square(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         assert_raises(LinAlgError, matrix_power, np.array([1], dt), 1)
         assert_raises(LinAlgError, matrix_power, np.array([[1], [2]], dt), 1)
         assert_raises(LinAlgError, matrix_power, np.ones((4, 3, 2), dt), 1)
 
     def test_exceptions_not_invertible(self, dt):
+        """
+
+        Parameters
+        ----------
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         if dt in self.dtnoinv:
             return
         mat = self.noninv.astype(dt)
@@ -1069,8 +1652,24 @@
 
 
 class TestEigvalshCases(HermitianTestCase, HermitianGeneralizedTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         # note that eigenvalue arrays returned by eig must be sorted since
         # their order isn't guaranteed.
         ev = linalg.eigvalsh(a, 'L')
@@ -1083,19 +1682,33 @@
 
 
 class TestEigvalsh:
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         w = np.linalg.eigvalsh(x)
         assert_equal(w.dtype, get_real_dtype(dtype))
 
     def test_invalid(self):
+        """ """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)
         assert_raises(ValueError, np.linalg.eigvalsh, x, UPLO="lrong")
         assert_raises(ValueError, np.linalg.eigvalsh, x, "lower")
         assert_raises(ValueError, np.linalg.eigvalsh, x, "upper")
 
     def test_UPLO(self):
+        """ """
         Klo = np.array([[0, 0], [1, 0]], dtype=np.double)
         Kup = np.array([[0, 1], [0, 0]], dtype=np.double)
         tgt = np.array([-1, 1], dtype=np.double)
@@ -1118,8 +1731,10 @@
         assert_allclose(w, tgt, rtol=rtol)
 
     def test_0_size(self):
+        """ """
         # Check that all kinds of 0-sized arrays work
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res = linalg.eigvalsh(a)
@@ -1137,8 +1752,24 @@
 
 
 class TestEighCases(HermitianTestCase, HermitianGeneralizedTestCase):
+    """ """
 
     def do(self, a, b, tags):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        tags :
+            
+
+        Returns
+        -------
+
+        """
         # note that eigenvalue arrays returned by eig must be sorted since
         # their order isn't guaranteed.
         ev, evc = linalg.eigh(a)
@@ -1159,20 +1790,34 @@
 
 
 class TestEigh:
+    """ """
     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
     def test_types(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
         w, v = np.linalg.eigh(x)
         assert_equal(w.dtype, get_real_dtype(dtype))
         assert_equal(v.dtype, dtype)
 
     def test_invalid(self):
+        """ """
         x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)
         assert_raises(ValueError, np.linalg.eigh, x, UPLO="lrong")
         assert_raises(ValueError, np.linalg.eigh, x, "lower")
         assert_raises(ValueError, np.linalg.eigh, x, "upper")
 
     def test_UPLO(self):
+        """ """
         Klo = np.array([[0, 0], [1, 0]], dtype=np.double)
         Kup = np.array([[0, 1], [0, 0]], dtype=np.double)
         tgt = np.array([-1, 1], dtype=np.double)
@@ -1195,8 +1840,10 @@
         assert_allclose(w, tgt, rtol=rtol)
 
     def test_0_size(self):
+        """ """
         # Check that all kinds of 0-sized arrays work
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res, res_v = linalg.eigh(a)
@@ -1218,18 +1865,22 @@
 
 
 class _TestNormBase:
+    """ """
     dt = None
     dec = None
 
 
 class _TestNormGeneral(_TestNormBase):
+    """ """
 
     def test_empty(self):
+        """ """
         assert_equal(norm([]), 0.0)
         assert_equal(norm(array([], dtype=self.dt)), 0.0)
         assert_equal(norm(atleast_2d(array([], dtype=self.dt))), 0.0)
 
     def test_vector_return_type(self):
+        """ """
         a = np.array([1, 0, 1])
 
         exact_types = np.typecodes['AllInteger']
@@ -1271,11 +1922,23 @@
             assert_almost_equal(an, 1.0)
 
     def test_vector(self):
+        """ """
         a = [1, 2, 3, 4]
         b = [-1, -2, -3, -4]
         c = [-1, 2, -3, 4]
 
         def _test(v):
+            """
+
+            Parameters
+            ----------
+            v :
+                
+
+            Returns
+            -------
+
+            """
             np.testing.assert_almost_equal(norm(v), 30 ** 0.5,
                                            decimal=self.dec)
             np.testing.assert_almost_equal(norm(v, inf), 4.0,
@@ -1301,6 +1964,7 @@
             _test(v)
 
     def test_axis(self):
+        """ """
         # Vector norms.
         # Compare the use of `axis` with computing the norm of each row
         # or column separately.
@@ -1338,6 +2002,7 @@
                     assert_almost_equal(n, expected)
 
     def test_keepdims(self):
+        """ """
         A = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
 
         allclose_err = 'order {0}, axis = {1}'
@@ -1381,14 +2046,17 @@
 
 
 class _TestNorm2D(_TestNormBase):
+    """ """
     # Define the part for 2d arrays separately, so we can subclass this
     # and run the tests using np.matrix in matrixlib.tests.test_matrix_linalg.
     array = np.array
 
     def test_matrix_empty(self):
+        """ """
         assert_equal(norm(self.array([[]], dtype=self.dt)), 0.0)
 
     def test_matrix_return_type(self):
+        """ """
         a = self.array([[1, 0, 1], [0, 1, 1]])
 
         exact_types = np.typecodes['AllInteger']
@@ -1440,6 +2108,7 @@
             np.testing.assert_almost_equal(an, 2.7320508075688772, decimal=6)
 
     def test_matrix_2x2(self):
+        """ """
         A = self.array([[1, 3], [5, 7]], dtype=self.dt)
         assert_almost_equal(norm(A), 84 ** 0.5)
         assert_almost_equal(norm(A, 'fro'), 84 ** 0.5)
@@ -1456,6 +2125,7 @@
         assert_raises(ValueError, norm, A, 0)
 
     def test_matrix_3x3(self):
+        """ """
         # This test has been added because the 2x2 example
         # happened to have equal nuclear norm and induced 1-norm.
         # The 1/10 scaling factor accommodates the absolute tolerance
@@ -1473,6 +2143,7 @@
         assert_almost_equal(norm(A, -2), 0.19456584790481812)
 
     def test_bad_args(self):
+        """ """
         # Check that bad arguments raise the appropriate exceptions.
 
         A = self.array([[1, 2, 3], [4, 5, 6]], dtype=self.dt)
@@ -1501,24 +2172,29 @@
 
 
 class _TestNorm(_TestNorm2D, _TestNormGeneral):
+    """ """
     pass
 
 
 class TestNorm_NonSystematic:
+    """ """
 
     def test_longdouble_norm(self):
+        """ """
         # Non-regression test: p-norm of longdouble would previously raise
         # UnboundLocalError.
         x = np.arange(10, dtype=np.longdouble)
         old_assert_almost_equal(norm(x, ord=3), 12.65, decimal=2)
 
     def test_intmin(self):
+        """ """
         # Non-regression test: p-norm of signed integer would previously do
         # float cast and abs in the wrong order.
         x = np.array([-2 ** 31], dtype=np.int32)
         old_assert_almost_equal(norm(x, ord=3), 2 ** 31, decimal=5)
 
     def test_complex_high_ord(self):
+        """ """
         # gh-4156
         d = np.empty((2,), dtype=np.clongdouble)
         d[0] = 6 + 7j
@@ -1533,35 +2209,43 @@
 
 # Separate definitions so we can use them for matrix tests.
 class _TestNormDoubleBase(_TestNormBase):
+    """ """
     dt = np.double
     dec = 12
 
 
 class _TestNormSingleBase(_TestNormBase):
+    """ """
     dt = np.float32
     dec = 6
 
 
 class _TestNormInt64Base(_TestNormBase):
+    """ """
     dt = np.int64
     dec = 12
 
 
 class TestNormDouble(_TestNorm, _TestNormDoubleBase):
+    """ """
     pass
 
 
 class TestNormSingle(_TestNorm, _TestNormSingleBase):
+    """ """
     pass
 
 
 class TestNormInt64(_TestNorm, _TestNormInt64Base):
+    """ """
     pass
 
 
 class TestMatrixRank:
+    """ """
 
     def test_matrix_rank(self):
+        """ """
         # Full rank matrix
         assert_equal(4, matrix_rank(np.eye(4)))
         # rank deficient matrix
@@ -1582,6 +2266,7 @@
         assert_equal(matrix_rank(1), 1)
 
     def test_symmetric_rank(self):
+        """ """
         assert_equal(4, matrix_rank(np.eye(4), hermitian=True))
         assert_equal(1, matrix_rank(np.ones((4, 4)), hermitian=True))
         assert_equal(0, matrix_rank(np.zeros((4, 4)), hermitian=True))
@@ -1596,6 +2281,7 @@
 
 
 def test_reduced_rank():
+    """ """
     # Test matrices with reduced rank
     rng = np.random.RandomState(20120714)
     for i in range(100):
@@ -1609,10 +2295,22 @@
 
 
 class TestQR:
+    """ """
     # Define the array class here, so run this on matrices elsewhere.
     array = np.array
 
     def check_qr(self, a):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+
+        Returns
+        -------
+
+        """
         # This test expects the argument `a` to be an ndarray or
         # a subclass of an ndarray of inexact type.
         a_type = type(a)
@@ -1657,6 +2355,19 @@
         (0, 0)
     ])
     def test_qr_empty(self, m, n):
+        """
+
+        Parameters
+        ----------
+        m :
+            
+        n :
+            
+
+        Returns
+        -------
+
+        """
         k = min(m, n)
         a = np.empty((m, n))
 
@@ -1669,6 +2380,7 @@
         assert_equal(tau.shape, (k,))
 
     def test_mode_raw(self):
+        """ """
         # The factorization is not unique and varies between libraries,
         # so it is not possible to check against known values. Functional
         # testing is a possibility, but awaits the exposure of more
@@ -1691,6 +2403,7 @@
         assert_(tau.shape == (2,))
 
     def test_mode_all_but_economic(self):
+        """ """
         a = self.array([[1, 2], [3, 4]])
         b = self.array([[1, 2], [3, 4], [5, 6]])
         for dt in "fd":
@@ -1709,9 +2422,11 @@
 
 
 class TestCholesky:
+    """ """
     # TODO: are there no other tests for cholesky?
 
     def test_basic_property(self):
+        """ """
         # Check A = L L^H
         shapes = [(1, 1), (2, 2), (3, 3), (50, 50), (3, 10, 10)]
         dtypes = (np.float32, np.float64, np.complex64, np.complex128)
@@ -1736,7 +2451,9 @@
                             atol=500 * a.shape[0] * np.finfo(dtype).eps)
 
     def test_0_size(self):
+        """ """
         class ArraySubclass(np.ndarray):
+            """ """
             pass
         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
         res = linalg.cholesky(a)
@@ -1753,6 +2470,7 @@
 
 
 def test_byteorder_check():
+    """ """
     # Byte order check should pass for native order
     if sys.byteorder == 'little':
         native = '<'
@@ -1774,6 +2492,7 @@
 
 
 def test_generalized_raise_multiloop():
+    """ """
     # It should raise an error even if the error doesn't occur in the
     # last iteration of the ufunc inner loop
 
@@ -1788,6 +2507,7 @@
 
 
 def test_xerbla_override():
+    """ """
     # Check that our xerbla has been successfully linked in. If it is not,
     # the default xerbla routine is called, which prints a message to stdout
     # and may, or may not, abort the process depending on the LAPACK package.
@@ -1838,6 +2558,7 @@
 
 @pytest.mark.slow
 def test_sdot_bug_8577():
+    """ """
     # Regression test that loading certain other libraries does not
     # result to wrong results in float32 linear algebra.
     #
@@ -1872,8 +2593,10 @@
 
 
 class TestMultiDot:
+    """ """
 
     def test_basic_function_with_three_arguments(self):
+        """ """
         # multi_dot with three arguments uses a fast hand coded algorithm to
         # determine the optimal order. Therefore test it separately.
         A = np.random.random((6, 2))
@@ -1884,6 +2607,7 @@
         assert_almost_equal(multi_dot([A, B, C]), np.dot(A, np.dot(B, C)))
 
     def test_basic_function_with_two_arguments(self):
+        """ """
         # separate code path with two arguments
         A = np.random.random((6, 2))
         B = np.random.random((2, 6))
@@ -1892,6 +2616,7 @@
         assert_almost_equal(multi_dot([A, B]), np.dot(A, B))
 
     def test_basic_function_with_dynamic_programing_optimization(self):
+        """ """
         # multi_dot with four or more arguments uses the dynamic programing
         # optimization and therefore deserve a separate
         A = np.random.random((6, 2))
@@ -1901,6 +2626,7 @@
         assert_almost_equal(multi_dot([A, B, C, D]), A.dot(B).dot(C).dot(D))
 
     def test_vector_as_first_argument(self):
+        """ """
         # The first argument can be 1-D
         A1d = np.random.random(2)  # 1-D
         B = np.random.random((2, 6))
@@ -1911,6 +2637,7 @@
         assert_equal(multi_dot([A1d, B, C, D]).shape, (2,))
 
     def test_vector_as_last_argument(self):
+        """ """
         # The last argument can be 1-D
         A = np.random.random((6, 2))
         B = np.random.random((2, 6))
@@ -1921,6 +2648,7 @@
         assert_equal(multi_dot([A, B, C, D1d]).shape, (6,))
 
     def test_vector_as_first_and_last_argument(self):
+        """ """
         # The first and last arguments can be 1-D
         A1d = np.random.random(2)  # 1-D
         B = np.random.random((2, 6))
@@ -1931,6 +2659,7 @@
         assert_equal(multi_dot([A1d, B, C, D1d]).shape, ())
 
     def test_three_arguments_and_out(self):
+        """ """
         # multi_dot with three arguments uses a fast hand coded algorithm to
         # determine the optimal order. Therefore test it separately.
         A = np.random.random((6, 2))
@@ -1944,6 +2673,7 @@
         assert_almost_equal(out, np.dot(A, np.dot(B, C)))
 
     def test_two_arguments_and_out(self):
+        """ """
         # separate code path with two arguments
         A = np.random.random((6, 2))
         B = np.random.random((2, 6))
@@ -1954,6 +2684,7 @@
         assert_almost_equal(out, np.dot(A, B))
 
     def test_dynamic_programing_optimization_and_out(self):
+        """ """
         # multi_dot with four or more arguments uses the dynamic programing
         # optimization and therefore deserve a separate test
         A = np.random.random((6, 2))
@@ -1966,6 +2697,7 @@
         assert_almost_equal(out, A.dot(B).dot(C).dot(D))
 
     def test_dynamic_programming_logic(self):
+        """ """
         # Test for the dynamic programming part
         # This test is directly taken from Cormen page 376.
         arrays = [np.random.random((30, 35)),
@@ -1996,17 +2728,32 @@
         assert_almost_equal(np.triu(m), np.triu(m_expected))
 
     def test_too_few_input_arrays(self):
+        """ """
         assert_raises(ValueError, multi_dot, [])
         assert_raises(ValueError, multi_dot, [np.random.random((3, 3))])
 
 
 class TestTensorinv:
+    """ """
 
     @pytest.mark.parametrize("arr, ind", [
         (np.ones((4, 6, 8, 2)), 2),
         (np.ones((3, 3, 2)), 1),
         ])
     def test_non_square_handling(self, arr, ind):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+        ind :
+            
+
+        Returns
+        -------
+
+        """
         with assert_raises(LinAlgError):
             linalg.tensorinv(arr, ind=ind)
 
@@ -2016,6 +2763,19 @@
         ((24, 8, 3), 1),
         ])
     def test_tensorinv_shape(self, shape, ind):
+        """
+
+        Parameters
+        ----------
+        shape :
+            
+        ind :
+            
+
+        Returns
+        -------
+
+        """
         a = np.eye(24)
         a.shape = shape
         ainv = linalg.tensorinv(a=a, ind=ind)
@@ -2027,12 +2787,24 @@
         0, -2,
         ])
     def test_tensorinv_ind_limit(self, ind):
+        """
+
+        Parameters
+        ----------
+        ind :
+            
+
+        Returns
+        -------
+
+        """
         a = np.eye(24)
         a.shape = (4, 6, 8, 3)
         with assert_raises(ValueError):
             linalg.tensorinv(a=a, ind=ind)
 
     def test_tensorinv_result(self):
+        """ """
         # mimic a docstring example
         a = np.eye(24)
         a.shape = (24, 8, 3)
@@ -2042,6 +2814,7 @@
 
 
 def test_unsupported_commontype():
+    """ """
     # linalg gracefully handles unsupported type
     arr = np.array([[1, -2], [2, 5]], dtype='float16')
     with assert_raises_regex(TypeError, "unsupported in linalg"):
@@ -2053,6 +2826,7 @@
                    reason="Numpy not compiled with 64-bit BLAS/LAPACK")
 @requires_memory(free_bytes=16e9)
 def test_blas64_dot():
+    """ """
     n = 2**32
     a = np.zeros([1, n], dtype=np.float32)
     b = np.ones([1, 1], dtype=np.float32)
@@ -2064,6 +2838,7 @@
 @pytest.mark.xfail(not HAS_LAPACK64,
                    reason="Numpy not compiled with 64-bit BLAS/LAPACK")
 def test_blas64_geqrf_lwork_smoketest():
+    """ """
     # Smoke test LAPACK geqrf lwork call with 64-bit integers
     dtype = np.float64
     lapack_routine = np.linalg.lapack_lite.dgeqrf
