# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/dateutil/rrule.py
+++ b/..//venv/lib/python3.8/site-packages/dateutil/rrule.py
@@ -63,9 +63,7 @@
 
 
 class weekday(weekdaybase):
-    """
-    This version of weekday does not allow n = 0.
-    """
+    """This version of weekday does not allow n = 0."""
     def __init__(self, wkday, n=None):
         if n == 0:
             raise ValueError("Can't create weekday with n==0")
@@ -77,11 +75,32 @@
 
 
 def _invalidates_cache(f):
-    """
-    Decorator for rruleset methods which may invalidate the
+    """Decorator for rruleset methods which may invalidate the
     cached length.
+
+    Parameters
+    ----------
+    f :
+        
+
+    Returns
+    -------
+
     """
     def inner_func(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         rv = f(self, *args, **kwargs)
         self._invalidate_cache()
         return rv
@@ -90,6 +109,7 @@
 
 
 class rrulebase(object):
+    """ """
     def __init__(self, cache=False):
         if cache:
             self._cache = []
@@ -109,6 +129,7 @@
             return self._iter_cached()
 
     def _invalidate_cache(self):
+        """ """
         if self._cache is not None:
             self._cache = []
             self._cache_complete = False
@@ -120,6 +141,7 @@
         self._len = None
 
     def _iter_cached(self):
+        """ """
         i = 0
         gen = self._cache_gen
         cache = self._cache
@@ -179,17 +201,37 @@
 
     # __len__() introduces a large performance penalty.
     def count(self):
-        """ Returns the number of recurrences in this set. It will have go
-            trough the whole recurrence, if this hasn't been done before. """
+        """Returns the number of recurrences in this set. It will have go
+            trough the whole recurrence, if this hasn't been done before.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         if self._len is None:
             for x in self:
                 pass
         return self._len
 
     def before(self, dt, inc=False):
-        """ Returns the last recurrence before the given datetime instance. The
+        """Returns the last recurrence before the given datetime instance. The
             inc keyword defines what happens if dt is an occurrence. With
-            inc=True, if dt itself is an occurrence, it will be returned. """
+            inc=True, if dt itself is an occurrence, it will be returned.
+
+        Parameters
+        ----------
+        dt :
+            
+        inc :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if self._cache_complete:
             gen = self._cache
         else:
@@ -208,9 +250,21 @@
         return last
 
     def after(self, dt, inc=False):
-        """ Returns the first recurrence after the given datetime instance. The
+        """Returns the first recurrence after the given datetime instance. The
             inc keyword defines what happens if dt is an occurrence. With
-            inc=True, if dt itself is an occurrence, it will be returned.  """
+            inc=True, if dt itself is an occurrence, it will be returned.
+
+        Parameters
+        ----------
+        dt :
+            
+        inc :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if self._cache_complete:
             gen = self._cache
         else:
@@ -226,22 +280,25 @@
         return None
 
     def xafter(self, dt, count=None, inc=False):
-        """
-        Generator which yields up to `count` recurrences after the given
+        """Generator which yields up to `count` recurrences after the given
         datetime instance, equivalent to `after`.
 
-        :param dt:
+        Parameters
+        ----------
+        dt :
             The datetime at which to start generating recurrences.
-
-        :param count:
+        count :
             The maximum number of recurrences to generate. If `None` (default),
             dates are generated until the recurrence rule is exhausted.
-
-        :param inc:
+        inc :
             If `dt` is an instance of the rule and `inc` is `True`, it is
             included in the output.
-
-        :yields: Yields a sequence of `datetime` objects.
+            
+            :yields: Yields a sequence of `datetime` objects. (Default value = False)
+
+        Returns
+        -------
+
         """
 
         if self._cache_complete:
@@ -267,10 +324,26 @@
                 yield d
 
     def between(self, after, before, inc=False, count=1):
-        """ Returns all the occurrences of the rrule between after and before.
+        """Returns all the occurrences of the rrule between after and before.
         The inc keyword defines what happens if after and/or before are
         themselves occurrences. With inc=True, they will be included in the
-        list, if they are found in the recurrence set. """
+        list, if they are found in the recurrence set.
+
+        Parameters
+        ----------
+        after :
+            
+        before :
+            
+        inc :
+             (Default value = False)
+        count :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         if self._cache_complete:
             gen = self._cache
         else:
@@ -301,104 +374,96 @@
 
 
 class rrule(rrulebase):
-    """
-    That's the base of the rrule operation. It accepts all the keywords
+    """That's the base of the rrule operation. It accepts all the keywords
     defined in the RFC as its constructor parameters (except byday,
     which was renamed to byweekday) and more. The constructor prototype is::
-
+    
             rrule(freq)
-
+    
     Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
     or SECONDLY.
-
+    
     .. note::
         Per RFC section 3.3.10, recurrence instances falling on invalid dates
         and times are ignored rather than coerced:
-
+    
             Recurrence rules may generate recurrence instances with an invalid
             date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
             on a day where the local time is moved forward by an hour at 1:00
             AM).  Such recurrence instances MUST be ignored and MUST NOT be
             counted as part of the recurrence set.
-
+    
         This can lead to possibly surprising behavior when, for example, the
         start date occurs at the end of the month:
-
-        >>> from dateutil.rrule import rrule, MONTHLY
-        >>> from datetime import datetime
-        >>> start_date = datetime(2014, 12, 31)
-        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
-        ... # doctest: +NORMALIZE_WHITESPACE
-        [datetime.datetime(2014, 12, 31, 0, 0),
-         datetime.datetime(2015, 1, 31, 0, 0),
-         datetime.datetime(2015, 3, 31, 0, 0),
-         datetime.datetime(2015, 5, 31, 0, 0)]
-
+    
+    
     Additionally, it supports the following keyword arguments:
 
-    :param dtstart:
+    Parameters
+    ----------
+    dtstart :
         The recurrence start. Besides being the base for the recurrence,
         missing parameters in the final recurrence instances will also be
         extracted from this date. If not given, datetime.now() will be used
         instead.
-    :param interval:
+    interval :
         The interval between each freq iteration. For example, when using
         YEARLY, an interval of 2 means once every two years, but with HOURLY,
         it means once every two hours. The default interval is 1.
-    :param wkst:
+    wkst :
         The week start day. Must be one of the MO, TU, WE constants, or an
         integer, specifying the first day of the week. This will affect
         recurrences based on weekly periods. The default week start is got
         from calendar.firstweekday(), and may be modified by
         calendar.setfirstweekday().
-    :param count:
+    count :
         If given, this determines how many occurrences will be generated.
-
+        
         .. note::
-            As of version 2.5.0, the use of the keyword ``until`` in conjunction
-            with ``count`` is deprecated, to make sure ``dateutil`` is fully
-            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
-            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
-            **must not** occur in the same call to ``rrule``.
-    :param until:
+        As of version 2.5.0, the use of the keyword ``until`` in conjunction
+        with ``count`` is deprecated, to make sure ``dateutil`` is fully
+        compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+        html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+        **must not** occur in the same call to ``rrule``.
+    until :
         If given, this must be a datetime instance specifying the upper-bound
         limit of the recurrence. The last recurrence in the rule is the greatest
         datetime that is less than or equal to the value specified in the
         ``until`` parameter.
-
+        
         .. note::
-            As of version 2.5.0, the use of the keyword ``until`` in conjunction
-            with ``count`` is deprecated, to make sure ``dateutil`` is fully
-            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
-            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
-            **must not** occur in the same call to ``rrule``.
-    :param bysetpos:
+        As of version 2.5.0, the use of the keyword ``until`` in conjunction
+        with ``count`` is deprecated, to make sure ``dateutil`` is fully
+        compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+        html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+        **must not** occur in the same call to ``rrule``.
+    bysetpos :
         If given, it must be either an integer, or a sequence of integers,
         positive or negative. Each given integer will specify an occurrence
         number, corresponding to the nth occurrence of the rule inside the
         frequency period. For example, a bysetpos of -1 if combined with a
         MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
         result in the last work day of every month.
-    :param bymonth:
+    bymonth :
         If given, it must be either an integer, or a sequence of integers,
         meaning the months to apply the recurrence to.
-    :param bymonthday:
+    bymonthday :
         If given, it must be either an integer, or a sequence of integers,
         meaning the month days to apply the recurrence to.
-    :param byyearday:
+    byyearday :
         If given, it must be either an integer, or a sequence of integers,
         meaning the year days to apply the recurrence to.
-    :param byeaster:
+    byeaster :
         If given, it must be either an integer, or a sequence of integers,
         positive or negative. Each integer will define an offset from the
         Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
         Sunday itself. This is an extension to the RFC specification.
-    :param byweekno:
+    byweekno :
         If given, it must be either an integer, or a sequence of integers,
         meaning the week numbers to apply the recurrence to. Week numbers
         have the meaning described in ISO8601, that is, the first week of
         the year is that containing at least four days of the new year.
-    :param byweekday:
+    byweekday :
         If given, it must be either an integer (0 == MO), a sequence of
         integers, one of the weekday constants (MO, TU, etc), or a sequence
         of these constants. When given, these variables will define the
@@ -409,20 +474,33 @@
         first friday of the month where the recurrence happens. Notice that in
         the RFC documentation, this is specified as BYDAY, but was renamed to
         avoid the ambiguity of that keyword.
-    :param byhour:
+    byhour :
         If given, it must be either an integer, or a sequence of integers,
         meaning the hours to apply the recurrence to.
-    :param byminute:
+    byminute :
         If given, it must be either an integer, or a sequence of integers,
         meaning the minutes to apply the recurrence to.
-    :param bysecond:
+    bysecond :
         If given, it must be either an integer, or a sequence of integers,
         meaning the seconds to apply the recurrence to.
-    :param cache:
+    cache :
         If given, it must be a boolean value specifying to enable or disable
         caching of results. If you will use the same rrule instance multiple
         times, enabling caching will improve the performance considerably.
-     """
+
+    Returns
+    -------
+
+    >>> from dateutil.rrule import rrule, MONTHLY
+        >>> from datetime import datetime
+        >>> start_date = datetime(2014, 12, 31)
+        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
+        ... # doctest: +NORMALIZE_WHITESPACE
+        [datetime.datetime(2014, 12, 31, 0, 0),
+         datetime.datetime(2015, 1, 31, 0, 0),
+         datetime.datetime(2015, 3, 31, 0, 0),
+         datetime.datetime(2015, 5, 31, 0, 0)]
+    """
     def __init__(self, freq, dtstart=None,
                  interval=1, wkst=None, count=None, until=None, bysetpos=None,
                  bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
@@ -758,8 +836,19 @@
         return '\n'.join(output)
 
     def replace(self, **kwargs):
-        """Return new rrule with same attributes except for those attributes given new
-           values by whichever keyword arguments are specified."""
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+        type
+            values by whichever keyword arguments are specified.
+
+        """
         new_kwargs = {"interval": self._interval,
                       "count": self._count,
                       "dtstart": self._dtstart,
@@ -772,6 +861,7 @@
         return rrule(**new_kwargs)
 
     def _iter(self):
+        """ """
         year, month, day, hour, minute, second, weekday, yearday, _ = \
             self._dtstart.timetuple()
 
@@ -1108,6 +1198,7 @@
 
 
 class _iterinfo(object):
+    """ """
     __slots__ = ["rrule", "lastyear", "lastmonth",
                  "yearlen", "nextyearlen", "yearordinal", "yearweekday",
                  "mmask", "mrange", "mdaymask", "nmdaymask",
@@ -1119,6 +1210,19 @@
         self.rrule = rrule
 
     def rebuild(self, year, month):
+        """
+
+        Parameters
+        ----------
+        year :
+            
+        month :
+            
+
+        Returns
+        -------
+
+        """
         # Every mask is 7 days longer to handle cross-year weekly periods.
         rr = self.rrule
         if year != self.lastyear:
@@ -1249,9 +1353,39 @@
         self.lastmonth = month
 
     def ydayset(self, year, month, day):
+        """
+
+        Parameters
+        ----------
+        year :
+            
+        month :
+            
+        day :
+            
+
+        Returns
+        -------
+
+        """
         return list(range(self.yearlen)), 0, self.yearlen
 
     def mdayset(self, year, month, day):
+        """
+
+        Parameters
+        ----------
+        year :
+            
+        month :
+            
+        day :
+            
+
+        Returns
+        -------
+
+        """
         dset = [None]*self.yearlen
         start, end = self.mrange[month-1:month+1]
         for i in range(start, end):
@@ -1259,6 +1393,21 @@
         return dset, start, end
 
     def wdayset(self, year, month, day):
+        """
+
+        Parameters
+        ----------
+        year :
+            
+        month :
+            
+        day :
+            
+
+        Returns
+        -------
+
+        """
         # We need to handle cross-year weeks here.
         dset = [None]*(self.yearlen+7)
         i = datetime.date(year, month, day).toordinal()-self.yearordinal
@@ -1274,12 +1423,42 @@
         return dset, start, i
 
     def ddayset(self, year, month, day):
+        """
+
+        Parameters
+        ----------
+        year :
+            
+        month :
+            
+        day :
+            
+
+        Returns
+        -------
+
+        """
         dset = [None] * self.yearlen
         i = datetime.date(year, month, day).toordinal() - self.yearordinal
         dset[i] = i
         return dset, i, i + 1
 
     def htimeset(self, hour, minute, second):
+        """
+
+        Parameters
+        ----------
+        hour :
+            
+        minute :
+            
+        second :
+            
+
+        Returns
+        -------
+
+        """
         tset = []
         rr = self.rrule
         for minute in rr._byminute:
@@ -1290,6 +1469,21 @@
         return tset
 
     def mtimeset(self, hour, minute, second):
+        """
+
+        Parameters
+        ----------
+        hour :
+            
+        minute :
+            
+        second :
+            
+
+        Returns
+        -------
+
+        """
         tset = []
         rr = self.rrule
         for second in rr._bysecond:
@@ -1298,19 +1492,43 @@
         return tset
 
     def stimeset(self, hour, minute, second):
+        """
+
+        Parameters
+        ----------
+        hour :
+            
+        minute :
+            
+        second :
+            
+
+        Returns
+        -------
+
+        """
         return (datetime.time(hour, minute, second,
                 tzinfo=self.rrule._tzinfo),)
 
 
 class rruleset(rrulebase):
-    """ The rruleset type allows more complex recurrence setups, mixing
+    """The rruleset type allows more complex recurrence setups, mixing
     multiple rules, dates, exclusion rules, and exclusion dates. The type
     constructor takes the following keyword arguments:
 
-    :param cache: If True, caching of results will be enabled, improving
-                  performance of multiple queries considerably. """
+    Parameters
+    ----------
+    cache :
+        If True, caching of results will be enabled, improving
+        performance of multiple queries considerably
+
+    Returns
+    -------
+
+    """
 
     class _genitem(object):
+        """ """
         def __init__(self, genlist, gen):
             try:
                 self.dt = advance_iterator(gen)
@@ -1353,32 +1571,72 @@
 
     @_invalidates_cache
     def rrule(self, rrule):
-        """ Include the given :py:class:`rrule` instance in the recurrence set
-            generation. """
+        """Include the given :py:class:`rrule` instance in the recurrence set
+            generation.
+
+        Parameters
+        ----------
+        rrule :
+            
+
+        Returns
+        -------
+
+        """
         self._rrule.append(rrule)
 
     @_invalidates_cache
     def rdate(self, rdate):
-        """ Include the given :py:class:`datetime` instance in the recurrence
-            set generation. """
+        """Include the given :py:class:`datetime` instance in the recurrence
+            set generation.
+
+        Parameters
+        ----------
+        rdate :
+            
+
+        Returns
+        -------
+
+        """
         self._rdate.append(rdate)
 
     @_invalidates_cache
     def exrule(self, exrule):
-        """ Include the given rrule instance in the recurrence set exclusion
+        """Include the given rrule instance in the recurrence set exclusion
             list. Dates which are part of the given recurrence rules will not
             be generated, even if some inclusive rrule or rdate matches them.
+
+        Parameters
+        ----------
+        exrule :
+            
+
+        Returns
+        -------
+
         """
         self._exrule.append(exrule)
 
     @_invalidates_cache
     def exdate(self, exdate):
-        """ Include the given datetime instance in the recurrence set
+        """Include the given datetime instance in the recurrence set
             exclusion list. Dates included that way will not be generated,
-            even if some inclusive rrule or rdate matches them. """
+            even if some inclusive rrule or rdate matches them.
+
+        Parameters
+        ----------
+        exdate :
+            
+
+        Returns
+        -------
+
+        """
         self._exdate.append(exdate)
 
     def _iter(self):
+        """ """
         rlist = []
         self._rdate.sort()
         self._genitem(rlist, iter(self._rdate))
@@ -1414,48 +1672,45 @@
 
 
 class _rrulestr(object):
-    """ Parses a string representation of a recurrence rule or set of
+    """Parses a string representation of a recurrence rule or set of
     recurrence rules.
 
-    :param s:
+    Parameters
+    ----------
+    s :
         Required, a string defining one or more recurrence rules.
-
-    :param dtstart:
+    dtstart :
         If given, used as the default recurrence start if not specified in the
         rule string.
-
-    :param cache:
+    cache :
         If set ``True`` caching of results will be enabled, improving
         performance of multiple queries considerably.
-
-    :param unfold:
+    unfold :
         If set ``True`` indicates that a rule string is split over more
         than one line and should be joined before processing.
-
-    :param forceset:
+    forceset :
         If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
         be returned.
-
-    :param compatible:
+    compatible :
         If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.
-
-    :param ignoretz:
+    ignoretz :
         If set ``True``, time zones in parsed strings are ignored and a naive
         :class:`datetime.datetime` object is returned.
-
-    :param tzids:
+    tzids :
         If given, a callable or mapping used to retrieve a
         :class:`datetime.tzinfo` from a string representation.
         Defaults to :func:`dateutil.tz.gettz`.
-
-    :param tzinfos:
+    tzinfos :
         Additional time zone names / aliases which may be present in a string
         representation.  See :func:`dateutil.parser.parse` for more
         information.
 
-    :return:
+    Returns
+    -------
+    type
         Returns a :class:`dateutil.rrule.rruleset` or
         :class:`dateutil.rrule.rrule`
+
     """
 
     _freq_map = {"YEARLY": YEARLY,
@@ -1470,9 +1725,43 @@
                     "FR": 4, "SA": 5, "SU": 6}
 
     def _handle_int(self, rrkwargs, name, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         rrkwargs[name.lower()] = int(value)
 
     def _handle_int_list(self, rrkwargs, name, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         rrkwargs[name.lower()] = [int(x) for x in value.split(',')]
 
     _handle_INTERVAL = _handle_int
@@ -1488,9 +1777,43 @@
     _handle_BYSECOND = _handle_int_list
 
     def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         rrkwargs["freq"] = self._freq_map[value]
 
     def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         global parser
         if not parser:
             from dateutil import parser
@@ -1502,11 +1825,42 @@
             raise ValueError("invalid until date")
 
     def _handle_WKST(self, rrkwargs, name, value, **kwargs):
+        """
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         rrkwargs["wkst"] = self._weekday_map[value]
 
     def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
-        """
-        Two ways to specify this: +1MO or MO(+1)
+        """Two ways to specify this: +1MO or MO(+1)
+
+        Parameters
+        ----------
+        rrkwargs :
+            
+        name :
+            
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         l = []
         for wday in value.split(','):
@@ -1537,6 +1891,25 @@
                          cache=False,
                          ignoretz=False,
                          tzinfos=None):
+        """
+
+        Parameters
+        ----------
+        line :
+            
+        dtstart :
+             (Default value = None)
+        cache :
+             (Default value = False)
+        ignoretz :
+             (Default value = False)
+        tzinfos :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if line.find(':') != -1:
             name, value = line.split(':')
             if name != "RRULE":
@@ -1560,6 +1933,27 @@
 
     def _parse_date_value(self, date_value, parms, rule_tzids,
                           ignoretz, tzids, tzinfos):
+        """
+
+        Parameters
+        ----------
+        date_value :
+            
+        parms :
+            
+        rule_tzids :
+            
+        ignoretz :
+            
+        tzids :
+            
+        tzinfos :
+            
+
+        Returns
+        -------
+
+        """
         global parser
         if not parser:
             from dateutil import parser
@@ -1619,6 +2013,33 @@
                    ignoretz=False,
                    tzids=None,
                    tzinfos=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        dtstart :
+             (Default value = None)
+        cache :
+             (Default value = False)
+        unfold :
+             (Default value = False)
+        forceset :
+             (Default value = False)
+        compatible :
+             (Default value = False)
+        ignoretz :
+             (Default value = False)
+        tzids :
+             (Default value = None)
+        tzinfos :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         global parser
         if compatible:
             forceset = True
