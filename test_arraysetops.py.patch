# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/tests/test_arraysetops.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/tests/test_arraysetops.py
@@ -12,8 +12,10 @@
 
 
 class TestSetOps:
+    """ """
 
     def test_intersect1d(self):
+        """ """
         # unique inputs
         a = np.array([5, 7, 1, 2])
         b = np.array([2, 4, 3, 1, 5])
@@ -32,8 +34,10 @@
         assert_array_equal([], intersect1d([], []))
 
     def test_intersect1d_array_like(self):
+        """ """
         # See gh-11772
         class Test:
+            """ """
             def __array__(self):
                 return np.arange(3)
 
@@ -44,6 +48,7 @@
         assert_array_equal(res, [1, 2, 3])
 
     def test_intersect1d_indices(self):
+        """ """
         # unique inputs
         a = np.array([1, 2, 3, 4])
         b = np.array([2, 1, 4, 6])
@@ -83,6 +88,7 @@
         assert_array_equal(ea, b[ui2])
 
     def test_setxor1d(self):
+        """ """
         a = np.array([5, 7, 1, 2])
         b = np.array([2, 4, 3, 1, 5])
 
@@ -107,6 +113,7 @@
         assert_array_equal([], setxor1d([], []))
 
     def test_ediff1d(self):
+        """ """
         zero_elem = np.array([])
         one_elem = np.array([1])
         two_elem = np.array([1, 2])
@@ -145,6 +152,21 @@
          np.nan),
          ])
     def test_ediff1d_forbidden_type_casts(self, ary, prepend, append):
+        """
+
+        Parameters
+        ----------
+        ary :
+            
+        prepend :
+            
+        append :
+            
+
+        Returns
+        -------
+
+        """
         # verify resolution of gh-11490
 
         # specifically, raise an appropriate
@@ -182,6 +204,23 @@
                                      prepend,
                                      append,
                                      expected):
+        """
+
+        Parameters
+        ----------
+        ary :
+            
+        prepend :
+            
+        append :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # maintain backwards-compatibility
         # of scalar prepend / append behavior
         # in ediff1d following fix for gh-11490
@@ -192,15 +231,42 @@
         assert actual.dtype == expected.dtype
 
     def test_isin(self):
+        """ """
         # the tests for in1d cover most of isin's behavior
         # if in1d is removed, would need to change those tests to test
         # isin instead.
         def _isin_slow(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             b = np.asarray(b).flatten().tolist()
             return a in b
         isin_slow = np.vectorize(_isin_slow, otypes=[bool], excluded={1})
 
         def assert_isin_equal(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             x = isin(a, b)
             y = isin_slow(a, b)
             assert_array_equal(x, y)
@@ -233,6 +299,7 @@
         assert_isin_equal(x, x)
 
     def test_in1d(self):
+        """ """
         # we use two different sizes for the b array here to test the
         # two different paths in in1d().
         for mult in (1, 10):
@@ -293,6 +360,7 @@
         assert_array_equal(in1d([], []), [])
 
     def test_in1d_char_array(self):
+        """ """
         a = np.array(['a', 'b', 'c', 'd', 'e', 'c', 'e', 'b'])
         b = np.array(['a', 'c'])
 
@@ -302,6 +370,7 @@
         assert_array_equal(c, ec)
 
     def test_in1d_invert(self):
+        """ """
         "Test in1d's invert parameter"
         # We use two different sizes for the b array here to test the
         # two different paths in in1d().
@@ -311,6 +380,7 @@
             assert_array_equal(np.invert(in1d(a, b)), in1d(a, b, invert=True))
 
     def test_in1d_ravel(self):
+        """ """
         # Test that in1d ravels its input arrays. This is not documented
         # behavior however. The test is to ensure consistentency.
         a = np.arange(6).reshape(2, 3)
@@ -324,6 +394,7 @@
         assert_array_equal(in1d(a, long_b, assume_unique=False), ec)
 
     def test_in1d_first_array_is_object(self):
+        """ """
         ar1 = [None]
         ar2 = np.array([1]*10)
         expected = np.array([False])
@@ -331,6 +402,7 @@
         assert_array_equal(result, expected)
 
     def test_in1d_second_array_is_object(self):
+        """ """
         ar1 = 1
         ar2 = np.array([None]*10)
         expected = np.array([False])
@@ -338,6 +410,7 @@
         assert_array_equal(result, expected)
 
     def test_in1d_both_arrays_are_object(self):
+        """ """
         ar1 = [None]
         ar2 = np.array([None]*10)
         expected = np.array([True])
@@ -345,6 +418,7 @@
         assert_array_equal(result, expected)
 
     def test_in1d_both_arrays_have_structured_dtype(self):
+        """ """
         # Test arrays of a structured data type containing an integer field
         # and a field of dtype `object` allowing for arbitrary Python objects
         dt = np.dtype([('field1', int), ('field2', object)])
@@ -355,6 +429,7 @@
         assert_array_equal(result, expected)
 
     def test_union1d(self):
+        """ """
         a = np.array([5, 4, 7, 1, 2])
         b = np.array([2, 4, 3, 3, 2, 1, 5])
 
@@ -373,6 +448,7 @@
         assert_array_equal([], union1d([], []))
 
     def test_setdiff1d(self):
+        """ """
         a = np.array([6, 5, 4, 7, 1, 2, 7, 4])
         b = np.array([2, 4, 3, 3, 2, 1, 5])
 
@@ -391,6 +467,7 @@
         assert_equal(setdiff1d(a, []).dtype, np.uint32)
 
     def test_setdiff1d_unique(self):
+        """ """
         a = np.array([3, 2, 1])
         b = np.array([7, 5, 2])
         expected = np.array([3, 1])
@@ -398,11 +475,13 @@
         assert_equal(actual, expected)
 
     def test_setdiff1d_char_array(self):
+        """ """
         a = np.array(['a', 'b', 'c'])
         b = np.array(['a', 'b', 's'])
         assert_array_equal(setdiff1d(a, b), np.array(['c']))
 
     def test_manyways(self):
+        """ """
         a = np.array([5, 7, 1, 2, 8])
         b = np.array([9, 8, 2, 4, 3, 1, 5])
 
@@ -414,10 +493,33 @@
 
 
 class TestUnique:
+    """ """
 
     def test_unique_1d(self):
+        """ """
 
         def check_all(a, b, i1, i2, c, dt):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+            i1 :
+                
+            i2 :
+                
+            c :
+                
+            dt :
+                
+
+            Returns
+            -------
+
+            """
             base_msg = 'check {0} failed for type {1}'
 
             msg = base_msg.format('values', dt)
@@ -528,6 +630,7 @@
         assert_equal(a3_inv.dtype, np.intp)
 
     def test_unique_axis_errors(self):
+        """ """
         assert_raises(TypeError, self._run_axis_tests, object)
         assert_raises(TypeError, self._run_axis_tests,
                       [('a', int), ('b', object)])
@@ -536,6 +639,7 @@
         assert_raises(np.AxisError, unique, np.arange(10), axis=-2)
 
     def test_unique_axis_list(self):
+        """ """
         msg = "Unique failed on list of lists"
         inp = [[0, 1, 0], [0, 1, 0]]
         inp_arr = np.asarray(inp)
@@ -543,6 +647,7 @@
         assert_array_equal(unique(inp, axis=1), unique(inp_arr, axis=1), msg)
 
     def test_unique_axis(self):
+        """ """
         types = []
         types.extend(np.typecodes['AllInteger'])
         types.extend(np.typecodes['AllFloat'])
@@ -566,11 +671,23 @@
 
     @pytest.mark.parametrize("axis", [0, -1])
     def test_unique_1d_with_axis(self, axis):
+        """
+
+        Parameters
+        ----------
+        axis :
+            
+
+        Returns
+        -------
+
+        """
         x = np.array([4, 3, 2, 3, 2, 1, 2, 2])
         uniq = unique(x, axis=axis)
         assert_array_equal(uniq, [1, 2, 3, 4])
 
     def test_unique_axis_zeros(self):
+        """ """
         # issue 15559
         single_zero = np.empty(shape=(2, 0), dtype=np.int8)
         uniq, idx, inv, cnt = unique(single_zero, axis=0, return_index=True,
@@ -607,6 +724,7 @@
                                np.empty(shape=expected_shape))
 
     def test_unique_masked(self):
+        """ """
         # issue 8664
         x = np.array([64, 0, 1, 2, 3, 63, 63, 0, 0, 0, 1, 2, 0, 63, 0],
                      dtype='uint8')
@@ -620,6 +738,7 @@
         assert_array_equal(v.mask, v2.mask, msg)
 
     def test_unique_sort_order_with_axis(self):
+        """ """
         # These tests fail if sorting along axis is done by treating subarrays
         # as unsigned byte strings.  See gh-10495.
         fmt = "sort order incorrect for integer type '%s'"
@@ -629,6 +748,17 @@
             assert_array_equal(a, b, fmt % dt)
 
     def _run_axis_tests(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         data = np.array([[0, 1, 0, 0],
                          [1, 0, 0, 0],
                          [0, 1, 0, 0],
