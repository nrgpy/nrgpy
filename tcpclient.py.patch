# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/tcpclient.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/tcpclient.py
@@ -36,19 +36,25 @@
 
 class _Connector(object):
     """A stateless implementation of the "Happy Eyeballs" algorithm.
-
+    
     "Happy Eyeballs" is documented in RFC6555 as the recommended practice
     for when both IPv4 and IPv6 addresses are available.
-
+    
     In this implementation, we partition the addresses by family, and
     make the first connection attempt to whichever address was
-    returned first by ``getaddrinfo``.  If that connection fails or
-    times out, we begin a connection in parallel to the first address
-    of the other family.  If there are additional failures we retry
-    with other addresses, keeping one connection attempt per family
-    in flight at a time.
-
-    http://tools.ietf.org/html/rfc6555
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        times out, we begin a connection in parallel to the first address
+        of the other family.  If there are additional failures we retry
+        with other addresses, keeping one connection attempt per family
+        in flight at a time.
+        
+        http://tools.ietf.org/html/rfc6555
 
     """
 
@@ -80,12 +86,21 @@
         List[Tuple[socket.AddressFamily, Tuple]],
     ]:
         """Partition the ``addrinfo`` list by address family.
-
+        
         Returns two lists.  The first list contains the first entry from
         ``addrinfo`` and all others with the same family, and the
         second list contains all other addresses (normally one list will
         be AF_INET and the other AF_INET6, although non-standard resolvers
         may return additional families).
+
+        Parameters
+        ----------
+        addrinfo: List[Tuple] :
+            
+
+        Returns
+        -------
+
         """
         primary = []
         secondary = []
@@ -102,6 +117,21 @@
         timeout: float = _INITIAL_CONNECT_TIMEOUT,
         connect_timeout: Optional[Union[float, datetime.timedelta]] = None,
     ) -> "Future[Tuple[socket.AddressFamily, Any, IOStream]]":
+        """
+
+        Parameters
+        ----------
+        timeout: float :
+             (Default value = _INITIAL_CONNECT_TIMEOUT)
+        connect_timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self.try_connect(iter(self.primary_addrs))
         self.set_timeout(timeout)
         if connect_timeout is not None:
@@ -109,6 +139,19 @@
         return self.future
 
     def try_connect(self, addrs: Iterator[Tuple[socket.AddressFamily, Tuple]]) -> None:
+        """
+
+        Parameters
+        ----------
+        addrs: Iterator[Tuple[socket.AddressFamily :
+            
+        Tuple]] :
+            
+
+        Returns
+        -------
+
+        """
         try:
             af, addr = next(addrs)
         except StopIteration:
@@ -133,6 +176,25 @@
         addr: Tuple,
         future: "Future[IOStream]",
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        addrs: Iterator[Tuple[socket.AddressFamily :
+            
+        Tuple]] :
+            
+        af: socket.AddressFamily :
+            
+        addr: Tuple :
+            
+        future: "Future[IOStream]" :
+            
+
+        Returns
+        -------
+
+        """
         self.remaining -= 1
         try:
             stream = future.result()
@@ -159,47 +221,83 @@
             self.close_streams()
 
     def set_timeout(self, timeout: float) -> None:
+        """
+
+        Parameters
+        ----------
+        timeout: float :
+            
+
+        Returns
+        -------
+
+        """
         self.timeout = self.io_loop.add_timeout(
             self.io_loop.time() + timeout, self.on_timeout
         )
 
     def on_timeout(self) -> None:
+        """ """
         self.timeout = None
         if not self.future.done():
             self.try_connect(iter(self.secondary_addrs))
 
     def clear_timeout(self) -> None:
+        """ """
         if self.timeout is not None:
             self.io_loop.remove_timeout(self.timeout)
 
     def set_connect_timeout(
         self, connect_timeout: Union[float, datetime.timedelta]
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        connect_timeout: Union[float :
+            
+        datetime.timedelta] :
+            
+
+        Returns
+        -------
+
+        """
         self.connect_timeout = self.io_loop.add_timeout(
             connect_timeout, self.on_connect_timeout
         )
 
     def on_connect_timeout(self) -> None:
+        """ """
         if not self.future.done():
             self.future.set_exception(TimeoutError())
         self.close_streams()
 
     def clear_timeouts(self) -> None:
+        """ """
         if self.timeout is not None:
             self.io_loop.remove_timeout(self.timeout)
         if self.connect_timeout is not None:
             self.io_loop.remove_timeout(self.connect_timeout)
 
     def close_streams(self) -> None:
+        """ """
         for stream in self.streams:
             stream.close()
 
 
 class TCPClient(object):
     """A non-blocking TCP connection factory.
-
+    
     .. versionchanged:: 5.0
        The ``io_loop`` argument (deprecated since version 4.1) has been removed.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, resolver: Optional[Resolver] = None) -> None:
@@ -211,6 +309,7 @@
             self._own_resolver = True
 
     def close(self) -> None:
+        """ """
         if self._own_resolver:
             self.resolver.close()
 
@@ -298,6 +397,25 @@
         source_ip: Optional[str] = None,
         source_port: Optional[int] = None,
     ) -> Tuple[IOStream, "Future[IOStream]"]:
+        """
+
+        Parameters
+        ----------
+        max_buffer_size: int :
+            
+        af: socket.AddressFamily :
+            
+        addr: Tuple :
+            
+        source_ip: Optional[str] :
+             (Default value = None)
+        source_port: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Always connect in plaintext; we'll convert to ssl if necessary
         # after one connection has completed.
         source_port_bind = source_port if isinstance(source_port, int) else 0
