# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/parser_utils.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/parser_utils.py
@@ -20,8 +20,18 @@
 
 
 def get_executable_nodes(node, last_added=False):
-    """
-    For static analysis.
+    """For static analysis.
+
+    Parameters
+    ----------
+    node :
+        
+    last_added :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     result = []
     typ = node.type
@@ -57,6 +67,17 @@
 
 
 def get_sync_comp_fors(comp_for):
+    """
+
+    Parameters
+    ----------
+    comp_for :
+        
+
+    Returns
+    -------
+
+    """
     yield comp_for
     last = comp_for.children[-1]
     while True:
@@ -70,16 +91,37 @@
 
 
 def for_stmt_defines_one_name(for_stmt):
-    """
-    Returns True if only one name is returned: ``for x in y``.
+    """Returns True if only one name is returned: ``for x in y``.
     Returns False if the for loop is more complicated: ``for x, z in y``.
 
-    :returns: bool
+    Parameters
+    ----------
+    for_stmt :
+        
+
+    Returns
+    -------
+    type
+        bool
+
     """
     return for_stmt.children[1].type == 'name'
 
 
 def get_flow_branch_keyword(flow_node, node):
+    """
+
+    Parameters
+    ----------
+    flow_node :
+        
+    node :
+        
+
+    Returns
+    -------
+
+    """
     start_pos = node.start_pos
     if not (flow_node.start_pos < start_pos <= flow_node.end_pos):
         raise ValueError('The node is not part of the flow.')
@@ -95,7 +137,17 @@
 
 
 def clean_scope_docstring(scope_node):
-    """ Returns a cleaned version of the docstring token. """
+    """Returns a cleaned version of the docstring token.
+
+    Parameters
+    ----------
+    scope_node :
+        
+
+    Returns
+    -------
+
+    """
     node = scope_node.get_doc_node()
     if node is not None:
         # TODO We have to check next leaves until there are no new
@@ -110,6 +162,17 @@
 
 
 def find_statement_documentation(tree_node):
+    """
+
+    Parameters
+    ----------
+    tree_node :
+        
+
+    Returns
+    -------
+
+    """
     if tree_node.type == 'expr_stmt':
         tree_node = tree_node.parent  # simple_stmt
         maybe_string = tree_node.get_next_sibling()
@@ -125,6 +188,17 @@
 
 
 def safe_literal_eval(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     first_two = value[:2].lower()
     if first_two[0] == 'f' or first_two in ('fr', 'rf'):
         # literal_eval is not able to resovle f literals. We have to do that
@@ -144,15 +218,25 @@
 
 def get_signature(funcdef, width=72, call_string=None,
                   omit_first_param=False, omit_return_annotation=False):
-    """
-    Generate a string signature of a function.
-
-    :param width: Fold lines if a line is longer than this value.
-    :type width: int
-    :arg func_name: Override function name when given.
-    :type func_name: str
-
-    :rtype: str
+    """Generate a string signature of a function.
+
+    Parameters
+    ----------
+    width : int
+:arg func_name: Override function name when given.
+        Fold lines if a line is longer than this value. (Default value = 72)
+    funcdef :
+        
+    call_string :
+         (Default value = None)
+    omit_first_param :
+         (Default value = False)
+    omit_return_annotation :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     # Lambdas have no name.
     if call_string is None:
@@ -176,8 +260,18 @@
 
 
 def move(node, line_offset):
-    """
-    Move the `Node` start_pos.
+    """Move the `Node` start_pos.
+
+    Parameters
+    ----------
+    node :
+        
+    line_offset :
+        
+
+    Returns
+    -------
+
     """
     try:
         children = node.children
@@ -189,9 +283,17 @@
 
 
 def get_following_comment_same_line(node):
-    """
-    returns (as string) any comment that appears on the same line,
+    """returns (as string) any comment that appears on the same line,
     after the node, including the #
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
     """
     try:
         if node.type == 'for_stmt':
@@ -220,6 +322,17 @@
 
 
 def is_scope(node):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
+    """
     t = node.type
     if t == 'comp_for':
         # Starting with Python 3.8, async is outside of the statement.
@@ -229,9 +342,35 @@
 
 
 def _get_parent_scope_cache(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     cache = WeakKeyDictionary()
 
     def wrapper(used_names, node, include_flows=False):
+        """
+
+        Parameters
+        ----------
+        used_names :
+            
+        node :
+            
+        include_flows :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         try:
             for_module = cache[used_names]
         except KeyError:
@@ -246,8 +385,18 @@
 
 
 def get_parent_scope(node, include_flows=False):
-    """
-    Returns the underlying scope.
+    """Returns the underlying scope.
+
+    Parameters
+    ----------
+    node :
+        
+    include_flows :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     scope = node.parent
     if scope is None:
@@ -273,16 +422,36 @@
 
 
 def get_cached_code_lines(grammar, path):
-    """
-    Basically access the cached code lines in parso. This is not the nicest way
+    """Basically access the cached code lines in parso. This is not the nicest way
     to do this, but we avoid splitting all the lines again.
+
+    Parameters
+    ----------
+    grammar :
+        
+    path :
+        
+
+    Returns
+    -------
+
     """
     return parser_cache[grammar._hashed][path].lines
 
 
 def cut_value_at_position(leaf, position):
-    """
-    Cuts of the value of the leaf at position
+    """Cuts of the value of the leaf at position
+
+    Parameters
+    ----------
+    leaf :
+        
+    position :
+        
+
+    Returns
+    -------
+
     """
     lines = split_lines(leaf.value, keepends=True)[:position[0] - leaf.line + 1]
     column = position[1]
@@ -295,8 +464,16 @@
 
 
 def expr_is_dotted(node):
-    """
-    Checks if a path looks like `name` or `name.foo.bar` and not `name()`.
+    """Checks if a path looks like `name` or `name.foo.bar` and not `name()`.
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
     """
     if node.type == 'atom':
         if len(node.children) == 3 and node.children[0] == '(':
@@ -314,12 +491,31 @@
 
 
 def _function_is_x_method(method_name):
+    """
+
+    Parameters
+    ----------
+    method_name :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(function_node):
-        """
-        This is a heuristic. It will not hold ALL the times, but it will be
+        """This is a heuristic. It will not hold ALL the times, but it will be
         correct pretty much for anyone that doesn't try to beat it.
         staticmethod/classmethod are builtins and unless overwritten, this will
         be correct.
+
+        Parameters
+        ----------
+        function_node :
+            
+
+        Returns
+        -------
+
         """
         for decorator in function_node.get_decorators():
             dotted_name = decorator.children[1]
