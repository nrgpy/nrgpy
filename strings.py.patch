# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/strings.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/strings.py
@@ -56,8 +56,7 @@
 
 
 def cat_core(list_of_columns: List, sep: str):
-    """
-    Auxiliary function for :meth:`str.cat`
+    """Auxiliary function for :meth:`str.cat`
 
     Parameters
     ----------
@@ -66,11 +65,15 @@
         these arrays may not contain NaNs!
     sep : string
         The separator string for concatenating the columns.
-
-    Returns
-    -------
-    nd.array
-        The concatenation of list_of_columns with sep.
+    list_of_columns: List :
+        
+    sep: str :
+        
+
+    Returns
+    -------
+
+    
     """
     if sep == "":
         # no need to interleave sep if it is empty
@@ -83,9 +86,8 @@
 
 
 def cat_safe(list_of_columns: List, sep: str):
-    """
-    Auxiliary function for :meth:`str.cat`.
-
+    """Auxiliary function for :meth:`str.cat`.
+    
     Same signature as cat_core, but handles TypeErrors in concatenation, which
     happen if the arrays in list_of columns have the wrong dtypes or content.
 
@@ -96,11 +98,15 @@
         these arrays may not contain NaNs!
     sep : string
         The separator string for concatenating the columns.
-
-    Returns
-    -------
-    nd.array
-        The concatenation of list_of_columns with sep.
+    list_of_columns: List :
+        
+    sep: str :
+        
+
+    Returns
+    -------
+
+    
     """
     try:
         result = cat_core(list_of_columns, sep)
@@ -119,6 +125,23 @@
 
 
 def _na_map(f, arr, na_result=None, dtype=np.dtype(object)):
+    """
+
+    Parameters
+    ----------
+    f :
+        
+    arr :
+        
+    na_result :
+         (Default value = None)
+    dtype :
+         (Default value = np.dtype(object))
+
+    Returns
+    -------
+
+    """
     if is_extension_array_dtype(arr.dtype):
         if na_result is None:
             na_result = libmissing.NA
@@ -133,27 +156,35 @@
 def _map_stringarray(
     func: Callable[[str], Any], arr: "StringArray", na_value: Any, dtype: Dtype
 ) -> ArrayLike:
-    """
-    Map a callable over valid elements of a StringArray.
+    """Map a callable over valid elements of a StringArray.
 
     Parameters
     ----------
     func : Callable[[str], Any]
         Apply to each valid element.
     arr : StringArray
+        
     na_value : Any
         The value to use for missing values. By default, this is
         the original value (NA).
     dtype : Dtype
         The result dtype to use. Specifying this avoids an intermediate
         object-dtype allocation.
-
-    Returns
-    -------
-    ArrayLike
-        An ExtensionArray for integer or string dtypes, otherwise
-        an ndarray.
-
+    func: Callable[[str] :
+        
+    Any] :
+        
+    arr: "StringArray" :
+        
+    na_value: Any :
+        
+    dtype: Dtype :
+        
+
+    Returns
+    -------
+
+    
     """
     from pandas.arrays import BooleanArray, IntegerArray, StringArray
 
@@ -201,6 +232,25 @@
 
 
 def _map_object(f, arr, na_mask=False, na_value=np.nan, dtype=np.dtype(object)):
+    """
+
+    Parameters
+    ----------
+    f :
+        
+    arr :
+        
+    na_mask :
+         (Default value = False)
+    na_value :
+         (Default value = np.nan)
+    dtype :
+         (Default value = np.dtype(object))
+
+    Returns
+    -------
+
+    """
     if not len(arr):
         return np.ndarray(0, dtype=dtype)
 
@@ -226,6 +276,17 @@
                 raise e
 
             def g(x):
+                """
+
+                Parameters
+                ----------
+                x :
+                    
+
+                Returns
+                -------
+
+                """
                 try:
                     return f(x)
                 except (TypeError, AttributeError):
@@ -242,9 +303,8 @@
 
 
 def str_count(arr, pat, flags=0):
-    """
-    Count occurrences of pattern in each string of the Series/Index.
-
+    """Count occurrences of pattern in each string of the Series/Index.
+    
     This function is used to count the number of times a particular regex
     pattern is repeated in each of the string elements of the
     :class:`~pandas.Series`.
@@ -255,9 +315,11 @@
         Valid regular expression.
     flags : int, default 0, meaning no flags
         Flags for the `re` module. For a complete list, `see here
-        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_.
-    **kwargs
+        <https://docs.python.org/3/howto/regex.html#compilation-flags>`_. (Default value = 0)
+    **kwargs :
         For compatibility with other string methods. Not used.
+    arr :
+        
 
     Returns
     -------
@@ -268,15 +330,18 @@
     --------
     re : Standard library module for regular expressions.
     str.count : Standard library version, without regular expression support.
-
     Notes
     -----
     Some characters need to be escaped when passing in `pat`.
     eg. ``'$'`` has a special meaning in regex and must be escaped when
     finding this literal character.
-
     Examples
     --------
+    
+    Escape ``'$'`` to find the literal dollar sign.
+    
+    
+    This is also available on Index
     >>> s = pd.Series(['A', 'B', 'Aaba', 'Baca', np.nan, 'CABA', 'cat'])
     >>> s.str.count('a')
     0    0.0
@@ -287,9 +352,7 @@
     5    0.0
     6    1.0
     dtype: float64
-
-    Escape ``'$'`` to find the literal dollar sign.
-
+    
     >>> s = pd.Series(['$', 'B', 'Aab$', '$$ca', 'C$B$', 'cat'])
     >>> s.str.count('\\$')
     0    1
@@ -299,9 +362,7 @@
     4    2
     5    0
     dtype: int64
-
-    This is also available on Index
-
+    
     >>> pd.Index(['A', 'A', 'Aaba', 'cat']).str.count('a')
     Int64Index([0, 0, 2, 1], dtype='int64')
     """
@@ -311,9 +372,8 @@
 
 
 def str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):
-    """
-    Test if pattern or regex is contained within a string of a Series or Index.
-
+    """Test if pattern or regex is contained within a string of a Series or Index.
+    
     Return boolean Series or Index based on whether a given pattern or regex is
     contained within a string of a Series or Index.
 
@@ -322,15 +382,16 @@
     pat : str
         Character sequence or regular expression.
     case : bool, default True
-        If True, case sensitive.
+        If True, case sensitive. (Default value = True)
     flags : int, default 0 (no flags)
-        Flags to pass through to the re module, e.g. re.IGNORECASE.
+        Flags to pass through to the re module, e.g. re.IGNORECASE. (Default value = 0)
     na : default NaN
-        Fill value for missing values.
+        Fill value for missing values. (Default value = np.nan)
     regex : bool, default True
         If True, assumes the pat is a regular expression.
-
-        If False, treats the pat as a literal string.
+        If False, treats the pat as a literal string. (Default value = True)
+    arr :
+        
 
     Returns
     -------
@@ -345,11 +406,35 @@
     Series.str.startswith : Test if the start of each string element matches a
         pattern.
     Series.str.endswith : Same as startswith, but tests the end of string.
-
     Examples
     --------
     Returning a Series of booleans using only a literal pattern.
-
+    
+    
+    Returning an Index of booleans using only a literal pattern.
+    
+    
+    Specifying case sensitivity using `case`.
+    
+    
+    Specifying `na` to be `False` instead of `NaN` replaces NaN values
+    with `False`. If Series or Index does not contain NaN values
+    the resultant dtype will be `bool`, otherwise, an `object` dtype.
+    
+    
+    Returning 'house' or 'dog' when either expression occurs in a string.
+    
+    
+    Ignoring case sensitivity using `flags` with regex.
+    
+    
+    Returning any digit using regular expression.
+    
+    
+    Ensure `pat` is a not a literal pattern when `regex` is set to True.
+    Note in the following example one might expect only `s2[1]` and `s2[3]` to
+    return `True`. However, '.0' as a regex matches any character
+    followed by a 0.
     >>> s1 = pd.Series(['Mouse', 'dog', 'house and parrot', '23', np.NaN])
     >>> s1.str.contains('og', regex=False)
     0    False
@@ -358,15 +443,11 @@
     3    False
     4      NaN
     dtype: object
-
-    Returning an Index of booleans using only a literal pattern.
-
+    
     >>> ind = pd.Index(['Mouse', 'dog', 'house and parrot', '23.0', np.NaN])
     >>> ind.str.contains('23', regex=False)
     Index([False, False, False, True, nan], dtype='object')
-
-    Specifying case sensitivity using `case`.
-
+    
     >>> s1.str.contains('oG', case=True, regex=True)
     0    False
     1    False
@@ -374,11 +455,7 @@
     3    False
     4      NaN
     dtype: object
-
-    Specifying `na` to be `False` instead of `NaN` replaces NaN values
-    with `False`. If Series or Index does not contain NaN values
-    the resultant dtype will be `bool`, otherwise, an `object` dtype.
-
+    
     >>> s1.str.contains('og', na=False, regex=True)
     0    False
     1     True
@@ -386,9 +463,7 @@
     3    False
     4    False
     dtype: bool
-
-    Returning 'house' or 'dog' when either expression occurs in a string.
-
+    
     >>> s1.str.contains('house|dog', regex=True)
     0    False
     1     True
@@ -396,9 +471,7 @@
     3    False
     4      NaN
     dtype: object
-
-    Ignoring case sensitivity using `flags` with regex.
-
+    
     >>> import re
     >>> s1.str.contains('PARROT', flags=re.IGNORECASE, regex=True)
     0    False
@@ -407,9 +480,7 @@
     3    False
     4      NaN
     dtype: object
-
-    Returning any digit using regular expression.
-
+    
     >>> s1.str.contains('\\d', regex=True)
     0    False
     1    False
@@ -417,12 +488,7 @@
     3     True
     4      NaN
     dtype: object
-
-    Ensure `pat` is a not a literal pattern when `regex` is set to True.
-    Note in the following example one might expect only `s2[1]` and `s2[3]` to
-    return `True`. However, '.0' as a regex matches any character
-    followed by a 0.
-
+    
     >>> s2 = pd.Series(['40', '40.0', '41', '41.0', '35'])
     >>> s2.str.contains('.0', regex=True)
     0     True
@@ -459,9 +525,8 @@
 
 
 def str_startswith(arr, pat, na=np.nan):
-    """
-    Test if the start of each string element matches a pattern.
-
+    """Test if the start of each string element matches a pattern.
+    
     Equivalent to :meth:`str.startswith`.
 
     Parameters
@@ -469,7 +534,9 @@
     pat : str
         Character sequence. Regular expressions are not accepted.
     na : object, default NaN
-        Object shown if element tested is not a string.
+        Object shown if element tested is not a string. (Default value = np.nan)
+    arr :
+        
 
     Returns
     -------
@@ -482,9 +549,11 @@
     str.startswith : Python standard library string method.
     Series.str.endswith : Same as startswith, but tests the end of string.
     Series.str.contains : Tests if string element contains a pattern.
-
     Examples
     --------
+    
+    
+    Specifying `na` to be `False` instead of `NaN`.
     >>> s = pd.Series(['bat', 'Bear', 'cat', np.nan])
     >>> s
     0     bat
@@ -492,16 +561,14 @@
     2     cat
     3     NaN
     dtype: object
-
+    
     >>> s.str.startswith('b')
     0     True
     1    False
     2    False
     3      NaN
     dtype: object
-
-    Specifying `na` to be `False` instead of `NaN`.
-
+    
     >>> s.str.startswith('b', na=False)
     0     True
     1    False
@@ -514,9 +581,8 @@
 
 
 def str_endswith(arr, pat, na=np.nan):
-    """
-    Test if the end of each string element matches a pattern.
-
+    """Test if the end of each string element matches a pattern.
+    
     Equivalent to :meth:`str.endswith`.
 
     Parameters
@@ -524,7 +590,9 @@
     pat : str
         Character sequence. Regular expressions are not accepted.
     na : object, default NaN
-        Object shown if element tested is not a string.
+        Object shown if element tested is not a string. (Default value = np.nan)
+    arr :
+        
 
     Returns
     -------
@@ -537,9 +605,11 @@
     str.endswith : Python standard library string method.
     Series.str.startswith : Same as endswith, but tests the start of string.
     Series.str.contains : Tests if string element contains a pattern.
-
     Examples
     --------
+    
+    
+    Specifying `na` to be `False` instead of `NaN`.
     >>> s = pd.Series(['bat', 'bear', 'caT', np.nan])
     >>> s
     0     bat
@@ -547,16 +617,14 @@
     2     caT
     3     NaN
     dtype: object
-
+    
     >>> s.str.endswith('t')
     0     True
     1    False
     2    False
     3      NaN
     dtype: object
-
-    Specifying `na` to be `False` instead of `NaN`.
-
+    
     >>> s.str.endswith('t', na=False)
     0     True
     1    False
@@ -569,9 +637,9 @@
 
 
 def str_replace(arr, pat, repl, n=-1, case=None, flags=0, regex=True):
-    r"""
+    """r"""
     Replace each occurrence of pattern/regex in the Series/Index.
-
+    
     Equivalent to :meth:`str.replace` or :func:`re.sub`, depending on the regex value.
 
     Parameters
@@ -583,26 +651,24 @@
         match object and must return a replacement string to be used.
         See :func:`re.sub`.
     n : int, default -1 (all)
-        Number of replacements to make from start.
+        Number of replacements to make from start. (Default value = -1)
     case : bool, default None
         Determines if replace is case sensitive:
-
         - If True, case sensitive (the default if `pat` is a string)
         - Set to False for case insensitive
         - Cannot be set if `pat` is a compiled regex.
-
     flags : int, default 0 (no flags)
         Regex module flags, e.g. re.IGNORECASE. Cannot be set if `pat` is a compiled
-        regex.
+        regex. (Default value = 0)
     regex : bool, default True
         Determines if assumes the passed-in pattern is a regular expression:
-
         - If True, assumes the passed-in pattern is a regular expression.
         - If False, treats the pattern as a literal string
         - Cannot be set to False if `pat` is a compiled regex or `repl` is
-          a callable.
-
-        .. versionadded:: 0.23.0
+        a callable.
+        .. versionadded:: 0.23.0 (Default value = True)
+    arr :
+        
 
     Returns
     -------
@@ -614,7 +680,7 @@
     ------
     ValueError
         * if `regex` is False and `repl` is a callable or `pat` is a compiled
-          regex
+        regex
         * if `pat` is a compiled regex and `case` or `flags` is set
 
     Notes
@@ -622,61 +688,64 @@
     When `pat` is a compiled regex, all flags should be included in the
     compiled regex. Use of `case`, `flags`, or `regex=False` with a compiled
     regex will raise an error.
-
     Examples
     --------
     When `pat` is a string and `regex` is True (the default), the given `pat`
     is compiled as a regex. When `repl` is a string, it replaces matching
     regex patterns as with :meth:`re.sub`. NaN value(s) in the Series are
     left as is:
-
+    
+    
+    When `pat` is a string and `regex` is False, every `pat` is replaced with
+    `repl` as with :meth:`str.replace`:
+    
+    
+    When `repl` is a callable, it is called on every `pat` using
+    :func:`re.sub`. The callable should expect one positional argument
+    (a regex object) and return a string.
+    
+    To get the idea:
+    
+    
+    Reverse every lowercase alphabetic word:
+    
+    
+    Using regex groups (extract second group and swap case):
+    
+    
+    Using a compiled regex with flags
     >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f.', 'ba', regex=True)
     0    bao
     1    baz
     2    NaN
     dtype: object
-
-    When `pat` is a string and `regex` is False, every `pat` is replaced with
-    `repl` as with :meth:`str.replace`:
-
+    
     >>> pd.Series(['f.o', 'fuz', np.nan]).str.replace('f.', 'ba', regex=False)
     0    bao
     1    fuz
     2    NaN
     dtype: object
-
-    When `repl` is a callable, it is called on every `pat` using
-    :func:`re.sub`. The callable should expect one positional argument
-    (a regex object) and return a string.
-
-    To get the idea:
-
+    
     >>> pd.Series(['foo', 'fuz', np.nan]).str.replace('f', repr)
     0    <re.Match object; span=(0, 1), match='f'>oo
     1    <re.Match object; span=(0, 1), match='f'>uz
     2                                            NaN
     dtype: object
-
-    Reverse every lowercase alphabetic word:
-
+    
     >>> repl = lambda m: m.group(0)[::-1]
     >>> pd.Series(['foo 123', 'bar baz', np.nan]).str.replace(r'[a-z]+', repl)
     0    oof 123
     1    rab zab
     2        NaN
     dtype: object
-
-    Using regex groups (extract second group and swap case):
-
+    
     >>> pat = r"(?P<one>\w+) (?P<two>\w+) (?P<three>\w+)"
     >>> repl = lambda m: m.group('two').swapcase()
     >>> pd.Series(['One Two Three', 'Foo Bar Baz']).str.replace(pat, repl)
     0    tWO
     1    bAR
     dtype: object
-
-    Using a compiled regex with flags
-
+    
     >>> import re
     >>> regex_pat = re.compile(r'FUZ', flags=re.IGNORECASE)
     >>> pd.Series(['foo', 'fuz', np.nan]).str.replace(regex_pat, 'bar')
@@ -684,7 +753,6 @@
     1    bar
     2    NaN
     dtype: object
-    """
     # Check whether repl is valid (GH 13438, GH 15055)
     if not (isinstance(repl, str) or callable(repl)):
         raise TypeError("repl must be a string or callable")
@@ -724,13 +792,14 @@
 
 
 def str_repeat(arr, repeats):
-    """
-    Duplicate each string in the Series or Index.
+    """Duplicate each string in the Series or Index.
 
     Parameters
     ----------
     repeats : int or sequence of int
         Same value for all (int) or different value per (sequence).
+    arr :
+        
 
     Returns
     -------
@@ -740,23 +809,24 @@
 
     Examples
     --------
+    
+    Single int repeats string in Series
+    
+    
+    Sequence of int repeats corresponding string in Series
     >>> s = pd.Series(['a', 'b', 'c'])
     >>> s
     0    a
     1    b
     2    c
     dtype: object
-
-    Single int repeats string in Series
-
+    
     >>> s.str.repeat(repeats=2)
     0    aa
     1    bb
     2    cc
     dtype: object
-
-    Sequence of int repeats corresponding string in Series
-
+    
     >>> s.str.repeat(repeats=[1, 2, 3])
     0      a
     1     bb
@@ -766,6 +836,17 @@
     if is_scalar(repeats):
 
         def scalar_rep(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 return bytes.__mul__(x, repeats)
             except TypeError:
@@ -775,6 +856,19 @@
     else:
 
         def rep(x, r):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+            r :
+                
+
+            Returns
+            -------
+
+            """
             if x is libmissing.NA:
                 return x
             try:
@@ -794,8 +888,7 @@
     flags: int = 0,
     na: Scalar = np.nan,
 ):
-    """
-    Determine if each string starts with a match of a regular expression.
+    """Determine if each string starts with a match of a regular expression.
 
     Parameters
     ----------
@@ -807,10 +900,23 @@
         Regex module flags, e.g. re.IGNORECASE.
     na : default NaN
         Fill value for missing values.
+    arr: ArrayLike :
+        
+    pat: Union[str :
+        
+    Pattern] :
+        
+    case: bool :
+         (Default value = True)
+    flags: int :
+         (Default value = 0)
+    na: Scalar :
+         (Default value = np.nan)
 
     Returns
     -------
     Series/array of boolean values
+        
 
     See Also
     --------
@@ -836,9 +942,8 @@
     flags: int = 0,
     na: Scalar = np.nan,
 ):
-    """
-    Determine if each string entirely matches a regular expression.
-
+    """Determine if each string entirely matches a regular expression.
+    
     .. versionadded:: 1.1.0
 
     Parameters
@@ -851,10 +956,23 @@
         Regex module flags, e.g. re.IGNORECASE.
     na : default NaN
         Fill value for missing values.
+    arr: ArrayLike :
+        
+    pat: Union[str :
+        
+    Pattern] :
+        
+    case: bool :
+         (Default value = True)
+    flags: int :
+         (Default value = 0)
+    na: Scalar :
+         (Default value = np.nan)
 
     Returns
     -------
     Series/array of boolean values
+        
 
     See Also
     --------
@@ -873,6 +991,17 @@
 
 
 def _get_single_group_name(rx):
+    """
+
+    Parameters
+    ----------
+    rx :
+        
+
+    Returns
+    -------
+
+    """
     try:
         return list(rx.groupindex.keys()).pop()
     except IndexError:
@@ -880,12 +1009,33 @@
 
 
 def _groups_or_na_fun(regex):
-    """Used in both extract_noexpand and extract_frame"""
+    """Used in both extract_noexpand and extract_frame
+
+    Parameters
+    ----------
+    regex :
+        
+
+    Returns
+    -------
+
+    """
     if regex.groups == 0:
         raise ValueError("pattern contains no capture groups")
     empty_row = [np.nan] * regex.groups
 
     def f(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(x, str):
             return empty_row
         m = regex.search(x)
@@ -898,6 +1048,17 @@
 
 
 def _result_dtype(arr):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+
+    Returns
+    -------
+
+    """
     # workaround #27953
     # ideally we just pass `dtype=arr.dtype` unconditionally, but this fails
     # when the list of values is empty.
@@ -908,11 +1069,22 @@
 
 
 def _str_extract_noexpand(arr, pat, flags=0):
-    """
-    Find groups in each string in the Series using passed regular
+    """Find groups in each string in the Series using passed regular
     expression. This function is called from
     str_extract(expand=False), and can return Series, DataFrame, or
     Index.
+
+    Parameters
+    ----------
+    arr :
+        
+    pat :
+        
+    flags :
+         (Default value = 0)
+
+    Returns
+    -------
 
     """
     from pandas import DataFrame
@@ -943,10 +1115,21 @@
 
 
 def _str_extract_frame(arr, pat, flags=0):
-    """
-    For each subject string in the Series, extract groups from the
+    """For each subject string in the Series, extract groups from the
     first match of regular expression pat. This function is called from
     str_extract(expand=True), and always returns a DataFrame.
+
+    Parameters
+    ----------
+    arr :
+        
+    pat :
+        
+    flags :
+         (Default value = 0)
+
+    Returns
+    -------
 
     """
     from pandas import DataFrame
@@ -972,9 +1155,9 @@
 
 
 def str_extract(arr, pat, flags=0, expand=True):
-    r"""
+    """r"""
     Extract capture groups in the regex `pat` as columns in a DataFrame.
-
+    
     For each subject string in the Series, extract groups from the
     first match of regular expression `pat`.
 
@@ -985,11 +1168,13 @@
     flags : int, default 0 (no flags)
         Flags from the ``re`` module, e.g. ``re.IGNORECASE``, that
         modify regular expression matching for things like case,
-        spaces, etc. For more details, see :mod:`re`.
+        spaces, etc. For more details, see :mod:`re`. (Default value = 0)
     expand : bool, default True
         If True, return DataFrame with one column per capture group.
         If False, return a Series/Index if there is one capture group
-        or DataFrame if there are multiple capture groups.
+        or DataFrame if there are multiple capture groups. (Default value = True)
+    arr :
+        
 
     Returns
     -------
@@ -1006,52 +1191,53 @@
     See Also
     --------
     extractall : Returns all matches (not just the first match).
-
     Examples
     --------
     A pattern with two groups will return a DataFrame with two columns.
     Non-matches will be NaN.
-
+    
+    
+    A pattern may contain optional groups.
+    
+    
+    Named groups will become column names in the result.
+    
+    
+    A pattern with one group will return a DataFrame with one column
+    if expand=True.
+    
+    
+    A pattern with one group will return a Series if expand=False.
     >>> s = pd.Series(['a1', 'b2', 'c3'])
     >>> s.str.extract(r'([ab])(\d)')
          0    1
     0    a    1
     1    b    2
     2  NaN  NaN
-
-    A pattern may contain optional groups.
-
+    
     >>> s.str.extract(r'([ab])?(\d)')
          0  1
     0    a  1
     1    b  2
     2  NaN  3
-
-    Named groups will become column names in the result.
-
+    
     >>> s.str.extract(r'(?P<letter>[ab])(?P<digit>\d)')
       letter digit
     0      a     1
     1      b     2
     2    NaN   NaN
-
-    A pattern with one group will return a DataFrame with one column
-    if expand=True.
-
+    
     >>> s.str.extract(r'[ab](\d)', expand=True)
          0
     0    1
     1    2
     2  NaN
-
-    A pattern with one group will return a Series if expand=False.
-
+    
     >>> s.str.extract(r'[ab](\d)', expand=False)
     0      1
     1      2
     2    NaN
     dtype: object
-    """
     if not isinstance(expand, bool):
         raise ValueError("expand must be True or False")
     if expand:
@@ -1062,9 +1248,9 @@
 
 
 def str_extractall(arr, pat, flags=0):
-    r"""
+    """r"""
     Extract capture groups in the regex `pat` as columns in DataFrame.
-
+    
     For each subject string in the Series, extract groups from all
     matches of regular expression pat. When each subject string in the
     Series has exactly one match, extractall(pat).xs(0, level='match')
@@ -1078,7 +1264,9 @@
         A ``re`` module flag, for example ``re.IGNORECASE``. These allow
         to modify regular expression matching for things like case, spaces,
         etc. Multiple flags can be combined with the bitwise OR operator,
-        for example ``re.IGNORECASE | re.MULTILINE``.
+        for example ``re.IGNORECASE | re.MULTILINE``. (Default value = 0)
+    arr :
+        
 
     Returns
     -------
@@ -1093,12 +1281,19 @@
     See Also
     --------
     extract : Returns first match only (not all matches).
-
     Examples
     --------
     A pattern with one group will return a DataFrame with one column.
     Indices with no matches will not appear in the result.
-
+    
+    
+    Capture group names are used for column names of the result.
+    
+    
+    A pattern with two groups will return a DataFrame with two columns.
+    
+    
+    Optional groups that do not match are NaN in the result.
     >>> s = pd.Series(["a1a2", "b1", "c1"], index=["A", "B", "C"])
     >>> s.str.extractall(r"[ab](\d)")
              0
@@ -1106,27 +1301,21 @@
     A 0      1
       1      2
     B 0      1
-
-    Capture group names are used for column names of the result.
-
+    
     >>> s.str.extractall(r"[ab](?P<digit>\d)")
             digit
       match
     A 0         1
       1         2
     B 0         1
-
-    A pattern with two groups will return a DataFrame with two columns.
-
+    
     >>> s.str.extractall(r"(?P<letter>[ab])(?P<digit>\d)")
             letter digit
       match
     A 0          a     1
       1          a     2
     B 0          b     1
-
-    Optional groups that do not match are NaN in the result.
-
+    
     >>> s.str.extractall(r"(?P<letter>[ab])?(?P<digit>\d)")
             letter digit
       match
@@ -1134,7 +1323,6 @@
       1          a     2
     B 0          b     1
     C 0        NaN     1
-    """
     regex = re.compile(pat, flags=flags)
     # the regex must contain capture groups.
     if regex.groups == 0:
@@ -1175,16 +1363,17 @@
 
 
 def str_get_dummies(arr, sep="|"):
-    """
-    Return DataFrame of dummy/indicator variables for Series.
-
+    """Return DataFrame of dummy/indicator variables for Series.
+    
     Each string in Series is split by sep and returned as a DataFrame
     of dummy/indicator variables.
 
     Parameters
     ----------
     sep : str, default "|"
-        String to split on.
+        String to split on. (Default value = "|")
+    arr :
+        
 
     Returns
     -------
@@ -1195,7 +1384,6 @@
     --------
     get_dummies : Convert categorical variable into dummy/indicator
         variables.
-
     Examples
     --------
     >>> pd.Series(['a|b', 'a', 'a|c']).str.get_dummies()
@@ -1203,7 +1391,7 @@
     0  1  1  0
     1  1  0  0
     2  1  0  1
-
+    
     >>> pd.Series(['a|b', np.nan, 'a|c']).str.get_dummies()
        a  b  c
     0  1  1  0
@@ -1230,9 +1418,8 @@
 
 
 def str_join(arr, sep):
-    """
-    Join lists contained as elements in the Series/Index with passed delimiter.
-
+    """Join lists contained as elements in the Series/Index with passed delimiter.
+    
     If the elements of a Series are lists themselves, join the content of these
     lists using the delimiter passed to the function.
     This function is an equivalent to :meth:`str.join`.
@@ -1241,10 +1428,12 @@
     ----------
     sep : str
         Delimiter to use between list entries.
-
-    Returns
-    -------
-    Series/Index: object
+    arr :
+        
+
+    Returns
+    -------
+    Series/Index : object
         The list entries concatenated by intervening occurrences of the
         delimiter.
 
@@ -1257,16 +1446,17 @@
     --------
     str.join : Standard library version of this method.
     Series.str.split : Split strings around given separator/delimiter.
-
     Notes
     -----
     If any of the list items is not a string object, the result of the join
     will be `NaN`.
-
     Examples
     --------
     Example with a list that contains non-string elements.
-
+    
+    
+    Join all lists using a '-'. The lists containing object(s) of types other
+    than str will produce a NaN.
     >>> s = pd.Series([['lion', 'elephant', 'zebra'],
     ...                [1.1, 2.2, 3.3],
     ...                ['cat', np.nan, 'dog'],
@@ -1279,10 +1469,7 @@
     3               [cow, 4.5, goat]
     4    [duck, [swan, fish], guppy]
     dtype: object
-
-    Join all lists using a '-'. The lists containing object(s) of types other
-    than str will produce a NaN.
-
+    
     >>> s.str.join('-')
     0    lion-elephant-zebra
     1                    NaN
@@ -1295,9 +1482,8 @@
 
 
 def str_findall(arr, pat, flags=0):
-    """
-    Find all occurrences of pattern or regular expression in the Series/Index.
-
+    """Find all occurrences of pattern or regular expression in the Series/Index.
+    
     Equivalent to applying :func:`re.findall` to all the elements in the
     Series/Index.
 
@@ -1308,6 +1494,8 @@
     flags : int, default 0
         Flags from ``re`` module, e.g. `re.IGNORECASE` (default is 0, which
         means no flags).
+    arr :
+        
 
     Returns
     -------
@@ -1324,59 +1512,63 @@
         match and one column for each group.
     re.findall : The equivalent ``re`` function to all non-overlapping matches
         of pattern or regular expression in string, as a list of strings.
-
     Examples
     --------
+    
+    The search for the pattern 'Monkey' returns one match:
+    
+    
+    On the other hand, the search for the pattern 'MONKEY' doesn't return any
+    match:
+    
+    
+    Flags can be added to the pattern or regular expression. For instance,
+    to find the pattern 'MONKEY' ignoring the case:
+    
+    
+    When the pattern matches more than one string in the Series, all matches
+    are returned:
+    
+    
+    Regular expressions are supported too. For instance, the search for all the
+    strings ending with the word 'on' is shown next:
+    
+    
+    If the pattern is found more than once in the same string, then a list of
+    multiple strings is returned:
     >>> s = pd.Series(['Lion', 'Monkey', 'Rabbit'])
-
-    The search for the pattern 'Monkey' returns one match:
-
+    
     >>> s.str.findall('Monkey')
     0          []
     1    [Monkey]
     2          []
     dtype: object
-
-    On the other hand, the search for the pattern 'MONKEY' doesn't return any
-    match:
-
+    
     >>> s.str.findall('MONKEY')
     0    []
     1    []
     2    []
     dtype: object
-
-    Flags can be added to the pattern or regular expression. For instance,
-    to find the pattern 'MONKEY' ignoring the case:
-
+    
     >>> import re
     >>> s.str.findall('MONKEY', flags=re.IGNORECASE)
     0          []
     1    [Monkey]
     2          []
     dtype: object
-
-    When the pattern matches more than one string in the Series, all matches
-    are returned:
-
+    
     >>> s.str.findall('on')
     0    [on]
     1    [on]
     2      []
     dtype: object
-
-    Regular expressions are supported too. For instance, the search for all the
-    strings ending with the word 'on' is shown next:
-
+    
     >>> s.str.findall('on$')
     0    [on]
     1      []
     2      []
     dtype: object
-
-    If the pattern is found more than once in the same string, then a list of
-    multiple strings is returned:
-
+    
     >>> s.str.findall('b')
     0        []
     1        []
@@ -1388,8 +1580,7 @@
 
 
 def str_find(arr, sub, start=0, end=None, side="left"):
-    """
-    Return indexes in each strings in the Series/Index where the
+    """Return indexes in each strings in the Series/Index where the
     substring is fully contained between [start:end]. Return -1 on failure.
 
     Parameters
@@ -1397,16 +1588,18 @@
     sub : str
         Substring being searched.
     start : int
-        Left edge index.
+        Left edge index. (Default value = 0)
     end : int
-        Right edge index.
+        Right edge index. (Default value = None)
     side : {'left', 'right'}, default 'left'
-        Specifies a starting side, equivalent to ``find`` or ``rfind``.
-
-    Returns
-    -------
-    Series or Index
-        Indexes where substring is found.
+        Specifies a starting side, equivalent to ``find`` or ``rfind``. (Default value = "left")
+    arr :
+        
+
+    Returns
+    -------
+
+    
     """
     if not isinstance(sub, str):
         msg = f"expected a string object, not {type(sub).__name__}"
@@ -1428,6 +1621,25 @@
 
 
 def str_index(arr, sub, start=0, end=None, side="left"):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    sub :
+        
+    start :
+         (Default value = 0)
+    end :
+         (Default value = None)
+    side :
+         (Default value = "left")
+
+    Returns
+    -------
+
+    """
     if not isinstance(sub, str):
         msg = f"expected a string object, not {type(sub).__name__}"
         raise TypeError(msg)
@@ -1448,8 +1660,7 @@
 
 
 def str_pad(arr, width, side="left", fillchar=" "):
-    """
-    Pad strings in the Series/Index up to width.
+    """Pad strings in the Series/Index up to width.
 
     Parameters
     ----------
@@ -1457,9 +1668,11 @@
         Minimum width of resulting string; additional characters will be filled
         with character defined in `fillchar`.
     side : {'left', 'right', 'both'}, default 'left'
-        Side from which to fill resulting string.
+        Side from which to fill resulting string. (Default value = "left")
     fillchar : str, default ' '
         Additional character for filling, default is whitespace.
+    arr :
+        
 
     Returns
     -------
@@ -1476,7 +1689,6 @@
         character. Equivalent to ``Series.str.pad(side='both')``.
     Series.str.zfill : Pad strings in the Series/Index by prepending '0'
         character. Equivalent to ``Series.str.pad(side='left', fillchar='0')``.
-
     Examples
     --------
     >>> s = pd.Series(["caribou", "tiger"])
@@ -1484,17 +1696,17 @@
     0    caribou
     1      tiger
     dtype: object
-
+    
     >>> s.str.pad(width=10)
     0       caribou
     1         tiger
     dtype: object
-
+    
     >>> s.str.pad(width=10, side='right', fillchar='-')
     0    caribou---
     1    tiger-----
     dtype: object
-
+    
     >>> s.str.pad(width=10, side='both', fillchar='-')
     0    -caribou--
     1    --tiger---
@@ -1524,6 +1736,21 @@
 
 
 def str_split(arr, pat=None, n=None):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    pat :
+         (Default value = None)
+    n :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
 
     if pat is None:
         if n is None or n == 0:
@@ -1544,6 +1771,21 @@
 
 
 def str_rsplit(arr, pat=None, n=None):
+    """
+
+    Parameters
+    ----------
+    arr :
+        
+    pat :
+         (Default value = None)
+    n :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
 
     if n is None or n == 0:
         n = -1
@@ -1553,17 +1795,18 @@
 
 
 def str_slice(arr, start=None, stop=None, step=None):
-    """
-    Slice substrings from each element in the Series or Index.
+    """Slice substrings from each element in the Series or Index.
 
     Parameters
     ----------
     start : int, optional
-        Start position for slice operation.
+        Start position for slice operation. (Default value = None)
     stop : int, optional
-        Stop position for slice operation.
+        Stop position for slice operation. (Default value = None)
     step : int, optional
-        Step size for slice operation.
+        Step size for slice operation. (Default value = None)
+    arr :
+        
 
     Returns
     -------
@@ -1576,48 +1819,52 @@
     Series.str.get : Return element at position.
         Equivalent to `Series.str.slice(start=i, stop=i+1)` with `i`
         being the position.
-
     Examples
     --------
+    
+    
+    
+    
+    
+    
+    Equivalent behaviour to:
     >>> s = pd.Series(["koala", "fox", "chameleon"])
     >>> s
     0        koala
     1          fox
     2    chameleon
     dtype: object
-
+    
     >>> s.str.slice(start=1)
     0        oala
     1          ox
     2    hameleon
     dtype: object
-
+    
     >>> s.str.slice(start=-1)
     0           a
     1           x
     2           n
     dtype: object
-
+    
     >>> s.str.slice(stop=2)
     0    ko
     1    fo
     2    ch
     dtype: object
-
+    
     >>> s.str.slice(step=2)
     0      kaa
     1       fx
     2    caeen
     dtype: object
-
+    
     >>> s.str.slice(start=0, stop=5, step=3)
     0    kl
     1     f
     2    cm
     dtype: object
-
-    Equivalent behaviour to:
-
+    
     >>> s.str[0:5:3]
     0    kl
     1     f
@@ -1630,22 +1877,23 @@
 
 
 def str_slice_replace(arr, start=None, stop=None, repl=None):
-    """
-    Replace a positional slice of a string with another value.
+    """Replace a positional slice of a string with another value.
 
     Parameters
     ----------
     start : int, optional
         Left index position to use for the slice. If not specified (None),
         the slice is unbounded on the left, i.e. slice from the start
-        of the string.
+        of the string. (Default value = None)
     stop : int, optional
         Right index position to use for the slice. If not specified (None),
         the slice is unbounded on the right, i.e. slice until the
-        end of the string.
+        end of the string. (Default value = None)
     repl : str, optional
         String for replacement. If not specified (None), the sliced region
-        is replaced with an empty string.
+        is replaced with an empty string. (Default value = None)
+    arr :
+        
 
     Returns
     -------
@@ -1655,9 +1903,20 @@
     See Also
     --------
     Series.str.slice : Just slicing without replacement.
-
     Examples
     --------
+    
+    Specify just `start`, meaning replace `start` until the end of the
+    string with `repl`.
+    
+    
+    Specify just `stop`, meaning the start of the string to `stop` is replaced
+    with `repl`, and the rest of the string is included.
+    
+    
+    Specify `start` and `stop`, meaning the slice from `start` to `stop` is
+    replaced with `repl`. Everything before or after `start` and `stop` is
+    included as is.
     >>> s = pd.Series(['a', 'ab', 'abc', 'abdc', 'abcde'])
     >>> s
     0        a
@@ -1666,10 +1925,7 @@
     3     abdc
     4    abcde
     dtype: object
-
-    Specify just `start`, meaning replace `start` until the end of the
-    string with `repl`.
-
+    
     >>> s.str.slice_replace(1, repl='X')
     0    aX
     1    aX
@@ -1677,10 +1933,7 @@
     3    aX
     4    aX
     dtype: object
-
-    Specify just `stop`, meaning the start of the string to `stop` is replaced
-    with `repl`, and the rest of the string is included.
-
+    
     >>> s.str.slice_replace(stop=2, repl='X')
     0       X
     1       X
@@ -1688,11 +1941,7 @@
     3     Xdc
     4    Xcde
     dtype: object
-
-    Specify `start` and `stop`, meaning the slice from `start` to `stop` is
-    replaced with `repl`. Everything before or after `start` and `stop` is
-    included as is.
-
+    
     >>> s.str.slice_replace(start=1, stop=3, repl='X')
     0      aX
     1      aX
@@ -1705,6 +1954,17 @@
         repl = ""
 
     def f(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if x[start:stop] == "":
             local_stop = start
         else:
@@ -1721,18 +1981,22 @@
 
 
 def str_strip(arr, to_strip=None, side="both"):
-    """
-    Strip whitespace (including newlines) from each string in the
+    """Strip whitespace (including newlines) from each string in the
     Series/Index.
 
     Parameters
     ----------
     to_strip : str or unicode
+         (Default value = None)
     side : {'left', 'right', 'both'}, default 'both'
-
-    Returns
-    -------
-    Series or Index
+         (Default value = "both")
+    arr :
+        
+
+    Returns
+    -------
+
+    
     """
     if side == "both":
         f = lambda x: x.strip(to_strip)
@@ -1746,9 +2010,9 @@
 
 
 def str_wrap(arr, width, **kwargs):
-    r"""
+    """r"""
     Wrap strings in Series/Index at specified line width.
-
+    
     This method has the same keyword parameters and defaults as
     :class:`textwrap.TextWrapper`.
 
@@ -1775,23 +2039,27 @@
         only whitespaces will be considered as potentially good places for line
         breaks, but you need to set break_long_words to false if you want truly
         insecable words (default: True).
+    arr :
+        
+    **kwargs :
+        
 
     Returns
     -------
     Series or Index
+        
 
     Notes
     -----
     Internally, this method uses a :class:`textwrap.TextWrapper` instance with
     default settings. To achieve behavior matching R's stringr library str_wrap
     function, use the arguments:
-
+    
     - expand_tabs = False
     - replace_whitespace = True
     - drop_whitespace = True
     - break_long_words = False
     - break_on_hyphens = False
-
     Examples
     --------
     >>> s = pd.Series(['line to be wrapped', 'another line to be wrapped'])
@@ -1799,7 +2067,6 @@
     0             line to be\nwrapped
     1    another line\nto be\nwrapped
     dtype: object
-    """
     kwargs["width"] = width
 
     tw = textwrap.TextWrapper(**kwargs)
@@ -1808,9 +2075,8 @@
 
 
 def str_translate(arr, table):
-    """
-    Map all characters in the string through the given mapping table.
-
+    """Map all characters in the string through the given mapping table.
+    
     Equivalent to standard :meth:`str.translate`.
 
     Parameters
@@ -1820,18 +2086,20 @@
         None. Unmapped characters are left untouched.
         Characters mapped to None are deleted. :meth:`str.maketrans` is a
         helper function for making translation tables.
-
-    Returns
-    -------
-    Series or Index
+    arr :
+        
+
+    Returns
+    -------
+
+    
     """
     return _na_map(lambda x: x.translate(table), arr, dtype=str)
 
 
 def str_get(arr, i):
-    """
-    Extract element from each component at specified position.
-
+    """Extract element from each component at specified position.
+    
     Extract element from lists, tuples, or strings in each element in the
     Series/Index.
 
@@ -1839,10 +2107,13 @@
     ----------
     i : int
         Position of element to extract.
+    arr :
+        
 
     Returns
     -------
     Series or Index
+        
 
     Examples
     --------
@@ -1860,7 +2131,7 @@
     4                          -456
     5    {1: 'Hello', '2': 'World'}
     dtype: object
-
+    
     >>> s.str.get(1)
     0        t
     1        2
@@ -1869,7 +2140,7 @@
     4      NaN
     5    Hello
     dtype: object
-
+    
     >>> s.str.get(-1)
     0      g
     1      3
@@ -1881,6 +2152,17 @@
     """
 
     def f(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(x, dict):
             return x.get(i)
         elif len(x) > i >= -len(x):
@@ -1891,20 +2173,24 @@
 
 
 def str_decode(arr, encoding, errors="strict"):
-    """
-    Decode character string in the Series/Index using indicated encoding.
-
+    """Decode character string in the Series/Index using indicated encoding.
+    
     Equivalent to :meth:`str.decode` in python2 and :meth:`bytes.decode` in
     python3.
 
     Parameters
     ----------
     encoding : str
+        
     errors : str, optional
-
-    Returns
-    -------
-    Series or Index
+         (Default value = "strict")
+    arr :
+        
+
+    Returns
+    -------
+
+    
     """
     if encoding in _cpython_optimized_decoders:
         # CPython optimized implementation
@@ -1916,19 +2202,23 @@
 
 
 def str_encode(arr, encoding, errors="strict"):
-    """
-    Encode character string in the Series/Index using indicated encoding.
-
+    """Encode character string in the Series/Index using indicated encoding.
+    
     Equivalent to :meth:`str.encode`.
 
     Parameters
     ----------
     encoding : str
+        
     errors : str, optional
-
-    Returns
-    -------
-    encoded : Series/Index of objects
+         (Default value = "strict")
+    arr :
+        
+
+    Returns
+    -------
+
+    
     """
     if encoding in _cpython_optimized_encoders:
         # CPython optimized implementation
@@ -1940,20 +2230,19 @@
 
 
 def forbid_nonstring_types(forbidden, name=None):
-    """
-    Decorator to forbid specific types for a method of StringMethods.
-
+    """Decorator to forbid specific types for a method of StringMethods.
+    
     For calling `.str.{method}` on a Series or Index, it is necessary to first
     initialize the :class:`StringMethods` object, and then call the method.
     However, different methods allow different input types, and so this can not
     be checked during :meth:`StringMethods.__init__`, but must be done on a
     per-method basis. This decorator exists to facilitate this process, and
     make it explicit which (inferred) types are disallowed by the method.
-
+    
     :meth:`StringMethods.__init__` allows the *union* of types its different
     methods allow (after skipping NaNs; see :meth:`StringMethods._validate`),
     namely: ['string', 'empty', 'bytes', 'mixed', 'mixed-integer'].
-
+    
     The default string types ['string', 'empty'] are allowed for all methods.
     For the additional types ['bytes', 'mixed', 'mixed-integer'], each method
     then needs to forbid the types it is not intended for.
@@ -1975,10 +2264,7 @@
         The method to which the decorator is applied, with an added check that
         enforces the inferred type to not be in the list of forbidden types.
 
-    Raises
-    ------
-    TypeError
-        If the inferred type of the underlying data is in `forbidden`.
+    
     """
     # deal with None
     forbidden = [] if forbidden is None else forbidden
@@ -1988,10 +2274,34 @@
     )
 
     def _forbid_nonstring_types(func):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         func_name = func.__name__ if name is None else name
 
         @wraps(func)
         def wrapper(self, *args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             if self._inferred_dtype not in allowed_types:
                 msg = (
                     f"Cannot use .str.{func_name} with values of "
@@ -2014,8 +2324,30 @@
     returns_string=True,
     **kwargs,
 ):
+    """
+
+    Parameters
+    ----------
+    f :
+        
+    name :
+         (Default value = None)
+    docstring :
+         (Default value = None)
+    forbidden_types :
+         (Default value = ["bytes"])
+    returns_string :
+         (Default value = True)
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     @forbid_nonstring_types(forbidden_types, name=name)
     def wrapper(self):
+        """ """
         result = _na_map(f, self._parent, **kwargs)
         return self._wrap_result(result, returns_string=returns_string)
 
@@ -2037,18 +2369,80 @@
     returns_string=True,
     **kwargs,
 ):
+    """
+
+    Parameters
+    ----------
+    f :
+        
+    flags :
+         (Default value = False)
+    na :
+         (Default value = False)
+    name :
+         (Default value = None)
+    forbidden_types :
+         (Default value = ["bytes"])
+    returns_string :
+         (Default value = True)
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     @forbid_nonstring_types(forbidden_types, name=name)
     def wrapper1(self, pat):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+
+        Returns
+        -------
+
+        """
         result = f(self._parent, pat)
         return self._wrap_result(result, returns_string=returns_string)
 
     @forbid_nonstring_types(forbidden_types, name=name)
     def wrapper2(self, pat, flags=0, **kwargs):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        flags :
+             (Default value = 0)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         result = f(self._parent, pat, flags=flags, **kwargs)
         return self._wrap_result(result, returns_string=returns_string)
 
     @forbid_nonstring_types(forbidden_types, name=name)
     def wrapper3(self, pat, na=np.nan):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        na :
+             (Default value = np.nan)
+
+        Returns
+        -------
+
+        """
         result = f(self._parent, pat, na=na)
         return self._wrap_result(result, returns_string=returns_string, fill_value=na)
 
@@ -2062,9 +2456,30 @@
 
 
 def copy(source):
-    """Copy a docstring from another source function (if present)"""
+    """Copy a docstring from another source function (if present)
+
+    Parameters
+    ----------
+    source :
+        
+
+    Returns
+    -------
+
+    """
 
     def do_copy(target):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
+        """
         if source.__doc__:
             target.__doc__ = source.__doc__
         return target
@@ -2073,12 +2488,17 @@
 
 
 class StringMethods(NoNewAttributesMixin):
-    """
-    Vectorized string functions for Series and Index.
-
+    """Vectorized string functions for Series and Index.
+    
     NAs stay NA unless handled otherwise by a particular method.
     Patterned after Python's string methods, with some inspiration from
     R's stringr package.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     Examples
     --------
@@ -2086,11 +2506,11 @@
     >>> s
     0    A_Str_Series
     dtype: object
-
+    
     >>> s.str.split("_")
     0    [A, Str, Series]
     dtype: object
-
+    
     >>> s.str.replace("_", "")
     0    AStrSeries
     dtype: object
@@ -2109,15 +2529,14 @@
 
     @staticmethod
     def _validate(data):
-        """
-        Auxiliary function for StringMethods, infers and checks dtype of data.
-
+        """Auxiliary function for StringMethods, infers and checks dtype of data.
+        
         This is a "first line of defence" at the creation of the StringMethods-
         object (see _make_accessor), and just checks that the dtype is in the
         *union* of the allowed types over all string methods below; this
         restriction is then refined on a per-method basis using the decorator
         @forbid_nonstring_types (more info in the corresponding docstring).
-
+        
         This really should exclude all series/index with any non-string values,
         but that isn't practical for performance reasons until we have a str
         dtype (GH 9343 / 13877)
@@ -2125,10 +2544,12 @@
         Parameters
         ----------
         data : The content of the Series
+            
 
         Returns
         -------
-        dtype : inferred dtype of data
+
+        
         """
         from pandas import StringDtype
 
@@ -2185,6 +2606,27 @@
         fill_value=np.nan,
         returns_string=True,
     ):
+        """
+
+        Parameters
+        ----------
+        result :
+            
+        use_codes :
+             (Default value = True)
+        name :
+             (Default value = None)
+        expand :
+             (Default value = None)
+        fill_value :
+             (Default value = np.nan)
+        returns_string :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
 
         from pandas import Index, MultiIndex, Series
 
@@ -2221,6 +2663,17 @@
             # not needed when inferred
 
             def cons_row(x):
+                """
+
+                Parameters
+                ----------
+                x :
+                    
+
+                Returns
+                -------
+
+                """
                 if is_list_like(x):
                     return x
                 else:
@@ -2277,8 +2730,7 @@
             return result
 
     def _get_series_list(self, others):
-        """
-        Auxiliary function for :meth:`str.cat`. Turn potentially mixed input
+        """Auxiliary function for :meth:`str.cat`. Turn potentially mixed input
         into a list of Series (elements without an index must match the length
         of the calling Series/Index).
 
@@ -2289,8 +2741,8 @@
 
         Returns
         -------
-        list of Series
-            Others transformed into list of Series.
+
+        
         """
         from pandas import DataFrame, Series
 
@@ -2335,9 +2787,8 @@
 
     @forbid_nonstring_types(["bytes", "mixed", "mixed-integer"])
     def cat(self, others=None, sep=None, na_rep=None, join="left"):
-        """
-        Concatenate strings in the Series/Index with given separator.
-
+        """Concatenate strings in the Series/Index with given separator.
+        
         If `others` is specified, this function concatenates the Series/Index
         and elements of `others` element-wise.
         If `others` is not passed, then all values in the Series/Index are
@@ -2350,33 +2801,29 @@
             other list-likes of strings must have the same length as the
             calling Series/Index, with the exception of indexed objects (i.e.
             Series/Index/DataFrame) if `join` is not None.
-
             If others is a list-like that contains a combination of Series,
             Index or np.ndarray (1-dim), then all elements will be unpacked and
             must satisfy the above criteria individually.
-
             If others is None, the method returns the concatenation of all
-            strings in the calling Series/Index.
+            strings in the calling Series/Index. (Default value = None)
         sep : str, default ''
             The separator between the different elements/columns. By default
             the empty string `''` is used.
         na_rep : str or None, default None
             Representation that is inserted for all missing values:
-
             - If `na_rep` is None, and `others` is None, missing values in the
-              Series/Index are omitted from the result.
+            Series/Index are omitted from the result.
             - If `na_rep` is None, and `others` is not None, a row containing a
-              missing value in any of the columns (before concatenation) will
-              have a missing value in the result.
+            missing value in any of the columns (before concatenation) will
+            have a missing value in the result. (Default value = None)
         join : {'left', 'right', 'outer', 'inner'}, default 'left'
             Determines the join-style between the calling Series/Index and any
             Series/Index/DataFrame in `others` (objects without an index need
             to match the length of the calling Series/Index). To disable
             alignment, use `.values` on any Series/Index/DataFrame in `others`.
-
             .. versionadded:: 0.23.0
             .. versionchanged:: 1.0.0
-                Changed default of `join` from None to `'left'`.
+            Changed default of `join` from None to `'left'`.
 
         Returns
         -------
@@ -2388,55 +2835,61 @@
         --------
         split : Split each string in the Series/Index.
         join : Join lists contained as elements in the Series/Index.
-
         Examples
         --------
         When not passing `others`, all values are concatenated into a single
         string:
-
+        
+        
+        By default, NA values in the Series are ignored. Using `na_rep`, they
+        can be given a representation:
+        
+        
+        If `others` is specified, corresponding values are concatenated with
+        the separator. Result will be a Series of strings.
+        
+        
+        Missing values will remain missing in the result, but can again be
+        represented using `na_rep`
+        
+        
+        If `sep` is not specified, the values are concatenated without
+        separation.
+        
+        
+        Series with different indexes can be aligned before concatenation. The
+        `join`-keyword works as in other methods.
+        
+        
+        For more examples, see :ref:`here <text.concatenate>`.
         >>> s = pd.Series(['a', 'b', np.nan, 'd'])
         >>> s.str.cat(sep=' ')
         'a b d'
-
-        By default, NA values in the Series are ignored. Using `na_rep`, they
-        can be given a representation:
-
+        
         >>> s.str.cat(sep=' ', na_rep='?')
         'a b ? d'
-
-        If `others` is specified, corresponding values are concatenated with
-        the separator. Result will be a Series of strings.
-
+        
         >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',')
         0    a,A
         1    b,B
         2    NaN
         3    d,D
         dtype: object
-
-        Missing values will remain missing in the result, but can again be
-        represented using `na_rep`
-
+        
         >>> s.str.cat(['A', 'B', 'C', 'D'], sep=',', na_rep='-')
         0    a,A
         1    b,B
         2    -,C
         3    d,D
         dtype: object
-
-        If `sep` is not specified, the values are concatenated without
-        separation.
-
+        
         >>> s.str.cat(['A', 'B', 'C', 'D'], na_rep='-')
         0    aA
         1    bB
         2    -C
         3    dD
         dtype: object
-
-        Series with different indexes can be aligned before concatenation. The
-        `join`-keyword works as in other methods.
-
+        
         >>> t = pd.Series(['d', 'a', 'e', 'c'], index=[3, 0, 4, 2])
         >>> s.str.cat(t, join='left', na_rep='-')
         0    aa
@@ -2465,8 +2918,6 @@
         4    -e
         2    -c
         dtype: object
-
-        For more examples, see :ref:`here <text.concatenate>`.
         """
         from pandas import Index, Series, concat
 
@@ -2686,12 +3137,42 @@
     @Appender(_shared_docs["str_split"] % {"side": "beginning", "method": "split"})
     @forbid_nonstring_types(["bytes"])
     def split(self, pat=None, n=-1, expand=False):
+        """
+
+        Parameters
+        ----------
+        pat :
+             (Default value = None)
+        n :
+             (Default value = -1)
+        expand :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         result = str_split(self._parent, pat, n=n)
         return self._wrap_result(result, expand=expand, returns_string=expand)
 
     @Appender(_shared_docs["str_split"] % {"side": "end", "method": "rsplit"})
     @forbid_nonstring_types(["bytes"])
     def rsplit(self, pat=None, n=-1, expand=False):
+        """
+
+        Parameters
+        ----------
+        pat :
+             (Default value = None)
+        n :
+             (Default value = -1)
+        expand :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         result = str_rsplit(self._parent, pat, n=n)
         return self._wrap_result(result, expand=expand, returns_string=expand)
 
@@ -2788,6 +3269,19 @@
     )
     @forbid_nonstring_types(["bytes"])
     def partition(self, sep=" ", expand=True):
+        """
+
+        Parameters
+        ----------
+        sep :
+             (Default value = " ")
+        expand :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         f = lambda x: x.partition(sep)
         result = _na_map(f, self._parent)
         return self._wrap_result(result, expand=expand, returns_string=expand)
@@ -2803,24 +3297,78 @@
     )
     @forbid_nonstring_types(["bytes"])
     def rpartition(self, sep=" ", expand=True):
+        """
+
+        Parameters
+        ----------
+        sep :
+             (Default value = " ")
+        expand :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         f = lambda x: x.rpartition(sep)
         result = _na_map(f, self._parent)
         return self._wrap_result(result, expand=expand, returns_string=expand)
 
     @copy(str_get)
     def get(self, i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         result = str_get(self._parent, i)
         return self._wrap_result(result)
 
     @copy(str_join)
     @forbid_nonstring_types(["bytes"])
     def join(self, sep):
+        """
+
+        Parameters
+        ----------
+        sep :
+            
+
+        Returns
+        -------
+
+        """
         result = str_join(self._parent, sep)
         return self._wrap_result(result)
 
     @copy(str_contains)
     @forbid_nonstring_types(["bytes"])
     def contains(self, pat, case=True, flags=0, na=np.nan, regex=True):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        case :
+             (Default value = True)
+        flags :
+             (Default value = 0)
+        na :
+             (Default value = np.nan)
+        regex :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         result = str_contains(
             self._parent, pat, case=case, flags=flags, na=na, regex=regex
         )
@@ -2829,18 +3377,73 @@
     @copy(str_match)
     @forbid_nonstring_types(["bytes"])
     def match(self, pat, case=True, flags=0, na=np.nan):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        case :
+             (Default value = True)
+        flags :
+             (Default value = 0)
+        na :
+             (Default value = np.nan)
+
+        Returns
+        -------
+
+        """
         result = str_match(self._parent, pat, case=case, flags=flags, na=na)
         return self._wrap_result(result, fill_value=na, returns_string=False)
 
     @copy(str_fullmatch)
     @forbid_nonstring_types(["bytes"])
     def fullmatch(self, pat, case=True, flags=0, na=np.nan):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        case :
+             (Default value = True)
+        flags :
+             (Default value = 0)
+        na :
+             (Default value = np.nan)
+
+        Returns
+        -------
+
+        """
         result = str_fullmatch(self._parent, pat, case=case, flags=flags, na=na)
         return self._wrap_result(result, fill_value=na, returns_string=False)
 
     @copy(str_replace)
     @forbid_nonstring_types(["bytes"])
     def replace(self, pat, repl, n=-1, case=None, flags=0, regex=True):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        repl :
+            
+        n :
+             (Default value = -1)
+        case :
+             (Default value = None)
+        flags :
+             (Default value = 0)
+        regex :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         result = str_replace(
             self._parent, pat, repl, n=n, case=case, flags=flags, regex=regex
         )
@@ -2849,12 +3452,38 @@
     @copy(str_repeat)
     @forbid_nonstring_types(["bytes"])
     def repeat(self, repeats):
+        """
+
+        Parameters
+        ----------
+        repeats :
+            
+
+        Returns
+        -------
+
+        """
         result = str_repeat(self._parent, repeats)
         return self._wrap_result(result)
 
     @copy(str_pad)
     @forbid_nonstring_types(["bytes"])
     def pad(self, width, side="left", fillchar=" "):
+        """
+
+        Parameters
+        ----------
+        width :
+            
+        side :
+             (Default value = "left")
+        fillchar :
+             (Default value = " ")
+
+        Returns
+        -------
+
+        """
         result = str_pad(self._parent, width, side=side, fillchar=fillchar)
         return self._wrap_result(result)
 
@@ -2881,23 +3510,61 @@
     @Appender(_shared_docs["str_pad"] % dict(side="left and right", method="center"))
     @forbid_nonstring_types(["bytes"])
     def center(self, width, fillchar=" "):
+        """
+
+        Parameters
+        ----------
+        width :
+            
+        fillchar :
+             (Default value = " ")
+
+        Returns
+        -------
+
+        """
         return self.pad(width, side="both", fillchar=fillchar)
 
     @Appender(_shared_docs["str_pad"] % dict(side="right", method="ljust"))
     @forbid_nonstring_types(["bytes"])
     def ljust(self, width, fillchar=" "):
+        """
+
+        Parameters
+        ----------
+        width :
+            
+        fillchar :
+             (Default value = " ")
+
+        Returns
+        -------
+
+        """
         return self.pad(width, side="right", fillchar=fillchar)
 
     @Appender(_shared_docs["str_pad"] % dict(side="left", method="rjust"))
     @forbid_nonstring_types(["bytes"])
     def rjust(self, width, fillchar=" "):
+        """
+
+        Parameters
+        ----------
+        width :
+            
+        fillchar :
+             (Default value = " ")
+
+        Returns
+        -------
+
+        """
         return self.pad(width, side="left", fillchar=fillchar)
 
     @forbid_nonstring_types(["bytes"])
     def zfill(self, width):
-        """
-        Pad strings in the Series/Index by prepending '0' characters.
-
+        """Pad strings in the Series/Index by prepending '0' characters.
+        
         Strings in the Series/Index are padded with '0' characters on the
         left of the string to reach a total string length  `width`. Strings
         in the Series/Index with length greater or equal to `width` are
@@ -2912,6 +3579,7 @@
         Returns
         -------
         Series/Index of objects.
+            
 
         See Also
         --------
@@ -2923,14 +3591,18 @@
             character.
         Series.str.center : Fills boths sides of strings with an arbitrary
             character.
-
         Notes
         -----
         Differs from :meth:`str.zfill` which has special handling
         for '+'/'-' in the string.
-
         Examples
         --------
+        
+        Note that ``10`` and ``NaN`` are not strings, therefore they are
+        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a
+        regular character and the zero is added to the left of it
+        (:meth:`str.zfill` would have moved it to the left). ``1000``
+        remains unchanged as it is longer than `width`.
         >>> s = pd.Series(['-1', '1', '1000', 10, np.nan])
         >>> s
         0      -1
@@ -2939,13 +3611,7 @@
         3      10
         4     NaN
         dtype: object
-
-        Note that ``10`` and ``NaN`` are not strings, therefore they are
-        converted to ``NaN``. The minus sign in ``'-1'`` is treated as a
-        regular character and the zero is added to the left of it
-        (:meth:`str.zfill` would have moved it to the left). ``1000``
-        remains unchanged as it is longer than `width`.
-
+        
         >>> s.str.zfill(3)
         0     0-1
         1     001
@@ -2959,17 +3625,60 @@
 
     @copy(str_slice)
     def slice(self, start=None, stop=None, step=None):
+        """
+
+        Parameters
+        ----------
+        start :
+             (Default value = None)
+        stop :
+             (Default value = None)
+        step :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_slice(self._parent, start, stop, step)
         return self._wrap_result(result)
 
     @copy(str_slice_replace)
     @forbid_nonstring_types(["bytes"])
     def slice_replace(self, start=None, stop=None, repl=None):
+        """
+
+        Parameters
+        ----------
+        start :
+             (Default value = None)
+        stop :
+             (Default value = None)
+        repl :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_slice_replace(self._parent, start, stop, repl)
         return self._wrap_result(result)
 
     @copy(str_decode)
     def decode(self, encoding, errors="strict"):
+        """
+
+        Parameters
+        ----------
+        encoding :
+            
+        errors :
+             (Default value = "strict")
+
+        Returns
+        -------
+
+        """
         # need to allow bytes here
         result = str_decode(self._parent, encoding, errors)
         # TODO: Not sure how to handle this.
@@ -2978,6 +3687,19 @@
     @copy(str_encode)
     @forbid_nonstring_types(["bytes"])
     def encode(self, encoding, errors="strict"):
+        """
+
+        Parameters
+        ----------
+        encoding :
+            
+        errors :
+             (Default value = "strict")
+
+        Returns
+        -------
+
+        """
         result = str_encode(self._parent, encoding, errors)
         return self._wrap_result(result, returns_string=False)
 
@@ -3054,6 +3776,17 @@
     )
     @forbid_nonstring_types(["bytes"])
     def strip(self, to_strip=None):
+        """
+
+        Parameters
+        ----------
+        to_strip :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_strip(self._parent, to_strip, side="both")
         return self._wrap_result(result)
 
@@ -3063,6 +3796,17 @@
     )
     @forbid_nonstring_types(["bytes"])
     def lstrip(self, to_strip=None):
+        """
+
+        Parameters
+        ----------
+        to_strip :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_strip(self._parent, to_strip, side="left")
         return self._wrap_result(result)
 
@@ -3072,18 +3816,53 @@
     )
     @forbid_nonstring_types(["bytes"])
     def rstrip(self, to_strip=None):
+        """
+
+        Parameters
+        ----------
+        to_strip :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_strip(self._parent, to_strip, side="right")
         return self._wrap_result(result)
 
     @copy(str_wrap)
     @forbid_nonstring_types(["bytes"])
     def wrap(self, width, **kwargs):
+        """
+
+        Parameters
+        ----------
+        width :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         result = str_wrap(self._parent, width, **kwargs)
         return self._wrap_result(result)
 
     @copy(str_get_dummies)
     @forbid_nonstring_types(["bytes"])
     def get_dummies(self, sep="|"):
+        """
+
+        Parameters
+        ----------
+        sep :
+             (Default value = "|")
+
+        Returns
+        -------
+
+        """
         # we need to cast to Series of strings as only that has all
         # methods available for making the dummies...
         data = self._orig.astype(str) if self._is_categorical else self._parent
@@ -3099,6 +3878,17 @@
     @copy(str_translate)
     @forbid_nonstring_types(["bytes"])
     def translate(self, table):
+        """
+
+        Parameters
+        ----------
+        table :
+            
+
+        Returns
+        -------
+
+        """
         result = str_translate(self._parent, table)
         return self._wrap_result(result)
 
@@ -3116,11 +3906,39 @@
     @copy(str_extract)
     @forbid_nonstring_types(["bytes"])
     def extract(self, pat, flags=0, expand=True):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        flags :
+             (Default value = 0)
+        expand :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         return str_extract(self, pat, flags=flags, expand=expand)
 
     @copy(str_extractall)
     @forbid_nonstring_types(["bytes"])
     def extractall(self, pat, flags=0):
+        """
+
+        Parameters
+        ----------
+        pat :
+            
+        flags :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         return str_extractall(self._orig, pat, flags=flags)
 
     _shared_docs[
@@ -3160,6 +3978,21 @@
     )
     @forbid_nonstring_types(["bytes"])
     def find(self, sub, start=0, end=None):
+        """
+
+        Parameters
+        ----------
+        sub :
+            
+        start :
+             (Default value = 0)
+        end :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_find(self._parent, sub, start=start, end=end, side="left")
         return self._wrap_result(result, returns_string=False)
 
@@ -3173,14 +4006,28 @@
     )
     @forbid_nonstring_types(["bytes"])
     def rfind(self, sub, start=0, end=None):
+        """
+
+        Parameters
+        ----------
+        sub :
+            
+        start :
+             (Default value = 0)
+        end :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_find(self._parent, sub, start=start, end=end, side="right")
         return self._wrap_result(result, returns_string=False)
 
     @forbid_nonstring_types(["bytes"])
     def normalize(self, form):
-        """
-        Return the Unicode normal form for the strings in the Series/Index.
-
+        """Return the Unicode normal form for the strings in the Series/Index.
+        
         For more information on the forms, see the
         :func:`unicodedata.normalize`.
 
@@ -3191,7 +4038,8 @@
 
         Returns
         -------
-        normalized : Series/Index of objects
+
+        
         """
         import unicodedata
 
@@ -3239,6 +4087,21 @@
     )
     @forbid_nonstring_types(["bytes"])
     def index(self, sub, start=0, end=None):
+        """
+
+        Parameters
+        ----------
+        sub :
+            
+        start :
+             (Default value = 0)
+        end :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_index(self._parent, sub, start=start, end=end, side="left")
         return self._wrap_result(result, returns_string=False)
 
@@ -3253,6 +4116,21 @@
     )
     @forbid_nonstring_types(["bytes"])
     def rindex(self, sub, start=0, end=None):
+        """
+
+        Parameters
+        ----------
+        sub :
+            
+        start :
+             (Default value = 0)
+        end :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         result = str_index(self._parent, sub, start=start, end=end, side="right")
         return self._wrap_result(result, returns_string=False)
 
@@ -3649,5 +4527,16 @@
 
     @classmethod
     def _make_accessor(cls, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         cls._validate(data)
         return cls(data)
