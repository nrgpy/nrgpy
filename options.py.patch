# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/options.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/options.py
@@ -35,6 +35,7 @@
            help="Main user memcache servers")
 
     def connect():
+        """ """
         db = database.Connection(options.mysql_host)
         ...
 
@@ -44,6 +45,7 @@
     define("port", default=8080, help="port to listen on")
 
     def start_server():
+        """ """
         app = make_app()
         app.listen(options.port)
 
@@ -119,16 +121,23 @@
 
 
 class Error(Exception):
-    """Exception raised by errors in the options module."""
+    """ """
 
     pass
 
 
 class OptionParser(object):
     """A collection of options, a dictionary with object-like access.
-
+    
     Normally accessed via static functions in the `tornado.options` module,
     which reference a global instance.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self) -> None:
@@ -143,6 +152,17 @@
         )
 
     def _normalize_name(self, name: str) -> str:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+
+        Returns
+        -------
+
+        """
         return name.replace("_", "-")
 
     def __getattr__(self, name: str) -> Any:
@@ -172,34 +192,57 @@
 
     def items(self) -> Iterable[Tuple[str, Any]]:
         """An iterable of (name, value) pairs.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return [(opt.name, opt.value()) for name, opt in self._options.items()]
 
     def groups(self) -> Set[str]:
         """The set of option-groups created by ``define``.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return set(opt.group_name for opt in self._options.values())
 
     def group_dict(self, group: str) -> Dict[str, Any]:
         """The names and values of options in a group.
-
+        
         Useful for copying options into Application settings::
-
+        
             from tornado.options import define, parse_command_line, options
-
+        
             define('template_path', group='application')
             define('static_path', group='application')
-
+        
             parse_command_line()
-
+        
             application = Application(
                 handlers, **options.group_dict('application'))
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        group: str :
+            
+
+        Returns
+        -------
+
         """
         return dict(
             (opt.name, opt.value())
@@ -209,8 +252,15 @@
 
     def as_dict(self) -> Dict[str, Any]:
         """The names and values of all options.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return dict((opt.name, opt.value()) for name, opt in self._options.items())
 
@@ -226,37 +276,61 @@
         callback: Optional[Callable[[Any], None]] = None,
     ) -> None:
         """Defines a new command line option.
-
+        
         ``type`` can be any of `str`, `int`, `float`, `bool`,
         `~datetime.datetime`, or `~datetime.timedelta`. If no ``type``
         is given but a ``default`` is, ``type`` is the type of
         ``default``. Otherwise, ``type`` defaults to `str`.
-
+        
         If ``multiple`` is True, the option value is a list of ``type``
         instead of an instance of ``type``.
-
+        
         ``help`` and ``metavar`` are used to construct the
         automatically generated command line help string. The help
         message is formatted like::
-
+        
            --name=METAVAR      help string
-
+        
         ``group`` is used to group the defined options in logical
         groups. By default, command line options are grouped by the
         file in which they are defined.
-
+        
         Command line option names must be unique globally.
-
+        
         If a ``callback`` is given, it will be run with the new value whenever
         the option is changed.  This can be used to combine command-line
         and file-based options::
-
+        
             define("config", type=str, help="path to config file",
                    callback=lambda path: parse_config_file(path, final=False))
-
+        
         With this definition, options in the file specified by ``--config`` will
         override options set earlier on the command line, but can be overridden
         by later flags.
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: Any :
+             (Default value = None)
+        type: Optional[type] :
+             (Default value = None)
+        help: Optional[str] :
+             (Default value = None)
+        metavar: Optional[str] :
+             (Default value = None)
+        multiple: bool :
+             (Default value = False)
+        group: Optional[str] :
+             (Default value = None)
+        callback: Optional[Callable[[Any] :
+            
+        None]] :
+             (Default value = None)
+
+        Returns
+        -------
 
         """
         normalized = self._normalize_name(name)
@@ -306,23 +380,33 @@
     ) -> List[str]:
         """Parses all options given on the command line (defaults to
         `sys.argv`).
-
+        
         Options look like ``--option=value`` and are parsed according
         to their ``type``. For boolean options, ``--option`` is
         equivalent to ``--option=true``
-
+        
         If the option has ``multiple=True``, comma-separated values
         are accepted. For multi-value integer options, the syntax
         ``x:y`` is also accepted and equivalent to ``range(x, y)``.
-
+        
         Note that ``args[0]`` is ignored since it is the program name
         in `sys.argv`.
-
+        
         We return a list of all arguments that are not parsed as options.
-
+        
         If ``final`` is ``False``, parse callbacks will not be run.
         This is useful for applications that wish to combine configurations
         from multiple sources.
+
+        Parameters
+        ----------
+        args: Optional[List[str]] :
+             (Default value = None)
+        final: bool :
+             (Default value = True)
+
+        Returns
+        -------
 
         """
         if args is None:
@@ -357,19 +441,19 @@
 
     def parse_config_file(self, path: str, final: bool = True) -> None:
         """Parses and loads the config file at the given path.
-
+        
         The config file contains Python code that will be executed (so
         it is **not safe** to use untrusted config files). Anything in
         the global namespace that matches a defined option will be
         used to set that option's value.
-
+        
         Options may either be the specified type for the option or
         strings (in which case they will be parsed the same way as in
         `.parse_command_line`)
-
+        
         Example (using the options defined in the top-level docs of
         this module)::
-
+        
             port = 80
             mysql_host = 'mydb.example.com:3306'
             # Both lists and comma-separated strings are allowed for
@@ -377,28 +461,38 @@
             memcache_hosts = ['cache1.example.com:11011',
                               'cache2.example.com:11011']
             memcache_hosts = 'cache1.example.com:11011,cache2.example.com:11011'
-
+        
         If ``final`` is ``False``, parse callbacks will not be run.
         This is useful for applications that wish to combine configurations
         from multiple sources.
-
+        
         .. note::
-
+        
             `tornado.options` is primarily a command-line library.
             Config file support is provided for applications that wish
             to use it, but applications that prefer config files may
             wish to look at other libraries instead.
-
+        
         .. versionchanged:: 4.1
            Config files are now always interpreted as utf-8 instead of
            the system default encoding.
-
+        
         .. versionchanged:: 4.4
            The special variable ``__file__`` is available inside config
            files, specifying the absolute path to the config file itself.
-
+        
         .. versionchanged:: 5.1
            Added the ability to set options via strings in config files.
+
+        Parameters
+        ----------
+        path: str :
+            
+        final: bool :
+             (Default value = True)
+
+        Returns
+        -------
 
         """
         config = {"__file__": os.path.abspath(path)}
@@ -425,7 +519,17 @@
             self.run_parse_callbacks()
 
     def print_help(self, file: Optional[TextIO] = None) -> None:
-        """Prints all the command line options to stderr (or another file)."""
+        """Prints all the command line options to stderr (or another file).
+
+        Parameters
+        ----------
+        file: Optional[TextIO] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if file is None:
             file = sys.stderr
         print("Usage: %s [OPTIONS]" % sys.argv[0], file=file)
@@ -455,22 +559,46 @@
         print(file=file)
 
     def _help_callback(self, value: bool) -> None:
+        """
+
+        Parameters
+        ----------
+        value: bool :
+            
+
+        Returns
+        -------
+
+        """
         if value:
             self.print_help()
             sys.exit(0)
 
     def add_parse_callback(self, callback: Callable[[], None]) -> None:
-        """Adds a parse callback, to be invoked when option parsing is done."""
+        """Adds a parse callback, to be invoked when option parsing is done.
+
+        Parameters
+        ----------
+        callback: Callable[[] :
+            
+        None] :
+            
+
+        Returns
+        -------
+
+        """
         self._parse_callbacks.append(callback)
 
     def run_parse_callbacks(self) -> None:
+        """ """
         for callback in self._parse_callbacks:
             callback()
 
     def mockable(self) -> "_Mockable":
         """Returns a wrapper around self that is compatible with
         `mock.patch <unittest.mock.patch>`.
-
+        
         The `mock.patch <unittest.mock.patch>` function (included in
         the standard library `unittest.mock` package since Python 3.3,
         or in the third-party ``mock`` package for older versions of
@@ -478,24 +606,38 @@
         override ``__getattr__`` and ``__setattr__``.  This function
         returns an object that can be used with `mock.patch.object
         <unittest.mock.patch.object>` to modify option values::
-
+        
             with mock.patch.object(options.mockable(), 'name', value):
                 assert options.name == value
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return _Mockable(self)
 
 
 class _Mockable(object):
     """`mock.patch` compatible wrapper for `OptionParser`.
-
+    
     As of ``mock`` version 1.0.1, when an object uses ``__getattr__``
     hooks instead of ``__dict__``, ``patch.__exit__`` tries to delete
     the attribute it set instead of setting a new one (assuming that
     the object does not capture ``__setattr__``, so the patch
     created a new attribute in ``__dict__``).
-
+    
     _Mockable's getattr and setattr pass through to the underlying
     OptionParser, and delattr undoes the effect of a previous setattr.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, options: OptionParser) -> None:
@@ -516,6 +658,7 @@
 
 
 class _Option(object):
+    """ """
     # This class could almost be made generic, but the way the types
     # interact with the multiple argument makes this tricky. (default
     # and the callback use List[T], but type is still Type[T]).
@@ -549,9 +692,21 @@
         self._value = _Option.UNSET  # type: Any
 
     def value(self) -> Any:
+        """ """
         return self.default if self._value is _Option.UNSET else self._value
 
     def parse(self, value: str) -> Any:
+        """
+
+        Parameters
+        ----------
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         _parse = {
             datetime.datetime: self._parse_datetime,
             datetime.timedelta: self._parse_timedelta,
@@ -578,6 +733,17 @@
         return self.value()
 
     def set(self, value: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        value: Any :
+            
+
+        Returns
+        -------
+
+        """
         if self.multiple:
             if not isinstance(value, list):
                 raise Error(
@@ -615,6 +781,17 @@
     ]
 
     def _parse_datetime(self, value: str) -> datetime.datetime:
+        """
+
+        Parameters
+        ----------
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         for format in self._DATETIME_FORMATS:
             try:
                 return datetime.datetime.strptime(value, format)
@@ -641,6 +818,17 @@
     )
 
     def _parse_timedelta(self, value: str) -> datetime.timedelta:
+        """
+
+        Parameters
+        ----------
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         try:
             sum = datetime.timedelta()
             start = 0
@@ -658,9 +846,31 @@
             raise
 
     def _parse_bool(self, value: str) -> bool:
+        """
+
+        Parameters
+        ----------
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         return value.lower() not in ("false", "0", "f")
 
     def _parse_string(self, value: str) -> str:
+        """
+
+        Parameters
+        ----------
+        value: str :
+            
+
+        Returns
+        -------
+
+        """
         return _unicode(value)
 
 
@@ -682,8 +892,33 @@
     callback: Optional[Callable[[Any], None]] = None,
 ) -> None:
     """Defines an option in the global namespace.
-
+    
     See `OptionParser.define`.
+
+    Parameters
+    ----------
+    name: str :
+        
+    default: Any :
+         (Default value = None)
+    type: Optional[type] :
+         (Default value = None)
+    help: Optional[str] :
+         (Default value = None)
+    metavar: Optional[str] :
+         (Default value = None)
+    multiple: bool :
+         (Default value = False)
+    group: Optional[str] :
+         (Default value = None)
+    callback: Optional[Callable[[Any] :
+        
+    None]] :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     return options.define(
         name,
@@ -701,32 +936,74 @@
     args: Optional[List[str]] = None, final: bool = True
 ) -> List[str]:
     """Parses global options from the command line.
-
+    
     See `OptionParser.parse_command_line`.
+
+    Parameters
+    ----------
+    args: Optional[List[str]] :
+         (Default value = None)
+    final: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     return options.parse_command_line(args, final=final)
 
 
 def parse_config_file(path: str, final: bool = True) -> None:
     """Parses global options from a config file.
-
+    
     See `OptionParser.parse_config_file`.
+
+    Parameters
+    ----------
+    path: str :
+        
+    final: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     return options.parse_config_file(path, final=final)
 
 
 def print_help(file: Optional[TextIO] = None) -> None:
     """Prints all the command line options to stderr (or another file).
-
+    
     See `OptionParser.print_help`.
+
+    Parameters
+    ----------
+    file: Optional[TextIO] :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     return options.print_help(file)
 
 
 def add_parse_callback(callback: Callable[[], None]) -> None:
     """Adds a parse callback, to be invoked when option parsing is done.
-
+    
     See `OptionParser.add_parse_callback`
+
+    Parameters
+    ----------
+    callback: Callable[[] :
+        
+    None] :
+        
+
+    Returns
+    -------
+
     """
     options.add_parse_callback(callback)
 
