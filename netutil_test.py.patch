# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/netutil_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/netutil_test.py
@@ -39,10 +39,22 @@
 
 
 class _ResolverTestMixin(object):
+    """ """
     resolver = None  # type: typing.Any
 
     @gen_test
     def test_localhost(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         addrinfo = yield self.resolver.resolve("localhost", 80, socket.AF_UNSPEC)
         self.assertIn((socket.AF_INET, ("127.0.0.1", 80)), addrinfo)
 
@@ -50,22 +62,46 @@
 # It is impossible to quickly and consistently generate an error in name
 # resolution, so test this case separately, using mocks as needed.
 class _ResolverErrorTestMixin(object):
+    """ """
     resolver = None  # type: typing.Any
 
     @gen_test
     def test_bad_host(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         with self.assertRaises(IOError):
             yield self.resolver.resolve("an invalid domain", 80, socket.AF_UNSPEC)
 
 
 def _failing_getaddrinfo(*args):
-    """Dummy implementation of getaddrinfo for use in mocks"""
+    """Dummy implementation of getaddrinfo for use in mocks
+
+    Parameters
+    ----------
+    *args :
+        
+
+    Returns
+    -------
+
+    """
     raise socket.gaierror(errno.EIO, "mock: lookup failed")
 
 
 @skipIfNoNetwork
 class BlockingResolverTest(AsyncTestCase, _ResolverTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = BlockingResolver()
 
@@ -74,19 +110,24 @@
 # some configurations are slow to produce errors and take longer than
 # our default timeout.
 class BlockingResolverErrorTest(AsyncTestCase, _ResolverErrorTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = BlockingResolver()
         self.real_getaddrinfo = socket.getaddrinfo
         socket.getaddrinfo = _failing_getaddrinfo
 
     def tearDown(self):
+        """ """
         socket.getaddrinfo = self.real_getaddrinfo
         super().tearDown()
 
 
 class OverrideResolverTest(AsyncTestCase, _ResolverTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         mapping = {
             ("google.com", 80): ("1.2.3.4", 80),
@@ -100,6 +141,7 @@
 
     @gen_test
     def test_resolve_multiaddr(self):
+        """ """
         result = yield self.resolver.resolve("google.com", 80, socket.AF_INET)
         self.assertIn((socket.AF_INET, ("1.2.3.4", 80)), result)
 
@@ -111,23 +153,29 @@
 
 @skipIfNoNetwork
 class ThreadedResolverTest(AsyncTestCase, _ResolverTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = ThreadedResolver()
 
     def tearDown(self):
+        """ """
         self.resolver.close()
         super().tearDown()
 
 
 class ThreadedResolverErrorTest(AsyncTestCase, _ResolverErrorTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = BlockingResolver()
         self.real_getaddrinfo = socket.getaddrinfo
         socket.getaddrinfo = _failing_getaddrinfo
 
     def tearDown(self):
+        """ """
         socket.getaddrinfo = self.real_getaddrinfo
         super().tearDown()
 
@@ -135,7 +183,9 @@
 @skipIfNoNetwork
 @unittest.skipIf(sys.platform == "win32", "preexec_fn not available on win32")
 class ThreadedResolverImportTest(unittest.TestCase):
+    """ """
     def test_import(self):
+        """ """
         TIMEOUT = 5
 
         # Test for a deadlock when importing a module that runs the
@@ -166,7 +216,9 @@
 @unittest.skipIf(sys.platform == "win32", "pycares doesn't return loopback on windows")
 @unittest.skipIf(sys.platform == "darwin", "pycares doesn't return 127.0.0.1 on darwin")
 class CaresResolverTest(AsyncTestCase, _ResolverTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = CaresResolver()
 
@@ -185,13 +237,17 @@
 )
 @unittest.skipIf(sys.platform == "win32", "twisted resolver hangs on windows")
 class TwistedResolverTest(AsyncTestCase, _ResolverTestMixin):
-    def setUp(self):
+    """ """
+    def setUp(self):
+        """ """
         super().setUp()
         self.resolver = TwistedResolver()
 
 
 class IsValidIPTest(unittest.TestCase):
+    """ """
     def test_is_valid_ip(self):
+        """ """
         self.assertTrue(is_valid_ip("127.0.0.1"))
         self.assertTrue(is_valid_ip("4.4.4.4"))
         self.assertTrue(is_valid_ip("::1"))
@@ -207,7 +263,9 @@
 
 
 class TestPortAllocation(unittest.TestCase):
+    """ """
     def test_same_port_allocation(self):
+        """ """
         if "TRAVIS" in os.environ:
             self.skipTest("dual-stack servers often have port conflicts on travis")
         sockets = bind_sockets(0, "localhost")
@@ -222,6 +280,7 @@
         not hasattr(socket, "SO_REUSEPORT"), "SO_REUSEPORT is not supported"
     )
     def test_reuse_port(self):
+        """ """
         sockets = []  # type: List[socket.socket]
         socket, port = bind_unused_port(reuse_port=True)
         try:
