# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/nanfunctions.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/nanfunctions.py
@@ -40,6 +40,7 @@
 
 def _nan_mask(a, out=None):
     """
+
     Parameters
     ----------
     a : array-like
@@ -51,10 +52,8 @@
 
     Returns
     -------
-    y : bool ndarray or True
-        A bool array where ``np.nan`` positions are marked with ``False``
-        and other positions are marked with ``True``. If the type of ``a``
-        is such that it can't possibly contain ``np.nan``, returns ``True``.
+
+    
     """
     # we assume that a is an array for this private function
 
@@ -66,12 +65,11 @@
     return y
 
 def _replace_nan(a, val):
-    """
-    If `a` is of inexact type, make a copy of `a`, replace NaNs with
+    """If `a` is of inexact type, make a copy of `a`, replace NaNs with
     the `val` value, and return the copy together with a boolean mask
     marking the locations where NaNs were present. If `a` is not of
     inexact type, do nothing and return `a` together with a mask of None.
-
+    
     Note that scalars will end up as array scalars, which is important
     for using the result as the value of the out argument in some
     operations.
@@ -85,13 +83,8 @@
 
     Returns
     -------
-    y : ndarray
-        If `a` is of inexact type, return a copy of `a` with the NaNs
-        replaced by the fill value, otherwise return `a`.
-    mask: {bool, None}
-        If `a` is of inexact type, return a boolean mask marking locations of
-        NaNs, otherwise return None.
-
+
+    
     """
     a = np.asanyarray(a)
 
@@ -111,8 +104,7 @@
 
 
 def _copyto(a, val, mask):
-    """
-    Replace values in `a` with NaN where `mask` is True.  This differs from
+    """Replace values in `a` with NaN where `mask` is True.  This differs from
     copyto in that it will deal with the case where `a` is a numpy scalar.
 
     Parameters
@@ -128,9 +120,8 @@
 
     Returns
     -------
-    res : ndarray, scalar
-        Array with elements replaced or scalar `val`.
-
+
+    
     """
     if isinstance(a, np.ndarray):
         np.copyto(a, val, where=mask, casting='unsafe')
@@ -140,9 +131,8 @@
 
 
 def _remove_nan_1d(arr1d, overwrite_input=False):
-    """
-    Equivalent to arr1d[~arr1d.isnan()], but in a different order
-
+    """Equivalent to arr1d[~arr1d.isnan()], but in a different order
+    
     Presumably faster as it incurs fewer copies
 
     Parameters
@@ -150,15 +140,12 @@
     arr1d : ndarray
         Array to remove nans from
     overwrite_input : bool
-        True if `arr1d` can be modified in place
-
-    Returns
-    -------
-    res : ndarray
-        Array with nan elements removed
-    overwrite_input : bool
-        True if `res` can be modified in place, given the constraint on the
-        input
+        True if `arr1d` can be modified in place (Default value = False)
+
+    Returns
+    -------
+
+    
     """
 
     c = np.isnan(arr1d)
@@ -181,8 +168,7 @@
 
 
 def _divide_by_count(a, b, out=None):
-    """
-    Compute a/b ignoring invalid results. If `a` is an array the division
+    """Compute a/b ignoring invalid results. If `a` is an array the division
     is done in place. If `a` is a scalar, then its type is preserved in the
     output. If out is None, then then a is used instead so that the
     division is in place. Note that this is only called with `a` an inexact
@@ -201,10 +187,8 @@
 
     Returns
     -------
-    ret : {ndarray, numpy scalar}
-        The return value is a/b. If `a` was an ndarray the division is done
-        in place. If `a` is a numpy scalar, the division preserves its type.
-
+
+    
     """
     with np.errstate(invalid='ignore', divide='ignore'):
         if isinstance(a, np.ndarray):
@@ -222,13 +206,29 @@
 
 
 def _nanmin_dispatcher(a, axis=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanmin_dispatcher)
 def nanmin(a, axis=None, out=None, keepdims=np._NoValue):
-    """
-    Return minimum of an array or minimum along an axis, ignoring any NaNs.
+    """Return minimum of an array or minimum along an axis, ignoring any NaNs.
     When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
     Nan is returned for that slice.
 
@@ -245,18 +245,15 @@
         is ``None``; if provided, it must have the same shape as the
         expected output, but the type will be cast if necessary. See
         `ufuncs-output-type` for more details.
-
         .. versionadded:: 1.8.0
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
         If the value is anything but the default, then
         `keepdims` will be passed through to the `min` method
         of sub-classes of `ndarray`.  If the sub-classes methods
         does not implement `keepdims` any exceptions will be raised.
-
         .. versionadded:: 1.8.0
 
     Returns
@@ -280,20 +277,20 @@
         Shows which elements are Not a Number (NaN).
     isfinite:
         Shows which elements are neither NaN nor infinity.
-
+    
     amax, fmax, maximum
-
     Notes
     -----
     NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
     (IEEE 754). This means that Not a Number is not equivalent to infinity.
     Positive infinity is treated as a very large number and negative
     infinity is treated as a very small (i.e. negative) number.
-
+    
     If the input has a integer type the function is equivalent to np.min.
-
     Examples
     --------
+    
+    When positive infinity and negative infinity are present:
     >>> a = np.array([[1, 2], [3, np.nan]])
     >>> np.nanmin(a)
     1.0
@@ -301,14 +298,11 @@
     array([1.,  2.])
     >>> np.nanmin(a, axis=1)
     array([1.,  3.])
-
-    When positive infinity and negative infinity are present:
-
+    
     >>> np.nanmin([1, 2, np.nan, np.inf])
     1.0
     >>> np.nanmin([1, 2, np.nan, np.NINF])
     -inf
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -337,13 +331,29 @@
 
 
 def _nanmax_dispatcher(a, axis=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanmax_dispatcher)
 def nanmax(a, axis=None, out=None, keepdims=np._NoValue):
-    """
-    Return the maximum of an array or maximum along an axis, ignoring any
+    """Return the maximum of an array or maximum along an axis, ignoring any
     NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
     raised and NaN is returned for that slice.
 
@@ -360,18 +370,15 @@
         is ``None``; if provided, it must have the same shape as the
         expected output, but the type will be cast if necessary. See
         `ufuncs-output-type` for more details.
-
         .. versionadded:: 1.8.0
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
         If the value is anything but the default, then
         `keepdims` will be passed through to the `max` method
         of sub-classes of `ndarray`.  If the sub-classes methods
         does not implement `keepdims` any exceptions will be raised.
-
         .. versionadded:: 1.8.0
 
     Returns
@@ -395,20 +402,20 @@
         Shows which elements are Not a Number (NaN).
     isfinite:
         Shows which elements are neither NaN nor infinity.
-
+    
     amin, fmin, minimum
-
     Notes
     -----
     NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
     (IEEE 754). This means that Not a Number is not equivalent to infinity.
     Positive infinity is treated as a very large number and negative
     infinity is treated as a very small (i.e. negative) number.
-
+    
     If the input has a integer type the function is equivalent to np.max.
-
     Examples
     --------
+    
+    When positive infinity and negative infinity are present:
     >>> a = np.array([[1, 2], [3, np.nan]])
     >>> np.nanmax(a)
     3.0
@@ -416,14 +423,11 @@
     array([3.,  2.])
     >>> np.nanmax(a, axis=1)
     array([2.,  3.])
-
-    When positive infinity and negative infinity are present:
-
+    
     >>> np.nanmax([1, 2, np.nan, np.NINF])
     2.0
     >>> np.nanmax([1, 2, np.nan, np.inf])
     inf
-
     """
     kwargs = {}
     if keepdims is not np._NoValue:
@@ -452,13 +456,25 @@
 
 
 def _nanargmin_dispatcher(a, axis=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_nanargmin_dispatcher)
 def nanargmin(a, axis=None):
-    """
-    Return the indices of the minimum values in the specified axis ignoring
+    """Return the indices of the minimum values in the specified axis ignoring
     NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
     cannot be trusted if a slice contains only NaNs and Infs.
 
@@ -477,7 +493,6 @@
     See Also
     --------
     argmin, nanargmax
-
     Examples
     --------
     >>> a = np.array([[np.nan, 4], [2, 3]])
@@ -489,7 +504,6 @@
     array([1, 1])
     >>> np.nanargmin(a, axis=1)
     array([1, 0])
-
     """
     a, mask = _replace_nan(a, np.inf)
     res = np.argmin(a, axis=axis)
@@ -501,16 +515,27 @@
 
 
 def _nanargmax_dispatcher(a, axis=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_nanargmax_dispatcher)
 def nanargmax(a, axis=None):
-    """
-    Return the indices of the maximum values in the specified axis ignoring
+    """Return the indices of the maximum values in the specified axis ignoring
     NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
     results cannot be trusted if a slice contains only NaNs and -Infs.
-
 
     Parameters
     ----------
@@ -527,7 +552,6 @@
     See Also
     --------
     argmax, nanargmin
-
     Examples
     --------
     >>> a = np.array([[np.nan, 4], [2, 3]])
@@ -539,7 +563,6 @@
     array([1, 0])
     >>> np.nanargmax(a, axis=1)
     array([1, 1])
-
     """
     a, mask = _replace_nan(a, -np.inf)
     res = np.argmax(a, axis=axis)
@@ -551,15 +574,33 @@
 
 
 def _nansum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nansum_dispatcher)
 def nansum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):
-    """
-    Return the sum of array elements over a given axis treating Not a
+    """Return the sum of array elements over a given axis treating Not a
     Numbers (NaNs) as zero.
-
+    
     In NumPy versions <= 1.9.0 Nan is returned for slices that are all-NaN or
     empty. In later versions zero is returned.
 
@@ -578,7 +619,6 @@
         the platform (u)intp. In that case, the default will be either
         (u)int32 or (u)int64 depending on whether the platform is 32 or 64
         bits. For inexact inputs, dtype must be inexact.
-
         .. versionadded:: 1.8.0
     out : ndarray, optional
         Alternate output array in which to place the result.  The default
@@ -586,19 +626,15 @@
         expected output, but the type will be cast if necessary.  See
         `ufuncs-output-type` for more details. The casting of NaN to integer
         can yield unexpected results.
-
         .. versionadded:: 1.8.0
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
-
         If the value is anything but the default, then
         `keepdims` will be passed through to the `mean` or `sum` methods
         of sub-classes of `ndarray`.  If the sub-classes methods
         does not implement `keepdims` any exceptions will be raised.
-
         .. versionadded:: 1.8.0
 
     Returns
@@ -614,12 +650,10 @@
     numpy.sum : Sum across array propagating NaNs.
     isnan : Show which elements are NaN.
     isfinite: Show which elements are not NaN or +/-inf.
-
     Notes
     -----
     If both positive and negative infinity are present, the sum will be Not
     A Number (NaN).
-
     Examples
     --------
     >>> np.nansum(1)
@@ -642,24 +676,41 @@
     ...     sup.filter(RuntimeWarning)
     ...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
     nan
-
     """
     a, mask = _replace_nan(a, 0)
     return np.sum(a, axis=axis, dtype=dtype, out=out, keepdims=keepdims)
 
 
 def _nanprod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanprod_dispatcher)
 def nanprod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):
-    """
-    Return the product of array elements over a given axis treating Not a
+    """Return the product of array elements over a given axis treating Not a
     Numbers (NaNs) as ones.
-
+    
     One is returned for slices that are all-NaN or empty.
-
+    
     .. versionadded:: 1.10.0
 
     Parameters
@@ -686,7 +737,7 @@
     keepdims : bool, optional
         If True, the axes which are reduced are left in the result as
         dimensions with size one. With this option, the result will
-        broadcast correctly against the original `arr`.
+        broadcast correctly against the original `arr`. (Default value = np._NoValue)
 
     Returns
     -------
@@ -698,7 +749,6 @@
     --------
     numpy.prod : Product across array propagating NaNs.
     isnan : Show which elements are NaN.
-
     Examples
     --------
     >>> np.nanprod(1)
@@ -712,25 +762,40 @@
     6.0
     >>> np.nanprod(a, axis=0)
     array([3., 2.])
-
     """
     a, mask = _replace_nan(a, 1)
     return np.prod(a, axis=axis, dtype=dtype, out=out, keepdims=keepdims)
 
 
 def _nancumsum_dispatcher(a, axis=None, dtype=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nancumsum_dispatcher)
 def nancumsum(a, axis=None, dtype=None, out=None):
-    """
-    Return the cumulative sum of array elements over a given axis treating Not a
+    """Return the cumulative sum of array elements over a given axis treating Not a
     Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
     encountered and leading NaNs are replaced by zeros.
-
+    
     Zeros are returned for slices that are all-NaN or empty.
-
+    
     .. versionadded:: 1.12.0
 
     Parameters
@@ -750,7 +815,7 @@
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output
         but the type will be cast if necessary. See `ufuncs-output-type` for
-        more details.
+        more details. (Default value = None)
 
     Returns
     -------
@@ -764,7 +829,6 @@
     --------
     numpy.cumsum : Cumulative sum across array propagating NaNs.
     isnan : Show which elements are NaN.
-
     Examples
     --------
     >>> np.nancumsum(1)
@@ -782,25 +846,40 @@
     >>> np.nancumsum(a, axis=1)
     array([[1.,  3.],
            [3.,  3.]])
-
     """
     a, mask = _replace_nan(a, 0)
     return np.cumsum(a, axis=axis, dtype=dtype, out=out)
 
 
 def _nancumprod_dispatcher(a, axis=None, dtype=None, out=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nancumprod_dispatcher)
 def nancumprod(a, axis=None, dtype=None, out=None):
-    """
-    Return the cumulative product of array elements over a given axis treating Not a
+    """Return the cumulative product of array elements over a given axis treating Not a
     Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
     encountered and leading NaNs are replaced by ones.
-
+    
     Ones are returned for slices that are all-NaN or empty.
-
+    
     .. versionadded:: 1.12.0
 
     Parameters
@@ -819,7 +898,7 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output
-        but the type of the resulting values will be cast if necessary.
+        but the type of the resulting values will be cast if necessary. (Default value = None)
 
     Returns
     -------
@@ -831,7 +910,6 @@
     --------
     numpy.cumprod : Cumulative product across array propagating NaNs.
     isnan : Show which elements are NaN.
-
     Examples
     --------
     >>> np.nancumprod(1)
@@ -849,27 +927,44 @@
     >>> np.nancumprod(a, axis=1)
     array([[1.,  2.],
            [3.,  3.]])
-
     """
     a, mask = _replace_nan(a, 1)
     return np.cumprod(a, axis=axis, dtype=dtype, out=out)
 
 
 def _nanmean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanmean_dispatcher)
 def nanmean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):
-    """
-    Compute the arithmetic mean along the specified axis, ignoring NaNs.
-
+    """Compute the arithmetic mean along the specified axis, ignoring NaNs.
+    
     Returns the average of the array elements.  The average is taken over
     the flattened array by default, otherwise over the specified axis.
     `float64` intermediate and return values are used for integer inputs.
-
+    
     For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.
-
+    
     .. versionadded:: 1.8.0
 
     Parameters
@@ -893,7 +988,6 @@
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
         If the value is anything but the default, then
         `keepdims` will be passed through to the `mean` or `sum` methods
         of sub-classes of `ndarray`.  If the sub-classes methods
@@ -911,18 +1005,16 @@
     average : Weighted average
     mean : Arithmetic mean taken while not ignoring NaNs
     var, nanvar
-
     Notes
     -----
     The arithmetic mean is the sum of the non-NaN elements along the axis
     divided by the number of non-NaN elements.
-
+    
     Note that for floating-point input, the mean is computed using the same
     precision the input has.  Depending on the input data, this can cause
     the results to be inaccurate, especially for `float32`.  Specifying a
     higher-precision accumulator using the `dtype` keyword can alleviate
     this issue.
-
     Examples
     --------
     >>> a = np.array([[1, np.nan], [3, 4]])
@@ -932,7 +1024,6 @@
     array([2.,  4.])
     >>> np.nanmean(a, axis=1)
     array([1.,  3.5]) # may vary
-
     """
     arr, mask = _replace_nan(a, 0)
     if mask is None:
@@ -958,9 +1049,19 @@
 
 
 def _nanmedian1d(arr1d, overwrite_input=False):
-    """
-    Private function for rank 1 arrays. Compute the median ignoring NaNs.
+    """Private function for rank 1 arrays. Compute the median ignoring NaNs.
     See nanmedian for parameter usage
+
+    Parameters
+    ----------
+    arr1d :
+        
+    overwrite_input :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     arr1d, overwrite_input = _remove_nan_1d(arr1d,
                                             overwrite_input=overwrite_input)
@@ -971,10 +1072,23 @@
 
 
 def _nanmedian(a, axis=None, out=None, overwrite_input=False):
-    """
-    Private function that doesn't support extended axis or keepdims.
+    """Private function that doesn't support extended axis or keepdims.
     These methods are extended to this function using _ureduce
     See nanmedian for parameter usage
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = False)
+
+    Returns
+    -------
 
     """
     if axis is None or a.ndim == 1:
@@ -997,11 +1111,25 @@
 
 
 def _nanmedian_small(a, axis=None, out=None, overwrite_input=False):
-    """
-    sort + indexing median, faster for small medians along multiple
+    """sort + indexing median, faster for small medians along multiple
     dimensions due to the high overhead of apply_along_axis
-
+    
     see nanmedian for parameter usage
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     a = np.ma.masked_array(a, np.isnan(a))
     m = np.ma.median(a, axis=axis, overwrite_input=overwrite_input)
@@ -1016,16 +1144,34 @@
 
 def _nanmedian_dispatcher(
         a, axis=None, out=None, overwrite_input=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanmedian_dispatcher)
 def nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=np._NoValue):
-    """
-    Compute the median along the specified axis, while ignoring NaNs.
-
+    """Compute the median along the specified axis, while ignoring NaNs.
+    
     Returns the median of the array elements.
-
+    
     .. versionadded:: 1.9.0
 
     Parameters
@@ -1039,20 +1185,19 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output,
-        but the type (of the output) will be cast if necessary.
+        but the type (of the output) will be cast if necessary. (Default value = None)
     overwrite_input : bool, optional
-       If True, then allow use of memory of input array `a` for
-       calculations. The input array will be modified by the call to
-       `median`. This will save memory when you do not need to preserve
-       the contents of the input array. Treat the input as undefined,
-       but it will probably be fully or partially sorted. Default is
-       False. If `overwrite_input` is ``True`` and `a` is not already an
-       `ndarray`, an error will be raised.
+        If True, then allow use of memory of input array `a` for
+        calculations. The input array will be modified by the call to
+        `median`. This will save memory when you do not need to preserve
+        the contents of the input array. Treat the input as undefined,
+        but it will probably be fully or partially sorted. Default is
+        False. If `overwrite_input` is ``True`` and `a` is not already an
+        `ndarray`, an error will be raised.
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
         If this is anything but the default value it will be passed
         through (in the special case of an empty array) to the
         `mean` function of the underlying array.  If the array is
@@ -1071,14 +1216,12 @@
     See Also
     --------
     mean, median, percentile
-
     Notes
     -----
     Given a vector ``V`` of length ``N``, the median of ``V`` is the
     middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,
     ``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two
     middle values of ``V_sorted`` when ``N`` is even.
-
     Examples
     --------
     >>> a = np.array([[10.0, 7, 4], [3, 2, 1]])
@@ -1102,7 +1245,6 @@
     >>> np.nanmedian(b, axis=None, overwrite_input=True)
     3.0
     >>> assert not np.all(a==b)
-
     """
     a = np.asanyarray(a)
     # apply_along_axis in _nanmedian doesn't handle empty arrays well,
@@ -1120,18 +1262,40 @@
 
 def _nanpercentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
                               interpolation=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    q :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = None)
+    interpolation :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, q, out)
 
 
 @array_function_dispatch(_nanpercentile_dispatcher)
 def nanpercentile(a, q, axis=None, out=None, overwrite_input=False,
                   interpolation='linear', keepdims=np._NoValue):
-    """
-    Compute the qth percentile of the data along the specified axis,
+    """Compute the qth percentile of the data along the specified axis,
     while ignoring nan values.
-
+    
     Returns the qth percentile(s) of the array elements.
-
+    
     .. versionadded:: 1.9.0
 
     Parameters
@@ -1149,28 +1313,26 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output,
-        but the type (of the output) will be cast if necessary.
+        but the type (of the output) will be cast if necessary. (Default value = None)
     overwrite_input : bool, optional
         If True, then allow the input array `a` to be modified by intermediate
         calculations, to save memory. In this case, the contents of the input
-        `a` after this function completes is undefined.
+        `a` after this function completes is undefined. (Default value = False)
     interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
         This optional parameter specifies the interpolation method to
         use when the desired percentile lies between two data points
         ``i < j``:
-
         * 'linear': ``i + (j - i) * fraction``, where ``fraction``
-          is the fractional part of the index surrounded by ``i``
-          and ``j``.
+        is the fractional part of the index surrounded by ``i``
+        and ``j``.
         * 'lower': ``i``.
         * 'higher': ``j``.
         * 'nearest': ``i`` or ``j``, whichever is nearest.
-        * 'midpoint': ``(i + j) / 2``.
+        * 'midpoint': ``(i + j) / 2``. (Default value = 'linear')
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left in
         the result as dimensions with size one. With this option, the
         result will broadcast correctly against the original array `a`.
-
         If this is anything but the default value it will be passed
         through (in the special case of an empty array) to the
         `mean` function of the underlying array.  If the array is
@@ -1195,7 +1357,6 @@
     nanmedian : equivalent to ``nanpercentile(..., 50)``
     percentile, median, mean
     nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].
-
     Notes
     -----
     Given a vector ``V`` of length ``N``, the ``q``-th percentile of
@@ -1206,7 +1367,6 @@
     match the location of ``q`` exactly. This function is the same as
     the median if ``q=50``, the same as the minimum if ``q=0`` and the
     same as the maximum if ``q=100``.
-
     Examples
     --------
     >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
@@ -1229,12 +1389,11 @@
     array([6.5, 2. , 2.5])
     >>> m
     array([6.5,  2. ,  2.5])
-
+    
     >>> b = a.copy()
     >>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)
     array([7., 2.])
     >>> assert not np.all(a==b)
-
     """
     a = np.asanyarray(a)
     q = np.true_divide(q, 100.0)  # handles the asarray for us too
@@ -1246,14 +1405,36 @@
 
 def _nanquantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
                             interpolation=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    q :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = None)
+    interpolation :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, q, out)
 
 
 @array_function_dispatch(_nanquantile_dispatcher)
 def nanquantile(a, q, axis=None, out=None, overwrite_input=False,
                 interpolation='linear', keepdims=np._NoValue):
-    """
-    Compute the qth quantile of the data along the specified axis,
+    """Compute the qth quantile of the data along the specified axis,
     while ignoring nan values.
     Returns the qth quantile(s) of the array elements.
     
@@ -1274,29 +1455,26 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must
         have the same shape and buffer length as the expected output,
-        but the type (of the output) will be cast if necessary.
+        but the type (of the output) will be cast if necessary. (Default value = None)
     overwrite_input : bool, optional
         If True, then allow the input array `a` to be modified by intermediate
         calculations, to save memory. In this case, the contents of the input
-        `a` after this function completes is undefined.
+        `a` after this function completes is undefined. (Default value = False)
     interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
         This optional parameter specifies the interpolation method to
         use when the desired quantile lies between two data points
         ``i < j``:
-
         * linear: ``i + (j - i) * fraction``, where ``fraction``
-          is the fractional part of the index surrounded by ``i``
-          and ``j``.
+        is the fractional part of the index surrounded by ``i``
+        and ``j``.
         * lower: ``i``.
         * higher: ``j``.
         * nearest: ``i`` or ``j``, whichever is nearest.
-        * midpoint: ``(i + j) / 2``.
-
+        * midpoint: ``(i + j) / 2``. (Default value = 'linear')
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left in
         the result as dimensions with size one. With this option, the
         result will broadcast correctly against the original array `a`.
-
         If this is anything but the default value it will be passed
         through (in the special case of an empty array) to the
         `mean` function of the underlying array.  If the array is
@@ -1321,7 +1499,6 @@
     nanmean, nanmedian
     nanmedian : equivalent to ``nanquantile(..., 0.5)``
     nanpercentile : same as nanquantile, but with q in the range [0, 100].
-
     Examples
     --------
     >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
@@ -1359,7 +1536,29 @@
 
 def _nanquantile_unchecked(a, q, axis=None, out=None, overwrite_input=False,
                            interpolation='linear', keepdims=np._NoValue):
-    """Assumes that q is in [0, 1], and is an ndarray"""
+    """Assumes that q is in [0, 1], and is an ndarray
+
+    Parameters
+    ----------
+    a :
+        
+    q :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = False)
+    interpolation :
+         (Default value = 'linear')
+    keepdims :
+         (Default value = np._NoValue)
+
+    Returns
+    -------
+
+    """
     # apply_along_axis in _nanpercentile doesn't handle empty arrays well,
     # so deal them upfront
     if a.size == 0:
@@ -1377,10 +1576,28 @@
 
 def _nanquantile_ureduce_func(a, q, axis=None, out=None, overwrite_input=False,
                               interpolation='linear'):
-    """
-    Private function that doesn't support extended axis or keepdims.
+    """Private function that doesn't support extended axis or keepdims.
     These methods are extended to this function using _ureduce
     See nanpercentile for parameter usage
+
+    Parameters
+    ----------
+    a :
+        
+    q :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+    overwrite_input :
+         (Default value = False)
+    interpolation :
+         (Default value = 'linear')
+
+    Returns
+    -------
+
     """
     if axis is None or a.ndim == 1:
         part = a.ravel()
@@ -1400,9 +1617,23 @@
 
 
 def _nanquantile_1d(arr1d, q, overwrite_input=False, interpolation='linear'):
-    """
-    Private function for rank 1 arrays. Compute quantile ignoring NaNs.
+    """Private function for rank 1 arrays. Compute quantile ignoring NaNs.
     See nanpercentile for parameter usage
+
+    Parameters
+    ----------
+    arr1d :
+        
+    q :
+        
+    overwrite_input :
+         (Default value = False)
+    interpolation :
+         (Default value = 'linear')
+
+    Returns
+    -------
+
     """
     arr1d, overwrite_input = _remove_nan_1d(arr1d,
         overwrite_input=overwrite_input)
@@ -1415,21 +1646,41 @@
 
 def _nanvar_dispatcher(
         a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    ddof :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanvar_dispatcher)
 def nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
-    """
-    Compute the variance along the specified axis, while ignoring NaNs.
-
+    """Compute the variance along the specified axis, while ignoring NaNs.
+    
     Returns the variance of the array elements, a measure of the spread of
     a distribution.  The variance is computed for the flattened array by
     default, otherwise over the specified axis.
-
+    
     For all-NaN slices or slices with zero degrees of freedom, NaN is
     returned and a `RuntimeWarning` is raised.
-
+    
     .. versionadded:: 1.8.0
 
     Parameters
@@ -1447,7 +1698,7 @@
     out : ndarray, optional
         Alternate output array in which to place the result.  It must have
         the same shape as the expected output, but the type is cast if
-        necessary.
+        necessary. (Default value = None)
     ddof : int, optional
         "Delta Degrees of Freedom": the divisor used in the calculation is
         ``N - ddof``, where ``N`` represents the number of non-NaN
@@ -1455,8 +1706,7 @@
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
-        the result will broadcast correctly against the original `a`.
-
+        the result will broadcast correctly against the original `a`. (Default value = np._NoValue)
 
     Returns
     -------
@@ -1473,31 +1723,29 @@
     var : Variance while not ignoring NaNs
     nanstd, nanmean
     ufuncs-output-type
-
     Notes
     -----
     The variance is the average of the squared deviations from the mean,
     i.e.,  ``var = mean(abs(x - x.mean())**2)``.
-
+    
     The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
     If, however, `ddof` is specified, the divisor ``N - ddof`` is used
     instead.  In standard statistical practice, ``ddof=1`` provides an
     unbiased estimator of the variance of a hypothetical infinite
     population.  ``ddof=0`` provides a maximum likelihood estimate of the
     variance for normally distributed variables.
-
+    
     Note that for complex numbers, the absolute value is taken before
     squaring, so that the result is always real and nonnegative.
-
+    
     For floating-point input, the variance is computed using the same
     precision the input has.  Depending on the input data, this can cause
     the results to be inaccurate, especially for `float32` (see example
     below).  Specifying a higher-accuracy accumulator using the ``dtype``
     keyword can alleviate this issue.
-
+    
     For this function to work on sub-classes of ndarray, they must define
     `sum` with the kwarg `keepdims`
-
     Examples
     --------
     >>> a = np.array([[1, np.nan], [3, 4]])
@@ -1507,7 +1755,6 @@
     array([1.,  0.])
     >>> np.nanvar(a, axis=1)
     array([0.,  0.25])  # may vary
-
     """
     arr, mask = _replace_nan(a, 0)
     if mask is None:
@@ -1563,23 +1810,43 @@
 
 def _nanstd_dispatcher(
         a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    axis :
+         (Default value = None)
+    dtype :
+         (Default value = None)
+    out :
+         (Default value = None)
+    ddof :
+         (Default value = None)
+    keepdims :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a, out)
 
 
 @array_function_dispatch(_nanstd_dispatcher)
 def nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
-    """
-    Compute the standard deviation along the specified axis, while
+    """Compute the standard deviation along the specified axis, while
     ignoring NaNs.
-
+    
     Returns the standard deviation, a measure of the spread of a
     distribution, of the non-NaN array elements. The standard deviation is
     computed for the flattened array by default, otherwise over the
     specified axis.
-
+    
     For all-NaN slices or slices with zero degrees of freedom, NaN is
     returned and a `RuntimeWarning` is raised.
-
+    
     .. versionadded:: 1.8.0
 
     Parameters
@@ -1596,17 +1863,15 @@
     out : ndarray, optional
         Alternative output array in which to place the result. It must have
         the same shape as the expected output but the type (of the
-        calculated values) will be cast if necessary.
+        calculated values) will be cast if necessary. (Default value = None)
     ddof : int, optional
         Means Delta Degrees of Freedom.  The divisor used in calculations
         is ``N - ddof``, where ``N`` represents the number of non-NaN
         elements.  By default `ddof` is zero.
-
     keepdims : bool, optional
         If this is set to True, the axes which are reduced are left
         in the result as dimensions with size one. With this option,
         the result will broadcast correctly against the original `a`.
-
         If this value is anything but the default it is passed through
         as-is to the relevant functions of the sub-classes.  If these
         functions do not have a `keepdims` kwarg, a RuntimeError will
@@ -1625,12 +1890,11 @@
     var, mean, std
     nanvar, nanmean
     ufuncs-output-type
-
     Notes
     -----
     The standard deviation is the square root of the average of the squared
     deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.
-
+    
     The average squared deviation is normally calculated as
     ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
     specified, the divisor ``N - ddof`` is used instead. In standard
@@ -1640,16 +1904,15 @@
     The standard deviation computed in this function is the square root of
     the estimated variance, so even with ``ddof=1``, it will not be an
     unbiased estimate of the standard deviation per se.
-
+    
     Note that, for complex numbers, `std` takes the absolute value before
     squaring, so that the result is always real and nonnegative.
-
+    
     For floating-point input, the *std* is computed using the same
     precision the input has. Depending on the input data, this can cause
     the results to be inaccurate, especially for float32 (see example
     below).  Specifying a higher-accuracy accumulator using the `dtype`
     keyword can alleviate this issue.
-
     Examples
     --------
     >>> a = np.array([[1, np.nan], [3, 4]])
@@ -1659,7 +1922,6 @@
     array([1., 0.])
     >>> np.nanstd(a, axis=1)
     array([0.,  0.5]) # may vary
-
     """
     var = nanvar(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
                  keepdims=keepdims)
