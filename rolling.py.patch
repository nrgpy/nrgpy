# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/window/rolling.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/window/rolling.py
@@ -57,17 +57,17 @@
 
 
 def calculate_center_offset(window) -> int:
-    """
-    Calculate an offset necessary to have the window label to be centered.
+    """Calculate an offset necessary to have the window label to be centered.
 
     Parameters
     ----------
-    window: ndarray or int
+    window : ndarray or int
         window weights or window
 
     Returns
     -------
-    int
+
+    
     """
     if not is_integer(window):
         window = len(window)
@@ -81,20 +81,35 @@
     required_min_periods: int,
     floor: int,
 ) -> int:
-    """
-    Calculate final minimum periods value for rolling aggregations.
+    """Calculate final minimum periods value for rolling aggregations.
 
     Parameters
     ----------
     window : passed window value
+        
     min_periods : passed min periods value
+        
     num_values : total number of values
+        
     required_min_periods : required min periods per aggregation function
+        
     floor : required min periods per aggregation function
+        
+    window: int :
+        
+    min_periods: Optional[int] :
+        
+    num_values: int :
+        
+    required_min_periods: int :
+        
+    floor: int :
+        
 
     Returns
     -------
-    min_periods : int
+
+    
     """
     if min_periods is None:
         min_periods = window
@@ -110,20 +125,37 @@
 
 
 def get_weighted_roll_func(cfunc: Callable) -> Callable:
-    """
-    Wrap weighted rolling cython function with min periods argument.
+    """Wrap weighted rolling cython function with min periods argument.
 
     Parameters
     ----------
     cfunc : function
         Cython weighted rolling function
+    cfunc: Callable :
+        
 
     Returns
     -------
-    function
+
+    
     """
 
     def func(arg, window, min_periods=None):
+        """
+
+        Parameters
+        ----------
+        arg :
+            
+        window :
+            
+        min_periods :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if min_periods is None:
             min_periods = len(window)
         return cfunc(arg, window, min_periods)
@@ -132,6 +164,7 @@
 
 
 class _Window(PandasObject, ShallowMixin, SelectionMixin):
+    """ """
     _attributes: List[str] = [
         "window",
         "min_periods",
@@ -170,21 +203,26 @@
 
     @property
     def _constructor(self):
+        """ """
         return Window
 
     @property
     def is_datetimelike(self) -> Optional[bool]:
+        """ """
         return None
 
     @property
     def _on(self):
+        """ """
         return None
 
     @property
     def is_freq_type(self) -> bool:
+        """ """
         return self.win_type == "freq"
 
     def validate(self) -> None:
+        """ """
         if self.center is not None and not is_bool(self.center):
             raise ValueError("center must be a boolean")
         if self.min_periods is not None and not is_integer(self.min_periods):
@@ -203,9 +241,17 @@
 
     @staticmethod
     def _validate_get_window_bounds_signature(window: BaseIndexer) -> None:
-        """
-        Validate that the passed BaseIndexer subclass has
+        """Validate that the passed BaseIndexer subclass has
         a get_window_bounds with the correct signature.
+
+        Parameters
+        ----------
+        window: BaseIndexer :
+            
+
+        Returns
+        -------
+
         """
         get_window_bounds_signature = inspect.signature(
             window.get_window_bounds
@@ -220,8 +266,16 @@
             )
 
     def _create_blocks(self, obj: FrameOrSeries):
-        """
-        Split data into blocks & return conformed data.
+        """Split data into blocks & return conformed data.
+
+        Parameters
+        ----------
+        obj: FrameOrSeries :
+            
+
+        Returns
+        -------
+
         """
         # filter out the on from the object
         if self.on is not None and not isinstance(self.on, Index):
@@ -232,16 +286,21 @@
         return blocks, obj
 
     def _gotitem(self, key, ndim, subset=None):
-        """
-        Sub-classes to define. Return a sliced object.
-
-        Parameters
-        ----------
-        key : str / list of selections
-        ndim : 1,2
-            requested ndim of result
-        subset : object, default None
-            subset to act on
+        """Sub-classes to define. Return a sliced object.
+
+        Parameters
+        ----------
+        key :
+            
+        ndim :
+            
+        subset :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         # create a new object to prevent aliasing
         if subset is None:
@@ -264,37 +323,42 @@
         )
 
     def _dir_additions(self):
+        """ """
         return self.obj._dir_additions()
 
     def _get_win_type(self, kwargs: Dict):
-        """
-        Exists for compatibility, overridden by subclass Window.
+        """Exists for compatibility, overridden by subclass Window.
 
         Parameters
         ----------
         kwargs : dict
             ignored, exists for compatibility
-
-        Returns
-        -------
-        None
+        kwargs: Dict :
+            
+
+        Returns
+        -------
+
+        
         """
         return None
 
     def _get_window(self, other=None, win_type: Optional[str] = None) -> int:
-        """
-        Return window length.
+        """Return window length.
 
         Parameters
         ----------
         other :
-            ignored, exists for compatibility
+            ignored, exists for compatibility (Default value = None)
         win_type :
             ignored, exists for compatibility
-
-        Returns
-        -------
-        window : int
+        win_type: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if isinstance(self.window, BaseIndexer):
             return self.min_periods or 0
@@ -302,6 +366,7 @@
 
     @property
     def _window_type(self) -> str:
+        """ """
         return type(self).__name__
 
     def __repr__(self) -> str:
@@ -335,7 +400,17 @@
             yield result
 
     def _prep_values(self, values: Optional[np.ndarray] = None) -> np.ndarray:
-        """Convert input to numpy arrays for Cython routines"""
+        """Convert input to numpy arrays for Cython routines
+
+        Parameters
+        ----------
+        values: Optional[np.ndarray] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if values is None:
             values = extract_array(self._selected_obj, extract_numpy=True)
 
@@ -364,8 +439,20 @@
         return values
 
     def _wrap_result(self, result, block=None, obj=None):
-        """
-        Wrap a single result.
+        """Wrap a single result.
+
+        Parameters
+        ----------
+        result :
+            
+        block :
+             (Default value = None)
+        obj :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if obj is None:
             obj = self._selected_obj
@@ -382,15 +469,23 @@
         return result
 
     def _wrap_results(self, results, blocks, obj, exclude=None) -> FrameOrSeries:
-        """
-        Wrap the results.
-
-        Parameters
-        ----------
-        results : list of ndarrays
-        blocks : list of blocks
-        obj : conformed data (may be resampled)
-        exclude: list of columns to exclude, default to None
+        """Wrap the results.
+
+        Parameters
+        ----------
+        results :
+            
+        blocks :
+            
+        obj :
+            
+        exclude :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         from pandas import Series, concat
 
@@ -434,8 +529,18 @@
         return concat(final, axis=1).reindex(columns=columns, copy=False)
 
     def _center_window(self, result, window) -> np.ndarray:
-        """
-        Center the result in the window.
+        """Center the result in the window.
+
+        Parameters
+        ----------
+        result :
+            
+        window :
+            
+
+        Returns
+        -------
+
         """
         if self.axis > result.ndim - 1:
             raise ValueError("Requested axis is larger then no. of argument dimensions")
@@ -448,17 +553,19 @@
         return result
 
     def _get_roll_func(self, func_name: str) -> Callable:
-        """
-        Wrap rolling function to check values passed.
+        """Wrap rolling function to check values passed.
 
         Parameters
         ----------
         func_name : str
             Cython function used to calculate rolling statistics
-
-        Returns
-        -------
-        func : callable
+        func_name: str :
+            
+
+        Returns
+        -------
+
+        
         """
         window_func = getattr(window_aggregations, func_name, None)
         if window_func is None:
@@ -469,9 +576,17 @@
 
     def _get_cython_func_type(self, func: str) -> Callable:
         """
-        Return a variable or fixed cython function type.
-
-        Variable algorithms do not use window while fixed do.
+
+        Parameters
+        ----------
+        func: str :
+            
+
+        Returns
+        -------
+        type
+            Variable algorithms do not use window while fixed do.
+
         """
         if self.is_freq_type or isinstance(self.window, BaseIndexer):
             return self._get_roll_func(f"{func}_variable")
@@ -479,7 +594,17 @@
 
     def _get_window_indexer(self, window: int) -> BaseIndexer:
         """
-        Return an indexer class that will compute the window start and end bounds
+
+        Parameters
+        ----------
+        window: int :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         if isinstance(self.window, BaseIndexer):
             return self.window
@@ -498,29 +623,48 @@
         use_numba_cache: bool = False,
         **kwargs,
     ):
-        """
-        Rolling statistical measure using supplied function.
-
+        """Rolling statistical measure using supplied function.
+        
         Designed to be used with passed-in Cython array-based functions.
 
         Parameters
         ----------
         func : callable function to apply
+            
         center : bool
+            
         require_min_periods : int
+            
         floor : int
+            
         is_weighted : bool
+            
         name : str,
             compatibility with groupby.rolling
         use_numba_cache : bool
             whether to cache a numba compiled function. Only available for numba
             enabled methods (so far only apply)
-        **kwargs
+        **kwargs :
             additional arguments for rolling function and window function
-
-        Returns
-        -------
-        y : type of input
+        func: Callable :
+            
+        center: bool :
+            
+        require_min_periods: int :
+             (Default value = 0)
+        floor: int :
+             (Default value = 1)
+        is_weighted: bool :
+             (Default value = False)
+        name: Optional[str] :
+             (Default value = None)
+        use_numba_cache: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         win_type = self._get_win_type(kwargs)
         window = self._get_window(win_type=win_type)
@@ -554,6 +698,17 @@
             if not is_weighted:
 
                 def calc(x):
+                    """
+
+                    Parameters
+                    ----------
+                    x :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     x = np.concatenate((x, additional_nans))
                     if not isinstance(self.window, BaseIndexer):
                         min_periods = calculate_min_periods(
@@ -578,6 +733,17 @@
             else:
 
                 def calc(x):
+                    """
+
+                    Parameters
+                    ----------
+                    x :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     x = np.concatenate((x, additional_nans))
                     return func(x, window, self.min_periods)
 
@@ -599,6 +765,21 @@
         return self._wrap_results(results, block_list, obj, exclude)
 
     def aggregate(self, func, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         result, how = self._aggregate(func, *args, **kwargs)
         if result is None:
             return self.apply(func, raw=False, args=args, kwargs=kwargs)
@@ -851,19 +1032,16 @@
 
 
 class Window(_Window):
-    """
-    Provide rolling window calculations.
+    """Provide rolling window calculations.
 
     Parameters
     ----------
     window : int, offset, or BaseIndexer subclass
         Size of the moving window. This is the number of observations used for
         calculating the statistic. Each window will be a fixed size.
-
         If its an offset then this will be the time period of each window. Each
         window will be a variable sized based on the observations included in
         the time-period. This is only valid for datetimelike indexes.
-
         If a BaseIndexer subclass is passed, calculates the window boundaries
         based on the defined ``get_window_bounds`` method. Additional rolling
         keyword arguments, namely `min_periods`, `center`, and
@@ -884,6 +1062,7 @@
         Provided integer column is ignored and excluded from result since
         an integer index is not used to calculate the rolling window.
     axis : int or str, default 0
+        
     closed : str, default None
         Make the interval closed on the 'right', 'left', 'both' or
         'neither' endpoints.
@@ -894,22 +1073,22 @@
     Returns
     -------
     a Window or Rolling sub-classed for the particular operation
+        
 
     See Also
     --------
     expanding : Provides expanding transformations.
     ewm : Provides exponential weighted functions.
-
     Notes
     -----
     By default, the result is set to the right edge of the window. This can be
     changed to the center of the window by setting ``center=True``.
-
+    
     To learn more about the offsets & frequency strings, please see `this link
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.
-
+    
     The recognized win_types are:
-
+    
     * ``boxcar``
     * ``triang``
     * ``blackman``
@@ -925,16 +1104,41 @@
     * ``general_gaussian`` (needs parameters: power, width)
     * ``slepian`` (needs parameter: width)
     * ``exponential`` (needs parameter: tau), center is set to None.
-
+    
     If ``win_type=None`` all points are evenly weighted. To learn more about
     different window types see `scipy.signal window functions
     <https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions>`__.
-
+    
     Certain window types require additional parameters to be passed. Please see
     the third example below on how to add the additional parameters.
-
     Examples
     --------
+    
+    Rolling sum with a window length of 2, using the 'triang'
+    window type.
+    
+    
+    Rolling sum with a window length of 2, using the 'gaussian'
+    window type (note how we need to specify std).
+    
+    
+    Rolling sum with a window length of 2, min_periods defaults
+    to the window length.
+    
+    
+    Same as above, but explicitly set the min_periods
+    
+    
+    Same as above, but with forward-looking windows
+    
+    
+    A ragged (meaning not-a-regular frequency), time-indexed DataFrame
+    
+    
+    
+    Contrasting to an integer rolling window, this will roll a variable
+    length window corresponding to the time period.
+    The default for min_periods is 1.
     >>> df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]})
     >>> df
          B
@@ -943,10 +1147,7 @@
     2  2.0
     3  NaN
     4  4.0
-
-    Rolling sum with a window length of 2, using the 'triang'
-    window type.
-
+    
     >>> df.rolling(2, win_type='triang').sum()
          B
     0  NaN
@@ -954,10 +1155,7 @@
     2  1.5
     3  NaN
     4  NaN
-
-    Rolling sum with a window length of 2, using the 'gaussian'
-    window type (note how we need to specify std).
-
+    
     >>> df.rolling(2, win_type='gaussian').sum(std=3)
               B
     0       NaN
@@ -965,10 +1163,7 @@
     2  2.958621
     3       NaN
     4       NaN
-
-    Rolling sum with a window length of 2, min_periods defaults
-    to the window length.
-
+    
     >>> df.rolling(2).sum()
          B
     0  NaN
@@ -976,9 +1171,7 @@
     2  3.0
     3  NaN
     4  NaN
-
-    Same as above, but explicitly set the min_periods
-
+    
     >>> df.rolling(2, min_periods=1).sum()
          B
     0  0.0
@@ -986,9 +1179,7 @@
     2  3.0
     3  2.0
     4  4.0
-
-    Same as above, but with forward-looking windows
-
+    
     >>> indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=2)
     >>> df.rolling(window=indexer, min_periods=1).sum()
          B
@@ -997,16 +1188,14 @@
     2  2.0
     3  4.0
     4  4.0
-
-    A ragged (meaning not-a-regular frequency), time-indexed DataFrame
-
+    
     >>> df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]},
     ...                   index = [pd.Timestamp('20130101 09:00:00'),
     ...                            pd.Timestamp('20130101 09:00:02'),
     ...                            pd.Timestamp('20130101 09:00:03'),
     ...                            pd.Timestamp('20130101 09:00:05'),
     ...                            pd.Timestamp('20130101 09:00:06')])
-
+    
     >>> df
                            B
     2013-01-01 09:00:00  0.0
@@ -1014,11 +1203,7 @@
     2013-01-01 09:00:03  2.0
     2013-01-01 09:00:05  NaN
     2013-01-01 09:00:06  4.0
-
-    Contrasting to an integer rolling window, this will roll a variable
-    length window corresponding to the time period.
-    The default for min_periods is 1.
-
+    
     >>> df.rolling('2s').sum()
                            B
     2013-01-01 09:00:00  0.0
@@ -1029,6 +1214,7 @@
     """
 
     def validate(self):
+        """ """
         super().validate()
 
         window = self.window
@@ -1054,20 +1240,36 @@
             raise ValueError(f"Invalid window {window}")
 
     def _get_win_type(self, kwargs: Dict) -> Union[str, Tuple]:
-        """
-        Extract arguments for the window type, provide validation for it
+        """Extract arguments for the window type, provide validation for it
         and return the validated window type.
 
         Parameters
         ----------
         kwargs : dict
-
-        Returns
-        -------
-        win_type : str, or tuple
+            
+        kwargs: Dict :
+            
+
+        Returns
+        -------
+
+        
         """
         # the below may pop from kwargs
         def _validate_win_type(win_type, kwargs):
+            """
+
+            Parameters
+            ----------
+            win_type :
+                
+            kwargs :
+                
+
+            Returns
+            -------
+
+            """
             arg_map = {
                 "kaiser": ["beta"],
                 "gaussian": ["std"],
@@ -1088,6 +1290,21 @@
             return win_type
 
         def _pop_args(win_type, arg_names, kwargs):
+            """
+
+            Parameters
+            ----------
+            win_type :
+                
+            arg_names :
+                
+            kwargs :
+                
+
+            Returns
+            -------
+
+            """
             all_args = []
             for n in arg_names:
                 if n not in kwargs:
@@ -1100,20 +1317,23 @@
     def _get_window(
         self, other=None, win_type: Optional[Union[str, Tuple]] = None
     ) -> np.ndarray:
-        """
-        Get the window, weights.
+        """Get the window, weights.
 
         Parameters
         ----------
         other :
-            ignored, exists for compatibility
+            ignored, exists for compatibility (Default value = None)
         win_type : str, or tuple
             type of window to create
-
-        Returns
-        -------
-        window : ndarray
-            the window, weights
+        win_type: Optional[Union[str :
+            
+        Tuple]] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         window = self.window
         if isinstance(window, (list, tuple, np.ndarray)):
@@ -1161,6 +1381,21 @@
         axis="",
     )
     def aggregate(self, func, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         result, how = self._aggregate(func, *args, **kwargs)
         if result is None:
 
@@ -1174,6 +1409,19 @@
     @Substitution(name="window")
     @Appender(_shared_docs["sum"])
     def sum(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("sum", args, kwargs)
         window_func = self._get_roll_func("roll_weighted_sum")
         window_func = get_weighted_roll_func(window_func)
@@ -1184,6 +1432,19 @@
     @Substitution(name="window")
     @Appender(_shared_docs["mean"])
     def mean(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("mean", args, kwargs)
         window_func = self._get_roll_func("roll_weighted_mean")
         window_func = get_weighted_roll_func(window_func)
@@ -1194,6 +1455,21 @@
     @Substitution(name="window", versionadded="\n.. versionadded:: 1.0.0\n")
     @Appender(_shared_docs["var"])
     def var(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("var", args, kwargs)
         window_func = partial(self._get_roll_func("roll_weighted_var"), ddof=ddof)
         window_func = get_weighted_roll_func(window_func)
@@ -1205,17 +1481,35 @@
     @Substitution(name="window", versionadded="\n.. versionadded:: 1.0.0\n")
     @Appender(_shared_docs["std"])
     def std(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("std", args, kwargs)
         return zsqrt(self.var(ddof=ddof, name="std", **kwargs))
 
 
 class _Rolling(_Window):
+    """ """
     @property
     def _constructor(self):
+        """ """
         return Rolling
 
 
 class _Rolling_and_Expanding(_Rolling):
+    """ """
 
     _shared_docs["count"] = dedent(
         r"""
@@ -1258,6 +1552,7 @@
     )
 
     def count(self):
+        """ """
         # GH 32865. Using count with custom BaseIndexer subclass
         # implementations shouldn't end up here
         assert not isinstance(self.window, BaseIndexer)
@@ -1349,6 +1644,27 @@
         args: Optional[Tuple] = None,
         kwargs: Optional[Dict] = None,
     ):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        raw: bool :
+             (Default value = False)
+        engine: Optional[str] :
+             (Default value = None)
+        engine_kwargs: Optional[Dict] :
+             (Default value = None)
+        args: Optional[Tuple] :
+             (Default value = None)
+        kwargs: Optional[Dict] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if args is None:
             args = ()
         if kwargs is None:
@@ -1398,6 +1714,25 @@
         )
 
     def _generate_cython_apply_func(self, args, kwargs, raw, offset, func):
+        """
+
+        Parameters
+        ----------
+        args :
+            
+        kwargs :
+            
+        raw :
+            
+        offset :
+            
+        func :
+            
+
+        Returns
+        -------
+
+        """
         from pandas import Series
 
         window_func = partial(
@@ -1410,6 +1745,25 @@
         )
 
         def apply_func(values, begin, end, min_periods, raw=raw):
+            """
+
+            Parameters
+            ----------
+            values :
+                
+            begin :
+                
+            end :
+                
+            min_periods :
+                
+            raw :
+                 (Default value = raw)
+
+            Returns
+            -------
+
+            """
             if not raw:
                 values = Series(values, index=self.obj.index)
             return window_func(values, begin, end, min_periods)
@@ -1417,6 +1771,19 @@
         return apply_func
 
     def sum(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("sum", args, kwargs)
         window_func = self._get_cython_func_type("roll_sum")
         kwargs.pop("floor", None)
@@ -1436,6 +1803,19 @@
     )
 
     def max(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("max", args, kwargs)
         window_func = self._get_cython_func_type("roll_max")
         return self._apply(window_func, center=self.center, name="max", **kwargs)
@@ -1478,11 +1858,37 @@
     )
 
     def min(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("min", args, kwargs)
         window_func = self._get_cython_func_type("roll_min")
         return self._apply(window_func, center=self.center, name="min", **kwargs)
 
     def mean(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("mean", args, kwargs)
         window_func = self._get_cython_func_type("roll_mean")
         return self._apply(window_func, center=self.center, name="mean", **kwargs)
@@ -1525,17 +1931,60 @@
     )
 
     def median(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         window_func = self._get_roll_func("roll_median_c")
         # GH 32865. Move max window size calculation to
         # the median function implementation
         return self._apply(window_func, center=self.center, name="median", **kwargs)
 
     def std(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("std", args, kwargs)
         kwargs.pop("require_min_periods", None)
         window_func = self._get_cython_func_type("roll_var")
 
         def zsqrt_func(values, begin, end, min_periods):
+            """
+
+            Parameters
+            ----------
+            values :
+                
+            begin :
+                
+            end :
+                
+            min_periods :
+                
+
+            Returns
+            -------
+
+            """
             return zsqrt(window_func(values, begin, end, min_periods, ddof=ddof))
 
         # ddof passed again for compat with groupby.rolling
@@ -1549,6 +1998,21 @@
         )
 
     def var(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_window_func("var", args, kwargs)
         kwargs.pop("require_min_periods", None)
         window_func = partial(self._get_cython_func_type("roll_var"), ddof=ddof)
@@ -1574,6 +2038,17 @@
     """
 
     def skew(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         window_func = self._get_cython_func_type("roll_skew")
         kwargs.pop("require_min_periods", None)
         return self._apply(
@@ -1617,6 +2092,17 @@
     )
 
     def kurt(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         window_func = self._get_cython_func_type("roll_kurt")
         kwargs.pop("require_min_periods", None)
         return self._apply(
@@ -1684,6 +2170,21 @@
     )
 
     def quantile(self, quantile, interpolation="linear", **kwargs):
+        """
+
+        Parameters
+        ----------
+        quantile :
+            
+        interpolation :
+             (Default value = "linear")
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if quantile == 1.0:
             window_func = self._get_cython_func_type("roll_max")
         elif quantile == 0.0:
@@ -1726,6 +2227,23 @@
     """
 
     def cov(self, other=None, pairwise=None, ddof=1, **kwargs):
+        """
+
+        Parameters
+        ----------
+        other :
+             (Default value = None)
+        pairwise :
+             (Default value = None)
+        ddof :
+             (Default value = 1)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if other is None:
             other = self._selected_obj
             # only default unset
@@ -1745,6 +2263,19 @@
                 window = self._get_window(other)
 
         def _get_cov(X, Y):
+            """
+
+            Parameters
+            ----------
+            X :
+                
+            Y :
+                
+
+            Returns
+            -------
+
+            """
             # GH #12373 : rolling functions error on float32 data
             # to avoid potential overflow, cast the data to float64
             X = X.astype("float64")
@@ -1875,6 +2406,21 @@
     )
 
     def corr(self, other=None, pairwise=None, **kwargs):
+        """
+
+        Parameters
+        ----------
+        other :
+             (Default value = None)
+        pairwise :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if other is None:
             other = self._selected_obj
             # only default unset
@@ -1890,6 +2436,19 @@
             window = self._get_window(other) if not self.is_freq_type else self.win_freq
 
         def _get_corr(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             a = a.rolling(
                 window=window, min_periods=self.min_periods, center=self.center
             )
@@ -1905,14 +2464,17 @@
 
 
 class Rolling(_Rolling_and_Expanding):
+    """ """
     @cache_readonly
     def is_datetimelike(self) -> bool:
+        """ """
         return isinstance(
             self._on, (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex)
         )
 
     @cache_readonly
     def _on(self) -> Index:
+        """ """
         if self.on is None:
             if self.axis == 0:
                 return self.obj.index
@@ -1930,6 +2492,7 @@
             )
 
     def validate(self):
+        """ """
         super().validate()
 
         # we allow rolling on a datetimelike index
@@ -1970,9 +2533,7 @@
             )
 
     def _validate_monotonic(self):
-        """
-        Validate monotonic (increasing or decreasing).
-        """
+        """Validate monotonic (increasing or decreasing)."""
         if not (self._on.is_monotonic_increasing or self._on.is_monotonic_decreasing):
             formatted = self.on
             if self.on is None:
@@ -1980,9 +2541,7 @@
             raise ValueError(f"{formatted} must be monotonic")
 
     def _validate_freq(self):
-        """
-        Validate & return window frequency.
-        """
+        """Validate & return window frequency."""
         try:
             return to_offset(self.window)
         except (TypeError, ValueError) as err:
@@ -2034,6 +2593,21 @@
         axis="",
     )
     def aggregate(self, func, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().aggregate(func, *args, **kwargs)
 
     agg = aggregate
@@ -2041,6 +2615,7 @@
     @Substitution(name="rolling")
     @Appender(_shared_docs["count"])
     def count(self):
+        """ """
 
         # different impl for freq counting
         # GH 32865. Use a custom count function implementation
@@ -2056,6 +2631,27 @@
     def apply(
         self, func, raw=False, engine=None, engine_kwargs=None, args=None, kwargs=None,
     ):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        raw :
+             (Default value = False)
+        engine :
+             (Default value = None)
+        engine_kwargs :
+             (Default value = None)
+        args :
+             (Default value = None)
+        kwargs :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return super().apply(
             func,
             raw=raw,
@@ -2068,6 +2664,19 @@
     @Substitution(name="rolling")
     @Appender(_shared_docs["sum"])
     def sum(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("sum", args, kwargs)
         return super().sum(*args, **kwargs)
 
@@ -2075,35 +2684,115 @@
     @Appender(_doc_template)
     @Appender(_shared_docs["max"])
     def max(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("max", args, kwargs)
         return super().max(*args, **kwargs)
 
     @Substitution(name="rolling")
     @Appender(_shared_docs["min"])
     def min(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("min", args, kwargs)
         return super().min(*args, **kwargs)
 
     @Substitution(name="rolling")
     @Appender(_shared_docs["mean"])
     def mean(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("mean", args, kwargs)
         return super().mean(*args, **kwargs)
 
     @Substitution(name="rolling")
     @Appender(_shared_docs["median"])
     def median(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().median(**kwargs)
 
     @Substitution(name="rolling", versionadded="")
     @Appender(_shared_docs["std"])
     def std(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("std", args, kwargs)
         return super().std(ddof=ddof, **kwargs)
 
     @Substitution(name="rolling", versionadded="")
     @Appender(_shared_docs["var"])
     def var(self, ddof=1, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        ddof :
+             (Default value = 1)
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_rolling_func("var", args, kwargs)
         return super().var(ddof=ddof, **kwargs)
 
@@ -2111,6 +2800,17 @@
     @Appender(_doc_template)
     @Appender(_shared_docs["skew"])
     def skew(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().skew(**kwargs)
 
     _agg_doc = dedent(
@@ -2142,11 +2842,37 @@
     @Substitution(name="rolling")
     @Appender(_shared_docs["kurt"])
     def kurt(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().kurt(**kwargs)
 
     @Substitution(name="rolling")
     @Appender(_shared_docs["quantile"])
     def quantile(self, quantile, interpolation="linear", **kwargs):
+        """
+
+        Parameters
+        ----------
+        quantile :
+            
+        interpolation :
+             (Default value = "linear")
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().quantile(
             quantile=quantile, interpolation=interpolation, **kwargs
         )
@@ -2155,11 +2881,43 @@
     @Appender(_doc_template)
     @Appender(_shared_docs["cov"])
     def cov(self, other=None, pairwise=None, ddof=1, **kwargs):
+        """
+
+        Parameters
+        ----------
+        other :
+             (Default value = None)
+        pairwise :
+             (Default value = None)
+        ddof :
+             (Default value = 1)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().cov(other=other, pairwise=pairwise, ddof=ddof, **kwargs)
 
     @Substitution(name="rolling")
     @Appender(_shared_docs["corr"])
     def corr(self, other=None, pairwise=None, **kwargs):
+        """
+
+        Parameters
+        ----------
+        other :
+             (Default value = None)
+        pairwise :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return super().corr(other=other, pairwise=pairwise, **kwargs)
 
 
@@ -2167,9 +2925,7 @@
 
 
 class RollingGroupby(WindowGroupByMixin, Rolling):
-    """
-    Provide a rolling groupby implementation.
-    """
+    """Provide a rolling groupby implementation."""
 
     def _apply(
         self,
@@ -2182,6 +2938,31 @@
         use_numba_cache: bool = False,
         **kwargs,
     ):
+        """
+
+        Parameters
+        ----------
+        func: Callable :
+            
+        center: bool :
+            
+        require_min_periods: int :
+             (Default value = 0)
+        floor: int :
+             (Default value = 1)
+        is_weighted: bool :
+             (Default value = False)
+        name: Optional[str] :
+             (Default value = None)
+        use_numba_cache: bool :
+             (Default value = False)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         result = Rolling._apply(
             self,
             func,
@@ -2218,11 +2999,20 @@
 
     @property
     def _constructor(self):
+        """ """
         return Rolling
 
     def _create_blocks(self, obj: FrameOrSeries):
-        """
-        Split data into blocks & return conformed data.
+        """Split data into blocks & return conformed data.
+
+        Parameters
+        ----------
+        obj: FrameOrSeries :
+            
+
+        Returns
+        -------
+
         """
         # Ensure the object we're rolling over is monotonically sorted relative
         # to the groups
@@ -2236,26 +3026,36 @@
 
     def _get_cython_func_type(self, func: str) -> Callable:
         """
-        Return the cython function type.
-
-        RollingGroupby needs to always use "variable" algorithms since processing
-        the data in group order may not be monotonic with the data which
-        "fixed" algorithms assume
+
+        Parameters
+        ----------
+        func: str :
+            
+
+        Returns
+        -------
+        type
+            RollingGroupby needs to always use "variable" algorithms since processing
+            the data in group order may not be monotonic with the data which
+            "fixed" algorithms assume
+
         """
         return self._get_roll_func(f"{func}_variable")
 
     def _get_window_indexer(self, window: int) -> GroupbyRollingIndexer:
-        """
-        Return an indexer class that will compute the window start and end bounds
+        """Return an indexer class that will compute the window start and end bounds
 
         Parameters
         ----------
         window : int
             window size for FixedWindowIndexer
-
-        Returns
-        -------
-        GroupbyRollingIndexer
+        window: int :
+            
+
+        Returns
+        -------
+
+        
         """
         rolling_indexer: Type[BaseIndexer]
         indexer_kwargs: Optional[Dict] = None
@@ -2280,6 +3080,21 @@
         return window_indexer
 
     def _gotitem(self, key, ndim, subset=None):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        ndim :
+            
+        subset :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # we are setting the index on the actual object
         # here so our index is carried thru to the selected obj
         # when we do the splitting for the groupby
@@ -2289,10 +3104,16 @@
         return super()._gotitem(key, ndim, subset=subset)
 
     def _validate_monotonic(self):
-        """
-        Validate that on is monotonic;
+        """Validate that on is monotonic;
         we don't care for groupby.rolling
         because we have already validated at a higher
         level.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
