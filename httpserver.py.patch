# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/httpserver.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/httpserver.py
@@ -40,21 +40,22 @@
 from typing import Union, Any, Dict, Callable, List, Type, Tuple, Optional, Awaitable
 
 if typing.TYPE_CHECKING:
+    """ """
     from typing import Set  # noqa: F401
 
 
 class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate):
-    r"""A non-blocking, single-threaded HTTP server.
-
+    """r"""A non-blocking, single-threaded HTTP server.
+    
     A server is defined by a subclass of `.HTTPServerConnectionDelegate`,
     or, for backwards compatibility, a callback that takes an
     `.HTTPServerRequest` as an argument. The delegate is usually a
     `tornado.web.Application`.
-
+    
     `HTTPServer` supports keep-alive connections by default
     (automatically for HTTP/1.1, or for HTTP/1.0 when the client
     requests ``Connection: keep-alive``).
-
+    
     If ``xheaders`` is ``True``, we support the
     ``X-Real-Ip``/``X-Forwarded-For`` and
     ``X-Scheme``/``X-Forwarded-Proto`` headers, which override the
@@ -63,83 +64,94 @@
     balancer.  The ``protocol`` argument can also be set to ``https``
     if Tornado is run behind an SSL-decoding proxy that does not set one of
     the supported ``xheaders``.
-
+    
     By default, when parsing the ``X-Forwarded-For`` header, Tornado will
     select the last (i.e., the closest) address on the list of hosts as the
     remote host IP address.  To select the next server in the chain, a list of
     trusted downstream hosts may be passed as the ``trusted_downstream``
     argument.  These hosts will be skipped when parsing the ``X-Forwarded-For``
     header.
-
+    
     To make this server serve SSL traffic, send the ``ssl_options`` keyword
     argument with an `ssl.SSLContext` object. For compatibility with older
     versions of Python ``ssl_options`` may also be a dictionary of keyword
     arguments for the `ssl.wrap_socket` method.::
-
+    
        ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        ssl_ctx.load_cert_chain(os.path.join(data_dir, "mydomain.crt"),
                                os.path.join(data_dir, "mydomain.key"))
        HTTPServer(application, ssl_options=ssl_ctx)
-
+    
     `HTTPServer` initialization follows one of three patterns (the
     initialization methods are defined on `tornado.tcpserver.TCPServer`):
-
+    
     1. `~tornado.tcpserver.TCPServer.listen`: simple single-process::
-
+    
             server = HTTPServer(app)
             server.listen(8888)
             IOLoop.current().start()
-
+    
        In many cases, `tornado.web.Application.listen` can be used to avoid
        the need to explicitly create the `HTTPServer`.
-
+    
     2. `~tornado.tcpserver.TCPServer.bind`/`~tornado.tcpserver.TCPServer.start`:
        simple multi-process::
-
+    
             server = HTTPServer(app)
             server.bind(8888)
             server.start(0)  # Forks multiple sub-processes
             IOLoop.current().start()
-
+    
        When using this interface, an `.IOLoop` must *not* be passed
        to the `HTTPServer` constructor.  `~.TCPServer.start` will always start
        the server on the default singleton `.IOLoop`.
-
+    
     3. `~tornado.tcpserver.TCPServer.add_sockets`: advanced multi-process::
-
+    
             sockets = tornado.netutil.bind_sockets(8888)
             tornado.process.fork_processes(0)
             server = HTTPServer(app)
             server.add_sockets(sockets)
             IOLoop.current().start()
-
+    
        The `~.TCPServer.add_sockets` interface is more complicated,
        but it can be used with `tornado.process.fork_processes` to
        give you more flexibility in when the fork happens.
        `~.TCPServer.add_sockets` can also be used in single-process
        servers if you want to create your listening sockets in some
        way other than `tornado.netutil.bind_sockets`.
-
+    
     .. versionchanged:: 4.0
        Added ``decompress_request``, ``chunk_size``, ``max_header_size``,
        ``idle_connection_timeout``, ``body_timeout``, ``max_body_size``
-       arguments.  Added support for `.HTTPServerConnectionDelegate`
-       instances as ``request_callback``.
-
-    .. versionchanged:: 4.1
-       `.HTTPServerConnectionDelegate.start_request` is now called with
-       two arguments ``(server_conn, request_conn)`` (in accordance with the
-       documentation) instead of one ``(request_conn)``.
-
-    .. versionchanged:: 4.2
-       `HTTPServer` is now a subclass of `tornado.util.Configurable`.
-
-    .. versionchanged:: 4.5
-       Added the ``trusted_downstream`` argument.
-
-    .. versionchanged:: 5.0
-       The ``io_loop`` argument has been removed.
-    """
+
+    Parameters
+    ----------
+    instances :
+        as
+    versionchanged :
+        
+    HTTPServerConnectionDelegate :
+        start_request
+    two :
+        arguments
+    documentation :
+        instead of one
+    versionchanged :
+        
+    HTTPServer :
+        is now a subclass of
+    versionchanged :
+        
+    Added :
+        the
+    versionchanged :
+        
+    The :
+        io_loop
+
+    Returns
+    -------
 
     def __init__(self, *args: Any, **kwargs: Any) -> None:
         # Ignore args to __init__; real initialization belongs in
@@ -168,6 +180,51 @@
         max_buffer_size: Optional[int] = None,
         trusted_downstream: Optional[List[str]] = None,
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        request_callback: Union[httputil.HTTPServerConnectionDelegate :
+            
+        Callable[[httputil.HTTPServerRequest] :
+            
+        None] :
+            
+        ] :
+            
+        no_keep_alive: bool :
+             (Default value = False)
+        xheaders: bool :
+             (Default value = False)
+        ssl_options: Optional[Union[Dict[str :
+            
+        Any] :
+            
+        ssl.SSLContext]] :
+             (Default value = None)
+        protocol: Optional[str] :
+             (Default value = None)
+        decompress_request: bool :
+             (Default value = False)
+        chunk_size: Optional[int] :
+             (Default value = None)
+        max_header_size: Optional[int] :
+             (Default value = None)
+        idle_connection_timeout: Optional[float] :
+             (Default value = None)
+        body_timeout: Optional[float] :
+             (Default value = None)
+        max_body_size: Optional[int] :
+             (Default value = None)
+        max_buffer_size: Optional[int] :
+             (Default value = None)
+        trusted_downstream: Optional[List[str]] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # This method's signature is not extracted with autodoc
         # because we want its arguments to appear on the class
         # constructor. When changing this signature, also update the
@@ -195,10 +252,12 @@
 
     @classmethod
     def configurable_base(cls) -> Type[Configurable]:
+        """ """
         return HTTPServer
 
     @classmethod
     def configurable_default(cls) -> Type[Configurable]:
+        """ """
         return HTTPServer
 
     async def close_all_connections(self) -> None:
@@ -221,6 +280,19 @@
             await conn.close()
 
     def handle_stream(self, stream: iostream.IOStream, address: Tuple) -> None:
+        """
+
+        Parameters
+        ----------
+        stream: iostream.IOStream :
+            
+        address: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         context = _HTTPRequestContext(
             stream, address, self.protocol, self.trusted_downstream
         )
@@ -231,6 +303,19 @@
     def start_request(
         self, server_conn: object, request_conn: httputil.HTTPConnection
     ) -> httputil.HTTPMessageDelegate:
+        """
+
+        Parameters
+        ----------
+        server_conn: object :
+            
+        request_conn: httputil.HTTPConnection :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(self.request_callback, httputil.HTTPServerConnectionDelegate):
             delegate = self.request_callback.start_request(server_conn, request_conn)
         else:
@@ -242,10 +327,22 @@
         return delegate
 
     def on_close(self, server_conn: object) -> None:
+        """
+
+        Parameters
+        ----------
+        server_conn: object :
+            
+
+        Returns
+        -------
+
+        """
         self._connections.remove(typing.cast(HTTP1ServerConnection, server_conn))
 
 
 class _CallableAdapter(httputil.HTTPMessageDelegate):
+    """ """
     def __init__(
         self,
         request_callback: Callable[[httputil.HTTPServerRequest], None],
@@ -262,6 +359,21 @@
         start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],
         headers: httputil.HTTPHeaders,
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        start_line: Union[httputil.RequestStartLine :
+            
+        httputil.ResponseStartLine] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         self.request = httputil.HTTPServerRequest(
             connection=self.connection,
             start_line=typing.cast(httputil.RequestStartLine, start_line),
@@ -270,20 +382,34 @@
         return None
 
     def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
+        """
         self._chunks.append(chunk)
         return None
 
     def finish(self) -> None:
+        """ """
         assert self.request is not None
         self.request.body = b"".join(self._chunks)
         self.request._parse_body()
         self.request_callback(self.request)
 
     def on_connection_close(self) -> None:
+        """ """
         del self._chunks
 
 
 class _HTTPRequestContext(object):
+    """ """
     def __init__(
         self,
         stream: iostream.IOStream,
@@ -330,7 +456,17 @@
             return str(self.address)
 
     def _apply_xheaders(self, headers: httputil.HTTPHeaders) -> None:
-        """Rewrite the ``remote_ip`` and ``protocol`` fields."""
+        """Rewrite the ``remote_ip`` and ``protocol`` fields.
+
+        Parameters
+        ----------
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         # Squid uses X-Forwarded-For, others use X-Real-Ip
         ip = headers.get("X-Forwarded-For", self.remote_ip)
         # Skip trusted downstream hosts in X-Forwarded-For list
@@ -353,15 +489,23 @@
 
     def _unapply_xheaders(self) -> None:
         """Undo changes from `_apply_xheaders`.
-
+        
         Xheaders are per-request so they should not leak to the next
         request on the same connection.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.remote_ip = self._orig_remote_ip
         self.protocol = self._orig_protocol
 
 
 class _ProxyAdapter(httputil.HTTPMessageDelegate):
+    """ """
     def __init__(
         self,
         delegate: httputil.HTTPMessageDelegate,
@@ -375,23 +519,52 @@
         start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],
         headers: httputil.HTTPHeaders,
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        start_line: Union[httputil.RequestStartLine :
+            
+        httputil.ResponseStartLine] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: either make context an official part of the
         # HTTPConnection interface or figure out some other way to do this.
         self.connection.context._apply_xheaders(headers)  # type: ignore
         return self.delegate.headers_received(start_line, headers)
 
     def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
+        """
         return self.delegate.data_received(chunk)
 
     def finish(self) -> None:
+        """ """
         self.delegate.finish()
         self._cleanup()
 
     def on_connection_close(self) -> None:
+        """ """
         self.delegate.on_connection_close()
         self._cleanup()
 
     def _cleanup(self) -> None:
+        """ """
         self.connection.context._unapply_xheaders()  # type: ignore
 
 
