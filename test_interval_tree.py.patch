# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/interval/test_interval_tree.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/interval/test_interval_tree.py
@@ -10,9 +10,17 @@
 
 
 def skipif_32bit(param):
-    """
-    Skip parameters in a parametrize on 32bit systems. Specifically used
+    """Skip parameters in a parametrize on 32bit systems. Specifically used
     here to skip leaf_size parameters related to GH 23440.
+
+    Parameters
+    ----------
+    param :
+        
+
+    Returns
+    -------
+
     """
     marks = pytest.mark.skipif(
         compat.is_platform_32bit(), reason="GH 23440: int type mismatch on 32bit"
@@ -22,14 +30,33 @@
 
 @pytest.fixture(scope="class", params=["int64", "float64", "uint64"])
 def dtype(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=[skipif_32bit(1), skipif_32bit(2), 10])
 def leaf_size(request):
-    """
-    Fixture to specify IntervalTree leaf_size parameter; to be used with the
+    """Fixture to specify IntervalTree leaf_size parameter; to be used with the
     tree fixture.
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
     """
     return request.param
 
@@ -43,12 +70,37 @@
     ]
 )
 def tree(request, leaf_size):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+    leaf_size :
+        
+
+    Returns
+    -------
+
+    """
     left = request.param
     return IntervalTree(left, left + 2, leaf_size=leaf_size)
 
 
 class TestIntervalTree:
+    """ """
     def test_get_indexer(self, tree):
+        """
+
+        Parameters
+        ----------
+        tree :
+            
+
+        Returns
+        -------
+
+        """
         result = tree.get_indexer(np.array([1.0, 5.5, 6.5]))
         expected = np.array([0, 4, -1], dtype="intp")
         tm.assert_numpy_array_equal(result, expected)
@@ -63,6 +115,21 @@
         [("int64", 2 ** 63 + 1, "uint64"), ("uint64", -1, "int64")],
     )
     def test_get_indexer_overflow(self, dtype, target_value, target_dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        target_value :
+            
+        target_dtype :
+            
+
+        Returns
+        -------
+
+        """
         left, right = np.array([0, 1], dtype=dtype), np.array([1, 2], dtype=dtype)
         tree = IntervalTree(left, right)
 
@@ -71,6 +138,17 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_get_indexer_non_unique(self, tree):
+        """
+
+        Parameters
+        ----------
+        tree :
+            
+
+        Returns
+        -------
+
+        """
         indexer, missing = tree.get_indexer_non_unique(np.array([1.0, 2.0, 6.5]))
 
         result = indexer[:1]
@@ -94,6 +172,21 @@
         [("int64", 2 ** 63 + 1, "uint64"), ("uint64", -1, "int64")],
     )
     def test_get_indexer_non_unique_overflow(self, dtype, target_value, target_dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        target_value :
+            
+        target_dtype :
+            
+
+        Returns
+        -------
+
+        """
         left, right = np.array([0, 2], dtype=dtype), np.array([1, 3], dtype=dtype)
         tree = IntervalTree(left, right)
         target = np.array([target_value], dtype=target_dtype)
@@ -106,6 +199,17 @@
         tm.assert_numpy_array_equal(result_missing, expected_missing)
 
     def test_duplicates(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         left = np.array([0, 0, 0], dtype=dtype)
         tree = IntervalTree(left, left + 1)
 
@@ -127,6 +231,19 @@
         "leaf_size", [skipif_32bit(1), skipif_32bit(10), skipif_32bit(100), 10000]
     )
     def test_get_indexer_closed(self, closed, leaf_size):
+        """
+
+        Parameters
+        ----------
+        closed :
+            
+        leaf_size :
+            
+
+        Returns
+        -------
+
+        """
         x = np.arange(1000, dtype="float64")
         found = x.astype("intp")
         not_found = (-1 * np.ones(1000)).astype("intp")
@@ -152,6 +269,25 @@
     )
     @pytest.mark.parametrize("order", (list(x) for x in permutations(range(3))))
     def test_is_overlapping(self, closed, order, left, right, expected):
+        """
+
+        Parameters
+        ----------
+        closed :
+            
+        order :
+            
+        left :
+            
+        right :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 23309
         tree = IntervalTree(left[order], right[order], closed=closed)
         result = tree.is_overlapping
@@ -159,7 +295,19 @@
 
     @pytest.mark.parametrize("order", (list(x) for x in permutations(range(3))))
     def test_is_overlapping_endpoints(self, closed, order):
-        """shared endpoints are marked as overlapping"""
+        """shared endpoints are marked as overlapping
+
+        Parameters
+        ----------
+        closed :
+            
+        order :
+            
+
+        Returns
+        -------
+
+        """
         # GH 23309
         left, right = np.arange(3, dtype="int64"), np.arange(1, 4)
         tree = IntervalTree(left[order], right[order], closed=closed)
@@ -177,12 +325,28 @@
         ],
     )
     def test_is_overlapping_trivial(self, closed, left, right):
+        """
+
+        Parameters
+        ----------
+        closed :
+            
+        left :
+            
+        right :
+            
+
+        Returns
+        -------
+
+        """
         # GH 23309
         tree = IntervalTree(left, right, closed=closed)
         assert tree.is_overlapping is False
 
     @pytest.mark.skipif(compat.is_platform_32bit(), reason="GH 23440")
     def test_construction_overflow(self):
+        """ """
         # GH 25485
         left, right = np.arange(101, dtype="int64"), [np.iinfo(np.int64).max] * 101
         tree = IntervalTree(left, right)
