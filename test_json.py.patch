# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/json/test_json.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/json/test_json.py
@@ -12,6 +12,7 @@
 
 @pytest.fixture
 def dtype():
+    """ """
     return JSONDtype()
 
 
@@ -40,26 +41,41 @@
 
 @pytest.fixture
 def data_for_sorting():
+    """ """
     return JSONArray([{"b": 1}, {"c": 4}, {"a": 2, "c": 3}])
 
 
 @pytest.fixture
 def data_missing_for_sorting():
+    """ """
     return JSONArray([{"b": 1}, {}, {"a": 4}])
 
 
 @pytest.fixture
 def na_value(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     return dtype.na_value
 
 
 @pytest.fixture
 def na_cmp():
+    """ """
     return operator.eq
 
 
 @pytest.fixture
 def data_for_grouping():
+    """ """
     return JSONArray(
         [
             {"b": 1},
@@ -75,12 +91,30 @@
 
 
 class BaseJSON:
+    """ """
     # NumPy doesn't handle an array of equal-length UserDicts.
     # The default assert_series_equal eventually does a
     # Series.values, which raises. We work around it by
     # converting the UserDicts to dicts.
     @classmethod
     def assert_series_equal(cls, left, right, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+        right :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if left.dtype.name == "json":
             assert left.dtype == right.dtype
             left = pd.Series(
@@ -95,6 +129,23 @@
 
     @classmethod
     def assert_frame_equal(cls, left, right, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+        right :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         obj_type = kwargs.get("obj", "DataFrame")
         tm.assert_index_equal(
             left.columns,
@@ -117,11 +168,14 @@
 
 
 class TestDtype(BaseJSON, base.BaseDtypeTests):
+    """ """
     pass
 
 
 class TestInterface(BaseJSON, base.BaseInterfaceTests):
+    """ """
     def test_custom_asserts(self):
+        """ """
         # This would always trigger the KeyError from trying to put
         # an array of equal-length UserDicts inside an ndarray.
         data = JSONArray(
@@ -145,48 +199,121 @@
 
 
 class TestConstructors(BaseJSON, base.BaseConstructorsTests):
+    """ """
     @pytest.mark.skip(reason="not implemented constructor from dtype")
     def test_from_dtype(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # construct from our dtype & string dtype
         pass
 
     @pytest.mark.xfail(reason="RecursionError, GH-33900")
     def test_series_constructor_no_data_with_index(self, dtype, na_value):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # RecursionError: maximum recursion depth exceeded in comparison
         super().test_series_constructor_no_data_with_index(dtype, na_value)
 
     @pytest.mark.xfail(reason="RecursionError, GH-33900")
     def test_series_constructor_scalar_na_with_index(self, dtype, na_value):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # RecursionError: maximum recursion depth exceeded in comparison
         super().test_series_constructor_scalar_na_with_index(dtype, na_value)
 
     @pytest.mark.xfail(reason="collection as scalar, GH-33901")
     def test_series_constructor_scalar_with_index(self, data, dtype):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # TypeError: All values must be of type <class 'collections.abc.Mapping'>
         super().test_series_constructor_scalar_with_index(data, dtype)
 
 
 class TestReshaping(BaseJSON, base.BaseReshapingTests):
+    """ """
     @pytest.mark.skip(reason="Different definitions of NA")
     def test_stack(self):
-        """
-        The test does .astype(object).stack(). If we happen to have
+        """The test does .astype(object).stack(). If we happen to have
         any missing values in `data`, then we'll end up with different
         rows since we consider `{}` NA, but `.astype(object)` doesn't.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
     @pytest.mark.xfail(reason="dict for NA")
     def test_unstack(self, data, index):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        index :
+            
+
+        Returns
+        -------
+
+        """
         # The base test has NaN for the expected NA value.
         # this matches otherwise
         return super().test_unstack(data, index)
 
 
 class TestGetitem(BaseJSON, base.BaseGetitemTests):
+    """ """
     pass
 
 
 class TestMissing(BaseJSON, base.BaseMissingTests):
+    """ """
     @pytest.mark.skip(reason="Setting a dict as a scalar")
     def test_fillna_series(self):
         """We treat dictionaries as a mapping in fillna, not a scalar."""
@@ -200,59 +327,197 @@
 
 
 class TestReduce(base.BaseNoReduceTests):
+    """ """
     pass
 
 
 class TestMethods(BaseJSON, base.BaseMethodsTests):
+    """ """
     @unhashable
     def test_value_counts(self, all_data, dropna):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+        dropna :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @unhashable
     def test_value_counts_with_normalize(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @unhashable
     def test_sort_values_frame(self):
+        """ """
         # TODO (EA.factorize): see if _values_for_factorize allows this.
         pass
 
     def test_argsort(self, data_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         super().test_argsort(data_for_sorting)
 
     def test_argsort_missing(self, data_missing_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         super().test_argsort_missing(data_missing_for_sorting)
 
     @pytest.mark.parametrize("ascending", [True, False])
     def test_sort_values(self, data_for_sorting, ascending, sort_by_key):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+        ascending :
+            
+        sort_by_key :
+            
+
+        Returns
+        -------
+
+        """
         super().test_sort_values(data_for_sorting, ascending, sort_by_key)
 
     @pytest.mark.parametrize("ascending", [True, False])
     def test_sort_values_missing(
         self, data_missing_for_sorting, ascending, sort_by_key
     ):
+        """
+
+        Parameters
+        ----------
+        data_missing_for_sorting :
+            
+        ascending :
+            
+        sort_by_key :
+            
+
+        Returns
+        -------
+
+        """
         super().test_sort_values_missing(
             data_missing_for_sorting, ascending, sort_by_key
         )
 
     @pytest.mark.skip(reason="combine for JSONArray not supported")
     def test_combine_le(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @pytest.mark.skip(reason="combine for JSONArray not supported")
     def test_combine_add(self, data_repeated):
+        """
+
+        Parameters
+        ----------
+        data_repeated :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @pytest.mark.skip(reason="combine for JSONArray not supported")
     def test_combine_first(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @unhashable
     def test_hash_pandas_object_works(self, data, kind):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        kind :
+            
+
+        Returns
+        -------
+
+        """
         super().test_hash_pandas_object_works(data, kind)
 
     @pytest.mark.skip(reason="broadcasting error")
     def test_where_series(self, data, na_value):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+
+        Returns
+        -------
+
+        """
         # Fails with
         # *** ValueError: operands could not be broadcast together
         # with shapes (4,) (4,) (0,)
@@ -260,19 +525,53 @@
 
     @pytest.mark.skip(reason="Can't compare dicts.")
     def test_searchsorted(self, data_for_sorting):
+        """
+
+        Parameters
+        ----------
+        data_for_sorting :
+            
+
+        Returns
+        -------
+
+        """
         super().test_searchsorted(data_for_sorting)
 
     @pytest.mark.skip(reason="Can't compare dicts.")
     def test_equals(self, data, na_value, as_series):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        na_value :
+            
+        as_series :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
 
 class TestCasting(BaseJSON, base.BaseCastingTests):
+    """ """
     @pytest.mark.skip(reason="failing on np.array(self, dtype=str)")
     def test_astype_str(self):
         """This currently fails in NumPy on np.array(self, dtype=str) with
-
+        
         *** ValueError: setting an array element with a sequence
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
 
@@ -281,53 +580,124 @@
 
 
 class TestGroupby(BaseJSON, base.BaseGroupbyTests):
+    """ """
     @unhashable
     def test_groupby_extension_transform(self):
-        """
-        This currently fails in Series.name.setter, since the
+        """This currently fails in Series.name.setter, since the
         name must be hashable, but the value is a dictionary.
         I think this is what we want, i.e. `.name` should be the original
         values, and not the values for factorization.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
     @unhashable
     def test_groupby_extension_apply(self):
-        """
-        This fails in Index._do_unique_check with
-
+        """This fails in Index._do_unique_check with
+        
         >   hash(val)
         E   TypeError: unhashable type: 'UserDict' with
-
+        
         I suspect that once we support Index[ExtensionArray],
         we'll be able to dispatch unique.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
     @pytest.mark.parametrize("as_index", [True, False])
     def test_groupby_extension_agg(self, as_index, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        as_index :
+            
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         super().test_groupby_extension_agg(as_index, data_for_grouping)
 
 
 class TestArithmeticOps(BaseJSON, base.BaseArithmeticOpsTests):
+    """ """
     def test_error(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def test_add_series_with_extension_array(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         ser = pd.Series(data)
         with pytest.raises(TypeError, match="unsupported"):
             ser + data
 
     def test_divmod_series_array(self):
+        """ """
         # GH 23287
         # skipping because it is not implemented
         pass
 
     def _check_divmod_op(self, s, op, other, exc=NotImplementedError):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        exc :
+             (Default value = NotImplementedError)
+
+        Returns
+        -------
+
+        """
         return super()._check_divmod_op(s, op, other, exc=TypeError)
 
 
 class TestComparisonOps(BaseJSON, base.BaseComparisonOpsTests):
+    """ """
     pass
 
 
 class TestPrinting(BaseJSON, base.BasePrintingTests):
+    """ """
     pass
