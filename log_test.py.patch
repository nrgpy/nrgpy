# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/log_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/log_test.py
@@ -31,12 +31,14 @@
 
 @contextlib.contextmanager
 def ignore_bytes_warning():
+    """ """
     with warnings.catch_warnings():
         warnings.simplefilter("ignore", category=BytesWarning)
         yield
 
 
 class LogFormatterTest(unittest.TestCase):
+    """ """
     # Matches the output of a single logging call (which may be multiple lines
     # if a traceback was included, so we use the DOTALL option)
     LINE_RE = re.compile(
@@ -44,6 +46,7 @@
     )
 
     def setUp(self):
+        """ """
         self.formatter = LogFormatter(color=False)
         # Fake color support.  We can't guarantee anything about the $TERM
         # variable when the tests are run, so just patch in some values
@@ -61,11 +64,23 @@
         self.logger.addHandler(self.handler)
 
     def tearDown(self):
+        """ """
         self.handler.close()
         os.unlink(self.filename)
         os.rmdir(self.tempdir)
 
     def make_handler(self, filename):
+        """
+
+        Parameters
+        ----------
+        filename :
+            
+
+        Returns
+        -------
+
+        """
         # Base case: default setup without explicit encoding.
         # In python 2, supports arbitrary byte strings and unicode objects
         # that contain only ascii.  In python 3, supports ascii-only unicode
@@ -73,6 +88,7 @@
         return logging.FileHandler(filename)
 
     def get_output(self):
+        """ """
         with open(self.filename, "rb") as f:
             line = f.read().strip()
             m = LogFormatterTest.LINE_RE.match(line)
@@ -82,16 +98,19 @@
                 raise Exception("output didn't match regex: %r" % line)
 
     def test_basic_logging(self):
+        """ """
         self.logger.error("foo")
         self.assertEqual(self.get_output(), b"foo")
 
     def test_bytes_logging(self):
+        """ """
         with ignore_bytes_warning():
             # This will be "\xe9" on python 2 or "b'\xe9'" on python 3
             self.logger.error(b"\xe9")
             self.assertEqual(self.get_output(), utf8(repr(b"\xe9")))
 
     def test_utf8_logging(self):
+        """ """
         with ignore_bytes_warning():
             self.logger.error(u"\u00e9".encode("utf8"))
         if issubclass(bytes, basestring_type):
@@ -105,6 +124,7 @@
             self.assertEqual(self.get_output(), utf8(repr(utf8(u"\u00e9"))))
 
     def test_bytes_exception_logging(self):
+        """ """
         try:
             raise Exception(b"\xe9")
         except Exception:
@@ -118,19 +138,34 @@
 
 
 class UnicodeLogFormatterTest(LogFormatterTest):
+    """ """
     def make_handler(self, filename):
+        """
+
+        Parameters
+        ----------
+        filename :
+            
+
+        Returns
+        -------
+
+        """
         # Adding an explicit encoding configuration allows non-ascii unicode
         # strings in both python 2 and 3, without changing the behavior
         # for byte strings.
         return logging.FileHandler(filename, encoding="utf8")
 
     def test_unicode_logging(self):
+        """ """
         self.logger.error(u"\u00e9")
         self.assertEqual(self.get_output(), utf8(u"\u00e9"))
 
 
 class EnablePrettyLoggingTest(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.options = OptionParser()
         define_logging_options(self.options)
@@ -138,6 +173,7 @@
         self.logger.propagate = False
 
     def test_log_file(self):
+        """ """
         tmpdir = tempfile.mkdtemp()
         try:
             self.options.log_file_prefix = tmpdir + "/test_log"
@@ -158,6 +194,7 @@
             os.rmdir(tmpdir)
 
     def test_log_file_with_timed_rotating(self):
+        """ """
         tmpdir = tempfile.mkdtemp()
         try:
             self.options.log_file_prefix = tmpdir + "/test_log"
@@ -178,6 +215,7 @@
             os.rmdir(tmpdir)
 
     def test_wrong_rotate_mode_value(self):
+        """ """
         try:
             self.options.log_file_prefix = "some_path"
             self.options.log_rotate_mode = "wrong_mode"
@@ -197,6 +235,19 @@
     """Test the ability to enable and disable Tornado's logging hooks."""
 
     def logs_present(self, statement, args=None):
+        """
+
+        Parameters
+        ----------
+        statement :
+            
+        args :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Each test may manipulate and/or parse the options and then logs
         # a line at the 'info' level.  This level is ignored in the
         # logging module by default, but Tornado turns it on by default
@@ -215,28 +266,35 @@
         return b"hello" in stdout
 
     def test_default(self):
+        """ """
         self.assertFalse(self.logs_present("pass"))
 
     def test_tornado_default(self):
+        """ """
         self.assertTrue(self.logs_present("parse_command_line()"))
 
     def test_disable_command_line(self):
+        """ """
         self.assertFalse(self.logs_present("parse_command_line()", ["--logging=none"]))
 
     def test_disable_command_line_case_insensitive(self):
+        """ """
         self.assertFalse(self.logs_present("parse_command_line()", ["--logging=None"]))
 
     def test_disable_code_string(self):
+        """ """
         self.assertFalse(
             self.logs_present('options.logging = "none"; parse_command_line()')
         )
 
     def test_disable_code_none(self):
+        """ """
         self.assertFalse(
             self.logs_present("options.logging = None; parse_command_line()")
         )
 
     def test_disable_override(self):
+        """ """
         # command line trumps code defaults
         self.assertTrue(
             self.logs_present(
