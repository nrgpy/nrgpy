# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/sys_path.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/sys_path.py
@@ -15,6 +15,19 @@
 
 
 def _abs_path(module_context, path):
+    """
+
+    Parameters
+    ----------
+    module_context :
+        
+    path :
+        
+
+    Returns
+    -------
+
+    """
     if os.path.isabs(path):
         return path
 
@@ -30,15 +43,25 @@
 
 
 def _paths_from_assignment(module_context, expr_stmt):
-    """
-    Extracts the assigned strings from an assignment that looks as follows::
-
+    """Extracts the assigned strings from an assignment that looks as follows::
+    
         sys.path[0:0] = ['module/path', 'another/module/path']
-
+    
     This function is in general pretty tolerant (and therefore 'buggy').
     However, it's not a big issue usually to add more paths to Jedi's sys_path,
     because it will only affect Jedi in very random situations and by adding
     more paths than necessary, it usually benefits the general user.
+
+    Parameters
+    ----------
+    module_context :
+        
+    expr_stmt :
+        
+
+    Returns
+    -------
+
     """
     for assignee, operator in zip(expr_stmt.children[::2], expr_stmt.children[1::2]):
         try:
@@ -73,7 +96,21 @@
 
 
 def _paths_from_list_modifications(module_context, trailer1, trailer2):
-    """ extract the path from either "sys.path.append" or "sys.path.insert" """
+    """extract the path from either "sys.path.append" or "sys.path.insert"
+
+    Parameters
+    ----------
+    module_context :
+        
+    trailer1 :
+        
+    trailer2 :
+        
+
+    Returns
+    -------
+
+    """
     # Guarantee that both are trailers, the first one a name and the second one
     # a function execution with at least one param.
     if not (trailer1.type == 'trailer' and trailer1.children[0] == '.'
@@ -99,10 +136,29 @@
 
 @inference_state_method_cache(default=[])
 def check_sys_path_modifications(module_context):
-    """
-    Detect sys.path modifications within module.
+    """Detect sys.path modifications within module.
+
+    Parameters
+    ----------
+    module_context :
+        
+
+    Returns
+    -------
+
     """
     def get_sys_path_powers(names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         for name in names:
             power = name.parent.parent
             if power is not None and power.type in ('power', 'atom_expr'):
@@ -136,6 +192,19 @@
 
 
 def discover_buildout_paths(inference_state, script_path):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    script_path :
+        
+
+    Returns
+    -------
+
+    """
     buildout_script_paths = set()
 
     for buildout_script_path in _get_buildout_script_paths(script_path):
@@ -148,6 +217,19 @@
 
 
 def _get_paths_from_buildout_script(inference_state, buildout_script_path):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    buildout_script_path :
+        
+
+    Returns
+    -------
+
+    """
     file_io = FileIO(buildout_script_path)
     try:
         module_node = inference_state.parse(
@@ -171,6 +253,19 @@
 
 
 def _get_parent_dir_with_file(path, filename):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+    filename :
+        
+
+    Returns
+    -------
+
+    """
     for parent in traverse_parents(path):
         if os.path.isfile(os.path.join(parent, filename)):
             return parent
@@ -178,13 +273,18 @@
 
 
 def _get_buildout_script_paths(search_path):
-    """
-    if there is a 'buildout.cfg' file in one of the parent directories of the
+    """if there is a 'buildout.cfg' file in one of the parent directories of the
     given module it will return a list of all files in the buildout bin
     directory that look like python files.
 
-    :param search_path: absolute path to the module.
-    :type search_path: str
+    Parameters
+    ----------
+    search_path : str
+        absolute path to the module.
+
+    Returns
+    -------
+
     """
     project_root = _get_parent_dir_with_file(search_path, 'buildout.cfg')
     if not project_root:
@@ -208,6 +308,17 @@
 
 
 def remove_python_path_suffix(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     for suffix in all_suffixes() + ['.pyi']:
         if path.endswith(suffix):
             path = path[:-len(suffix)]
@@ -216,15 +327,25 @@
 
 
 def transform_path_to_dotted(sys_path, module_path):
-    """
-    Returns the dotted path inside a sys.path as a list of names. e.g.
+    """Returns the dotted path inside a sys.path as a list of names. e.g.
+    
+    
+    Returns (None, False) if the path doesn't really resolve to anything.
+    The second return part is if it is a package.
+
+    Parameters
+    ----------
+    sys_path :
+        
+    module_path :
+        
+
+    Returns
+    -------
 
     >>> from os.path import abspath
     >>> transform_path_to_dotted([abspath("/foo")], abspath('/foo/bar/baz.py'))
     (('bar', 'baz'), False)
-
-    Returns (None, False) if the path doesn't really resolve to anything.
-    The second return part is if it is a package.
     """
     # First remove the suffix.
     module_path = remove_python_path_suffix(module_path)
@@ -239,6 +360,7 @@
         module_path = module_path[:-len('__init__') - 1]
 
     def iter_potential_solutions():
+        """ """
         for p in sys_path:
             if module_path.startswith(p):
                 # Strip the trailing slash/backslash
