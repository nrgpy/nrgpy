# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/test_strings.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/test_strings.py
@@ -14,6 +14,19 @@
 
 
 def assert_series_or_index_equal(left, right):
+    """
+
+    Parameters
+    ----------
+    left :
+        
+    right :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(left, Series):
         tm.assert_series_equal(left, right)
     else:  # Index
@@ -114,11 +127,15 @@
 
 @pytest.fixture(params=_any_string_method, ids=ids)
 def any_string_method(request):
-    """
-    Fixture for all public methods of `StringMethods`
-
+    """Fixture for all public methods of `StringMethods`
+    
     This fixture returns a tuple of the method name and sample arguments
     necessary to call the method.
+
+    Parameters
+    ----------
+    request :
+        
 
     Returns
     -------
@@ -155,15 +172,19 @@
 
 @pytest.fixture(params=_any_allowed_skipna_inferred_dtype, ids=ids)
 def any_allowed_skipna_inferred_dtype(request):
-    """
-    Fixture for all (inferred) dtypes allowed in StringMethods.__init__
-
+    """Fixture for all (inferred) dtypes allowed in StringMethods.__init__
+    
     The covered (inferred) types are:
     * 'string'
     * 'empty'
     * 'bytes'
     * 'mixed'
     * 'mixed-integer'
+
+    Parameters
+    ----------
+    request :
+        
 
     Returns
     -------
@@ -193,13 +214,16 @@
 
 
 class TestStringMethods:
+    """ """
     def test_api(self):
+        """ """
 
         # GH 6106, GH 9322
         assert Series.str is strings.StringMethods
         assert isinstance(Series([""]).str, strings.StringMethods)
 
     def test_api_mi_raises(self):
+        """ """
         # GH 23679
         mi = MultiIndex.from_arrays([["a", "b", "c"]])
         msg = "Can only use .str accessor with Index, not MultiIndex"
@@ -209,6 +233,21 @@
 
     @pytest.mark.parametrize("dtype", [object, "category"])
     def test_api_per_dtype(self, index_or_series, dtype, any_skipna_inferred_dtype):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        dtype :
+            
+        any_skipna_inferred_dtype :
+            
+
+        Returns
+        -------
+
+        """
         # one instance of parametrized fixture
         box = index_or_series
         inferred_dtype, values = any_skipna_inferred_dtype
@@ -242,6 +281,25 @@
         any_string_method,
         request,
     ):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        dtype :
+            
+        any_allowed_skipna_inferred_dtype :
+            
+        any_string_method :
+            
+        request :
+            
+
+        Returns
+        -------
+
+        """
         # this test does not check correctness of the different methods,
         # just that the methods work on the specified (inferred) dtypes,
         # and raise on all others
@@ -300,6 +358,17 @@
                 method(*args, **kwargs)
 
     def test_api_for_categorical(self, any_string_method):
+        """
+
+        Parameters
+        ----------
+        any_string_method :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/10661
         s = Series(list("aabb"))
         s = s + " " + s
@@ -320,6 +389,7 @@
             assert result == expected
 
     def test_iter(self):
+        """ """
         # GH3638
         strs = "google", "wikimedia", "wikipedia", "wikitravel"
         ds = Series(strs)
@@ -343,6 +413,7 @@
         assert s.dropna().values.item() == "l"
 
     def test_iter_empty(self):
+        """ """
         ds = Series([], dtype=object)
 
         i, s = 100, 1
@@ -357,6 +428,7 @@
         assert s == 1
 
     def test_iter_single_element(self):
+        """ """
         ds = Series(["a"])
 
         with tm.assert_produces_warning(FutureWarning):
@@ -367,6 +439,7 @@
         tm.assert_series_equal(ds, s)
 
     def test_iter_object_try_string(self):
+        """ """
         ds = Series([slice(None, randint(10), randint(10, 20)) for _ in range(4)])
 
         i, s = 100, "h"
@@ -380,6 +453,19 @@
 
     @pytest.mark.parametrize("other", [None, Series, Index])
     def test_str_cat_name(self, index_or_series, other):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         # GH 21053
         box = index_or_series
         values = ["a", "b"]
@@ -391,6 +477,17 @@
         assert result.name == "name"
 
     def test_str_cat(self, index_or_series):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+
+        Returns
+        -------
+
+        """
         box = index_or_series
         # test_cat above tests "str_cat" from ndarray;
         # here testing "str.cat" from Series/Indext to ndarray/list
@@ -431,6 +528,17 @@
             s.str.cat(list(z))
 
     def test_str_cat_raises_intuitive_error(self, index_or_series):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+
+        Returns
+        -------
+
+        """
         # GH 11334
         box = index_or_series
         s = box(["a", "b", "c", "d"])
@@ -446,6 +554,23 @@
     def test_str_cat_categorical(
         self, index_or_series, dtype_caller, dtype_target, sep
     ):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        dtype_caller :
+            
+        dtype_target :
+            
+        sep :
+            
+
+        Returns
+        -------
+
+        """
         box = index_or_series
 
         s = Index(["a", "a", "b", "a"], dtype=dtype_caller)
@@ -491,6 +616,19 @@
         ids=["Series", "Index", "list", "np.array"],
     )
     def test_str_cat_wrong_dtype_raises(self, box, data):
+        """
+
+        Parameters
+        ----------
+        box :
+            
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # GH 22722
         s = Series(["a", "b", "c"])
         t = box(data)
@@ -501,6 +639,17 @@
             s.str.cat(t, join="outer", na_rep="-")
 
     def test_str_cat_mixed_inputs(self, index_or_series):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+
+        Returns
+        -------
+
+        """
         box = index_or_series
         s = Index(["a", "b", "c", "d"])
         s = s if box == Index else Series(s, index=s)
@@ -603,6 +752,19 @@
 
     @pytest.mark.parametrize("join", ["left", "outer", "inner", "right"])
     def test_str_cat_align_indexed(self, index_or_series, join):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        join :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/18657
         box = index_or_series
 
@@ -622,6 +784,17 @@
 
     @pytest.mark.parametrize("join", ["left", "outer", "inner", "right"])
     def test_str_cat_align_mixed_inputs(self, join):
+        """
+
+        Parameters
+        ----------
+        join :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(["a", "b", "c", "d"])
         t = Series(["d", "a", "e", "b"], index=[3, 0, 4, 1])
         d = concat([t, t], axis=1)
@@ -664,6 +837,19 @@
             s.str.cat([t, z], join=join)
 
     def test_str_cat_all_na(self, index_or_series, index_or_series2):
+        """
+
+        Parameters
+        ----------
+        index_or_series :
+            
+        index_or_series2 :
+            
+
+        Returns
+        -------
+
+        """
         # GH 24044
         box = index_or_series
         other = index_or_series2
@@ -690,6 +876,7 @@
             tm.assert_series_equal(result, expected)
 
     def test_str_cat_special_cases(self):
+        """ """
         s = Series(["a", "b", "c", "d"])
         t = Series(["d", "a", "e", "b"], index=[3, 0, 4, 1])
 
@@ -704,6 +891,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_cat_on_filtered_index(self):
+        """ """
         df = DataFrame(
             index=MultiIndex.from_product(
                 [[2011, 2012], [1, 2, 3]], names=["year", "month"]
@@ -724,6 +912,7 @@
         assert str_multiple.loc[1] == "2011 2 2"
 
     def test_count(self):
+        """ """
         values = np.array(
             ["foo", "foofoo", np.nan, "foooofooofommmfoo"], dtype=np.object_
         )
@@ -752,6 +941,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_contains(self):
+        """ """
         values = np.array(
             ["foo", np.nan, "fooommm__foo", "mmm_", "foommm[_]+bar"], dtype=np.object_
         )
@@ -820,6 +1010,7 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_contains_for_object_category(self):
+        """ """
         # gh 22158
 
         # na for category
@@ -846,6 +1037,21 @@
     @pytest.mark.parametrize("null_value", [None, np.nan, pd.NA])
     @pytest.mark.parametrize("na", [True, False])
     def test_startswith(self, dtype, null_value, na):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        null_value :
+            
+        na :
+            
+
+        Returns
+        -------
+
+        """
         # add category dtype parametrizations for GH-36241
         values = Series(
             ["om", null_value, "foo_nom", "nom", "bar_foo", null_value, "foo"],
@@ -883,6 +1089,21 @@
     @pytest.mark.parametrize("null_value", [None, np.nan, pd.NA])
     @pytest.mark.parametrize("na", [True, False])
     def test_endswith(self, dtype, null_value, na):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        null_value :
+            
+        na :
+            
+
+        Returns
+        -------
+
+        """
         # add category dtype parametrizations for GH-36241
         values = Series(
             ["om", null_value, "foo_nom", "nom", "bar_foo", null_value, "foo"],
@@ -917,6 +1138,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_title(self):
+        """ """
         values = Series(["FOO", "BAR", np.nan, "Blah", "blurg"])
 
         result = values.str.title()
@@ -934,6 +1156,7 @@
         tm.assert_almost_equal(mixed, exp)
 
     def test_lower_upper(self):
+        """ """
         values = Series(["om", np.nan, "nom", "nom"])
 
         result = values.str.upper()
@@ -952,6 +1175,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_capitalize(self):
+        """ """
         values = Series(["FOO", "BAR", np.nan, "Blah", "blurg"])
         result = values.str.capitalize()
         exp = Series(["Foo", "Bar", np.nan, "Blah", "Blurg"])
@@ -968,6 +1192,7 @@
         tm.assert_almost_equal(mixed, exp)
 
     def test_swapcase(self):
+        """ """
         values = Series(["FOO", "BAR", np.nan, "Blah", "blurg"])
         result = values.str.swapcase()
         exp = Series(["foo", "bar", np.nan, "bLAH", "BLURG"])
@@ -984,6 +1209,7 @@
         tm.assert_almost_equal(mixed, exp)
 
     def test_casemethods(self):
+        """ """
         values = ["aaa", "bbb", "CCC", "Dddd", "eEEE"]
         s = Series(values)
         assert s.str.lower().tolist() == [v.lower() for v in values]
@@ -993,6 +1219,7 @@
         assert s.str.swapcase().tolist() == [v.swapcase() for v in values]
 
     def test_replace(self):
+        """ """
         values = Series(["fooBAD__barBAD", np.nan])
 
         result = values.str.replace("BAD[_]*", "")
@@ -1029,6 +1256,7 @@
                         values.str.replace("a", repl)
 
     def test_replace_callable(self):
+        """ """
         # GH 15055
         values = Series(["fooBAD__barBAD", np.nan])
 
@@ -1065,6 +1293,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_replace_compiled_regex(self):
+        """ """
         # GH 15446
         values = Series(["fooBAD__barBAD", np.nan])
 
@@ -1118,6 +1347,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_replace_literal(self):
+        """ """
         # GH16808 literal replace (regex=False vs regex=True)
         values = Series(["f.o", "foo", np.nan])
         exp = Series(["bao", "bao", np.nan])
@@ -1142,6 +1372,7 @@
             values.str.replace(compiled_pat, "", regex=False)
 
     def test_repeat(self):
+        """ """
         values = Series(["a", "b", np.nan, "c", np.nan, "d"])
 
         result = values.str.repeat(3)
@@ -1163,6 +1394,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_repeat_with_null(self):
+        """ """
         # GH: 31632
         values = Series(["a", None], dtype="string")
         result = values.str.repeat([3, 4])
@@ -1175,6 +1407,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_match(self):
+        """ """
         # New match behavior introduced in 0.13
         values = Series(["fooBAD__barBAD", np.nan, "foo"])
         result = values.str.match(".*(BAD[_]+).*(BAD)")
@@ -1214,6 +1447,7 @@
         tm.assert_series_equal(exp, res)
 
     def test_fullmatch(self):
+        """ """
         # GH 32806
         values = Series(["fooBAD__barBAD", "BAD_BADleroybrown", np.nan, "foo"])
         result = values.str.fullmatch(".*BAD[_]+.*BAD")
@@ -1230,11 +1464,13 @@
         tm.assert_series_equal(result, string_exp)
 
     def test_extract_expand_None(self):
+        """ """
         values = Series(["fooBAD__barBAD", np.nan, "foo"])
         with pytest.raises(ValueError, match="expand must be True or False"):
             values.str.extract(".*(BAD[_]+).*(BAD)", expand=None)
 
     def test_extract_expand_unspecified(self):
+        """ """
         values = Series(["fooBAD__barBAD", np.nan, "foo"])
         result_unspecified = values.str.extract(".*(BAD[_]+).*")
         assert isinstance(result_unspecified, DataFrame)
@@ -1242,6 +1478,7 @@
         tm.assert_frame_equal(result_unspecified, result_true)
 
     def test_extract_expand_False(self):
+        """ """
         # Contains tests like those in test_match and some others.
         values = Series(["fooBAD__barBAD", np.nan, "foo"])
         er = [np.nan, np.nan]  # empty row
@@ -1381,6 +1618,17 @@
         # GH6348
         # not passing index to the extractor
         def check_index(index):
+            """
+
+            Parameters
+            ----------
+            index :
+                
+
+            Returns
+            -------
+
+            """
             data = ["A1", "B2", "C"]
             index = index[: len(data)]
             s = Series(data, index=index)
@@ -1414,6 +1662,7 @@
         assert r.name == e.name
 
     def test_extract_expand_True(self):
+        """ """
         # Contains tests like those in test_match and some others.
         values = Series(["fooBAD__barBAD", np.nan, "foo"])
         er = [np.nan, np.nan]  # empty row
@@ -1461,6 +1710,7 @@
             tm.assert_series_equal(result_series, Series(["A", "A"], name="uno"))
 
     def test_extract_series(self):
+        """ """
         # extract should give the same result whether or not the
         # series has a name.
         for series_name in None, "series_name":
@@ -1509,6 +1759,7 @@
             tm.assert_frame_equal(result, exp)
 
     def test_extract_optional_groups(self):
+        """ """
 
         # two normal groups, one non-capturing group
         result = Series(["A11", "B22", "C33"]).str.extract(
@@ -1536,6 +1787,17 @@
         # GH6348
         # not passing index to the extractor
         def check_index(index):
+            """
+
+            Parameters
+            ----------
+            index :
+                
+
+            Returns
+            -------
+
+            """
             data = ["A1", "B2", "C"]
             index = index[: len(data)]
             result = Series(data, index=index).str.extract(r"(\d)", expand=True)
@@ -1561,6 +1823,7 @@
             check_index(index())
 
     def test_extract_single_group_returns_frame(self):
+        """ """
         # GH11386 extract should always return DataFrame, even when
         # there is only one group. Prior to v0.18.0, extract returned
         # Series when there was only one group in the regex.
@@ -1570,6 +1833,7 @@
         tm.assert_frame_equal(r, e)
 
     def test_extractall(self):
+        """ """
         subject_list = [
             "dave@google.com",
             "tdhock5@gmail.com",
@@ -1672,6 +1936,7 @@
         tm.assert_frame_equal(computed_df, expected_df)
 
     def test_extractall_single_group(self):
+        """ """
         # extractall(one named group) returns DataFrame with one named
         # column.
         s = Series(["a3", "b3", "d4c2"], name="series_name")
@@ -1689,6 +1954,7 @@
         tm.assert_frame_equal(r, e)
 
     def test_extractall_single_group_with_quantifier(self):
+        """ """
         # extractall(one un-named group with quantifier) returns
         # DataFrame with one un-named column (GH13382).
         s = Series(["ab3", "abc3", "d4cd2"], name="series_name")
@@ -1713,6 +1979,19 @@
         ],
     )
     def test_extractall_no_matches(self, data, names):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        names :
+            
+
+        Returns
+        -------
+
+        """
         # GH19075 extractall with no matches should return a valid MultiIndex
         n = len(data)
         if len(names) == 1:
@@ -1749,6 +2028,7 @@
         tm.assert_frame_equal(r, e)
 
     def test_extractall_stringindex(self):
+        """ """
         s = Series(["a1a2", "b1", "c1"], name="xxx")
         res = s.str.extractall(r"[ab](?P<digit>\d)")
         exp_idx = MultiIndex.from_tuples(
@@ -1780,6 +2060,7 @@
         tm.assert_frame_equal(res, exp)
 
     def test_extractall_errors(self):
+        """ """
         # Does not make sense to use extractall with a regex that has
         # no capture groups. (it returns DataFrame with one column for
         # each capture group)
@@ -1788,6 +2069,7 @@
             s.str.extractall(r"[a-z]")
 
     def test_extract_index_one_two_groups(self):
+        """ """
         s = Series(["a3", "b3", "d4c2"], index=["A3", "B3", "D4"], name="series_name")
         r = s.index.str.extract(r"([A-Z])", expand=True)
         e = DataFrame(["A", "B", "D"])
@@ -1802,6 +2084,7 @@
         tm.assert_frame_equal(r, e)
 
     def test_extractall_same_as_extract(self):
+        """ """
         s = Series(["a3", "b3", "c2"], name="series_name")
 
         pattern_two_noname = r"([a-z])([0-9])"
@@ -1829,6 +2112,7 @@
         tm.assert_frame_equal(extract_one_noname, no_multi_index)
 
     def test_extractall_same_as_extract_subject_index(self):
+        """ """
         # same as above tests, but s has an MultiIndex.
         i = MultiIndex.from_tuples(
             [("A", "first"), ("B", "second"), ("C", "third")],
@@ -1861,6 +2145,7 @@
         tm.assert_frame_equal(extract_one_noname, no_match_index)
 
     def test_empty_str_methods(self):
+        """ """
         empty_str = empty = Series(dtype=object)
         empty_int = Series(dtype="int64")
         empty_bool = Series(dtype=bool)
@@ -1931,12 +2216,14 @@
         tm.assert_series_equal(empty_str, empty.str.translate(table))
 
     def test_empty_str_methods_to_frame(self):
+        """ """
         empty = Series(dtype=str)
         empty_df = DataFrame()
         tm.assert_frame_equal(empty_df, empty.str.partition("a"))
         tm.assert_frame_equal(empty_df, empty.str.rpartition("a"))
 
     def test_ismethods(self):
+        """ """
         values = ["A", "b", "Xy", "4", "3A", "", "TT", "55", "-", "  "]
         str_s = Series(values)
         alnum_e = [True, True, True, True, True, False, True, True, False, False]
@@ -1979,6 +2266,7 @@
         assert str_s.str.istitle().tolist() == [v.istitle() for v in values]
 
     def test_isnumeric(self):
+        """ """
         # 0x00bc: ¼ VULGAR FRACTION ONE QUARTER
         # 0x2605: ★ not number
         # 0x1378: ፸ ETHIOPIC NUMBER SEVENTY
@@ -2002,6 +2290,7 @@
         tm.assert_series_equal(s.str.isdecimal(), Series(decimal_e))
 
     def test_get_dummies(self):
+        """ """
         s = Series(["a|b", "a|c", np.nan])
         result = s.str.get_dummies("|")
         expected = DataFrame([[1, 1, 0], [1, 0, 1], [0, 0, 0]], columns=list("abc"))
@@ -2022,6 +2311,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_get_dummies_with_name_dummy(self):
+        """ """
         # GH 12180
         # Dummies named 'name' should work as expected
         s = Series(["a", "b,name", "b"])
@@ -2040,6 +2330,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_join(self):
+        """ """
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
         result = values.str.split("_").str.join("_")
         tm.assert_series_equal(values, result)
@@ -2078,6 +2369,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_len(self):
+        """ """
         values = Series(["foo", "fooo", "fooooo", np.nan, "fooooooo"])
 
         result = values.str.len()
@@ -2106,6 +2398,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_findall(self):
+        """ """
         values = Series(["fooBAD__barBAD", np.nan, "foo", "BAD"])
 
         result = values.str.findall("BAD[_]*")
@@ -2146,6 +2439,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_find(self):
+        """ """
         values = Series(["ABCDEFG", "BCDEFEF", "DEFGHIJEF", "EFGHEF", "XXXX"])
         result = values.str.find("EF")
         tm.assert_series_equal(result, Series([4, 3, 1, 0, -1]))
@@ -2186,6 +2480,7 @@
             result = values.str.rfind(0)
 
     def test_find_nan(self):
+        """ """
         values = Series(["ABCDEFG", np.nan, "DEFGHIJEF", np.nan, "XXXX"])
         result = values.str.find("EF")
         tm.assert_series_equal(result, Series([4, np.nan, 1, np.nan, -1]))
@@ -2206,7 +2501,21 @@
         tm.assert_series_equal(result, Series([4, np.nan, -1, np.nan, -1]))
 
     def test_index(self):
+        """ """
         def _check(result, expected):
+            """
+
+            Parameters
+            ----------
+            result :
+                
+            expected :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(result, Series):
                 tm.assert_series_equal(result, expected)
             else:
@@ -2260,6 +2569,7 @@
         tm.assert_series_equal(result, Series([3, 1, 2, np.nan]))
 
     def test_pad(self):
+        """ """
         values = Series(["a", "b", np.nan, "c", np.nan, "eeeeee"])
 
         result = values.str.pad(5, side="left")
@@ -2306,6 +2616,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_pad_fillchar(self):
+        """ """
 
         values = Series(["a", "b", np.nan, "c", np.nan, "eeeeee"])
 
@@ -2331,6 +2642,17 @@
 
     @pytest.mark.parametrize("f", ["center", "ljust", "rjust", "zfill", "pad"])
     def test_pad_width(self, f):
+        """
+
+        Parameters
+        ----------
+        f :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-13598
         s = Series(["1", "22", "a", "bb"])
         msg = "width must be of integer type, not*"
@@ -2339,7 +2661,21 @@
             getattr(s.str, f)("f")
 
     def test_translate(self):
+        """ """
         def _check(result, expected):
+            """
+
+            Parameters
+            ----------
+            result :
+                
+            expected :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(result, Series):
                 tm.assert_series_equal(result, expected)
             else:
@@ -2359,6 +2695,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_center_ljust_rjust(self):
+        """ """
         values = Series(["a", "b", np.nan, "c", np.nan, "eeeeee"])
 
         result = values.str.center(5)
@@ -2433,6 +2770,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_center_ljust_rjust_fillchar(self):
+        """ """
         values = Series(["a", "bb", "cccc", "ddddd", "eeeeee"])
 
         result = values.str.center(5, fillchar="X")
@@ -2477,6 +2815,7 @@
             values.str.rjust(5, fillchar=1)
 
     def test_zfill(self):
+        """ """
         values = Series(["1", "22", "aaa", "333", "45678"])
 
         result = values.str.zfill(5)
@@ -2497,6 +2836,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_split(self):
+        """ """
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
 
         result = values.str.split("_")
@@ -2540,6 +2880,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_rsplit(self):
+        """ """
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
         result = values.str.rsplit("_")
         exp = Series([["a", "b", "c"], ["c", "d", "e"], np.nan, ["f", "g", "h"]])
@@ -2588,6 +2929,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_split_blank_string(self):
+        """ """
         # expand blank split GH 20067
         values = Series([""], name="test")
         result = values.str.split(expand=True)
@@ -2607,6 +2949,7 @@
         tm.assert_frame_equal(result, exp)
 
     def test_split_noargs(self):
+        """ """
         # #1859
         s = Series(["Wes McKinney", "Travis  Oliphant"])
         result = s.str.split()
@@ -2616,6 +2959,7 @@
         assert result[1] == expected
 
     def test_split_maxsplit(self):
+        """ """
         # re.split 0, str.split -1
         s = Series(["bd asdf jfg", "kjasdflqw asdfnfk"])
 
@@ -2634,12 +2978,14 @@
         tm.assert_series_equal(result, xp)
 
     def test_split_no_pat_with_nonzero_n(self):
+        """ """
         s = Series(["split once", "split once too!"])
         result = s.str.split(n=1)
         expected = Series({0: ["split", "once"], 1: ["split", "once too!"]})
         tm.assert_series_equal(expected, result, check_index_type=False)
 
     def test_split_to_dataframe(self):
+        """ """
         s = Series(["nosplit", "alsonosplit"])
         result = s.str.split("_", expand=True)
         exp = DataFrame({0: Series(["nosplit", "alsonosplit"])})
@@ -2677,6 +3023,7 @@
             s.str.split("_", expand="not_a_boolean")
 
     def test_split_to_multiindex_expand(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/23677
 
         idx = Index(["nosplit", "alsonosplit", np.nan])
@@ -2715,6 +3062,7 @@
             idx.str.split("_", expand="not_a_boolean")
 
     def test_rsplit_to_dataframe_expand(self):
+        """ """
         s = Series(["nosplit", "alsonosplit"])
         result = s.str.rsplit("_", expand=True)
         exp = DataFrame({0: Series(["nosplit", "alsonosplit"])})
@@ -2745,6 +3093,7 @@
         tm.assert_frame_equal(result, exp)
 
     def test_rsplit_to_multiindex_expand(self):
+        """ """
         idx = Index(["nosplit", "alsonosplit"])
         result = idx.str.rsplit("_", expand=True)
         exp = idx
@@ -2766,6 +3115,7 @@
         assert result.nlevels == 2
 
     def test_split_nan_expand(self):
+        """ """
         # gh-18450
         s = Series(["foo,bar,baz", np.nan])
         result = s.str.split(",", expand=True)
@@ -2778,6 +3128,7 @@
         assert all(np.isnan(x) for x in result.iloc[1])
 
     def test_split_with_name(self):
+        """ """
         # GH 12617
 
         # should preserve name
@@ -2802,6 +3153,7 @@
         tm.assert_index_equal(res, exp)
 
     def test_partition_series(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/23558
 
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h", None])
@@ -2887,6 +3239,7 @@
         assert result == [v.rpartition("_") for v in values]
 
     def test_partition_index(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/23558
 
         values = Index(["a_b_c", "c_d_e", "f_g_h", np.nan, None])
@@ -2940,6 +3293,7 @@
         assert result.nlevels == 3
 
     def test_partition_to_dataframe(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/23558
 
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h", None])
@@ -2985,6 +3339,7 @@
         tm.assert_frame_equal(result, exp)
 
     def test_partition_with_name(self):
+        """ """
         # GH 12617
 
         s = Series(["a,b", "c,d"], name="xxx")
@@ -3010,6 +3365,7 @@
         tm.assert_index_equal(res, exp)
 
     def test_partition_sep_kwarg(self):
+        """ """
         # GH 22676; depr kwarg "pat" in favor of "sep"
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
 
@@ -3022,6 +3378,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_pipe_failures(self):
+        """ """
         # #2119
         s = Series(["A|B|C"])
 
@@ -3046,6 +3403,23 @@
         ],
     )
     def test_slice(self, start, stop, step, expected):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        stop :
+            
+        step :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         values = Series(["aafootwo", "aabartwo", np.nan, "aabazqux"])
         result = values.str.slice(start, stop, step)
         tm.assert_series_equal(result, expected)
@@ -3065,6 +3439,7 @@
         xp = Series(["oof", np.nan, "rab", np.nan, np.nan, np.nan, np.nan, np.nan])
 
     def test_slice_replace(self):
+        """ """
         values = Series(["short", "a bit longer", "evenlongerthanthat", "", np.nan])
 
         exp = Series(["shrt", "a it longer", "evnlongerthanthat", "", np.nan])
@@ -3100,6 +3475,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_strip_lstrip_rstrip(self):
+        """ """
         values = Series(["  aa   ", " bb \n", np.nan, "cc  "])
 
         result = values.str.strip()
@@ -3115,6 +3491,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_strip_lstrip_rstrip_mixed(self):
+        """ """
         # mixed
         mixed = Series(
             ["  aa  ", np.nan, " bb \t\n", True, datetime.today(), None, 1, 2.0]
@@ -3139,6 +3516,7 @@
         tm.assert_almost_equal(rs, xp)
 
     def test_strip_lstrip_rstrip_args(self):
+        """ """
         values = Series(["xxABCxx", "xx BNSD", "LDFJH xx"])
 
         rs = values.str.strip("x")
@@ -3154,6 +3532,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_wrap(self):
+        """ """
         # test values are: two words less than width, two words equal to width,
         # two words greater than width, one word less than width, one word
         # equal to width, one word greater than width, multiple tokens with
@@ -3198,6 +3577,7 @@
         tm.assert_series_equal(rs, xp)
 
     def test_get(self):
+        """ """
         values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
 
         result = values.str.split("_").str.get(1)
@@ -3227,6 +3607,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_get_complex(self):
+        """ """
         # GH 20671, getting value not in dict raising `KeyError`
         values = Series([(1, 2, 3), [1, 2, 3], {1, 2, 3}, {1: "a", 2: "b", 3: "c"}])
 
@@ -3240,6 +3621,17 @@
 
     @pytest.mark.parametrize("to_type", [tuple, list, np.array])
     def test_get_complex_nested(self, to_type):
+        """
+
+        Parameters
+        ----------
+        to_type :
+            
+
+        Returns
+        -------
+
+        """
         values = Series([to_type([to_type([1, 2])])])
 
         result = values.str.get(0)
@@ -3251,6 +3643,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_contains_moar(self):
+        """ """
         # PR #1179
         s = Series(["A", "B", "C", "Aaba", "Baca", "", np.nan, "CABA", "dog", "cat"])
 
@@ -3285,6 +3678,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_contains_nan(self):
+        """ """
         # PR #14171
         s = Series([np.nan, np.nan, np.nan], dtype=np.object_)
 
@@ -3305,6 +3699,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_replace_moar(self):
+        """ """
         # PR #1179
         s = Series(["A", "B", "C", "Aaba", "Baca", "", np.nan, "CABA", "dog", "cat"])
 
@@ -3349,6 +3744,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_string_slice_get_syntax(self):
+        """ """
         s = Series(
             [
                 "YYY",
@@ -3376,6 +3772,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_string_slice_out_of_bounds(self):
+        """ """
         s = Series([(1, 2), (1,), (3, 4, 5)])
 
         result = s.str[1]
@@ -3389,6 +3786,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_match_findall_flags(self):
+        """ """
         data = {
             "Dave": "dave@google.com",
             "Steve": "steve@gmail.com",
@@ -3419,6 +3817,7 @@
         assert result[0]
 
     def test_encode_decode(self):
+        """ """
         base = Series(["a", "b", "a\xe4"])
         series = base.str.encode("utf-8")
 
@@ -3429,6 +3828,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_encode_decode_errors(self):
+        """ """
         encodeBase = Series(["a", "b", "a\x9d"])
 
         msg = (
@@ -3459,6 +3859,7 @@
         tm.assert_series_equal(result, exp)
 
     def test_normalize(self):
+        """ """
         values = ["ABC", "ＡＢＣ", "１２３", np.nan, "ｱｲｴ"]
         s = Series(values, index=["a", "b", "c", "d", "e"])
 
@@ -3484,6 +3885,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_index_str_accessor_visibility(self):
+        """ """
         from pandas.core.strings import StringMethods
 
         cases = [
@@ -3527,18 +3929,21 @@
             idx.str
 
     def test_str_accessor_no_new_attributes(self):
+        """ """
         # https://github.com/pandas-dev/pandas/issues/10673
         s = Series(list("aabbcde"))
         with pytest.raises(AttributeError, match="You cannot add any new attribute"):
             s.str.xlabel = "a"
 
     def test_method_on_bytes(self):
+        """ """
         lhs = Series(np.array(list("abc"), "S1").astype(object))
         rhs = Series(np.array(list("def"), "S1").astype(object))
         with pytest.raises(TypeError, match="Cannot use .str.cat with values of.*"):
             lhs.str.cat(rhs)
 
     def test_casefold(self):
+        """ """
         # GH25405
         expected = Series(["ss", np.nan, "case", "ssd"])
         s = Series(["ß", np.nan, "case", "ßd"])
@@ -3548,6 +3953,17 @@
 
 
 def test_string_array(any_string_method):
+    """
+
+    Parameters
+    ----------
+    any_string_method :
+        
+
+    Returns
+    -------
+
+    """
     method_name, args, kwargs = any_string_method
     if method_name == "decode":
         pytest.skip("decode requires bytes.")
@@ -3597,6 +4013,19 @@
     ],
 )
 def test_string_array_numeric_integer_array(method, expected):
+    """
+
+    Parameters
+    ----------
+    method :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     s = Series(["aba", None], dtype="string")
     result = getattr(s.str, method)("a")
     expected = Series(expected, dtype="Int64")
@@ -3613,6 +4042,19 @@
     ],
 )
 def test_string_array_boolean_array(method, expected):
+    """
+
+    Parameters
+    ----------
+    method :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     s = Series(["a", None, "1"], dtype="string")
     result = getattr(s.str, method)()
     expected = Series(expected, dtype="boolean")
@@ -3620,6 +4062,7 @@
 
 
 def test_string_array_extract():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/30969
     # Only expand=False & multiple groups was failing
     a = Series(["a1", "b2", "cc"], dtype="string")
@@ -3636,6 +4079,17 @@
 
 @pytest.mark.parametrize("klass", [tuple, list, np.array, pd.Series, pd.Index])
 def test_cat_different_classes(klass):
+    """
+
+    Parameters
+    ----------
+    klass :
+        
+
+    Returns
+    -------
+
+    """
     # https://github.com/pandas-dev/pandas/issues/33425
     s = pd.Series(["a", "b", "c"])
     result = s.str.cat(klass(["x", "y", "z"]))
