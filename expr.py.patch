# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/computation/expr.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/computation/expr.py
@@ -36,38 +36,44 @@
 
 
 def _rewrite_assign(tok: Tuple[int, str]) -> Tuple[int, str]:
-    """
-    Rewrite the assignment operator for PyTables expressions that use ``=``
+    """Rewrite the assignment operator for PyTables expressions that use ``=``
     as a substitute for ``==``.
 
     Parameters
     ----------
     tok : tuple of int, str
         ints correspond to the all caps constants in the tokenize module
+    tok: Tuple[int :
+        
+    str] :
+        
 
     Returns
     -------
-    tuple of int, str
-        Either the input or token or the replacement values
+
+    
     """
     toknum, tokval = tok
     return toknum, "==" if tokval == "=" else tokval
 
 
 def _replace_booleans(tok: Tuple[int, str]) -> Tuple[int, str]:
-    """
-    Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise
+    """Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise
     precedence is changed to boolean precedence.
 
     Parameters
     ----------
     tok : tuple of int, str
         ints correspond to the all caps constants in the tokenize module
+    tok: Tuple[int :
+        
+    str] :
+        
 
     Returns
     -------
-    tuple of int, str
-        Either the input or token or the replacement values
+
+    
     """
     toknum, tokval = tok
     if toknum == tokenize.OP:
@@ -80,13 +86,16 @@
 
 
 def _replace_locals(tok: Tuple[int, str]) -> Tuple[int, str]:
-    """
-    Replace local variables with a syntactically valid name.
+    """Replace local variables with a syntactically valid name.
 
     Parameters
     ----------
     tok : tuple of int, str
         ints correspond to the all caps constants in the tokenize module
+    tok: Tuple[int :
+        
+    str] :
+        
 
     Returns
     -------
@@ -106,15 +115,33 @@
 
 
 def _compose2(f, g):
-    """
-    Compose 2 callables.
+    """Compose 2 callables.
+
+    Parameters
+    ----------
+    f :
+        
+    g :
+        
+
+    Returns
+    -------
+
     """
     return lambda *args, **kwargs: f(g(*args, **kwargs))
 
 
 def _compose(*funcs):
-    """
-    Compose 2 or more callables.
+    """Compose 2 or more callables.
+
+    Parameters
+    ----------
+    *funcs :
+        
+
+    Returns
+    -------
+
     """
     assert len(funcs) > 1, "At least 2 callables must be passed to compose"
     return reduce(_compose2, funcs)
@@ -126,8 +153,7 @@
         _replace_locals, _replace_booleans, _rewrite_assign, clean_backtick_quoted_toks
     ),
 ) -> str:
-    """
-    Compose a collection of tokenization functions.
+    """Compose a collection of tokenization functions.
 
     Parameters
     ----------
@@ -138,6 +164,14 @@
         tuple with the same structure but possibly different elements. Defaults
         to the composition of ``_rewrite_assign``, ``_replace_booleans``, and
         ``_replace_locals``.
+    source: str :
+        
+    _replace_booleans :
+        
+    _rewrite_assign :
+        
+    clean_backtick_quoted_toks) :
+        
 
     Returns
     -------
@@ -155,8 +189,16 @@
 
 
 def _is_type(t):
-    """
-    Factory for a type checking function of type ``t`` or tuple of types.
+    """Factory for a type checking function of type ``t`` or tuple of types.
+
+    Parameters
+    ----------
+    t :
+        
+
+    Returns
+    -------
+
     """
     return lambda x: isinstance(x.value, t)
 
@@ -175,8 +217,18 @@
 
 
 def _filter_nodes(superclass, all_nodes=_all_nodes):
-    """
-    Filter out AST nodes that are subclasses of ``superclass``.
+    """Filter out AST nodes that are subclasses of ``superclass``.
+
+    Parameters
+    ----------
+    superclass :
+        
+    all_nodes :
+         (Default value = _all_nodes)
+
+    Returns
+    -------
+
     """
     node_names = (node.__name__ for node in all_nodes if issubclass(node, superclass))
     return frozenset(node_names)
@@ -243,29 +295,68 @@
 # TODO: Python 3.6.2: replace Callable[..., None] with Callable[..., NoReturn]
 def _node_not_implemented(node_name: str) -> Callable[..., None]:
     """
-    Return a function that raises a NotImplementedError with a passed node name.
-    """
-
-    def f(self, *args, **kwargs):
-        raise NotImplementedError(f"'{node_name}' nodes are not implemented")
-
-    return f
-
-
-_T = TypeVar("_T", bound="BaseExprVisitor")
-
-
-def disallow(nodes: Set[str]) -> Callable[[Type[_T]], Type[_T]]:
-    """
-    Decorator to disallow certain nodes from parsing. Raises a
-    NotImplementedError instead.
+
+    Parameters
+    ----------
+    node_name: str :
+        
 
     Returns
     -------
-    callable
+    type
+        
+
     """
 
+    def f(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
+        raise NotImplementedError(f"'{node_name}' nodes are not implemented")
+
+    return f
+
+
+_T = TypeVar("_T", bound="BaseExprVisitor")
+
+
+def disallow(nodes: Set[str]) -> Callable[[Type[_T]], Type[_T]]:
+    """Decorator to disallow certain nodes from parsing. Raises a
+    NotImplementedError instead.
+
+    Parameters
+    ----------
+    nodes: Set[str] :
+        
+
+    Returns
+    -------
+
+    
+    """
+
     def disallowed(cls: Type[_T]) -> Type[_T]:
+        """
+
+        Parameters
+        ----------
+        cls: Type[_T] :
+            
+
+        Returns
+        -------
+
+        """
         cls.unsupported_nodes = ()
         for node in nodes:
             new_method = _node_not_implemented(node)
@@ -278,21 +369,37 @@
 
 
 def _op_maker(op_class, op_symbol):
-    """
-    Return a function to create an op class with its symbol already passed.
+    """Return a function to create an op class with its symbol already passed.
+
+    Parameters
+    ----------
+    op_class :
+        
+    op_symbol :
+        
 
     Returns
     -------
-    callable
+
+    
     """
 
     def f(self, node, *args, **kwargs):
-        """
-        Return a partial function with an Op subclass with an operator already passed.
-
-        Returns
-        -------
-        callable
+        """Return a partial function with an Op subclass with an operator already passed.
+
+        Parameters
+        ----------
+        node :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        
         """
         return partial(op_class, op_symbol, *args, **kwargs)
 
@@ -303,11 +410,20 @@
 
 
 def add_ops(op_classes):
+    """Decorator to add default implementation of ops.
+
+    Parameters
+    ----------
+    op_classes :
+        
+
+    Returns
+    -------
+
     """
-    Decorator to add default implementation of ops.
-    """
 
     def f(cls):
+        """ """
         for op_attr_name, op_class in op_classes.items():
             ops = getattr(cls, f"{op_attr_name}_ops")
             ops_map = getattr(cls, f"{op_attr_name}_op_nodes_map")
@@ -324,16 +440,16 @@
 @disallow(_unsupported_nodes)
 @add_ops(_op_classes)
 class BaseExprVisitor(ast.NodeVisitor):
-    """
-    Custom ast walker. Parsers of other engines should subclass this class
+    """Custom ast walker. Parsers of other engines should subclass this class
     if necessary.
 
     Parameters
     ----------
-    env : Scope
-    engine : str
-    parser : str
-    preparser : callable
+
+    Returns
+    -------
+
+    
     """
 
     const_type: Type[Term] = Constant
@@ -384,6 +500,19 @@
         self.assigner = None
 
     def visit(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(node, str):
             clean = self.preparser(node)
             try:
@@ -398,15 +527,56 @@
         return visitor(node, **kwargs)
 
     def visit_Module(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if len(node.body) != 1:
             raise SyntaxError("only a single expression is allowed")
         expr = node.body[0]
         return self.visit(expr, **kwargs)
 
     def visit_Expr(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.visit(node.value, **kwargs)
 
     def _rewrite_membership_op(self, node, left, right):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        left :
+            
+        right :
+            
+
+        Returns
+        -------
+
+        """
         # the kind of the operator (is actually an instance)
         op_instance = node.op
         op_type = type(op_instance)
@@ -435,6 +605,21 @@
         return op, op_instance, left, right
 
     def _maybe_transform_eq_ne(self, node, left=None, right=None):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        left :
+             (Default value = None)
+        right :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if left is None:
             left = self.visit(node.left, side="left")
         if right is None:
@@ -443,6 +628,19 @@
         return op, op_class, left, right
 
     def _maybe_downcast_constants(self, left, right):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+        right :
+            
+
+        Returns
+        -------
+
+        """
         f32 = np.dtype(np.float32)
         if (
             left.is_scalar
@@ -466,6 +664,19 @@
         return left, right
 
     def _maybe_eval(self, binop, eval_in_python):
+        """
+
+        Parameters
+        ----------
+        binop :
+            
+        eval_in_python :
+            
+
+        Returns
+        -------
+
+        """
         # eval `in` and `not in` (for now) in "partial" python space
         # things that can be evaluated in "eval" space will be turned into
         # temporary variables. for example,
@@ -485,6 +696,39 @@
         eval_in_python=("in", "not in"),
         maybe_eval_in_python=("==", "!=", "<", ">", "<=", ">="),
     ):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        op_class :
+            
+        lhs :
+            
+        rhs :
+            
+        eval_in_python :
+             (Default value = ("in")
+        "not in") :
+            
+        maybe_eval_in_python :
+             (Default value = ("==")
+        "! :
+             (Default value = ")
+        "<" :
+            
+        ">" :
+            
+        "< :
+             (Default value = ")
+        "> :
+             (Default value = "))
+
+        Returns
+        -------
+
+        """
         res = op(lhs, rhs)
 
         if res.has_invalid_return_type:
@@ -517,45 +761,187 @@
         return res
 
     def visit_BinOp(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         op, op_class, left, right = self._maybe_transform_eq_ne(node)
         left, right = self._maybe_downcast_constants(left, right)
         return self._maybe_evaluate_binop(op, op_class, left, right)
 
     def visit_Div(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return lambda lhs, rhs: Div(lhs, rhs)
 
     def visit_UnaryOp(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         op = self.visit(node.op)
         operand = self.visit(node.operand)
         return op(operand)
 
     def visit_Name(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.term_type(node.id, self.env, **kwargs)
 
     def visit_NameConstant(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.const_type(node.value, self.env)
 
     def visit_Num(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.const_type(node.n, self.env)
 
     def visit_Constant(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.const_type(node.n, self.env)
 
     def visit_Str(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         name = self.env.add_tmp(node.s)
         return self.term_type(name, self.env)
 
     def visit_List(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         name = self.env.add_tmp([self.visit(e)(self.env) for e in node.elts])
         return self.term_type(name, self.env)
 
     visit_Tuple = visit_List
 
     def visit_Index(self, node, **kwargs):
-        """ df.index[4] """
+        """df.index[4]
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.visit(node.value)
 
     def visit_Subscript(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         import pandas as pd
 
         value = self.visit(node.value)
@@ -576,7 +962,19 @@
         return self.term_type(name, env=self.env)
 
     def visit_Slice(self, node, **kwargs):
-        """ df.index[slice(4,6)] """
+        """df.index[slice(4,6)]
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         lower = node.lower
         if lower is not None:
             lower = self.visit(lower).value
@@ -590,13 +988,22 @@
         return slice(lower, upper, step)
 
     def visit_Assign(self, node, **kwargs):
-        """
-        support a single assignment node, like
-
+        """support a single assignment node, like
+        
         c = a + b
-
+        
         set the assigner at the top level, must be a Name node which
         might or might not exist in the resolvers
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
 
         """
         if len(node.targets) != 1:
@@ -620,6 +1027,19 @@
         return self.visit(node.value, **kwargs)
 
     def visit_Attribute(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         attr = node.attr
         value = node.value
 
@@ -640,6 +1060,21 @@
         raise ValueError(f"Invalid Attribute context {type(ctx).__name__}")
 
     def visit_Call(self, node, side=None, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        side :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
 
         if isinstance(node.func, ast.Attribute) and node.func.attr != "__call__":
             res = self.visit_Attribute(node.func)
@@ -686,9 +1121,33 @@
             return self.const_type(res(*new_args, **kwargs), self.env)
 
     def translate_In(self, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         return op
 
     def visit_Compare(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         ops = node.ops
         comps = node.comparators
 
@@ -710,12 +1169,49 @@
         return self.visit(ast.BoolOp(op=ast.And(), values=values))
 
     def _try_visit_binop(self, bop):
+        """
+
+        Parameters
+        ----------
+        bop :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(bop, (Op, Term)):
             return bop
         return self.visit(bop)
 
     def visit_BoolOp(self, node, **kwargs):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         def visitor(x, y):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+            y :
+                
+
+            Returns
+            -------
+
+            """
             lhs = self._try_visit_binop(x)
             rhs = self._try_visit_binop(y)
 
@@ -735,6 +1231,7 @@
     - (_boolop_nodes | frozenset(["BoolOp", "Attribute", "In", "NotIn", "Tuple"]))
 )
 class PandasExprVisitor(BaseExprVisitor):
+    """ """
     def __init__(
         self,
         env,
@@ -750,22 +1247,13 @@
 
 @disallow(_unsupported_nodes | _python_not_supported | frozenset(["Not"]))
 class PythonExprVisitor(BaseExprVisitor):
+    """ """
     def __init__(self, env, engine, parser, preparser=lambda x: x):
         super().__init__(env, engine, parser, preparser=preparser)
 
 
 class Expr:
-    """
-    Object encapsulating an expression.
-
-    Parameters
-    ----------
-    expr : str
-    engine : str, optional, default 'numexpr'
-    parser : str, optional, default 'pandas'
-    env : Scope, optional, default None
-    level : int, optional, default 2
-    """
+    """Object encapsulating an expression."""
 
     env: Scope
     engine: str
@@ -788,6 +1276,7 @@
 
     @property
     def assigner(self):
+        """ """
         return getattr(self._visitor, "assigner", None)
 
     def __call__(self):
@@ -800,16 +1289,12 @@
         return len(self.expr)
 
     def parse(self):
-        """
-        Parse an expression.
-        """
+        """Parse an expression."""
         return self._visitor.visit(self.expr)
 
     @property
     def names(self):
-        """
-        Get the names in an expression.
-        """
+        """Get the names in an expression."""
         if is_term(self.terms):
             return frozenset([self.terms.name])
         return frozenset(term.name for term in com.flatten(self.terms))
