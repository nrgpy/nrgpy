# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/core/magic.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/core/magic.py
@@ -51,15 +51,23 @@
 
 
 def on_off(tag):
-    """Return an ON/OFF string for a 1/0 input. Simple utility function."""
+    """ """
     return ['OFF','ON'][tag]
 
 
 def compress_dhist(dh):
     """Compress a directory history into a new one with at most 20 entries.
 
-    Return a new list made from the first and last 10 elements of dhist after
-    removal of duplicates.
+    Parameters
+    ----------
+    dh :
+        
+
+    Returns
+    -------
+    type
+        removal of duplicates.
+
     """
     head, tail = dh[:-10], dh[-10:]
 
@@ -75,7 +83,17 @@
 
 
 def needs_local_scope(func):
-    """Decorator to mark magic functions which need to local scope to run."""
+    """Decorator to mark magic functions which need to local scope to run.
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     func.needs_local_scope = True
     return func
 
@@ -85,7 +103,7 @@
 
 def magics_class(cls):
     """Class decorator for all subclasses of the main Magics class.
-
+    
     Any class that subclasses Magics *must* also apply this decorator, to
     ensure that all the methods that have been decorated as line/cell magics
     get correctly registered in the class instance.  This is necessary because
@@ -93,13 +111,20 @@
     temporarily store their information into a module global.  Application of
     this class decorator copies that global data to the class instance and
     clears the global.
-
+    
     Obviously, this mechanism is not thread-safe, which means that the
     *creation* of subclasses of Magic should only be done in a single-thread
     context.  Instantiation of the classes has no restrictions.  Given that
     these classes are typically created at IPython startup time and before user
     application code becomes active, in practice this should not pose any
     problems.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     cls.registered = True
     cls.magics = dict(line = magics['line'],
@@ -114,17 +139,19 @@
 
     Parameters
     ----------
-    dct : dict
-      A dictionary with 'line' and 'cell' subdicts.
-
-    magic_kind : str
-      Kind of magic to be stored.
-
-    magic_name : str
-      Key to store the magic as.
-
-    func : function
-      Callable object to store.
+    dct :
+        
+    magic_kind :
+        
+    magic_name :
+        
+    func :
+        
+
+    Returns
+    -------
+
+    
     """
     if magic_kind == 'line_cell':
         dct['line'][magic_name] = dct['cell'][magic_name] = func
@@ -134,9 +161,18 @@
 
 def validate_type(magic_kind):
     """Ensure that the given magic_kind is valid.
-
+    
     Check that the given magic_kind is one of the accepted spec types (stored
     in the global `magic_spec`), raise ValueError otherwise.
+
+    Parameters
+    ----------
+    magic_kind :
+        
+
+    Returns
+    -------
+
     """
     if magic_kind not in magic_spec:
         raise ValueError('magic_kind must be one of %s, %s given' %
@@ -161,6 +197,17 @@
 
 ii) with one string argument: which will be used as the actual name of the
 resulting magic::
+        """
+
+        Parameters
+        ----------
+        ...)will create a {1} magic named `foo`.ii :
+            
+
+        Returns
+        -------
+
+        """
 
     @deco('bar')
     def foo(...)
@@ -176,14 +223,34 @@
 # and make a single one with convoluted logic.
 
 def _method_magic_marker(magic_kind):
-    """Decorator factory for methods in Magics subclasses.
-    """
+        """Decorator factory for methods in Magics subclasses.
+
+        Parameters
+        ----------
+        ...)will create a {1} magic named `bar`.To register a class magic use ``Interactiveshell.register_magic(class or instance)``."""# These two are decorator factories.  While they are conceptually very similar :
+            
+        # there are enough differences in the details that it's simpler to have them# written as completely standalone functions rather than trying to share code# and make a single one with convoluted logic._method_magic_marker(magic_kind :
+            
+
+        Returns
+        -------
 
     validate_type(magic_kind)
 
     # This is a closure to capture the magic_kind.  We could also use a class,
     # but it's overkill for just that one bit of state.
     def magic_deco(arg):
+        """
+
+        Parameters
+        ----------
+        arg :
+            
+
+        Returns
+        -------
+
+        """
         call = lambda f, *a, **k: f(*a, **k)
 
         if callable(arg):
@@ -196,6 +263,21 @@
             # Decorator called with arguments (@foo('bar'))
             name = arg
             def mark(func, *a, **kw):
+                """
+
+                Parameters
+                ----------
+                func :
+                    
+                *a :
+                    
+                **kw :
+                    
+
+                Returns
+                -------
+
+                """
                 record_magic(magics, magic_kind, name, func.__name__)
                 return decorator(call, func)
             retval = mark
@@ -211,12 +293,32 @@
 
 def _function_magic_marker(magic_kind):
     """Decorator factory for standalone functions.
+
+    Parameters
+    ----------
+    magic_kind :
+        
+
+    Returns
+    -------
+
     """
     validate_type(magic_kind)
     
     # This is a closure to capture the magic_kind.  We could also use a class,
     # but it's overkill for just that one bit of state.
     def magic_deco(arg):
+        """
+
+        Parameters
+        ----------
+        arg :
+            
+
+        Returns
+        -------
+
+        """
         call = lambda f, *a, **k: f(*a, **k)
 
         # Find get_ipython() in the caller's namespace
@@ -241,6 +343,21 @@
             # Decorator called with arguments (@foo('bar'))
             name = arg
             def mark(func, *a, **kw):
+                """
+
+                Parameters
+                ----------
+                func :
+                    
+                *a :
+                    
+                **kw :
+                    
+
+                Returns
+                -------
+
+                """
                 ip.register_magic_function(func, magic_kind, name)
                 return decorator(call, func)
             retval = mark
@@ -270,15 +387,24 @@
 
 def no_var_expand(magic_func):
     """Mark a magic function as not needing variable expansion
-
+    
     By default, IPython interprets `{a}` or `$a` in the line passed to magics
     as variables that should be interpolated from the interactive namespace
     before passing the line to the magic function.
     This is not always desirable, e.g. when the magic executes Python code
     (%timeit, %time, etc.).
     Decorate magics with `@no_var_expand` to opt-out of variable expansion.
-
+    
     .. versionadded:: 7.3
+
+    Parameters
+    ----------
+    magic_func :
+        
+
+    Returns
+    -------
+
     """
     setattr(magic_func, MAGIC_NO_VAR_EXPAND_ATTR, True)
     return magic_func
@@ -302,8 +428,7 @@
 #-----------------------------------------------------------------------------
 
 class MagicsManager(Configurable):
-    """Object that handles all magic-related functionality for IPython.
-    """
+    """Object that handles all magic-related functionality for IPython."""
     # Non-configurable class attributes
 
     # A two-level dict, first keyed by magic type, then by magic function, and
@@ -321,6 +446,17 @@
     ).tag(config=True)
     @observe('auto_magic')
     def _auto_magic_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         self.shell.automagic = change['new']
     
     _auto_status = [
@@ -339,26 +475,44 @@
         self.registry[user_magics.__class__.__name__] = user_magics
 
     def auto_status(self):
-        """Return descriptive string with automagic status."""
+        """ """
         return self._auto_status[self.auto_magic]
     
     def lsmagic(self):
-        """Return a dict of currently available magic functions.
-
-        The return dict has the keys 'line' and 'cell', corresponding to the
-        two types of magics we support.  Each value is a list of names.
+        """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            The return dict has the keys 'line' and 'cell', corresponding to the
+            two types of magics we support.  Each value is a list of names.
+
         """
         return self.magics
 
     def lsmagic_docs(self, brief=False, missing=''):
-        """Return dict of documentation of magic functions.
-
-        The return dict has the keys 'line' and 'cell', corresponding to the
-        two types of magics we support. Each value is a dict keyed by magic
-        name whose value is the function docstring. If a docstring is
-        unavailable, the value of `missing` is used instead.
-
-        If brief is True, only the first line of each docstring will be returned.
+        """
+
+        Parameters
+        ----------
+        brief :
+             (Default value = False)
+        missing :
+             (Default value = '')
+
+        Returns
+        -------
+        type
+            The return dict has the keys 'line' and 'cell', corresponding to the
+            two types of magics we support. Each value is a dict keyed by magic
+            name whose value is the function docstring. If a docstring is
+            unavailable, the value of `missing` is used instead.
+            
+            If brief is True, only the first line of each docstring will be returned.
+
         """
         docs = {}
         for m_type in self.magics:
@@ -376,23 +530,29 @@
 
     def register(self, *magic_objects):
         """Register one or more instances of Magics.
-
-        Take one or more classes or instances of classes that subclass the main 
+        
+        Take one or more classes or instances of classes that subclass the main
         `core.Magic` class, and register them with IPython to use the magic
         functions they provide.  The registration process will then ensure that
         any methods that have decorated to provide line and/or cell magics will
         be recognized with the `%x`/`%%x` syntax as a line/cell magic
         respectively.
-
+        
         If classes are given, they will be instantiated with the default
         constructor.  If your classes need a custom constructor, you should
         instanitate them first and pass the instance.
-
+        
         The provided arguments can be an arbitrary mix of classes and instances.
 
         Parameters
         ----------
-        magic_objects : one or more classes or instances
+        *magic_objects :
+            
+
+        Returns
+        -------
+
+        
         """
         # Start by validating them to ensure they have all had their magic
         # methods registered at the instance level
@@ -412,29 +572,31 @@
 
     def register_function(self, func, magic_kind='line', magic_name=None):
         """Expose a standalone function as magic function for IPython.
-
+        
         This will create an IPython magic (line, cell or both) from a
         standalone function.  The functions should have the following
-        signatures: 
-
+        signatures:
+        
         * For line magics: `def f(line)`
         * For cell magics: `def f(line, cell)`
         * For a function that does both: `def f(line, cell=None)`
-
+        
         In the latter case, the function will be called with `cell==None` when
         invoked as `%f`, and with cell as a string when invoked as `%%f`.
 
         Parameters
         ----------
-        func : callable
-          Function to be registered as a magic.
-
-        magic_kind : str
-          Kind of magic, one of 'line', 'cell' or 'line_cell'
-
-        magic_name : optional str
-          If given, the name the magic will have in the IPython namespace.  By
-          default, the name of the function itself is used.
+        func :
+            
+        magic_kind :
+             (Default value = 'line')
+        magic_name :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
 
         # Create the new method in the user_magics and register it in the
@@ -446,7 +608,7 @@
 
     def register_alias(self, alias_name, magic_name, magic_kind='line', magic_params=None):
         """Register an alias to a magic function.
-
+        
         The alias is an instance of :class:`MagicAlias`, which holds the
         name and kind of the magic it should call. Binding is done at
         call time, so if the underlying magic function is changed the alias
@@ -454,14 +616,19 @@
 
         Parameters
         ----------
-        alias_name : str
-          The name of the magic to be registered.
-
-        magic_name : str
-          The name of an existing magic.
-
-        magic_kind : str
-          Kind of magic, one of 'line' or 'cell'
+        alias_name :
+            
+        magic_name :
+            
+        magic_kind :
+             (Default value = 'line')
+        magic_params :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
 
         # `validate_type` is too permissive, as it allows 'line_cell'
@@ -479,23 +646,30 @@
 
 class Magics(Configurable):
     """Base class for implementing magic functions.
-
+    
     Shell functions which can be reached as %function_name. All magic
     functions should accept a string, which they can parse for their own
     needs. This can make some functions easier to type, eg `%cd ../`
     vs. `%cd("../")`
-
+    
     Classes providing magic functions need to subclass this class, and they
     MUST:
-
+    
     - Use the method decorators `@line_magic` and `@cell_magic` to decorate
       individual methods as magic functions, AND
-
+    
     - Use the class decorator `@magics_class` to ensure that the magic
       methods are properly registered at the instance level upon instance
       initialization.
-
+    
     See :mod:`magic_functions` for examples of actual implementation classes.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     # Dict holding all command-line options for each magic.
     options_table = None
@@ -541,12 +715,32 @@
         super(Magics, self).__init__(**kwargs)
 
     def arg_err(self,func):
-        """Print docstring if incorrect arguments were passed"""
+        """Print docstring if incorrect arguments were passed
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         print('Error in arguments:')
         print(oinspect.getdoc(func))
 
     def format_latex(self, strng):
-        """Format a string for latex inclusion."""
+        """Format a string for latex inclusion.
+
+        Parameters
+        ----------
+        strng :
+            
+
+        Returns
+        -------
+
+        """
 
         # Characters that need to be escaped for latex:
         escape_re = re.compile(r'(%|_|\$|#|&)',re.MULTILINE)
@@ -574,36 +768,30 @@
 
     def parse_options(self, arg_str, opt_str, *long_opts, **kw):
         """Parse options passed to an argument string.
-
+        
         The interface is similar to that of :func:`getopt.getopt`, but it
         returns a :class:`~IPython.utils.struct.Struct` with the options as keys
         and the stripped argument string still as a string.
-
+        
         arg_str is quoted as a true sys.argv vector by using shlex.split.
         This allows us to easily expand variables, glob files, quote
         arguments, etc.
 
         Parameters
         ----------
-
-        arg_str : str
-          The arguments to parse.
-
-        opt_str : str
-          The options specification.
-
-        mode : str, default 'string'
-          If given as 'list', the argument string is returned as a list (split
-          on whitespace) instead of a string.
-
-        list_all : bool, default False
-          Put all option values in lists. Normally only options
-          appearing more than once are put in a list.
-
-        posix : bool, default True
-          Whether to split the input line in POSIX mode or not, as per the
-          conventions outlined in the :mod:`shlex` module from the standard
-          library.
+        arg_str :
+            
+        opt_str :
+            
+        *long_opts :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        
         """
 
         # inject default options at the beginning of the input line
@@ -654,7 +842,19 @@
         return opts,args
 
     def default_option(self, fn, optstr):
-        """Make an entry in the options_table for fn, with value optstr"""
+        """Make an entry in the options_table for fn, with value optstr
+
+        Parameters
+        ----------
+        fn :
+            
+        optstr :
+            
+
+        Returns
+        -------
+
+        """
 
         if fn not in self.lsmagic():
             error("%s is not a magic function" % fn)
@@ -663,13 +863,20 @@
 
 class MagicAlias(object):
     """An alias to another magic function.
-
+    
     An alias is determined by its magic name and magic kind. Lookup
     is done at call time, so if the underlying magic changes the alias
     will call the new function.
-
+    
     Use the :meth:`MagicsManager.register_alias` method or the
     `%alias_magic` magic function to create and register a new alias.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, shell, magic_name, magic_kind, magic_params=None):
         self.shell = shell
