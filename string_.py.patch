# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/arrays/string_.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/arrays/string_.py
@@ -24,27 +24,30 @@
 
 @register_extension_dtype
 class StringDtype(ExtensionDtype):
-    """
-    Extension dtype for string data.
-
+    """Extension dtype for string data.
+    
     .. versionadded:: 1.0.0
-
+    
     .. warning::
-
+    
        StringDtype is considered experimental. The implementation and
        parts of the API may change without warning.
-
+    
        In particular, StringDtype.na_value may change to no longer be
        ``numpy.nan``.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     Attributes
     ----------
     None
-
     Methods
     -------
     None
-
     Examples
     --------
     >>> pd.StringDtype()
@@ -58,17 +61,12 @@
 
     @property
     def type(self) -> Type[str]:
+        """ """
         return str
 
     @classmethod
     def construct_array_type(cls) -> Type["StringArray"]:
-        """
-        Return the array type associated with this dtype.
-
-        Returns
-        -------
-        type
-        """
+        """Return the array type associated with this dtype."""
         return StringArray
 
     def __repr__(self) -> str:
@@ -98,13 +96,12 @@
 
 
 class StringArray(PandasArray):
-    """
-    Extension array for string data.
-
+    """Extension array for string data.
+    
     .. versionadded:: 1.0.0
-
+    
     .. warning::
-
+    
        StringArray is considered experimental. The implementation and
        parts of the API may change without warning.
 
@@ -112,26 +109,24 @@
     ----------
     values : array-like
         The array of data.
-
         .. warning::
-
-           Currently, this expects an object-dtype ndarray
-           where the elements are Python strings or :attr:`pandas.NA`.
-           This may change without warning in the future. Use
-           :meth:`pandas.array` with ``dtype="string"`` for a stable way of
-           creating a `StringArray` from any sequence.
-
+        Currently, this expects an object-dtype ndarray
+        where the elements are Python strings or :attr:`pandas.NA`.
+        This may change without warning in the future. Use
+        :meth:`pandas.array` with ``dtype="string"`` for a stable way of
+        creating a `StringArray` from any sequence.
     copy : bool, default False
         Whether to copy the array of data.
+
+    Returns
+    -------
 
     Attributes
     ----------
     None
-
     Methods
     -------
     None
-
     See Also
     --------
     array
@@ -139,21 +134,24 @@
     Series.str
         The string methods are available on Series backed by
         a StringArray.
-
     Notes
     -----
     StringArray returns a BooleanArray for comparison methods.
-
     Examples
     --------
+    
+    Unlike arrays instantiated with ``dtype="object"``, ``StringArray``
+    will convert the values to strings.
+    
+    
+    However, instantiating StringArrays directly with non-strings will raise an error.
+    
+    For comparison methods, `StringArray` returns a :class:`pandas.BooleanArray`:
     >>> pd.array(['This is', 'some text', None, 'data.'], dtype="string")
     <StringArray>
     ['This is', 'some text', <NA>, 'data.']
     Length: 4, dtype: string
-
-    Unlike arrays instantiated with ``dtype="object"``, ``StringArray``
-    will convert the values to strings.
-
+    
     >>> pd.array(['1', 1], dtype="object")
     <PandasArray>
     ['1', 1]
@@ -162,11 +160,7 @@
     <StringArray>
     ['1', '1']
     Length: 2, dtype: string
-
-    However, instantiating StringArrays directly with non-strings will raise an error.
-
-    For comparison methods, `StringArray` returns a :class:`pandas.BooleanArray`:
-
+    
     >>> pd.array(["a", None, "c"], dtype="string") == "a"
     <BooleanArray>
     [True, <NA>, False]
@@ -196,6 +190,21 @@
 
     @classmethod
     def _from_sequence(cls, scalars, dtype=None, copy=False):
+        """
+
+        Parameters
+        ----------
+        scalars :
+            
+        dtype :
+             (Default value = None)
+        copy :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if dtype:
             assert dtype == "string"
 
@@ -208,6 +217,21 @@
 
     @classmethod
     def _from_sequence_of_strings(cls, strings, dtype=None, copy=False):
+        """
+
+        Parameters
+        ----------
+        strings :
+            
+        dtype :
+             (Default value = None)
+        copy :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return cls._from_sequence(strings, dtype=dtype, copy=copy)
 
     def __arrow_array__(self, type=None):
@@ -224,6 +248,7 @@
         return pa.array(values, type=type, from_pandas=True)
 
     def _values_for_factorize(self):
+        """ """
         arr = self._ndarray.copy()
         mask = self.isna()
         arr[mask] = -1
@@ -258,10 +283,38 @@
         super().__setitem__(key, value)
 
     def fillna(self, value=None, method=None, limit=None):
+        """
+
+        Parameters
+        ----------
+        value :
+             (Default value = None)
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # TODO: validate dtype
         return super().fillna(value, method, limit)
 
     def astype(self, dtype, copy=True):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         dtype = pandas_dtype(dtype)
         if isinstance(dtype, StringDtype):
             if copy:
@@ -277,17 +330,54 @@
         return super().astype(dtype, copy)
 
     def _reduce(self, name: str, skipna: bool = True, **kwargs):
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        skipna: bool :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if name in ["min", "max"]:
             return getattr(self, name)(skipna=skipna)
 
         raise TypeError(f"Cannot perform reduction '{name}' with string dtype")
 
     def value_counts(self, dropna=False):
+        """
+
+        Parameters
+        ----------
+        dropna :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         from pandas import value_counts
 
         return value_counts(self._ndarray, dropna=dropna).astype("Int64")
 
     def memory_usage(self, deep=False):
+        """
+
+        Parameters
+        ----------
+        deep :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         result = self._ndarray.nbytes
         if deep:
             return result + lib.memory_usage_of_objects(self._ndarray)
@@ -296,8 +386,30 @@
     # Override parent because we have different return types.
     @classmethod
     def _create_arithmetic_method(cls, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         # Note: this handles both arithmetic and comparison methods.
         def method(self, other):
+            """
+
+            Parameters
+            ----------
+            other :
+                
+
+            Returns
+            -------
+
+            """
             from pandas.arrays import BooleanArray
 
             assert op.__name__ in ops.ARITHMETIC_BINOPS | ops.COMPARISON_BINOPS
@@ -336,6 +448,7 @@
 
     @classmethod
     def _add_arithmetic_ops(cls):
+        """ """
         cls.__add__ = cls._create_arithmetic_method(operator.add)
         cls.__radd__ = cls._create_arithmetic_method(ops.radd)
 
