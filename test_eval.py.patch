# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/computation/test_eval.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/computation/test_eval.py
@@ -50,16 +50,39 @@
     )
 )  # noqa
 def engine(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=expr._parsers)
 def parser(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture
 def ne_lt_2_6_9():
+    """ """
     if _NUMEXPR_INSTALLED and _NUMEXPR_VERSION >= LooseVersion("2.6.9"):
         pytest.skip("numexpr is >= 2.6.9")
     return "numexpr"
@@ -67,6 +90,7 @@
 
 @pytest.fixture
 def unary_fns_for_ne():
+    """ """
     if _NUMEXPR_INSTALLED:
         if _NUMEXPR_VERSION >= LooseVersion("2.6.9"):
             return _unary_math_ops
@@ -77,10 +101,38 @@
 
 
 def engine_has_neg_frac(engine):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+
+    Returns
+    -------
+
+    """
     return _engines[engine].has_neg_frac
 
 
 def _eval_single_bin(lhs, cmp1, rhs, engine):
+    """
+
+    Parameters
+    ----------
+    lhs :
+        
+    cmp1 :
+        
+    rhs :
+        
+    engine :
+        
+
+    Returns
+    -------
+
+    """
     c = _binary_ops_dict[cmp1]
     if engine_has_neg_frac(engine):
         try:
@@ -95,22 +147,74 @@
 
 
 def _series_and_2d_ndarray(lhs, rhs):
+    """
+
+    Parameters
+    ----------
+    lhs :
+        
+    rhs :
+        
+
+    Returns
+    -------
+
+    """
     return (
         isinstance(lhs, Series) and isinstance(rhs, np.ndarray) and rhs.ndim > 1
     ) or (isinstance(rhs, Series) and isinstance(lhs, np.ndarray) and lhs.ndim > 1)
 
 
 def _series_and_frame(lhs, rhs):
+    """
+
+    Parameters
+    ----------
+    lhs :
+        
+    rhs :
+        
+
+    Returns
+    -------
+
+    """
     return (isinstance(lhs, Series) and isinstance(rhs, DataFrame)) or (
         isinstance(rhs, Series) and isinstance(lhs, DataFrame)
     )
 
 
 def _bool_and_frame(lhs, rhs):
+    """
+
+    Parameters
+    ----------
+    lhs :
+        
+    rhs :
+        
+
+    Returns
+    -------
+
+    """
     return isinstance(lhs, bool) and isinstance(rhs, pd.core.generic.NDFrame)
 
 
 def _is_py3_complex_incompat(result, expected):
+    """
+
+    Parameters
+    ----------
+    result :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     return isinstance(expected, (complex, np.complexfloating)) and np.isnan(result)
 
 
@@ -119,8 +223,10 @@
 
 @td.skip_if_no_ne
 class TestEvalNumexprPandas:
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         import numexpr as ne
 
         cls.ne = ne
@@ -129,11 +235,13 @@
 
     @classmethod
     def teardown_class(cls):
+        """ """
         del cls.engine, cls.parser
         if hasattr(cls, "ne"):
             del cls.ne
 
     def setup_data(self):
+        """ """
         nan_df1 = DataFrame(rand(10, 5))
         nan_df1[nan_df1 > 0.5] = np.nan
         nan_df2 = DataFrame(rand(10, 5))
@@ -158,6 +266,7 @@
         self.rhses = self.pandas_rhses + self.scalar_rhses
 
     def setup_ops(self):
+        """ """
         self.cmp_ops = expr._cmp_ops_syms
         self.cmp2_ops = self.cmp_ops[::-1]
         self.bin_ops = expr._bool_ops_syms
@@ -166,11 +275,33 @@
         self.unary_ops = "-", "~", "not "
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.setup_ops()
         self.setup_data()
         self.current_engines = filter(lambda x: x != self.engine, _engines)
 
     def teardown_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         del self.lhses, self.rhses, self.scalar_rhses, self.scalar_lhses
         del self.pandas_rhses, self.pandas_lhses, self.current_engines
 
@@ -182,6 +313,19 @@
     )
     @pytest.mark.parametrize("cmp2", [">", "<"], ids=["gt", "lt"])
     def test_complex_cmp_ops(self, cmp1, cmp2):
+        """
+
+        Parameters
+        ----------
+        cmp1 :
+            
+        cmp2 :
+            
+
+        Returns
+        -------
+
+        """
         for lhs, rhs, binop in product(self.lhses, self.rhses, self.bin_ops):
             lhs_new = _eval_single_bin(lhs, cmp1, rhs, self.engine)
             rhs_new = _eval_single_bin(lhs, cmp2, rhs, self.engine)
@@ -192,6 +336,7 @@
             self.check_equal(result, expected)
 
     def test_simple_cmp_ops(self):
+        """ """
         bool_lhses = (
             DataFrame(tm.randbool(size=(10, 5))),
             Series(tm.randbool((5,))),
@@ -207,35 +352,42 @@
 
     @pytest.mark.slow
     def test_binary_arith_ops(self):
+        """ """
         for lhs, op, rhs in product(self.lhses, self.arith_ops, self.rhses):
             self.check_binary_arith_op(lhs, op, rhs)
 
     def test_modulus(self):
+        """ """
         for lhs, rhs in product(self.lhses, self.rhses):
             self.check_modulus(lhs, "%", rhs)
 
     def test_floor_division(self):
+        """ """
         for lhs, rhs in product(self.lhses, self.rhses):
             self.check_floor_division(lhs, "//", rhs)
 
     @td.skip_if_windows
     def test_pow(self):
+        """ """
         # odd failure on win32 platform, so skip
         for lhs, rhs in product(self.lhses, self.rhses):
             self.check_pow(lhs, "**", rhs)
 
     @pytest.mark.slow
     def test_single_invert_op(self):
+        """ """
         for lhs, op, rhs in product(self.lhses, self.cmp_ops, self.rhses):
             self.check_single_invert_op(lhs, op, rhs)
 
     @pytest.mark.slow
     def test_compound_invert_op(self):
+        """ """
         for lhs, op, rhs in product(self.lhses, self.cmp_ops, self.rhses):
             self.check_compound_invert_op(lhs, op, rhs)
 
     @pytest.mark.slow
     def test_chained_cmp_op(self):
+        """ """
         mids = self.lhses
         cmp_ops = "<", ">"
         for lhs, cmp1, mid, cmp2, rhs in product(
@@ -244,6 +396,19 @@
             self.check_chained_cmp_op(lhs, cmp1, mid, cmp2, rhs)
 
     def check_equal(self, result, expected):
+        """
+
+        Parameters
+        ----------
+        result :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(result, DataFrame):
             tm.assert_frame_equal(result, expected)
         elif isinstance(result, Series):
@@ -254,7 +419,41 @@
             assert result == expected
 
     def check_chained_cmp_op(self, lhs, cmp1, mid, cmp2, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        mid :
+            
+        cmp2 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         def check_operands(left, right, cmp_op):
+            """
+
+            Parameters
+            ----------
+            left :
+                
+            right :
+                
+            cmp_op :
+                
+
+            Returns
+            -------
+
+            """
             return _eval_single_bin(left, cmp_op, right, self.engine)
 
         lhs_new = check_operands(lhs, mid, cmp1)
@@ -272,6 +471,21 @@
                 tm.assert_almost_equal(result, expected)
 
     def check_simple_cmp_op(self, lhs, cmp1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {cmp1} rhs"
         msg = (
             r"only list-like( or dict-like)? objects are allowed to be "
@@ -293,6 +507,21 @@
             self.check_equal(result, expected)
 
     def check_binary_arith_op(self, lhs, arith1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        arith1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {arith1} rhs"
         result = pd.eval(ex, engine=self.engine, parser=self.parser)
         expected = _eval_single_bin(lhs, arith1, rhs, self.engine)
@@ -304,6 +533,23 @@
         self.check_alignment(result, nlhs, rhs, arith1)
 
     def check_alignment(self, result, nlhs, ghs, op):
+        """
+
+        Parameters
+        ----------
+        result :
+            
+        nlhs :
+            
+        ghs :
+            
+        op :
+            
+
+        Returns
+        -------
+
+        """
         try:
             nlhs, ghs = nlhs.align(ghs)
         except (ValueError, TypeError, AttributeError):
@@ -319,6 +565,21 @@
     # modulus, pow, and floor division require special casing
 
     def check_modulus(self, lhs, arith1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        arith1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {arith1} rhs"
         result = pd.eval(ex, engine=self.engine, parser=self.parser)
         expected = lhs % rhs
@@ -331,6 +592,21 @@
             tm.assert_almost_equal(result, expected.item())
 
     def check_floor_division(self, lhs, arith1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        arith1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {arith1} rhs"
 
         if self.engine == "python":
@@ -351,6 +627,19 @@
                 )
 
     def get_expected_pow_result(self, lhs, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         try:
             expected = _eval_single_bin(lhs, "**", rhs, self.engine)
         except ValueError as e:
@@ -366,6 +655,21 @@
         return expected
 
     def check_pow(self, lhs, arith1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        arith1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {arith1} rhs"
         expected = self.get_expected_pow_result(lhs, rhs)
         result = pd.eval(ex, engine=self.engine, parser=self.parser)
@@ -389,6 +693,21 @@
             tm.assert_almost_equal(result, expected)
 
     def check_single_invert_op(self, lhs, cmp1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         # simple
         for el in (lhs, rhs):
             try:
@@ -405,6 +724,21 @@
                 )
 
     def check_compound_invert_op(self, lhs, cmp1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         skip_these = ["in", "not in"]
         ex = f"~(lhs {cmp1} rhs)"
 
@@ -440,9 +774,23 @@
                 tm.assert_almost_equal(ev, result)
 
     def ex(self, op, var_name="lhs"):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        var_name :
+             (Default value = "lhs")
+
+        Returns
+        -------
+
+        """
         return f"{op}{var_name}"
 
     def test_frame_invert(self):
+        """ """
         expr = self.ex("~")
 
         # ~ ##
@@ -486,6 +834,7 @@
                 result = pd.eval(expr, engine=self.engine, parser=self.parser)
 
     def test_series_invert(self):
+        """ """
         # ~ ####
         expr = self.ex("~")
 
@@ -533,6 +882,7 @@
                 result = pd.eval(expr, engine=self.engine, parser=self.parser)
 
     def test_frame_negate(self):
+        """ """
         expr = self.ex("-")
 
         # float
@@ -559,6 +909,7 @@
             tm.assert_frame_equal(expect, result)
 
     def test_series_negate(self):
+        """ """
         expr = self.ex("-")
 
         # float
@@ -596,6 +947,17 @@
         ],
     )
     def test_frame_pos(self, lhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+
+        Returns
+        -------
+
+        """
         expr = self.ex("+")
         expect = lhs
 
@@ -614,6 +976,17 @@
         ],
     )
     def test_series_pos(self, lhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+
+        Returns
+        -------
+
+        """
         expr = self.ex("+")
         expect = lhs
 
@@ -621,6 +994,7 @@
         tm.assert_series_equal(expect, result)
 
     def test_scalar_unary(self):
+        """ """
         msg = "bad operand type for unary ~: 'float'"
         with pytest.raises(TypeError, match=msg):
             pd.eval("~1.0", engine=self.engine, parser=self.parser)
@@ -638,6 +1012,7 @@
         assert pd.eval("+False", parser=self.parser, engine=self.engine) == +False
 
     def test_unary_in_array(self):
+        """ """
         # GH 11235
         tm.assert_numpy_array_equal(
             pd.eval(
@@ -666,6 +1041,17 @@
 
     @pytest.mark.parametrize("dtype", [np.float32, np.float64])
     def test_float_comparison_bin_op(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # GH 16363
         df = pd.DataFrame({"x": np.array([0], dtype=dtype)})
         res = df.eval("x < -0.1")
@@ -675,6 +1061,7 @@
         assert res.values == np.array([False])
 
     def test_disallow_scalar_bool_ops(self):
+        """ """
         exprs = "1 or 2", "1 and 2"
         exprs += "a and b", "a or b"
         exprs += ("1 or 2 and (3 + 2) > 3",)
@@ -688,6 +1075,7 @@
                 pd.eval(ex, engine=self.engine, parser=self.parser)
 
     def test_identical(self):
+        """ """
         # see gh-10546
         x = 1
         result = pd.eval("x", engine=self.engine, parser=self.parser)
@@ -721,6 +1109,7 @@
         assert result.shape == (1,)
 
     def test_line_continuation(self):
+        """ """
         # GH 11149
         exp = """1 + 2 * \
         5 - 1 + 2 """
@@ -728,6 +1117,7 @@
         assert result == 12
 
     def test_float_truncation(self):
+        """ """
         # GH 14241
         exp = "1000000000.006"
         result = pd.eval(exp, engine=self.engine, parser=self.parser)
@@ -750,6 +1140,7 @@
         tm.assert_frame_equal(expected, result)
 
     def test_disallow_python_keywords(self):
+        """ """
         # GH 18221
         df = pd.DataFrame([[0, 0, 0]], columns=["foo", "bar", "class"])
         msg = "Python keyword not valid identifier in numexpr query"
@@ -764,8 +1155,10 @@
 
 @td.skip_if_no_ne
 class TestEvalNumexprPython(TestEvalNumexprPandas):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         import numexpr as ne
 
@@ -774,6 +1167,7 @@
         cls.parser = "python"
 
     def setup_ops(self):
+        """ """
         self.cmp_ops = list(
             filter(lambda x: x not in ("in", "not in"), expr._cmp_ops_syms)
         )
@@ -784,6 +1178,25 @@
         self.unary_ops = "+", "-", "~"
 
     def check_chained_cmp_op(self, lhs, cmp1, mid, cmp2, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        mid :
+            
+        cmp2 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex1 = f"lhs {cmp1} mid {cmp2} rhs"
         msg = "'BoolOp' nodes are not implemented"
         with pytest.raises(NotImplementedError, match=msg):
@@ -791,13 +1204,30 @@
 
 
 class TestEvalPythonPython(TestEvalNumexprPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "python"
         cls.parser = "python"
 
     def check_modulus(self, lhs, arith1, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        arith1 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         ex = f"lhs {arith1} rhs"
         result = pd.eval(ex, engine=self.engine, parser=self.parser)
 
@@ -808,6 +1238,23 @@
         tm.assert_almost_equal(result, expected)
 
     def check_alignment(self, result, nlhs, ghs, op):
+        """
+
+        Parameters
+        ----------
+        result :
+            
+        nlhs :
+            
+        ghs :
+            
+        op :
+            
+
+        Returns
+        -------
+
+        """
         try:
             nlhs, ghs = nlhs.align(ghs)
         except (ValueError, TypeError, AttributeError):
@@ -820,13 +1267,34 @@
 
 
 class TestEvalPythonPandas(TestEvalPythonPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "python"
         cls.parser = "pandas"
 
     def check_chained_cmp_op(self, lhs, cmp1, mid, cmp2, rhs):
+        """
+
+        Parameters
+        ----------
+        lhs :
+            
+        cmp1 :
+            
+        mid :
+            
+        cmp2 :
+            
+        rhs :
+            
+
+        Returns
+        -------
+
+        """
         TestEvalNumexprPandas.check_chained_cmp_op(self, lhs, cmp1, mid, cmp2, rhs)
 
 
@@ -838,11 +1306,29 @@
 
 
 class TestTypeCasting:
+    """ """
     @pytest.mark.parametrize("op", ["+", "-", "*", "**", "/"])
     # maybe someday... numexpr has too many upcasting rules now
     # chain(*(np.sctypes[x] for x in ['uint', 'int', 'float']))
     @pytest.mark.parametrize("dt", [np.float32, np.float64])
     def test_binop_typecasting(self, engine, parser, op, dt):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+        op :
+            
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         df = tm.makeCustomDataframe(5, 3, data_gen_f=f, dtype=dt)
         s = f"df {op} 3"
         res = pd.eval(s, engine=engine, parser=parser)
@@ -862,27 +1348,76 @@
 
 
 def _is_datetime(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return issubclass(x.dtype.type, np.datetime64)
 
 
 def should_warn(*args):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+
+    Returns
+    -------
+
+    """
     not_mono = not any(map(operator.attrgetter("is_monotonic"), args))
     only_one_dt = reduce(operator.xor, map(_is_datetime, args))
     return not_mono and only_one_dt
 
 
 class TestAlignment:
+    """ """
 
     index_types = "i", "u", "dt"
     lhs_index_types = index_types + ("s",)  # 'p'
 
     def test_align_nested_unary_op(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         s = "df * ~2"
         df = tm.makeCustomDataframe(5, 3, data_gen_f=f)
         res = pd.eval(s, engine=engine, parser=parser)
         tm.assert_frame_equal(res, df * ~2)
 
     def test_basic_frame_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         args = product(self.lhs_index_types, self.index_types, self.index_types)
         with warnings.catch_warnings(record=True):
             warnings.simplefilter("always", RuntimeWarning)
@@ -902,6 +1437,19 @@
                 tm.assert_frame_equal(res, df + df2)
 
     def test_frame_comparison(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         args = product(self.lhs_index_types, repeat=2)
         for r_idx_type, c_idx_type in args:
             df = tm.makeCustomDataframe(
@@ -916,6 +1464,19 @@
 
     @pytest.mark.slow
     def test_medium_complex_frame_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         args = product(
             self.lhs_index_types, self.index_types, self.index_types, self.index_types
         )
@@ -941,7 +1502,35 @@
                 tm.assert_frame_equal(res, df + df2 + df3)
 
     def test_basic_frame_series_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         def testit(r_idx_type, c_idx_type, index_name):
+            """
+
+            Parameters
+            ----------
+            r_idx_type :
+                
+            c_idx_type :
+                
+            index_name :
+                
+
+            Returns
+            -------
+
+            """
             df = tm.makeCustomDataframe(
                 10, 10, data_gen_f=f, r_idx_type=r_idx_type, c_idx_type=c_idx_type
             )
@@ -967,7 +1556,35 @@
                 testit(r_idx_type, c_idx_type, index_name)
 
     def test_basic_series_frame_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         def testit(r_idx_type, c_idx_type, index_name):
+            """
+
+            Parameters
+            ----------
+            r_idx_type :
+                
+            c_idx_type :
+                
+            index_name :
+                
+
+            Returns
+            -------
+
+            """
             df = tm.makeCustomDataframe(
                 10, 7, data_gen_f=f, r_idx_type=r_idx_type, c_idx_type=c_idx_type
             )
@@ -1004,6 +1621,19 @@
                 testit(r_idx_type, c_idx_type, index_name)
 
     def test_series_frame_commutativity(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         args = product(
             self.lhs_index_types, self.index_types, ("+", "*"), ("index", "columns")
         )
@@ -1034,6 +1664,19 @@
 
     @pytest.mark.slow
     def test_complex_series_frame_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         import random
 
         args = product(
@@ -1083,6 +1726,19 @@
                 tm.assert_frame_equal(res, expected)
 
     def test_performance_warning_for_poor_alignment(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(randn(1000, 10))
         s = Series(randn(10000))
         if engine == "numexpr":
@@ -1133,23 +1789,40 @@
 
 @td.skip_if_no_ne
 class TestOperationsNumExprPandas:
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.engine = "numexpr"
         cls.parser = "pandas"
         cls.arith_ops = expr._arith_ops_syms + expr._cmp_ops_syms
 
     @classmethod
     def teardown_class(cls):
+        """ """
         del cls.engine, cls.parser
 
     def eval(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         kwargs["engine"] = self.engine
         kwargs["parser"] = self.parser
         kwargs["level"] = kwargs.pop("level", 0) + 1
         return pd.eval(*args, **kwargs)
 
     def test_simple_arith_ops(self):
+        """ """
         ops = self.arith_ops
 
         for op in filter(lambda x: x != "//", ops):
@@ -1179,6 +1852,7 @@
                 assert y == expec
 
     def test_simple_bool_ops(self):
+        """ """
         for op, lhs, rhs in product(expr._bool_ops_syms, (True, False), (True, False)):
             ex = f"{lhs} {op} {rhs}"
             res = self.eval(ex)
@@ -1186,6 +1860,7 @@
             assert res == exp
 
     def test_bool_ops_with_constants(self):
+        """ """
         for op, lhs, rhs in product(
             expr._bool_ops_syms, ("True", "False"), ("True", "False")
         ):
@@ -1195,6 +1870,7 @@
             assert res == exp
 
     def test_4d_ndarray_fails(self):
+        """ """
         x = randn(3, 4, 5, 6)
         y = Series(randn(10))
         msg = "N-dimensional objects, where N > 2, are not supported with eval"
@@ -1202,15 +1878,18 @@
             self.eval("x + y", local_dict={"x": x, "y": y})
 
     def test_constant(self):
+        """ """
         x = self.eval("1")
         assert x == 1
 
     def test_single_variable(self):
+        """ """
         df = DataFrame(randn(10, 2))
         df2 = self.eval("df", local_dict={"df": df})
         tm.assert_frame_equal(df, df2)
 
     def test_truediv(self):
+        """ """
         s = np.array([1])
         ex = "s / 1"
         d = {"s": s}  # noqa
@@ -1246,17 +1925,20 @@
         assert res == expec
 
     def test_failing_subscript_with_name_error(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))  # noqa
         with pytest.raises(NameError, match="name 'x' is not defined"):
             self.eval("df[x > 2] > 2")
 
     def test_lhs_expression_subscript(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))
         result = self.eval("(df + 1)[df > 2]", local_dict={"df": df})
         expected = (df + 1)[df > 2]
         tm.assert_frame_equal(result, expected)
 
     def test_attr_expression(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3), columns=list("abc"))
         expr1 = "df.a < df.b"
         expec1 = df.a < df.b
@@ -1270,6 +1952,7 @@
             tm.assert_series_equal(expec, self.eval(e, local_dict={"df": df}))
 
     def test_assignment_fails(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3), columns=list("abc"))
         df2 = DataFrame(np.random.randn(5, 3))
         expr1 = "df = df2"
@@ -1278,6 +1961,7 @@
             self.eval(expr1, local_dict={"df": df, "df2": df2})
 
     def test_assignment_column(self):
+        """ """
         df = DataFrame(np.random.randn(5, 2), columns=list("ab"))
         orig_df = df.copy()
 
@@ -1312,6 +1996,7 @@
 
         # with a local name overlap
         def f():
+            """ """
             df = orig_df.copy()
             a = 1  # noqa
             df.eval("a = 1 + b", inplace=True)
@@ -1325,6 +2010,7 @@
         df = orig_df.copy()
 
         def f():
+            """ """
             a = 1  # noqa
             old_a = df.a.copy()
             df.eval("a = a + b", inplace=True)
@@ -1349,6 +2035,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_column_in(self):
+        """ """
         # GH 11235
         df = DataFrame({"a": [11], "b": [-32]})
         result = df.eval("a in [11, -32]")
@@ -1356,6 +2043,7 @@
         tm.assert_series_equal(result, expected)
 
     def assignment_not_inplace(self):
+        """ """
         # see gh-9297
         df = DataFrame(np.random.randn(5, 2), columns=list("ab"))
 
@@ -1367,6 +2055,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_multi_line_expression(self):
+        """ """
         # GH 11149
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
         expected = df.copy()
@@ -1404,6 +2093,7 @@
             )
 
     def test_multi_line_expression_not_inplace(self):
+        """ """
         # GH 11149
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
         expected = df.copy()
@@ -1429,6 +2119,7 @@
         tm.assert_frame_equal(expected, df)
 
     def test_multi_line_expression_local_variable(self):
+        """ """
         # GH 15342
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
         expected = df.copy()
@@ -1447,10 +2138,24 @@
         assert ans is None
 
     def test_multi_line_expression_callable_local_variable(self):
+        """ """
         # 26426
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 
         def local_func(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return b
 
         expected = df.copy()
@@ -1467,10 +2172,24 @@
         assert ans is None
 
     def test_multi_line_expression_callable_local_variable_with_kwargs(self):
+        """ """
         # 26426
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 
         def local_func(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return b
 
         expected = df.copy()
@@ -1487,6 +2206,7 @@
         assert ans is None
 
     def test_assignment_in_query(self):
+        """ """
         # GH 8664
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
         df_orig = df.copy()
@@ -1496,6 +2216,7 @@
         tm.assert_frame_equal(df, df_orig)
 
     def test_query_inplace(self):
+        """ """
         # see gh-11149
         df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
         expected = df.copy()
@@ -1512,6 +2233,17 @@
     @pytest.mark.parametrize("invalid_target", [1, "cat", [1, 2], np.array([]), (1, 3)])
     @pytest.mark.filterwarnings("ignore::FutureWarning")
     def test_cannot_item_assign(self, invalid_target):
+        """
+
+        Parameters
+        ----------
+        invalid_target :
+            
+
+        Returns
+        -------
+
+        """
         msg = "Cannot assign expression output to target"
         expression = "a = 1 + 2"
 
@@ -1524,6 +2256,17 @@
 
     @pytest.mark.parametrize("invalid_target", [1, "cat", (1, 3)])
     def test_cannot_copy_item(self, invalid_target):
+        """
+
+        Parameters
+        ----------
+        invalid_target :
+            
+
+        Returns
+        -------
+
+        """
         msg = "Cannot return a copy of the target"
         expression = "a = 1 + 2"
 
@@ -1532,6 +2275,17 @@
 
     @pytest.mark.parametrize("target", [1, "cat", [1, 2], np.array([]), (1, 3), {1: 2}])
     def test_inplace_no_assignment(self, target):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
+        """
         expression = "1 + 2"
 
         assert self.eval(expression, target=target, inplace=False) == 3
@@ -1541,6 +2295,7 @@
             self.eval(expression, target=target, inplace=True)
 
     def test_basic_period_index_boolean_expression(self):
+        """ """
         df = tm.makeCustomDataframe(2, 2, data_gen_f=f, c_idx_type="p", r_idx_type="i")
 
         e = df < 2
@@ -1551,18 +2306,21 @@
         tm.assert_frame_equal(x, e)
 
     def test_basic_period_index_subscript_expression(self):
+        """ """
         df = tm.makeCustomDataframe(2, 2, data_gen_f=f, c_idx_type="p", r_idx_type="i")
         r = self.eval("df[df < 2 + 3]", local_dict={"df": df})
         e = df[df < 2 + 3]
         tm.assert_frame_equal(r, e)
 
     def test_nested_period_index_subscript_expression(self):
+        """ """
         df = tm.makeCustomDataframe(2, 2, data_gen_f=f, c_idx_type="p", r_idx_type="i")
         r = self.eval("df[df[df < 2] < 2] + df * 2", local_dict={"df": df})
         e = df[df[df < 2] < 2] + df * 2
         tm.assert_frame_equal(r, e)
 
     def test_date_boolean(self):
+        """ """
         df = DataFrame(randn(5, 3))
         df["dates1"] = date_range("1/1/2012", periods=5)
         res = self.eval(
@@ -1575,6 +2333,7 @@
         tm.assert_series_equal(res, expec, check_names=False)
 
     def test_simple_in_ops(self):
+        """ """
         if self.parser != "python":
             res = pd.eval("1 in [1, 2]", engine=self.engine, parser=self.parser)
             assert res
@@ -1632,8 +2391,10 @@
 
 @td.skip_if_no_ne
 class TestOperationsNumExprPython(TestOperationsNumExprPandas):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "numexpr"
         cls.parser = "python"
@@ -1641,6 +2402,7 @@
         cls.arith_ops = filter(lambda x: x not in ("in", "not in"), cls.arith_ops)
 
     def test_check_many_exprs(self):
+        """ """
         a = 1  # noqa
         expr = " * ".join("a" * 33)
         expected = 1
@@ -1648,6 +2410,7 @@
         assert res == expected
 
     def test_fails_and(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))
         msg = "'BoolOp' nodes are not implemented"
         with pytest.raises(NotImplementedError, match=msg):
@@ -1659,6 +2422,7 @@
             )
 
     def test_fails_or(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))
         msg = "'BoolOp' nodes are not implemented"
         with pytest.raises(NotImplementedError, match=msg):
@@ -1670,6 +2434,7 @@
             )
 
     def test_fails_not(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))
         msg = "'Not' nodes are not implemented"
         with pytest.raises(NotImplementedError, match=msg):
@@ -1681,6 +2446,7 @@
             )
 
     def test_fails_ampersand(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))  # noqa
         ex = "(df + 2)[df > 1] > 0 & (df > 0)"
         msg = "cannot evaluate scalar only bool ops"
@@ -1688,6 +2454,7 @@
             pd.eval(ex, parser=self.parser, engine=self.engine)
 
     def test_fails_pipe(self):
+        """ """
         df = DataFrame(np.random.randn(5, 3))  # noqa
         ex = "(df + 2)[df > 1] > 0 | (df > 0)"
         msg = "cannot evaluate scalar only bool ops"
@@ -1695,6 +2462,7 @@
             pd.eval(ex, parser=self.parser, engine=self.engine)
 
     def test_bool_ops_with_constants(self):
+        """ """
         for op, lhs, rhs in product(
             expr._bool_ops_syms, ("True", "False"), ("True", "False")
         ):
@@ -1709,6 +2477,7 @@
                 assert res == exp
 
     def test_simple_bool_ops(self):
+        """ """
         for op, lhs, rhs in product(expr._bool_ops_syms, (True, False), (True, False)):
             ex = f"lhs {op} rhs"
             if op in ("and", "or"):
@@ -1722,8 +2491,10 @@
 
 
 class TestOperationsPythonPython(TestOperationsNumExprPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = cls.parser = "python"
         cls.arith_ops = expr._arith_ops_syms + expr._cmp_ops_syms
@@ -1731,8 +2502,10 @@
 
 
 class TestOperationsPythonPandas(TestOperationsNumExprPandas):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "python"
         cls.parser = "pandas"
@@ -1741,8 +2514,10 @@
 
 @td.skip_if_no_ne
 class TestMathPythonPython:
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         cls.engine = "python"
         cls.parser = "pandas"
         cls.unary_fns = _unary_math_ops
@@ -1750,15 +2525,40 @@
 
     @classmethod
     def teardown_class(cls):
+        """ """
         del cls.engine, cls.parser
 
     def eval(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         kwargs["engine"] = self.engine
         kwargs["parser"] = self.parser
         kwargs["level"] = kwargs.pop("level", 0) + 1
         return pd.eval(*args, **kwargs)
 
     def test_unary_functions(self, unary_fns_for_ne):
+        """
+
+        Parameters
+        ----------
+        unary_fns_for_ne :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame({"a": np.random.randn(10)})
         a = df.a
 
@@ -1770,6 +2570,19 @@
             tm.assert_series_equal(got, expect, check_names=False)
 
     def test_floor_and_ceil_functions_raise_error(self, ne_lt_2_6_9, unary_fns_for_ne):
+        """
+
+        Parameters
+        ----------
+        ne_lt_2_6_9 :
+            
+        unary_fns_for_ne :
+            
+
+        Returns
+        -------
+
+        """
         for fn in ("floor", "ceil"):
             msg = f'"{fn}" is not a supported function'
             with pytest.raises(ValueError, match=msg):
@@ -1777,6 +2590,7 @@
                 self.eval(expr)
 
     def test_binary_functions(self):
+        """ """
         df = DataFrame({"a": np.random.randn(10), "b": np.random.randn(10)})
         a = df.a
         b = df.b
@@ -1788,6 +2602,7 @@
             tm.assert_almost_equal(got, expect, check_names=False)
 
     def test_df_use_case(self):
+        """ """
         df = DataFrame({"a": np.random.randn(10), "b": np.random.randn(10)})
         df.eval(
             "e = arctan2(sin(a), b)",
@@ -1800,6 +2615,7 @@
         tm.assert_series_equal(got, expect, check_names=False)
 
     def test_df_arithmetic_subexpression(self):
+        """ """
         df = DataFrame({"a": np.random.randn(10), "b": np.random.randn(10)})
         df.eval("e = sin(a + b)", engine=self.engine, parser=self.parser, inplace=True)
         got = df.e
@@ -1807,6 +2623,19 @@
         tm.assert_series_equal(got, expect, check_names=False)
 
     def check_result_type(self, dtype, expect_dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        expect_dtype :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame({"a": np.random.randn(10).astype(dtype)})
         assert df.a.dtype == dtype
         df.eval("b = sin(a)", engine=self.engine, parser=self.parser, inplace=True)
@@ -1817,6 +2646,7 @@
         tm.assert_series_equal(got, expect, check_names=False)
 
     def test_result_types(self):
+        """ """
         self.check_result_type(np.int32, np.float64)
         self.check_result_type(np.int64, np.float64)
         self.check_result_type(np.float32, np.float32)
@@ -1824,6 +2654,7 @@
 
     @td.skip_if_windows
     def test_result_complex128(self):
+        """ """
         # xref https://github.com/pandas-dev/pandas/issues/12293
         #  this fails on Windows, apparently a floating point precision issue
 
@@ -1832,6 +2663,7 @@
         self.check_result_type(np.complex128, np.complex128)
 
     def test_undefined_func(self):
+        """ """
         df = DataFrame({"a": np.random.randn(10)})
         msg = '"mysin" is not a supported function'
 
@@ -1839,6 +2671,7 @@
             df.eval("mysin(a)", engine=self.engine, parser=self.parser)
 
     def test_keyword_arg(self):
+        """ """
         df = DataFrame({"a": np.random.randn(10)})
         msg = 'Function "sin" does not support keyword arguments'
 
@@ -1847,24 +2680,30 @@
 
 
 class TestMathPythonPandas(TestMathPythonPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "python"
         cls.parser = "pandas"
 
 
 class TestMathNumExprPandas(TestMathPythonPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "numexpr"
         cls.parser = "pandas"
 
 
 class TestMathNumExprPython(TestMathPythonPython):
+    """ """
     @classmethod
     def setup_class(cls):
+        """ """
         super().setup_class()
         cls.engine = "numexpr"
         cls.parser = "python"
@@ -1874,13 +2713,40 @@
 
 
 class TestScope:
+    """ """
     def test_global_scope(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         e = "_var_s * 2"
         tm.assert_numpy_array_equal(
             _var_s * 2, pd.eval(e, engine=engine, parser=parser)
         )
 
     def test_no_new_locals(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         x = 1  # noqa
         lcls = locals().copy()
         pd.eval("x + 1", local_dict=lcls, engine=engine, parser=parser)
@@ -1889,6 +2755,19 @@
         assert lcls == lcls2
 
     def test_no_new_globals(self, engine, parser):
+        """
+
+        Parameters
+        ----------
+        engine :
+            
+        parser :
+            
+
+        Returns
+        -------
+
+        """
         x = 1  # noqa
         gbls = globals().copy()
         pd.eval("x + 1", engine=engine, parser=parser)
@@ -1898,6 +2777,7 @@
 
 @td.skip_if_no_ne
 def test_invalid_engine():
+    """ """
     msg = "Invalid engine 'asdf' passed"
     with pytest.raises(KeyError, match=msg):
         pd.eval("x + y", local_dict={"x": 1, "y": 2}, engine="asdf")
@@ -1905,6 +2785,7 @@
 
 @td.skip_if_no_ne
 def test_invalid_parser():
+    """ """
     msg = "Invalid parser 'asdf' passed"
     with pytest.raises(KeyError, match=msg):
         pd.eval("x + y", local_dict={"x": 1, "y": 2}, parser="asdf")
@@ -1920,6 +2801,19 @@
 @pytest.mark.parametrize("engine", _engines)
 @pytest.mark.parametrize("parser", _parsers)
 def test_disallowed_nodes(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     VisitorClass = _parsers[parser]
     uns_ops = VisitorClass.unsupported_nodes
     inst = VisitorClass("x + 1", engine, parser)
@@ -1931,12 +2825,38 @@
 
 
 def test_syntax_error_exprs(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     e = "s +"
     with pytest.raises(SyntaxError, match="invalid syntax"):
         pd.eval(e, engine=engine, parser=parser)
 
 
 def test_name_error_exprs(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     e = "s + t"
     msg = "name 's' is not defined"
     with pytest.raises(NameError, match=msg):
@@ -1944,6 +2864,19 @@
 
 
 def test_invalid_local_variable_reference(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     a, b = 1, 2  # noqa
     exprs = "a + @b", "@a + b", "@a + @b"
 
@@ -1957,6 +2890,19 @@
 
 
 def test_numexpr_builtin_raises(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     sin, dotted_line = 1, 2
     if engine == "numexpr":
         msg = "Variables in expression .+"
@@ -1968,18 +2914,57 @@
 
 
 def test_bad_resolver_raises(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     cannot_resolve = 42, 3.0
     with pytest.raises(TypeError, match="Resolver of type .+"):
         pd.eval("1 + 2", resolvers=cannot_resolve, engine=engine, parser=parser)
 
 
 def test_empty_string_raises(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     # GH 13139
     with pytest.raises(ValueError, match="expr cannot be an empty string"):
         pd.eval("", engine=engine, parser=parser)
 
 
 def test_more_than_one_expression_raises(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     with pytest.raises(SyntaxError, match=("only a single expression is allowed")):
         pd.eval("1 + 1; 2 + 2", engine=engine, parser=parser)
 
@@ -1988,6 +2973,25 @@
 @pytest.mark.parametrize("lhs", (int, float))
 @pytest.mark.parametrize("rhs", (int, float))
 def test_bool_ops_fails_on_scalars(lhs, cmp, rhs, engine, parser):
+    """
+
+    Parameters
+    ----------
+    lhs :
+        
+    cmp :
+        
+    rhs :
+        
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     gen = {int: lambda: np.random.randint(10), float: np.random.randn}
 
     mid = gen[lhs]()  # noqa
@@ -2013,6 +3017,17 @@
     ],
 )
 def test_equals_various(other):
+    """
+
+    Parameters
+    ----------
+    other :
+        
+
+    Returns
+    -------
+
+    """
     df = DataFrame({"A": ["a", "b", "c"]})
     result = df.eval(f"A == {other}")
     expected = Series([False, False, False], name="A")
@@ -2024,6 +3039,19 @@
 
 
 def test_inf(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     s = "inf + 1"
     expected = np.inf
     result = pd.eval(s, engine=engine, parser=parser)
@@ -2031,6 +3059,19 @@
 
 
 def test_truediv_deprecated(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     # GH#29182
     match = "The `truediv` parameter in pd.eval is deprecated"
 
@@ -2048,6 +3089,19 @@
 
 
 def test_negate_lt_eq_le(engine, parser):
+    """
+
+    Parameters
+    ----------
+    engine :
+        
+    parser :
+        
+
+    Returns
+    -------
+
+    """
     df = pd.DataFrame([[0, 10], [1, 20]], columns=["cat", "count"])
     expected = df[~(df.cat > 0)]
 
@@ -2064,7 +3118,9 @@
 
 
 class TestValidate:
+    """ """
     def test_validate_bool_args(self):
+        """ """
         invalid_values = [1, "True", [1, 2, 3], 5.0]
 
         for value in invalid_values:
