# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/parso/python/errors.py
+++ b/..//venv/lib/python3.8/site-packages/parso/python/errors.py
@@ -20,6 +20,19 @@
 _COMP_FOR_TYPES = ('comp_for', 'sync_comp_for')
 
 def _get_rhs_name(node, version):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+    version :
+        
+
+    Returns
+    -------
+
+    """
     type_ = node.type
     if type_ == "lambdef":
         return "lambda"
@@ -94,8 +107,16 @@
     return type_ # shouldn't reach here
 
 def _iter_stmts(scope):
-    """
-    Iterates over all statements and splits up  simple_stmt.
+    """Iterates over all statements and splits up  simple_stmt.
+
+    Parameters
+    ----------
+    scope :
+        
+
+    Returns
+    -------
+
     """
     for child in scope.children:
         if child.type == 'simple_stmt':
@@ -108,6 +129,17 @@
 
 
 def _get_comprehension_type(atom):
+    """
+
+    Parameters
+    ----------
+    atom :
+        
+
+    Returns
+    -------
+
+    """
     first, second = atom.children[:2]
     if second.type == 'testlist_comp' and second.children[1].type in _COMP_FOR_TYPES:
         if first == '[':
@@ -123,6 +155,17 @@
 
 
 def _is_future_import(import_from):
+    """
+
+    Parameters
+    ----------
+    import_from :
+        
+
+    Returns
+    -------
+
+    """
     # It looks like a __future__ import that is relative is still a future
     # import. That feels kind of odd, but whatever.
     # if import_from.level != 0:
@@ -132,9 +175,17 @@
 
 
 def _remove_parens(atom):
-    """
-    Returns the inner part of an expression like `(foo)`. Also removes nested
+    """Returns the inner part of an expression like `(foo)`. Also removes nested
     parens.
+
+    Parameters
+    ----------
+    atom :
+        
+
+    Returns
+    -------
+
     """
     try:
         children = atom.children
@@ -147,12 +198,31 @@
 
 
 def _iter_params(parent_node):
+    """
+
+    Parameters
+    ----------
+    parent_node :
+        
+
+    Returns
+    -------
+
+    """
     return (n for n in parent_node.children if n.type == 'param')
 
 
 def _is_future_import_first(import_from):
-    """
-    Checks if the import is the first statement of a file.
+    """Checks if the import is the first statement of a file.
+
+    Parameters
+    ----------
+    import_from :
+        
+
+    Returns
+    -------
+
     """
     found_docstring = False
     for stmt in _iter_stmts(import_from.get_root_node()):
@@ -168,7 +238,29 @@
 
 
 def _iter_definition_exprs_from_lists(exprlist):
+    """
+
+    Parameters
+    ----------
+    exprlist :
+        
+
+    Returns
+    -------
+
+    """
     def check_expr(child):
+        """
+
+        Parameters
+        ----------
+        child :
+            
+
+        Returns
+        -------
+
+        """
         if child.type == 'atom':
             if child.children[0] == '(':
                 testlist_comp = child.children[1]
@@ -196,6 +288,17 @@
 
 
 def _get_expr_stmt_definition_exprs(expr_stmt):
+    """
+
+    Parameters
+    ----------
+    expr_stmt :
+        
+
+    Returns
+    -------
+
+    """
     exprs = []
     for list_ in expr_stmt.children[:-2:2]:
         if list_.type in ('testlist_star_expr', 'testlist'):
@@ -206,15 +309,50 @@
 
 
 def _get_for_stmt_definition_exprs(for_stmt):
+    """
+
+    Parameters
+    ----------
+    for_stmt :
+        
+
+    Returns
+    -------
+
+    """
     exprlist = for_stmt.children[1]
     return list(_iter_definition_exprs_from_lists(exprlist))
 
 
 def _is_argument_comprehension(argument):
+    """
+
+    Parameters
+    ----------
+    argument :
+        
+
+    Returns
+    -------
+
+    """
     return argument.children[1].type in _COMP_FOR_TYPES
 
 
 def _any_fstring_error(version, node):
+    """
+
+    Parameters
+    ----------
+    version :
+        
+    node :
+        
+
+    Returns
+    -------
+
+    """
     if version < (3, 9) or node is None:
         return False
     if node.type == "error_node":
@@ -226,6 +364,7 @@
 
 
 class _Context(object):
+    """ """
     def __init__(self, node, add_syntax_error, parent_context=None):
         self.node = node
         self.blocks = []
@@ -237,15 +376,28 @@
         self._add_syntax_error = add_syntax_error
 
     def is_async_funcdef(self):
+        """ """
         # Stupidly enough async funcdefs can have two different forms,
         # depending if a decorator is used or not.
         return self.is_function() \
             and self.node.parent.type in ('async_funcdef', 'async_stmt')
 
     def is_function(self):
+        """ """
         return self.node.type == 'funcdef'
 
     def add_name(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         parent_type = name.parent.type
         if parent_type == 'trailer':
             # We are only interested in first level names.
@@ -259,9 +411,7 @@
             self._used_name_dict.setdefault(name.value, []).append(name)
 
     def finalize(self):
-        """
-        Returns a list of nonlocal names that need to be part of that scope.
-        """
+        """Returns a list of nonlocal names that need to be part of that scope."""
         self._analyze_names(self._global_names, 'global')
         self._analyze_names(self._nonlocal_names, 'nonlocal')
 
@@ -291,7 +441,31 @@
         return self._nonlocal_names + nonlocals_not_handled
 
     def _analyze_names(self, globals_or_nonlocals, type_):
+        """
+
+        Parameters
+        ----------
+        globals_or_nonlocals :
+            
+        type_ :
+            
+
+        Returns
+        -------
+
+        """
         def raise_(message):
+            """
+
+            Parameters
+            ----------
+            message :
+                
+
+            Returns
+            -------
+
+            """
             self._add_syntax_error(base_name, message % (base_name.value, type_))
 
         params = []
@@ -337,28 +511,81 @@
 
     @contextmanager
     def add_block(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         self.blocks.append(node)
         yield
         self.blocks.pop()
 
     def add_context(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return _Context(node, self._add_syntax_error, parent_context=self)
 
     def close_child_context(self, child_context):
+        """
+
+        Parameters
+        ----------
+        child_context :
+            
+
+        Returns
+        -------
+
+        """
         self._nonlocal_names_in_subscopes += child_context.finalize()
 
 
 class ErrorFinder(Normalizer):
-    """
-    Searches for errors in the syntax tree.
-    """
+    """Searches for errors in the syntax tree."""
     def __init__(self, *args, **kwargs):
         super(ErrorFinder, self).__init__(*args, **kwargs)
         self._error_dict = {}
         self.version = self.grammar.version_info
 
     def initialize(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         def create_context(node):
+            """
+
+            Parameters
+            ----------
+            node :
+                
+
+            Returns
+            -------
+
+            """
             if node is None:
                 return None
 
@@ -371,6 +598,17 @@
         self._indentation_count = 0
 
     def visit(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if node.type == 'error_node':
             with self.visit_node(node):
                 # Don't need to investigate the inners of an error node. We
@@ -381,6 +619,17 @@
 
     @contextmanager
     def visit_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         self._check_type_rules(node)
 
         if node.type in _BLOCK_STMTS:
@@ -404,6 +653,17 @@
             self.context.close_child_context(context)
 
     def visit_leaf(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         if leaf.type == 'error_leaf':
             if leaf.token_type in ('INDENT', 'ERROR_DEDENT'):
                 # Indents/Dedents itself never have a prefix. They are just
@@ -443,12 +703,53 @@
         return super(ErrorFinder, self).visit_leaf(leaf)
 
     def _add_indentation_error(self, spacing, message):
+        """
+
+        Parameters
+        ----------
+        spacing :
+            
+        message :
+            
+
+        Returns
+        -------
+
+        """
         self.add_issue(spacing, 903, "IndentationError: " + message)
 
     def _add_syntax_error(self, node, message):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        message :
+            
+
+        Returns
+        -------
+
+        """
         self.add_issue(node, 901, "SyntaxError: " + message)
 
     def add_issue(self, node, code, message):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        code :
+            
+        message :
+            
+
+        Returns
+        -------
+
+        """
         # Overwrite the default behavior.
         # Check if the issues are on the same line.
         line = node.start_pos[0]
@@ -456,6 +757,7 @@
         self._error_dict.setdefault(line, args)
 
     def finalize(self):
+        """ """
         self.context.finalize()
 
         for code, message, node in self._error_dict.values():
@@ -463,34 +765,86 @@
 
 
 class IndentationRule(Rule):
+    """ """
     code = 903
 
     def _get_message(self, message, node):
+        """
+
+        Parameters
+        ----------
+        message :
+            
+        node :
+            
+
+        Returns
+        -------
+
+        """
         message = super(IndentationRule, self)._get_message(message, node)
         return "IndentationError: " + message
 
 
 @ErrorFinder.register_rule(type='error_node')
 class _ExpectIndentedBlock(IndentationRule):
+    """ """
     message = 'expected an indented block'
 
     def get_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         leaf = node.get_next_leaf()
         return list(leaf._split_prefix())[-1]
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         # This is the beginning of a suite that is not indented.
         return node.children[-1].type == 'newline'
 
 
 class ErrorFinderConfig(NormalizerConfig):
+    """ """
     normalizer_class = ErrorFinder
 
 
 class SyntaxRule(Rule):
+    """ """
     code = 901
 
     def _get_message(self, message, node):
+        """
+
+        Parameters
+        ----------
+        message :
+            
+        node :
+            
+
+        Returns
+        -------
+
+        """
         message = super(SyntaxRule, self)._get_message(message, node)
         if (
             "f-string" not in message
@@ -502,13 +856,36 @@
 
 @ErrorFinder.register_rule(type='error_node')
 class _InvalidSyntaxRule(SyntaxRule):
+    """ """
     message = "invalid syntax"
     fstring_message = "f-string: invalid syntax"
 
     def get_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return node.get_next_leaf()
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         error = node.get_next_leaf().type != 'error_leaf'
         if (
             error
@@ -522,21 +899,56 @@
 
 @ErrorFinder.register_rule(value='await')
 class _AwaitOutsideAsync(SyntaxRule):
+    """ """
     message = "'await' outside async function"
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         return not self._normalizer.context.is_async_funcdef()
 
     def get_error_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         # Return the whole await statement.
         return node.parent
 
 
 @ErrorFinder.register_rule(value='break')
 class _BreakOutsideLoop(SyntaxRule):
+    """ """
     message = "'break' outside loop"
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         in_loop = False
         for block in self._normalizer.context.blocks:
             if block.type in ('for_stmt', 'while_stmt'):
@@ -546,10 +958,22 @@
 
 @ErrorFinder.register_rule(value='continue')
 class _ContinueChecks(SyntaxRule):
+    """ """
     message = "'continue' not properly in loop"
     message_in_finally = "'continue' not supported inside 'finally' clause"
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         in_loop = False
         for block in self._normalizer.context.blocks:
             if block.type in ('for_stmt', 'while_stmt'):
@@ -569,22 +993,57 @@
 
 @ErrorFinder.register_rule(value='from')
 class _YieldFromCheck(SyntaxRule):
+    """ """
     message = "'yield from' inside async function"
 
     def get_node(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         return leaf.parent.parent  # This is the actual yield statement.
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         return leaf.parent.type == 'yield_arg' \
             and self._normalizer.context.is_async_funcdef()
 
 
 @ErrorFinder.register_rule(type='name')
 class _NameChecks(SyntaxRule):
+    """ """
     message = 'cannot assign to __debug__'
     message_none = 'cannot assign to None'
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         self._normalizer.context.add_name(leaf)
 
         if leaf.value == '__debug__' and leaf.is_definition():
@@ -596,9 +1055,21 @@
 
 @ErrorFinder.register_rule(type='string')
 class _StringChecks(SyntaxRule):
+    """ """
     message = "bytes can only contain ASCII literal characters."
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         string_prefix = leaf.string_prefix.lower()
         if 'b' in string_prefix \
                 and self._normalizer.version >= (3, 0) \
@@ -635,9 +1106,21 @@
 
 @ErrorFinder.register_rule(value='*')
 class _StarCheck(SyntaxRule):
+    """ """
     message = "named arguments must follow bare *"
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         params = leaf.parent
         if params.type == 'parameters' and params:
             after = params.children[params.children.index(leaf) + 1:]
@@ -648,12 +1131,24 @@
 
 @ErrorFinder.register_rule(value='**')
 class _StarStarCheck(SyntaxRule):
+    """ """
     # e.g. {**{} for a in [1]}
     # TODO this should probably get a better end_pos including
     #      the next sibling of leaf.
     message = "dict unpacking cannot be used in dict comprehension"
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         if leaf.parent.type == 'dictorsetmaker':
             comp_for = leaf.get_next_sibling().get_next_sibling()
             return comp_for is not None and comp_for.type in _COMP_FOR_TYPES
@@ -662,13 +1157,36 @@
 @ErrorFinder.register_rule(value='yield')
 @ErrorFinder.register_rule(value='return')
 class _ReturnAndYieldChecks(SyntaxRule):
+    """ """
     message = "'return' with value in async generator"
     message_async_yield = "'yield' inside async function"
 
     def get_node(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         return leaf.parent
 
     def is_issue(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         if self._normalizer.context.node.type != 'funcdef':
             self.add_issue(self.get_node(leaf), message="'%s' outside function" % leaf.value)
         elif self._normalizer.context.is_async_funcdef() \
@@ -683,15 +1201,38 @@
 
 @ErrorFinder.register_rule(type='strings')
 class _BytesAndStringMix(SyntaxRule):
+    """ """
     # e.g. 's' b''
     message = "cannot mix bytes and nonbytes literals"
 
     def _is_bytes_literal(self, string):
+        """
+
+        Parameters
+        ----------
+        string :
+            
+
+        Returns
+        -------
+
+        """
         if string.type == 'fstring':
             return False
         return 'b' in string.string_prefix.lower()
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         first = node.children[0]
         # In Python 2 it's allowed to mix bytes and unicode.
         if self._normalizer.version >= (3, 0):
@@ -703,27 +1244,63 @@
 
 @ErrorFinder.register_rule(type='import_as_names')
 class _TrailingImportComma(SyntaxRule):
+    """ """
     # e.g. from foo import a,
     message = "trailing comma not allowed without surrounding parentheses"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if node.children[-1] == ',' and node.parent.children[-1] != ')':
             return True
 
 
 @ErrorFinder.register_rule(type='import_from')
 class _ImportStarInFunction(SyntaxRule):
+    """ """
     message = "import * only allowed at module level"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return node.is_star_import() and self._normalizer.context.parent_context is not None
 
 
 @ErrorFinder.register_rule(type='import_from')
 class _FutureImportRule(SyntaxRule):
+    """ """
     message = "from __future__ imports must occur at the beginning of the file"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if _is_future_import(node):
             if not _is_future_import_first(node):
                 return True
@@ -747,10 +1324,22 @@
 
 @ErrorFinder.register_rule(type='star_expr')
 class _StarExprRule(SyntaxRule):
+    """ """
     message_iterable_unpacking = "iterable unpacking cannot be used in comprehension"
     message_assignment = "can use starred expression only as assignment target"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if node.parent.type == 'testlist_comp':
             # [*[] for a in [1]]
             if node.parent.children[1].type in _COMP_FOR_TYPES:
@@ -772,7 +1361,19 @@
 
 @ErrorFinder.register_rule(types=_STAR_EXPR_PARENTS)
 class _StarExprParentRule(SyntaxRule):
+    """ """
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if node.parent.type == 'del_stmt':
             if self._normalizer.version >= (3, 9):
                 self.add_issue(node.parent, message="cannot delete starred")
@@ -780,6 +1381,19 @@
                 self.add_issue(node.parent, message="can't use starred expression here")
         else:
             def is_definition(node, ancestor):
+                """
+
+                Parameters
+                ----------
+                node :
+                    
+                ancestor :
+                    
+
+                Returns
+                -------
+
+                """
                 if ancestor is None:
                     return False
 
@@ -810,14 +1424,37 @@
 
 @ErrorFinder.register_rule(type='annassign')
 class _AnnotatorRule(SyntaxRule):
+    """ """
     # True: int
     # {}: float
     message = "illegal target for annotation"
 
     def get_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return node.parent
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         type_ = None
         lhs = node.parent.children[0]
         lhs = _remove_parens(lhs)
@@ -847,7 +1484,19 @@
 
 @ErrorFinder.register_rule(type='argument')
 class _ArgumentRule(SyntaxRule):
+    """ """
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         first = node.children[0]
         if self._normalizer.version < (3, 8):
             # a((b)=c) is valid in <3.8
@@ -873,22 +1522,47 @@
 
 @ErrorFinder.register_rule(type='nonlocal_stmt')
 class _NonlocalModuleLevelRule(SyntaxRule):
+    """ """
     message = "nonlocal declaration not allowed at module level"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         return self._normalizer.context.parent_context is None
 
 
 @ErrorFinder.register_rule(type='arglist')
 class _ArglistRule(SyntaxRule):
+    """ """
     @property
     def message(self):
+        """ """
         if self._normalizer.version < (3, 7):
             return "Generator expression must be parenthesized if not sole argument"
         else:
             return "Generator expression must be parenthesized"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         arg_set = set()
         kw_only = False
         kw_unpacking_only = False
@@ -948,10 +1622,22 @@
 @ErrorFinder.register_rule(type='parameters')
 @ErrorFinder.register_rule(type='lambdef')
 class _ParameterRule(SyntaxRule):
+    """ """
     # def f(x=3, y): pass
     message = "non-default argument follows default argument"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         param_names = set()
         default_only = False
         for p in _iter_params(node):
@@ -969,9 +1655,21 @@
 
 @ErrorFinder.register_rule(type='try_stmt')
 class _TryStmtRule(SyntaxRule):
+    """ """
     message = "default 'except:' must be last"
 
     def is_issue(self, try_stmt):
+        """
+
+        Parameters
+        ----------
+        try_stmt :
+            
+
+        Returns
+        -------
+
+        """
         default_except = None
         for except_clause in try_stmt.children[3::3]:
             if except_clause in ('else', 'finally'):
@@ -984,15 +1682,42 @@
 
 @ErrorFinder.register_rule(type='fstring')
 class _FStringRule(SyntaxRule):
+    """ """
     _fstring_grammar = None
     message_expr = "f-string expression part cannot include a backslash"
     message_nested = "f-string: expressions nested too deeply"
     message_conversion = "f-string: invalid conversion character: expected 's', 'r', or 'a'"
 
     def _check_format_spec(self, format_spec, depth):
+        """
+
+        Parameters
+        ----------
+        format_spec :
+            
+        depth :
+            
+
+        Returns
+        -------
+
+        """
         self._check_fstring_contents(format_spec.children[1:], depth)
 
     def _check_fstring_expr(self, fstring_expr, depth):
+        """
+
+        Parameters
+        ----------
+        fstring_expr :
+            
+        depth :
+            
+
+        Returns
+        -------
+
+        """
         if depth >= 2:
             self.add_issue(fstring_expr, message=self.message_nested)
 
@@ -1011,16 +1736,58 @@
             self._check_format_spec(format_spec, depth + 1)
 
     def is_issue(self, fstring):
+        """
+
+        Parameters
+        ----------
+        fstring :
+            
+
+        Returns
+        -------
+
+        """
         self._check_fstring_contents(fstring.children[1:-1])
 
     def _check_fstring_contents(self, children, depth=0):
+        """
+
+        Parameters
+        ----------
+        children :
+            
+        depth :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         for fstring_content in children:
             if fstring_content.type == 'fstring_expr':
                 self._check_fstring_expr(fstring_content, depth)
 
 
 class _CheckAssignmentRule(SyntaxRule):
+    """ """
     def _check_assignment(self, node, is_deletion=False, is_namedexpr=False, is_aug_assign=False):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+        is_deletion :
+             (Default value = False)
+        is_namedexpr :
+             (Default value = False)
+        is_aug_assign :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         error = None
         type_ = node.type
         if type_ == 'lambdef':
@@ -1134,9 +1901,21 @@
 
 @ErrorFinder.register_rule(type='sync_comp_for')
 class _CompForRule(_CheckAssignmentRule):
+    """ """
     message = "asynchronous comprehension outside of an asynchronous function"
 
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         expr_list = node.children[1]
         if expr_list.type != 'expr_list':  # Already handled.
             self._check_assignment(expr_list)
@@ -1147,9 +1926,21 @@
 
 @ErrorFinder.register_rule(type='expr_stmt')
 class _ExprStmtRule(_CheckAssignmentRule):
+    """ """
     message = "illegal expression for augmented assignment"
     extended_message = "'{target}' is an " + message
     def is_issue(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         augassign = node.children[1]
         is_aug_assign = augassign != '=' and augassign.type != 'annassign'
 
@@ -1180,13 +1971,37 @@
 
 @ErrorFinder.register_rule(type='with_item')
 class _WithItemRule(_CheckAssignmentRule):
+    """ """
     def is_issue(self, with_item):
+        """
+
+        Parameters
+        ----------
+        with_item :
+            
+
+        Returns
+        -------
+
+        """
         self._check_assignment(with_item.children[2])
 
 
 @ErrorFinder.register_rule(type='del_stmt')
 class _DelStmtRule(_CheckAssignmentRule):
+    """ """
     def is_issue(self, del_stmt):
+        """
+
+        Parameters
+        ----------
+        del_stmt :
+            
+
+        Returns
+        -------
+
+        """
         child = del_stmt.children[1]
 
         if child.type != 'expr_list':  # Already handled.
@@ -1195,14 +2010,38 @@
 
 @ErrorFinder.register_rule(type='expr_list')
 class _ExprListRule(_CheckAssignmentRule):
+    """ """
     def is_issue(self, expr_list):
+        """
+
+        Parameters
+        ----------
+        expr_list :
+            
+
+        Returns
+        -------
+
+        """
         for expr in expr_list.children[::2]:
             self._check_assignment(expr)
 
 
 @ErrorFinder.register_rule(type='for_stmt')
 class _ForStmtRule(_CheckAssignmentRule):
+    """ """
     def is_issue(self, for_stmt):
+        """
+
+        Parameters
+        ----------
+        for_stmt :
+            
+
+        Returns
+        -------
+
+        """
         # Some of the nodes here are already used, so no else if
         expr_list = for_stmt.children[1]
         if expr_list.type != 'expr_list':  # Already handled.
@@ -1211,13 +2050,36 @@
 
 @ErrorFinder.register_rule(type='namedexpr_test')
 class _NamedExprRule(_CheckAssignmentRule):
+    """ """
     # namedexpr_test: test [':=' test]
 
     def is_issue(self, namedexpr_test):
+        """
+
+        Parameters
+        ----------
+        namedexpr_test :
+            
+
+        Returns
+        -------
+
+        """
         # assigned name
         first = namedexpr_test.children[0]
 
         def search_namedexpr_in_comp_for(node):
+            """
+
+            Parameters
+            ----------
+            node :
+                
+
+            Returns
+            -------
+
+            """
             while True:
                 parent = node.parent
                 if parent is None:
@@ -1237,6 +2099,17 @@
         exprlist = list()
 
         def process_comp_for(comp_for):
+            """
+
+            Parameters
+            ----------
+            comp_for :
+                
+
+            Returns
+            -------
+
+            """
             if comp_for.type == 'sync_comp_for':
                 comp = comp_for
             elif comp_for.type == 'comp_for':
@@ -1244,6 +2117,17 @@
             exprlist.extend(_get_for_stmt_definition_exprs(comp))
 
         def search_all_comp_ancestors(node):
+            """
+
+            Parameters
+            ----------
+            node :
+                
+
+            Returns
+            -------
+
+            """
             has_ancestors = False
             while True:
                 node = search_ancestor(node, 'testlist_comp', 'dictorsetmaker')
