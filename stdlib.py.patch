# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/plugins/stdlib.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/plugins/stdlib.py
@@ -44,6 +44,7 @@
 from collections import OrderedDict
 
 class {typename}(tuple):
+    """ """
     __slots__ = ()
 
     _fields = {field_names!r}
@@ -54,6 +55,21 @@
 
     @classmethod
     def _make(cls, iterable, new=tuple.__new__, len=len):
+        """
+
+        Parameters
+        ----------
+        iterable :
+            
+        new :
+             (Default value = tuple.__new__)
+        len :
+             (Default value = len)
+
+        Returns
+        -------
+
+        """
         'Make a new {typename} object from a sequence or iterable'
         result = new(cls, iterable)
         if len(result) != {num_fields:d}:
@@ -61,6 +77,19 @@
         return result
 
     def _replace(_self, **kwds):
+        """
+
+        Parameters
+        ----------
+        _self :
+            
+        **kwds :
+            
+
+        Returns
+        -------
+
+        """
         'Return a new {typename} object replacing specified fields with new values'
         result = _self._make(map(kwds.pop, {field_names!r}, _self))
         if kwds:
@@ -72,6 +101,7 @@
         return self.__class__.__name__ + '({repr_fmt})' % self
 
     def _asdict(self):
+        """ """
         'Return a new OrderedDict which maps field names to their values.'
         return OrderedDict(zip(self._fields, self))
 
@@ -102,8 +132,33 @@
 
 
 def execute(callback):
+    """
+
+    Parameters
+    ----------
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(value, arguments):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         def call():
+            """ """
             return callback(value, arguments=arguments)
 
         try:
@@ -137,6 +192,21 @@
 
 
 def _follow_param(inference_state, arguments, index):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    arguments :
+        
+    index :
+        
+
+    Returns
+    -------
+
+    """
     try:
         key, lazy_value = list(arguments.unpack())[index]
     except IndexError:
@@ -148,12 +218,56 @@
 def argument_clinic(clinic_string, want_value=False, want_context=False,
                     want_arguments=False, want_inference_state=False,
                     want_callback=False):
-    """
-    Works like Argument Clinic (PEP 436), to validate function params.
+    """Works like Argument Clinic (PEP 436), to validate function params.
+
+    Parameters
+    ----------
+    clinic_string :
+        
+    want_value :
+         (Default value = False)
+    want_context :
+         (Default value = False)
+    want_arguments :
+         (Default value = False)
+    want_inference_state :
+         (Default value = False)
+    want_callback :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
 
     def f(func):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         def wrapper(value, arguments, callback):
+            """
+
+            Parameters
+            ----------
+            value :
+                
+            arguments :
+                
+            callback :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 args = tuple(iterate_argument_clinic(
                     value.inference_state, arguments, clinic_string))
@@ -182,6 +296,21 @@
 
 @argument_clinic('iterator[, default], /', want_inference_state=True)
 def builtins_next(iterators, defaults, inference_state):
+    """
+
+    Parameters
+    ----------
+    iterators :
+        
+    defaults :
+        
+    inference_state :
+        
+
+    Returns
+    -------
+
+    """
     if inference_state.environment.version_info.major == 2:
         name = 'next'
     else:
@@ -194,12 +323,40 @@
 
 @argument_clinic('iterator[, default], /')
 def builtins_iter(iterators_or_callables, defaults):
+    """
+
+    Parameters
+    ----------
+    iterators_or_callables :
+        
+    defaults :
+        
+
+    Returns
+    -------
+
+    """
     # TODO implement this if it's a callable.
     return iterators_or_callables.py__getattribute__('__iter__').execute_with_values()
 
 
 @argument_clinic('object, name[, default], /')
 def builtins_getattr(objects, names, defaults=None):
+    """
+
+    Parameters
+    ----------
+    objects :
+        
+    names :
+        
+    defaults :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     # follow the first param
     for value in objects:
         for name in names:
@@ -214,6 +371,21 @@
 
 @argument_clinic('object[, bases, dict], /')
 def builtins_type(objects, bases, dicts):
+    """
+
+    Parameters
+    ----------
+    objects :
+        
+    bases :
+        
+    dicts :
+        
+
+    Returns
+    -------
+
+    """
     if bases or dicts:
         # It's a type creation... maybe someday...
         return NO_VALUES
@@ -228,9 +400,11 @@
         self._instance = instance  # Corresponds to super().__self__
 
     def _get_bases(self):
+        """ """
         return self._instance.py__class__().py__bases__()
 
     def _get_wrapped_value(self):
+        """ """
         objs = self._get_bases()[0].infer().execute_with_values()
         if not objs:
             # This is just a fallback and will only be used, if it's not
@@ -239,6 +413,17 @@
         return next(iter(objs))
 
     def get_filters(self, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for b in self._get_bases():
             for value in b.infer().execute_with_values():
                 for f in value.get_filters():
@@ -247,6 +432,21 @@
 
 @argument_clinic('[type[, value]], /', want_context=True)
 def builtins_super(types, objects, context):
+    """
+
+    Parameters
+    ----------
+    types :
+        
+    objects :
+        
+    context :
+        
+
+    Returns
+    -------
+
+    """
     instance = None
     if isinstance(context, AnonymousMethodExecutionContext):
         instance = context.instance
@@ -258,16 +458,39 @@
 
 
 class ReversedObject(AttributeOverwrite):
+    """ """
     def __init__(self, reversed_obj, iter_list):
         super(ReversedObject, self).__init__(reversed_obj)
         self._iter_list = iter_list
 
     def py__iter__(self, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         return self._iter_list
 
     @publish_method('next', python_version_match=2)
     @publish_method('__next__', python_version_match=3)
     def _next(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(
             lazy_value.infer() for lazy_value in self._iter_list
         )
@@ -275,6 +498,21 @@
 
 @argument_clinic('sequence, /', want_value=True, want_arguments=True)
 def builtins_reversed(sequences, value, arguments):
+    """
+
+    Parameters
+    ----------
+    sequences :
+        
+    value :
+        
+    arguments :
+        
+
+    Returns
+    -------
+
+    """
     # While we could do without this variable (just by using sequences), we
     # want static analysis to work well. Therefore we need to generated the
     # values again.
@@ -294,6 +532,23 @@
 
 @argument_clinic('value, type, /', want_arguments=True, want_inference_state=True)
 def builtins_isinstance(objects, types, arguments, inference_state):
+    """
+
+    Parameters
+    ----------
+    objects :
+        
+    types :
+        
+    arguments :
+        
+    inference_state :
+        
+
+    Returns
+    -------
+
+    """
     bool_results = set()
     for o in objects:
         cls = o.py__class__()
@@ -335,21 +590,60 @@
 
 
 class StaticMethodObject(ValueWrapper):
+    """ """
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet([self._wrapped_value])
 
 
 @argument_clinic('sequence, /')
 def builtins_staticmethod(functions):
+    """
+
+    Parameters
+    ----------
+    functions :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(StaticMethodObject(f) for f in functions)
 
 
 class ClassMethodObject(ValueWrapper):
+    """ """
     def __init__(self, class_method_obj, function):
         super(ClassMethodObject, self).__init__(class_method_obj)
         self._function = function
 
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet([
             ClassMethodGet(__get__, class_value, self._function)
             for __get__ in self._wrapped_value.py__getattribute__('__get__')
@@ -357,24 +651,49 @@
 
 
 class ClassMethodGet(ValueWrapper):
+    """ """
     def __init__(self, get_method, klass, function):
         super(ClassMethodGet, self).__init__(get_method)
         self._class = klass
         self._function = function
 
     def get_signatures(self):
+        """ """
         return [sig.bind(self._function) for sig in self._function.get_signatures()]
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return self._function.execute(ClassMethodArguments(self._class, arguments))
 
 
 class ClassMethodArguments(TreeArgumentsWrapper):
+    """ """
     def __init__(self, klass, arguments):
         super(ClassMethodArguments, self).__init__(arguments)
         self._class = klass
 
     def unpack(self, func=None):
+        """
+
+        Parameters
+        ----------
+        func :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield None, LazyKnownValue(self._class)
         for values in self._wrapped_arguments.unpack(func):
             yield values
@@ -382,6 +701,21 @@
 
 @argument_clinic('sequence, /', want_value=True, want_arguments=True)
 def builtins_classmethod(functions, value, arguments):
+    """
+
+    Parameters
+    ----------
+    functions :
+        
+    value :
+        
+    arguments :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(
         ClassMethodObject(class_method_object, function)
         for class_method_object in value.py__call__(arguments=arguments)
@@ -390,11 +724,25 @@
 
 
 class PropertyObject(AttributeOverwrite, ValueWrapper):
+    """ """
     def __init__(self, property_obj, function):
         super(PropertyObject, self).__init__(property_obj)
         self._function = function
 
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         if instance is None:
             return ValueSet([self])
         return self._function.execute_with_values(instance)
@@ -403,11 +751,35 @@
     @publish_method('getter')
     @publish_method('setter')
     def _return_self(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet({self})
 
 
 @argument_clinic('func, /', want_callback=True)
 def builtins_property(functions, callback):
+    """
+
+    Parameters
+    ----------
+    functions :
+        
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(
         PropertyObject(property_value, function)
         for property_value in callback()
@@ -416,11 +788,22 @@
 
 
 def collections_namedtuple(value, arguments, callback):
-    """
-    Implementation of the namedtuple function.
-
+    """Implementation of the namedtuple function.
+    
     This has to be done by processing the namedtuple class template and
     inferring the result.
+
+    Parameters
+    ----------
+    value :
+        
+    arguments :
+        
+    callback :
+        
+
+    Returns
+    -------
 
     """
     inference_state = value.inference_state
@@ -474,12 +857,24 @@
 
 
 class PartialObject(ValueWrapper):
+    """ """
     def __init__(self, actual_value, arguments, instance=None):
         super(PartialObject, self).__init__(actual_value)
         self._arguments = arguments
         self._instance = instance
 
     def _get_functions(self, unpacked_arguments):
+        """
+
+        Parameters
+        ----------
+        unpacked_arguments :
+            
+
+        Returns
+        -------
+
+        """
         key, lazy_value = next(unpacked_arguments, (None, None))
         if key is not None or lazy_value is None:
             debug.warning("Partial should have a proper function %s", self._arguments)
@@ -487,6 +882,7 @@
         return lazy_value.infer()
 
     def get_signatures(self):
+        """ """
         unpacked_arguments = self._arguments.unpack()
         funcs = self._get_functions(unpacked_arguments)
         if funcs is None:
@@ -504,6 +900,17 @@
         return [PartialSignature(s, arg_count, keys) for s in funcs.get_signatures()]
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         funcs = self._get_functions(self._arguments.unpack())
         if funcs is None:
             return NO_VALUES
@@ -513,10 +920,16 @@
         )
 
     def py__doc__(self):
-        """
-        In CPython partial does not replace the docstring. However we are still
+        """In CPython partial does not replace the docstring. However we are still
         imitating it here, because we want this docstring to be worth something
         for the user.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         callables = self._get_functions(self._arguments.unpack())
         if callables is None:
@@ -526,34 +939,85 @@
         return ''
 
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet([self])
 
 
 class PartialMethodObject(PartialObject):
+    """ """
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         if instance is None:
             return ValueSet([self])
         return ValueSet([PartialObject(self._wrapped_value, self._arguments, instance)])
 
 
 class PartialSignature(SignatureWrapper):
+    """ """
     def __init__(self, wrapped_signature, skipped_arg_count, skipped_arg_set):
         super(PartialSignature, self).__init__(wrapped_signature)
         self._skipped_arg_count = skipped_arg_count
         self._skipped_arg_set = skipped_arg_set
 
     def get_param_names(self, resolve_stars=False):
+        """
+
+        Parameters
+        ----------
+        resolve_stars :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         names = self._wrapped_signature.get_param_names()[self._skipped_arg_count:]
         return [n for n in names if n.string_name not in self._skipped_arg_set]
 
 
 class MergedPartialArguments(AbstractArguments):
+    """ """
     def __init__(self, partial_arguments, call_arguments, instance=None):
         self._partial_arguments = partial_arguments
         self._call_arguments = call_arguments
         self._instance = instance
 
     def unpack(self, funcdef=None):
+        """
+
+        Parameters
+        ----------
+        funcdef :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         unpacked = self._partial_arguments.unpack(funcdef)
         # Ignore this one, it's the function. It was checked before that it's
         # there.
@@ -567,6 +1031,21 @@
 
 
 def functools_partial(value, arguments, callback):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    arguments :
+        
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(
         PartialObject(instance, arguments)
         for instance in value.py__call__(arguments)
@@ -574,6 +1053,21 @@
 
 
 def functools_partialmethod(value, arguments, callback):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    arguments :
+        
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(
         PartialMethodObject(instance, arguments)
         for instance in value.py__call__(arguments)
@@ -582,11 +1076,33 @@
 
 @argument_clinic('first, /')
 def _return_first_param(firsts):
+    """
+
+    Parameters
+    ----------
+    firsts :
+        
+
+    Returns
+    -------
+
+    """
     return firsts
 
 
 @argument_clinic('seq')
 def _random_choice(sequences):
+    """
+
+    Parameters
+    ----------
+    sequences :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet.from_sets(
         lazy_value.infer()
         for sequence in sequences
@@ -595,6 +1111,21 @@
 
 
 def _dataclass(value, arguments, callback):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    arguments :
+        
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     for c in _follow_param(value.inference_state, arguments, 0):
         if c.is_class():
             return ValueSet([DataclassWrapper(c)])
@@ -604,7 +1135,9 @@
 
 
 class DataclassWrapper(ValueWrapper, ClassMixin):
+    """ """
     def get_signatures(self):
+        """ """
         param_names = []
         for cls in reversed(list(self.py__mro__())):
             if isinstance(cls, DataclassWrapper):
@@ -630,24 +1163,39 @@
 
 
 class DataclassSignature(AbstractSignature):
+    """ """
     def __init__(self, value, param_names):
         super(DataclassSignature, self).__init__(value)
         self._param_names = param_names
 
     def get_param_names(self, resolve_stars=False):
+        """
+
+        Parameters
+        ----------
+        resolve_stars :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return self._param_names
 
 
 class DataclassParamName(BaseTreeParamName):
+    """ """
     def __init__(self, parent_context, tree_name, annotation_node, default_node):
         super(DataclassParamName, self).__init__(parent_context, tree_name)
         self.annotation_node = annotation_node
         self.default_node = default_node
 
     def get_kind(self):
+        """ """
         return Parameter.POSITIONAL_OR_KEYWORD
 
     def infer(self):
+        """ """
         if self.annotation_node is None:
             return NO_VALUES
         else:
@@ -655,12 +1203,24 @@
 
 
 class ItemGetterCallable(ValueWrapper):
+    """ """
     def __init__(self, instance, args_value_set):
         super(ItemGetterCallable, self).__init__(instance)
         self._args_value_set = args_value_set
 
     @repack_with_argument_clinic('item, /')
     def py__call__(self, item_value_set):
+        """
+
+        Parameters
+        ----------
+        item_value_set :
+            
+
+        Returns
+        -------
+
+        """
         value_set = NO_VALUES
         for args_value in self._args_value_set:
             lazy_values = list(args_value.py__iter__())
@@ -680,33 +1240,74 @@
 
 @argument_clinic('func, /')
 def _functools_wraps(funcs):
+    """
+
+    Parameters
+    ----------
+    funcs :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet(WrapsCallable(func) for func in funcs)
 
 
 class WrapsCallable(ValueWrapper):
+    """ """
     # XXX this is not the correct wrapped value, it should be a weird
     #     partials object, but it doesn't matter, because it's always used as a
     #     decorator anyway.
     @repack_with_argument_clinic('func, /')
     def py__call__(self, funcs):
+        """
+
+        Parameters
+        ----------
+        funcs :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet({Wrapped(func, self._wrapped_value) for func in funcs})
 
 
 class Wrapped(ValueWrapper, FunctionMixin):
+    """ """
     def __init__(self, func, original_function):
         super(Wrapped, self).__init__(func)
         self._original_function = original_function
 
     @property
     def name(self):
+        """ """
         return self._original_function.name
 
     def get_signature_functions(self):
+        """ """
         return [self]
 
 
 @argument_clinic('*args, /', want_value=True, want_arguments=True)
 def _operator_itemgetter(args_value_set, value, arguments):
+    """
+
+    Parameters
+    ----------
+    args_value_set :
+        
+    value :
+        
+    arguments :
+        
+
+    Returns
+    -------
+
+    """
     return ValueSet([
         ItemGetterCallable(instance, args_value_set)
         for instance in value.py__call__(arguments)
@@ -714,9 +1315,36 @@
 
 
 def _create_string_input_function(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     @argument_clinic('string, /', want_value=True, want_arguments=True)
     def wrapper(strings, value, arguments):
+        """
+
+        Parameters
+        ----------
+        strings :
+            
+        value :
+            
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         def iterate():
+            """ """
             for value in strings:
                 s = get_str_or_none(value)
                 if s is not None:
@@ -731,6 +1359,19 @@
 
 @argument_clinic('*args, /', want_callback=True)
 def _os_path_join(args_set, callback):
+    """
+
+    Parameters
+    ----------
+    args_set :
+        
+    callback :
+        
+
+    Returns
+    -------
+
+    """
     if len(args_set) == 1:
         string = u''
         sequence, = args_set
@@ -817,7 +1458,31 @@
 
 
 def get_metaclass_filters(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(cls, metaclasses, is_instance):
+        """
+
+        Parameters
+        ----------
+        metaclasses :
+            
+        is_instance :
+            
+
+        Returns
+        -------
+
+        """
         for metaclass in metaclasses:
             if metaclass.py__name__() == 'EnumMeta' \
                     and metaclass.get_root_context().py__name__() == 'enum':
@@ -830,6 +1495,7 @@
 
 
 class EnumInstance(LazyValueWrapper):
+    """ """
     def __init__(self, cls, name):
         self.inference_state = cls.inference_state
         self._cls = cls  # Corresponds to super().__self__
@@ -838,13 +1504,26 @@
 
     @safe_property
     def name(self):
+        """ """
         return ValueName(self, self._name.tree_name)
 
     def _get_wrapped_value(self):
+        """ """
         value, = self._cls.execute_with_values()
         return value
 
     def get_filters(self, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield DictFilter(dict(
             name=compiled.create_simple_object(self.inference_state, self._name.string_name).name,
             value=self._name,
@@ -854,7 +1533,33 @@
 
 
 def tree_name_to_values(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(inference_state, context, tree_name):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+        context :
+            
+        tree_name :
+            
+
+        Returns
+        -------
+
+        """
         if tree_name.value == 'sep' and context.is_module() and context.py__name__() == 'os.path':
             return ValueSet({
                 compiled.create_simple_object(inference_state, os.path.sep),
