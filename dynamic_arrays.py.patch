# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/value/dynamic_arrays.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/value/dynamic_arrays.py
@@ -32,7 +32,19 @@
 
 
 def check_array_additions(context, sequence):
-    """ Just a mapper function for the internal _internal_check_array_additions """
+    """Just a mapper function for the internal _internal_check_array_additions
+
+    Parameters
+    ----------
+    context :
+        
+    sequence :
+        
+
+    Returns
+    -------
+
+    """
     if sequence.array_type not in ('list', 'set'):
         # TODO also check for dict updates
         return NO_VALUES
@@ -43,8 +55,17 @@
 @inference_state_method_cache(default=NO_VALUES)
 @debug.increase_indent
 def _internal_check_array_additions(context, sequence):
-    """
-    Checks if a `Array` has "add" (append, insert, extend) statements:
+    """Checks if a `Array` has "add" (append, insert, extend) statements:
+
+    Parameters
+    ----------
+    context :
+        
+    sequence :
+        
+
+    Returns
+    -------
 
     >>> a = [""]
     >>> a.append(1)
@@ -58,6 +79,21 @@
         return NO_VALUES
 
     def find_additions(context, arglist, add_name):
+        """
+
+        Parameters
+        ----------
+        context :
+            
+        arglist :
+            
+        add_name :
+            
+
+        Returns
+        -------
+
+        """
         params = list(arguments.TreeArguments(context.inference_state, context, arglist).unpack())
         result = set()
         if add_name in ['insert']:
@@ -124,31 +160,61 @@
 
 
 def get_dynamic_array_instance(instance, arguments):
-    """Used for set() and list() instances."""
+    """Used for set() and list() instances.
+
+    Parameters
+    ----------
+    instance :
+        
+    arguments :
+        
+
+    Returns
+    -------
+
+    """
     ai = _DynamicArrayAdditions(instance, arguments)
     from jedi.inference import arguments
     return arguments.ValuesArguments([ValueSet([ai])])
 
 
 class _DynamicArrayAdditions(HelperValueMixin):
-    """
-    Used for the usage of set() and list().
+    """Used for the usage of set() and list().
     This is definitely a hack, but a good one :-)
     It makes it possible to use set/list conversions.
-
+    
     This is not a proper context, because it doesn't have to be. It's not used
     in the wild, it's just used within typeshed as an argument to `__init__`
     for set/list and never used in any other place.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, instance, arguments):
         self._instance = instance
         self._arguments = arguments
 
     def py__class__(self):
+        """ """
         tuple_, = self._instance.inference_state.builtins_module.py__getattribute__('tuple')
         return tuple_
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         arguments = self._arguments
         try:
             _, lazy_value = next(arguments.unpack())
@@ -165,19 +231,57 @@
                 yield addition
 
     def iterate(self, contextualized_node=None, is_async=False):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+        is_async :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return self.py__iter__(contextualized_node)
 
 
 class _Modification(ValueWrapper):
+    """ """
     def __init__(self, wrapped_value, assigned_values, contextualized_key):
         super(_Modification, self).__init__(wrapped_value)
         self._assigned_values = assigned_values
         self._contextualized_key = contextualized_key
 
     def py__getitem__(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self._wrapped_value.py__getitem__(*args, **kwargs) | self._assigned_values
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         actual = [
             v.get_safe_value(_sentinel)
             for v in self._contextualized_key.infer()
@@ -188,17 +292,42 @@
 
 
 class DictModification(_Modification):
+    """ """
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for lazy_context in self._wrapped_value.py__iter__(contextualized_node):
             yield lazy_context
         yield self._contextualized_key
 
     def get_key_values(self):
+        """ """
         return self._wrapped_value.get_key_values() | self._contextualized_key.infer()
 
 
 class ListModification(_Modification):
+    """ """
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for lazy_context in self._wrapped_value.py__iter__(contextualized_node):
             yield lazy_context
         yield LazyKnownValues(self._assigned_values)
