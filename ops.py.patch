# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/base/ops.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/base/ops.py
@@ -10,15 +10,63 @@
 
 
 class BaseOpsUtil(BaseExtensionTests):
+    """ """
     def get_op_from_name(self, op_name):
+        """
+
+        Parameters
+        ----------
+        op_name :
+            
+
+        Returns
+        -------
+
+        """
         return tm.get_op_from_name(op_name)
 
     def check_opname(self, s, op_name, other, exc=Exception):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        other :
+            
+        exc :
+             (Default value = Exception)
+
+        Returns
+        -------
+
+        """
         op = self.get_op_from_name(op_name)
 
         self._check_op(s, op, other, op_name, exc)
 
     def _check_op(self, s, op, other, op_name, exc=NotImplementedError):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        op_name :
+            
+        exc :
+             (Default value = NotImplementedError)
+
+        Returns
+        -------
+
+        """
         if exc is None:
             result = op(s, other)
             if isinstance(s, pd.DataFrame):
@@ -34,6 +82,23 @@
                 op(s, other)
 
     def _check_divmod_op(self, s, op, other, exc=Exception):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        exc :
+             (Default value = Exception)
+
+        Returns
+        -------
+
+        """
         # divmod has multiple return values, so check separately
         if exc is None:
             result_div, result_mod = op(s, other)
@@ -49,16 +114,22 @@
 
 
 class BaseArithmeticOpsTests(BaseOpsUtil):
-    """
-    Various Series and DataFrame arithmetic ops methods.
-
+    """Various Series and DataFrame arithmetic ops methods.
+    
     Subclasses supporting various ops should set the class variables
     to indicate that they support ops of that kind
-
+    
     * series_scalar_exc = TypeError
     * frame_scalar_exc = TypeError
     * series_array_exc = TypeError
     * divmod_exc = TypeError
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     series_scalar_exc: Optional[Type[TypeError]] = TypeError
@@ -67,6 +138,19 @@
     divmod_exc: Optional[Type[TypeError]] = TypeError
 
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         # series & scalar
         op_name = all_arithmetic_operators
         s = pd.Series(data)
@@ -74,12 +158,38 @@
 
     @pytest.mark.xfail(run=False, reason="_reduce needs implementation")
     def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         # frame & scalar
         op_name = all_arithmetic_operators
         df = pd.DataFrame({"A": data})
         self.check_opname(df, op_name, data[0], exc=self.frame_scalar_exc)
 
     def test_arith_series_with_array(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         # ndarray & other series
         op_name = all_arithmetic_operators
         s = pd.Series(data)
@@ -88,11 +198,35 @@
         )
 
     def test_divmod(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data)
         self._check_divmod_op(s, divmod, 1, exc=self.divmod_exc)
         self._check_divmod_op(1, ops.rdivmod, s, exc=self.divmod_exc)
 
     def test_divmod_series_array(self, data, data_for_twos):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        data_for_twos :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data)
         self._check_divmod_op(s, divmod, data)
 
@@ -103,18 +237,53 @@
         self._check_divmod_op(other, ops.rdivmod, s)
 
     def test_add_series_with_extension_array(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data)
         result = s + data
         expected = pd.Series(data + data)
         self.assert_series_equal(result, expected)
 
     def test_error(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         # invalid ops
         op_name = all_arithmetic_operators
         with pytest.raises(AttributeError):
             getattr(data, op_name)
 
     def test_direct_arith_with_series_returns_not_implemented(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # EAs should return NotImplemented for ops with Series.
         # Pandas takes care of unboxing the series and calling the EA's op.
         other = pd.Series(data)
@@ -129,6 +298,23 @@
     """Various Series and DataFrame comparison ops methods."""
 
     def _compare_other(self, s, data, op_name, other):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        data :
+            
+        op_name :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         op = self.get_op_from_name(op_name)
         if op_name == "__eq__":
             assert not op(s, other).all()
@@ -146,17 +332,54 @@
                 op(s, other)
 
     def test_compare_scalar(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         op_name = all_compare_operators
         s = pd.Series(data)
         self._compare_other(s, data, op_name, 0)
 
     def test_compare_array(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         op_name = all_compare_operators
         s = pd.Series(data)
         other = pd.Series([data[0]] * len(data))
         self._compare_other(s, data, op_name, other)
 
     def test_direct_arith_with_series_returns_not_implemented(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # EAs should return NotImplemented for ops with Series.
         # Pandas takes care of unboxing the series and calling the EA's op.
         other = pd.Series(data)
@@ -174,7 +397,19 @@
 
 
 class BaseUnaryOpsTests(BaseOpsUtil):
+    """ """
     def test_invert(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(data, name="name")
         result = ~s
         expected = pd.Series(~data, name="name")
