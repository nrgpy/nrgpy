# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/shape_base.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/shape_base.py
@@ -18,14 +18,24 @@
 
 
 def _atleast_1d_dispatcher(*arys):
+    """
+
+    Parameters
+    ----------
+    *arys :
+        
+
+    Returns
+    -------
+
+    """
     return arys
 
 
 @array_function_dispatch(_atleast_1d_dispatcher)
 def atleast_1d(*arys):
-    """
-    Convert inputs to arrays with at least one dimension.
-
+    """Convert inputs to arrays with at least one dimension.
+    
     Scalar inputs are converted to 1-dimensional arrays, whilst
     higher-dimensional inputs are preserved.
 
@@ -33,6 +43,8 @@
     ----------
     arys1, arys2, ... : array_like
         One or more input arrays.
+    *arys :
+        
 
     Returns
     -------
@@ -43,12 +55,11 @@
     See Also
     --------
     atleast_2d, atleast_3d
-
     Examples
     --------
     >>> np.atleast_1d(1.0)
     array([1.])
-
+    
     >>> x = np.arange(9.0).reshape(3,3)
     >>> np.atleast_1d(x)
     array([[0., 1., 2.],
@@ -56,10 +67,9 @@
            [6., 7., 8.]])
     >>> np.atleast_1d(x) is x
     True
-
+    
     >>> np.atleast_1d(1, [3, 4])
     [array([1]), array([3, 4])]
-
     """
     res = []
     for ary in arys:
@@ -76,13 +86,23 @@
 
 
 def _atleast_2d_dispatcher(*arys):
+    """
+
+    Parameters
+    ----------
+    *arys :
+        
+
+    Returns
+    -------
+
+    """
     return arys
 
 
 @array_function_dispatch(_atleast_2d_dispatcher)
 def atleast_2d(*arys):
-    """
-    View inputs as arrays with at least two dimensions.
+    """View inputs as arrays with at least two dimensions.
 
     Parameters
     ----------
@@ -90,6 +110,8 @@
         One or more array-like sequences.  Non-array inputs are converted
         to arrays.  Arrays that already have two or more dimensions are
         preserved.
+    *arys :
+        
 
     Returns
     -------
@@ -101,21 +123,19 @@
     See Also
     --------
     atleast_1d, atleast_3d
-
     Examples
     --------
     >>> np.atleast_2d(3.0)
     array([[3.]])
-
+    
     >>> x = np.arange(3.0)
     >>> np.atleast_2d(x)
     array([[0., 1., 2.]])
     >>> np.atleast_2d(x).base is x
     True
-
+    
     >>> np.atleast_2d(1, [1, 2], [[1, 2]])
     [array([[1]]), array([[1, 2]]), array([[1, 2]])]
-
     """
     res = []
     for ary in arys:
@@ -134,13 +154,23 @@
 
 
 def _atleast_3d_dispatcher(*arys):
+    """
+
+    Parameters
+    ----------
+    *arys :
+        
+
+    Returns
+    -------
+
+    """
     return arys
 
 
 @array_function_dispatch(_atleast_3d_dispatcher)
 def atleast_3d(*arys):
-    """
-    View inputs as arrays with at least three dimensions.
+    """View inputs as arrays with at least three dimensions.
 
     Parameters
     ----------
@@ -148,6 +178,8 @@
         One or more array-like sequences.  Non-array inputs are converted to
         arrays.  Arrays that already have three or more dimensions are
         preserved.
+    *arys :
+        
 
     Returns
     -------
@@ -161,22 +193,21 @@
     See Also
     --------
     atleast_1d, atleast_2d
-
     Examples
     --------
     >>> np.atleast_3d(3.0)
     array([[[3.]]])
-
+    
     >>> x = np.arange(3.0)
     >>> np.atleast_3d(x).shape
     (1, 3, 1)
-
+    
     >>> x = np.arange(12.0).reshape(4,3)
     >>> np.atleast_3d(x).shape
     (4, 3, 1)
     >>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
     True
-
+    
     >>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
     ...     print(arr, arr.shape) # doctest: +SKIP
     ...
@@ -185,7 +216,6 @@
     [[[1]
       [2]]] (1, 2, 1)
     [[[1 2]]] (1, 1, 2)
-
     """
     res = []
     for ary in arys:
@@ -206,6 +236,19 @@
 
 
 def _arrays_for_stack_dispatcher(arrays, stacklevel=4):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    stacklevel :
+         (Default value = 4)
+
+    Returns
+    -------
+
+    """
     if not hasattr(arrays, '__getitem__') and hasattr(arrays, '__iter__'):
         warnings.warn('arrays to stack must be passed as a "sequence" type '
                       'such as list or tuple. Support for non-sequence '
@@ -217,18 +260,28 @@
 
 
 def _vhstack_dispatcher(tup):
+    """
+
+    Parameters
+    ----------
+    tup :
+        
+
+    Returns
+    -------
+
+    """
     return _arrays_for_stack_dispatcher(tup)
 
 
 @array_function_dispatch(_vhstack_dispatcher)
 def vstack(tup):
-    """
-    Stack arrays in sequence vertically (row wise).
-
+    """Stack arrays in sequence vertically (row wise).
+    
     This is equivalent to concatenation along the first axis after 1-D arrays
     of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
     `vsplit`.
-
+    
     This function makes most sense for arrays with up to 3 dimensions. For
     instance, for pixel-data with a height (first axis), width (second axis),
     and r/g/b channels (third axis). The functions `concatenate`, `stack` and
@@ -254,7 +307,6 @@
     dstack : Stack arrays in sequence depth wise (along third axis).
     column_stack : Stack 1-D arrays as columns into a 2-D array.
     vsplit : Split an array into multiple sub-arrays vertically (row-wise).
-
     Examples
     --------
     >>> a = np.array([1, 2, 3])
@@ -262,7 +314,7 @@
     >>> np.vstack((a,b))
     array([[1, 2, 3],
            [2, 3, 4]])
-
+    
     >>> a = np.array([[1], [2], [3]])
     >>> b = np.array([[2], [3], [4]])
     >>> np.vstack((a,b))
@@ -272,7 +324,6 @@
            [2],
            [3],
            [4]])
-
     """
     if not overrides.ARRAY_FUNCTION_ENABLED:
         # raise warning if necessary
@@ -285,13 +336,12 @@
 
 @array_function_dispatch(_vhstack_dispatcher)
 def hstack(tup):
-    """
-    Stack arrays in sequence horizontally (column wise).
-
+    """Stack arrays in sequence horizontally (column wise).
+    
     This is equivalent to concatenation along the second axis, except for 1-D
     arrays where it concatenates along the first axis. Rebuilds arrays divided
     by `hsplit`.
-
+    
     This function makes most sense for arrays with up to 3 dimensions. For
     instance, for pixel-data with a height (first axis), width (second axis),
     and r/g/b channels (third axis). The functions `concatenate`, `stack` and
@@ -317,7 +367,6 @@
     dstack : Stack arrays in sequence depth wise (along third axis).
     column_stack : Stack 1-D arrays as columns into a 2-D array.
     hsplit : Split an array into multiple sub-arrays horizontally (column-wise).
-
     Examples
     --------
     >>> a = np.array((1,2,3))
@@ -330,7 +379,6 @@
     array([[1, 2],
            [2, 3],
            [3, 4]])
-
     """
     if not overrides.ARRAY_FUNCTION_ENABLED:
         # raise warning if necessary
@@ -347,6 +395,21 @@
 
 
 def _stack_dispatcher(arrays, axis=None, out=None):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    axis :
+         (Default value = None)
+    out :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     arrays = _arrays_for_stack_dispatcher(arrays, stacklevel=6)
     if out is not None:
         # optimize for the typical case where only arrays is provided
@@ -357,27 +420,24 @@
 
 @array_function_dispatch(_stack_dispatcher)
 def stack(arrays, axis=0, out=None):
-    """
-    Join a sequence of arrays along a new axis.
-
+    """Join a sequence of arrays along a new axis.
+    
     The ``axis`` parameter specifies the index of the new axis in the
     dimensions of the result. For example, if ``axis=0`` it will be the first
     dimension and if ``axis=-1`` it will be the last dimension.
-
+    
     .. versionadded:: 1.10.0
 
     Parameters
     ----------
     arrays : sequence of array_like
         Each array must have the same shape.
-
     axis : int, optional
-        The axis in the result array along which the input arrays are stacked.
-
+        The axis in the result array along which the input arrays are stacked. (Default value = 0)
     out : ndarray, optional
         If provided, the destination to place the result. The shape must be
         correct, matching that of what stack would have returned if no
-        out argument were specified.
+        out argument were specified. (Default value = None)
 
     Returns
     -------
@@ -389,30 +449,28 @@
     concatenate : Join a sequence of arrays along an existing axis.
     block : Assemble an nd-array from nested lists of blocks.
     split : Split array into a list of multiple sub-arrays of equal size.
-
     Examples
     --------
     >>> arrays = [np.random.randn(3, 4) for _ in range(10)]
     >>> np.stack(arrays, axis=0).shape
     (10, 3, 4)
-
+    
     >>> np.stack(arrays, axis=1).shape
     (3, 10, 4)
-
+    
     >>> np.stack(arrays, axis=2).shape
     (3, 4, 10)
-
+    
     >>> a = np.array([1, 2, 3])
     >>> b = np.array([2, 3, 4])
     >>> np.stack((a, b))
     array([[1, 2, 3],
            [2, 3, 4]])
-
+    
     >>> np.stack((a, b), axis=-1)
     array([[1, 2],
            [2, 3],
            [3, 4]])
-
     """
     if not overrides.ARRAY_FUNCTION_ENABLED:
         # raise warning if necessary
@@ -443,19 +501,26 @@
 
 
 def _block_format_index(index):
-    """
-    Convert a list of indices ``[0, 1, 2]`` into ``"arrays[0][1][2]"``.
+    """Convert a list of indices ``[0, 1, 2]`` into ``"arrays[0][1][2]"``.
+
+    Parameters
+    ----------
+    index :
+        
+
+    Returns
+    -------
+
     """
     idx_str = ''.join('[{}]'.format(i) for i in index if i is not None)
     return 'arrays' + idx_str
 
 
 def _block_check_depths_match(arrays, parent_index=[]):
-    """
-    Recursive function checking that the depths of nested lists in `arrays`
+    """Recursive function checking that the depths of nested lists in `arrays`
     all match. Mismatch raises a ValueError as described in the block
     docstring below.
-
+    
     The entire index (rather than just the depth) needs to be calculated
     for each innermost list, in case an error needs to be raised, so that
     the index of the offending list can be printed as part of the error.
@@ -466,20 +531,12 @@
         The arrays to check
     parent_index : list of int
         The full index of `arrays` within the nested lists passed to
-        `_block_check_depths_match` at the top of the recursion.
-
-    Returns
-    -------
-    first_index : list of int
-        The full index of an element from the bottom of the nesting in
-        `arrays`. If any element at the bottom is an empty list, this will
-        refer to it, and the last index along the empty axis will be None.
-    max_arr_ndim : int
-        The maximum of the ndims of the arrays nested in `arrays`.
-    final_size: int
-        The number of elements in the final array. This is used the motivate
-        the choice of algorithm used using benchmarking wisdom.
-
+        `_block_check_depths_match` at the top of the recursion. (Default value = [])
+
+    Returns
+    -------
+
+    
     """
     if type(arrays) is tuple:
         # not strictly necessary, but saves us from:
@@ -527,50 +584,55 @@
 
 
 def _atleast_nd(a, ndim):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    ndim :
+        
+
+    Returns
+    -------
+
+    """
     # Ensures `a` has at least `ndim` dimensions by prepending
     # ones to `a.shape` as necessary
     return array(a, ndmin=ndim, copy=False, subok=True)
 
 
 def _accumulate(values):
+    """
+
+    Parameters
+    ----------
+    values :
+        
+
+    Returns
+    -------
+
+    """
     return list(itertools.accumulate(values))
 
 
 def _concatenate_shapes(shapes, axis):
     """Given array shapes, return the resulting shape and slices prefixes.
-
+    
     These help in nested concatation.
-    Returns
-    -------
-    shape: tuple of int
-        This tuple satisfies:
-        ```
-        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)
-        shape == concatenate(arrs, axis).shape
-        ```
-
-    slice_prefixes: tuple of (slice(start, end), )
-        For a list of arrays being concatenated, this returns the slice
-        in the larger array at axis that needs to be sliced into.
-
-        For example, the following holds:
-        ```
-        ret = concatenate([a, b, c], axis)
-        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)
-
-        ret[(slice(None),) * axis + sl_a] == a
-        ret[(slice(None),) * axis + sl_b] == b
-        ret[(slice(None),) * axis + sl_c] == c
-        ```
-
-        These are called slice prefixes since they are used in the recursive
-        blocking algorithm to compute the left-most slices during the
-        recursion. Therefore, they must be prepended to rest of the slice
-        that was computed deeper in the recursion.
-
-        These are returned as tuples to ensure that they can quickly be added
-        to existing slice tuple without creating a new tuple every time.
-
+
+    Parameters
+    ----------
+    shapes :
+        
+    axis :
+        
+
+    Returns
+    -------
+
+    
     """
     # Cache a result that will be reused.
     shape_at_axis = [shape[axis] for shape in shapes]
@@ -595,8 +657,7 @@
 
 
 def _block_info_recursion(arrays, max_depth, result_ndim, depth=0):
-    """
-    Returns the shape of the final array, along with a list
+    """Returns the shape of the final array, along with a list
     of slices and a list of arrays that can be used for assignment inside the
     new array
 
@@ -606,20 +667,15 @@
         The arrays to check
     max_depth : list of int
         The number of nested lists
-    result_ndim: int
+    result_ndim : int
         The number of dimensions in thefinal array.
-
-    Returns
-    -------
-    shape : tuple of int
-        The shape that the final array will take on.
-    slices: list of tuple of slices
-        The slices into the full array required for assignment. These are
-        required to be prepended with ``(Ellipsis, )`` to obtain to correct
-        final index.
-    arrays: list of ndarray
-        The data to assign to each slice of the full array
-
+    depth :
+         (Default value = 0)
+
+    Returns
+    -------
+
+    
     """
     if depth < max_depth:
         shapes, slices, arrays = zip(
@@ -648,13 +704,27 @@
 
 
 def _block(arrays, max_depth, result_ndim, depth=0):
-    """
-    Internal implementation of block based on repeated concatenation.
+    """Internal implementation of block based on repeated concatenation.
     `arrays` is the argument passed to
     block. `max_depth` is the depth of nested lists within `arrays` and
     `result_ndim` is the greatest of the dimensions of the arrays in
     `arrays` and the depth of the lists in `arrays` (see block docstring
     for details).
+
+    Parameters
+    ----------
+    arrays :
+        
+    max_depth :
+        
+    result_ndim :
+        
+    depth :
+         (Default value = 0)
+
+    Returns
+    -------
+
     """
     if depth < max_depth:
         arrs = [_block(arr, max_depth, result_ndim, depth+1)
@@ -667,6 +737,17 @@
 
 
 def _block_dispatcher(arrays):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+
+    Returns
+    -------
+
+    """
     # Use type(...) is list to match the behavior of np.block(), which special
     # cases list specifically rather than allowing for generic iterables or
     # tuple. Also, we know that list.__array_function__ will never exist.
@@ -679,22 +760,21 @@
 
 @array_function_dispatch(_block_dispatcher)
 def block(arrays):
-    """
-    Assemble an nd-array from nested lists of blocks.
-
+    """Assemble an nd-array from nested lists of blocks.
+    
     Blocks in the innermost lists are concatenated (see `concatenate`) along
     the last dimension (-1), then these are concatenated along the
     second-last dimension (-2), and so on until the outermost list is reached.
-
+    
     Blocks can be of any dimension, but will not be broadcasted using the normal
     rules. Instead, leading axes of size 1 are inserted, to make ``block.ndim``
     the same for all blocks. This is primarily useful for working with scalars,
     and means that code like ``np.block([v, 1])`` is valid, where
     ``v.ndim == 1``.
-
+    
     When the nested list is two levels deep, this allows block matrices to be
     constructed from their components.
-
+    
     .. versionadded:: 1.13.0
 
     Parameters
@@ -702,7 +782,6 @@
     arrays : nested list of array_like or scalars (but not tuples)
         If passed a single ndarray or scalar (a nested list of depth 0), this
         is returned unmodified (and not copied).
-
         Elements shapes must match along the appropriate axes (without
         broadcasting), but leading 1s will be prepended to the shape as
         necessary to make the dimensions match.
@@ -711,7 +790,6 @@
     -------
     block_array : ndarray
         The array assembled from the given blocks.
-
         The dimensionality of the output is equal to the greatest of:
         * the dimensionality of all the inputs
         * the depth to which the input list is nested
@@ -720,7 +798,7 @@
     ------
     ValueError
         * If list depths are mismatched - for instance, ``[[a, b], c]`` is
-          illegal, and should be spelt ``[[a, b], [c]]``
+        illegal, and should be spelt ``[[a, b], [c]]``
         * If lists are empty - for instance, ``[[a, b], []]``
 
     See Also
@@ -732,41 +810,50 @@
     dstack : Stack arrays in sequence depth wise (along third axis).
     column_stack : Stack 1-D arrays as columns into a 2-D array.
     vsplit : Split an array into multiple sub-arrays vertically (row-wise).
-
     Notes
     -----
-
+    
     When called with only scalars, ``np.block`` is equivalent to an ndarray
     call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
     ``np.array([[1, 2], [3, 4]])``.
-
+    
     This function does not enforce that the blocks lie on a fixed grid.
     ``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::
-
+    
         AAAbb
         AAAbb
         cccDD
-
+    
     But is also allowed to produce, for some ``a, b, c, d``::
-
+    
         AAAbb
         AAAbb
         cDDDD
-
+    
     Since concatenation happens along the last axis first, `block` is _not_
     capable of producing the following directly::
-
+    
         AAAbb
         cccbb
         cccDD
-
+    
     Matlab's "square bracket stacking", ``[A, B, ...; p, q, ...]``, is
     equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.
-
     Examples
     --------
     The most common use of this function is to build a block matrix
-
+    
+    
+    With a list of depth 1, `block` can be used as `hstack`
+    
+    
+    
+    
+    With a list of depth 2, `block` can be used in place of `vstack`:
+    
+    
+    
+    It can also be used in places of `atleast_1d` and `atleast_2d`
     >>> A = np.eye(2) * 2
     >>> B = np.eye(3) * 3
     >>> np.block([
@@ -778,31 +865,27 @@
            [1., 1., 3., 0., 0.],
            [1., 1., 0., 3., 0.],
            [1., 1., 0., 0., 3.]])
-
-    With a list of depth 1, `block` can be used as `hstack`
-
+    
     >>> np.block([1, 2, 3])              # hstack([1, 2, 3])
     array([1, 2, 3])
-
+    
     >>> a = np.array([1, 2, 3])
     >>> b = np.array([2, 3, 4])
     >>> np.block([a, b, 10])             # hstack([a, b, 10])
     array([ 1,  2,  3,  2,  3,  4, 10])
-
+    
     >>> A = np.ones((2, 2), int)
     >>> B = 2 * A
     >>> np.block([A, B])                 # hstack([A, B])
     array([[1, 1, 2, 2],
            [1, 1, 2, 2]])
-
-    With a list of depth 2, `block` can be used in place of `vstack`:
-
+    
     >>> a = np.array([1, 2, 3])
     >>> b = np.array([2, 3, 4])
     >>> np.block([[a], [b]])             # vstack([a, b])
     array([[1, 2, 3],
            [2, 3, 4]])
-
+    
     >>> A = np.ones((2, 2), int)
     >>> B = 2 * A
     >>> np.block([[A], [B]])             # vstack([A, B])
@@ -810,22 +893,18 @@
            [1, 1],
            [2, 2],
            [2, 2]])
-
-    It can also be used in places of `atleast_1d` and `atleast_2d`
-
+    
     >>> a = np.array(0)
     >>> b = np.array([1])
     >>> np.block([a])                    # atleast_1d(a)
     array([0])
     >>> np.block([b])                    # atleast_1d(b)
     array([1])
-
+    
     >>> np.block([[a]])                  # atleast_2d(a)
     array([[0]])
     >>> np.block([[b]])                  # atleast_2d(b)
     array([[1]])
-
-
     """
     arrays, list_ndim, result_ndim, final_size = _block_setup(arrays)
 
@@ -854,9 +933,17 @@
 # or `_block_concatenate` without blocking large arrays to force the wisdom
 # to trigger the desired path.
 def _block_setup(arrays):
-    """
-    Returns
+    """Returns
     (`arrays`, list_ndim, result_ndim, final_size)
+
+    Parameters
+    ----------
+    arrays :
+        
+
+    Returns
+    -------
+
     """
     bottom_index, arr_ndim, final_size = _block_check_depths_match(arrays)
     list_ndim = len(bottom_index)
@@ -871,6 +958,21 @@
 
 
 def _block_slicing(arrays, list_ndim, result_ndim):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    list_ndim :
+        
+    result_ndim :
+        
+
+    Returns
+    -------
+
+    """
     shape, slices, arrays = _block_info_recursion(
         arrays, list_ndim, result_ndim)
     dtype = _nx.result_type(*[arr.dtype for arr in arrays])
@@ -890,6 +992,21 @@
 
 
 def _block_concatenate(arrays, list_ndim, result_ndim):
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    list_ndim :
+        
+    result_ndim :
+        
+
+    Returns
+    -------
+
+    """
     result = _block(arrays, list_ndim, result_ndim)
     if list_ndim == 0:
         # Catch an edge case where _block returns a view because
