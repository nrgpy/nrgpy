# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/testing/_private/parameterized.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/testing/_private/parameterized.py
@@ -47,54 +47,78 @@
 _param = namedtuple("param", "args kwargs")
 
 class param(_param):
-    """ Represents a single parameter to a test case.
-
+    """Represents a single parameter to a test case.
+    
         For example::
-
-            >>> p = param("foo", bar=16)
+    
+    
+        Intended to be used as an argument to ``@parameterized``::
+
+    Parameters
+    ----------
+    eterized :
+        param("foo", bar=16),
+        ])
+        def test_stuff(foo, bar=16):
+        pass
+
+    Returns
+    -------
+
+    >>> p = param("foo", bar=16)
             >>> p
             param("foo", bar=16)
             >>> p.args
             ('foo', )
             >>> p.kwargs
             {'bar': 16}
-
-        Intended to be used as an argument to ``@parameterized``::
-
-            @parameterized([
-                param("foo", bar=16),
-            ])
-            def test_stuff(foo, bar=16):
-                pass
-        """
+    """
 
     def __new__(cls, *args , **kwargs):
         return _param.__new__(cls, args, kwargs)
 
     @classmethod
     def explicit(cls, args=None, kwargs=None):
-        """ Creates a ``param`` by explicitly specifying ``args`` and
+        """Creates a ``param`` by explicitly specifying ``args`` and
             ``kwargs``::
 
-                >>> param.explicit([1,2,3])
+        Parameters
+        ----------
+        args :
+             (Default value = None)
+        kwargs :
+             (Default value = None)
+
+        Returns
+        -------
+
+        >>> param.explicit([1,2,3])
                 param(*(1, 2, 3))
                 >>> param.explicit(kwargs={"foo": 42})
                 param(*(), **{"foo": "42"})
-            """
+        """
         args = args or ()
         kwargs = kwargs or {}
         return cls(*args, **kwargs)
 
     @classmethod
     def from_decorator(cls, args):
-        """ Returns an instance of ``param()`` for ``@parameterized`` argument
+        """Returns an instance of ``param()`` for ``@parameterized`` argument
             ``args``::
 
-                >>> param.from_decorator((42, ))
+        Parameters
+        ----------
+        args :
+            
+
+        Returns
+        -------
+
+        >>> param.from_decorator((42, ))
                 param(args=(42, ), kwargs={})
                 >>> param.from_decorator("foo")
                 param(args=("foo", ), kwargs={})
-            """
+        """
         if isinstance(args, param):
             return args
         elif isinstance(args, (str,)):
@@ -114,33 +138,53 @@
 
 
 class QuietOrderedDict(MaybeOrderedDict):
-    """ When OrderedDict is available, use it to make sure that the kwargs in
-        doc strings are consistently ordered. """
+    """When OrderedDict is available, use it to make sure that the kwargs in
+        doc strings are consistently ordered.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
     __str__ = dict.__str__
     __repr__ = dict.__repr__
 
 
 def parameterized_argument_value_pairs(func, p):
-    """Return tuples of parameterized arguments and their values.
-
+    """
+
+    Parameters
+    ----------
+    func :
+        
+    p :
+        
+
+    Returns
+    -------
+    type
         This is useful if you are writing your own doc_func
         function and need to know the values for each parameter name::
-
-            >>> def func(a, foo=None, bar=42, **kwargs): pass
+        
+        
+        If the function's first argument is named ``self`` then it will be
+        ignored::
+        
+        
+        Additionally, empty ``*args`` or ``**kwargs`` will be ignored::
+
+    >>> def func(a, foo=None, bar=42, **kwargs): pass
             >>> p = param(1, foo=7, extra=99)
             >>> parameterized_argument_value_pairs(func, p)
             [("a", 1), ("foo", 7), ("bar", 42), ("**kwargs", {"extra": 99})]
-
-        If the function's first argument is named ``self`` then it will be
-        ignored::
-
+    
             >>> def func(self, a): pass
             >>> p = param(1)
             >>> parameterized_argument_value_pairs(func, p)
             [("a", 1)]
-
-        Additionally, empty ``*args`` or ``**kwargs`` will be ignored::
-
+    
             >>> def func(foo, *args): pass
             >>> p = param(1)
             >>> parameterized_argument_value_pairs(func, p)
@@ -180,9 +224,19 @@
     return result
 
 def short_repr(x, n=64):
-    """ A shortened repr of ``x`` which is guaranteed to be ``unicode``::
-
-            >>> short_repr("foo")
+    """A shortened repr of ``x`` which is guaranteed to be ``unicode``::
+
+    Parameters
+    ----------
+    x :
+        
+    n :
+         (Default value = 64)
+
+    Returns
+    -------
+
+    >>> short_repr("foo")
             u"foo"
             >>> short_repr("123456789", n=4)
             u"12...89"
@@ -199,6 +253,21 @@
     return x_repr
 
 def default_doc_func(func, num, p):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+    num :
+        
+    p :
+        
+
+    Returns
+    -------
+
+    """
     if func.__doc__ is None:
         return None
 
@@ -219,6 +288,21 @@
     return "".join([first.rstrip(), args, suffix, nl, rest])
 
 def default_name_func(func, num, p):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+    num :
+        
+    p :
+        
+
+    Returns
+    -------
+
+    """
     base_name = func.__name__
     name_suffix = "_%s" %(num, )
     if len(p.args) > 0 and isinstance(p.args[0], (str,)):
@@ -235,6 +319,17 @@
 }
 
 def set_test_runner(name):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     global _test_runner_override
     if name not in _test_runners:
         raise TypeError(
@@ -244,10 +339,18 @@
     _test_runner_override = name
 
 def detect_runner():
-    """ Guess which test runner we're using by traversing the stack and looking
+    """Guess which test runner we're using by traversing the stack and looking
         for the first matching module. This *should* be reasonably safe, as
         it's done during test discovery where the test runner should be the
-        stack frame immediately outside. """
+        stack frame immediately outside.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
     if _test_runner_override is not None:
         return _test_runner_override
     global _test_runner_guess
@@ -266,25 +369,31 @@
     return _test_runner_guess
 
 class parameterized:
-    """ Parameterize a test case::
-
+    """Parameterize a test case::
+    
             class TestInt:
-                @parameterized([
-                    ("A", 10),
-                    ("F", 15),
-                    param("10", 42, base=42)
-                ])
-                def test_int(self, input, expected, base=16):
-                    actual = int(input, base=base)
-                    assert_equal(actual, expected)
-
-            @parameterized([
-                (2, 3, 5)
-                (3, 5, 8),
-            ])
-            def test_add(a, b, expected):
-                assert_equal(a + b, expected)
-        """
+
+    Parameters
+    ----------
+    eterized :
+        A", 10),
+        ("F", 15),
+        param("10", 42, base=42)
+        ])
+        def test_int(self, input, expected, base=16):
+        actual = int(input, base=base)
+        assert_equal(actual, expected)
+    eterized :
+        2, 3, 5)
+        (3, 5, 8),
+        ])
+        def test_add(a, b, expected):
+        assert_equal(a + b, expected)
+
+    Returns
+    -------
+
+    """
 
     def __init__(self, input, doc_func=None):
         self.get_input = self.input_as_callable(input)
@@ -295,6 +404,17 @@
 
         @wraps(test_func)
         def wrapper(test_self=None):
+            """
+
+            Parameters
+            ----------
+            test_self :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             test_cls = test_self and type(test_self)
 
             original_doc = wrapper.__doc__
@@ -321,6 +441,23 @@
         return wrapper
 
     def param_as_nose_tuple(self, test_self, func, num, p):
+        """
+
+        Parameters
+        ----------
+        test_self :
+            
+        func :
+            
+        num :
+            
+        p :
+            
+
+        Returns
+        -------
+
+        """
         nose_func = wraps(func)(lambda *args: func(*args[:-1], **args[-1]))
         nose_func.__doc__ = self.doc_func(func, num, p)
         # Track the unbound function because we need to setattr the unbound
@@ -332,6 +469,7 @@
         return unbound_func, (nose_func, ) + p.args + (p.kwargs or {}, )
 
     def assert_not_in_testcase_subclass(self):
+        """ """
         parent_classes = self._terrible_magic_get_defining_classes()
         if any(issubclass(cls, TestCase) for cls in parent_classes):
             raise Exception("Warning: '@parameterized' tests won't work "
@@ -339,11 +477,18 @@
                             "'@parameterized.expand' instead.")
 
     def _terrible_magic_get_defining_classes(self):
-        """ Returns the set of parent classes of the class currently being defined.
+        """Returns the set of parent classes of the class currently being defined.
             Will likely only work if called from the ``parameterized`` decorator.
             This function is entirely @brandon_rhodes's fault, as he suggested
             the implementation: http://stackoverflow.com/a/8793684/71522
-            """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         stack = inspect.stack()
         if len(stack) <= 4:
             return []
@@ -357,6 +502,17 @@
 
     @classmethod
     def input_as_callable(cls, input):
+        """
+
+        Parameters
+        ----------
+        input :
+            
+
+        Returns
+        -------
+
+        """
         if callable(input):
             return lambda: cls.check_input_values(input())
         input_values = cls.check_input_values(input)
@@ -364,6 +520,17 @@
 
     @classmethod
     def check_input_values(cls, input_values):
+        """
+
+        Parameters
+        ----------
+        input_values :
+            
+
+        Returns
+        -------
+
+        """
         # Explicitly convert non-list inputs to a list so that:
         # 1. A helpful exception will be raised if they aren't iterable, and
         # 2. Generators are unwrapped exactly once (otherwise `nosetests
@@ -375,12 +542,26 @@
 
     @classmethod
     def expand(cls, input, name_func=None, doc_func=None, **legacy):
-        """ A "brute force" method of parameterizing test cases. Creates new
+        """A "brute force" method of parameterizing test cases. Creates new
             test cases and injects them into the namespace that the wrapped
             function is being defined in. Useful for parameterizing tests in
             subclasses of 'UnitTest', where Nose test generators don't work.
 
-            >>> @parameterized.expand([("foo", 1, 2)])
+        Parameters
+        ----------
+        input :
+            
+        name_func :
+             (Default value = None)
+        doc_func :
+             (Default value = None)
+        **legacy :
+            
+
+        Returns
+        -------
+
+        >>> @parameterized.expand([("foo", 1, 2)])
             ... def test_add1(name, input, expected):
             ...     actual = add1(input)
             ...     assert_equal(actual, expected)
@@ -388,7 +569,7 @@
             >>> locals()
             ... 'test_add1_foo_0': <function ...> ...
             >>>
-            """
+        """
 
         if "testcase_func_name" in legacy:
             warnings.warn("testcase_func_name= is deprecated; use name_func=",
@@ -406,6 +587,19 @@
         name_func = name_func or default_name_func
 
         def parameterized_expand_wrapper(f, instance=None):
+            """
+
+            Parameters
+            ----------
+            f :
+                
+            instance :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             stack = inspect.stack()
             frame = stack[1]
             frame_locals = frame[0].f_locals
@@ -421,8 +615,34 @@
 
     @classmethod
     def param_as_standalone_func(cls, p, func, name):
+        """
+
+        Parameters
+        ----------
+        p :
+            
+        func :
+            
+        name :
+            
+
+        Returns
+        -------
+
+        """
         @wraps(func)
         def standalone_func(*a):
+            """
+
+            Parameters
+            ----------
+            *a :
+                
+
+            Returns
+            -------
+
+            """
             return func(*(a + p.args), **p.kwargs)
         standalone_func.__name__ = name
 
@@ -441,4 +661,15 @@
 
     @classmethod
     def to_safe_name(cls, s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return str(re.sub("[^a-zA-Z0-9_]+", "_", s))
