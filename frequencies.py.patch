# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tseries/frequencies.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tseries/frequencies.py
@@ -88,17 +88,32 @@
 
 
 def get_period_alias(offset_str: str) -> Optional[str]:
-    """
-    Alias to closest period strings BQ->Q etc.
+    """Alias to closest period strings BQ->Q etc.
+
+    Parameters
+    ----------
+    offset_str: str :
+        
+
+    Returns
+    -------
+
     """
     return _offset_to_period_map.get(offset_str, None)
 
 
 def get_offset(name: str) -> DateOffset:
-    """
-    Return DateOffset object associated with rule name.
-
+    """Return DateOffset object associated with rule name.
+    
     .. deprecated:: 1.0.0
+
+    Parameters
+    ----------
+    name: str :
+        
+
+    Returns
+    -------
 
     Examples
     --------
@@ -118,27 +133,24 @@
 
 
 def infer_freq(index, warn: bool = True) -> Optional[str]:
-    """
-    Infer the most likely frequency given the input index. If the frequency is
+    """Infer the most likely frequency given the input index. If the frequency is
     uncertain, a warning will be printed.
 
     Parameters
     ----------
     index : DatetimeIndex or TimedeltaIndex
-      If passed a Series will use the values of the series (NOT THE INDEX).
+        If passed a Series will use the values of the series (NOT THE INDEX).
     warn : bool, default True
+        
+    warn: bool :
+         (Default value = True)
 
     Returns
     -------
     str or None
         None if no discernible frequency.
 
-    Raises
-    ------
-    TypeError
-        If the index is not datetime-like.
-    ValueError
-        If there are fewer than three values.
+    
     """
     import pandas as pd
 
@@ -184,9 +196,7 @@
 
 
 class _FrequencyInferer:
-    """
-    Not sure if I can avoid the state machine here
-    """
+    """Not sure if I can avoid the state machine here"""
 
     def __init__(self, index, warn: bool = True):
         self.index = index
@@ -211,30 +221,37 @@
 
     @cache_readonly
     def deltas(self):
+        """ """
         return unique_deltas(self.i8values)
 
     @cache_readonly
     def deltas_asi8(self):
+        """ """
         # NB: we cannot use self.i8values here because we may have converted
         #  the tz in __init__
         return unique_deltas(self.index.asi8)
 
     @cache_readonly
     def is_unique(self) -> bool:
+        """ """
         return len(self.deltas) == 1
 
     @cache_readonly
     def is_unique_asi8(self) -> bool:
+        """ """
         return len(self.deltas_asi8) == 1
 
     def get_freq(self) -> Optional[str]:
-        """
-        Find the appropriate frequency string to describe the inferred
+        """Find the appropriate frequency string to describe the inferred
         frequency of self.i8values
+
+        Parameters
+        ----------
 
         Returns
         -------
-        str or None
+
+        
         """
         if not self.is_monotonic or not self.index._is_unique:
             return None
@@ -274,33 +291,41 @@
 
     @cache_readonly
     def day_deltas(self):
+        """ """
         return [x / _ONE_DAY for x in self.deltas]
 
     @cache_readonly
     def hour_deltas(self):
+        """ """
         return [x / _ONE_HOUR for x in self.deltas]
 
     @cache_readonly
     def fields(self):
+        """ """
         return build_field_sarray(self.i8values)
 
     @cache_readonly
     def rep_stamp(self):
+        """ """
         return Timestamp(self.i8values[0])
 
     def month_position_check(self):
+        """ """
         return month_position_check(self.fields, self.index.dayofweek)
 
     @cache_readonly
     def mdiffs(self):
+        """ """
         nmonths = self.fields["Y"] * 12 + self.fields["M"]
         return unique_deltas(nmonths.astype("i8"))
 
     @cache_readonly
     def ydiffs(self):
+        """ """
         return unique_deltas(self.fields["Y"].astype("i8"))
 
     def _infer_daily_rule(self) -> Optional[str]:
+        """ """
         annual_rule = self._get_annual_rule()
         if annual_rule:
             nyears = self.ydiffs[0]
@@ -339,6 +364,7 @@
         return None
 
     def _get_annual_rule(self) -> Optional[str]:
+        """ """
         if len(self.ydiffs) > 1:
             return None
 
@@ -349,6 +375,7 @@
         return {"cs": "AS", "bs": "BAS", "ce": "A", "be": "BA"}.get(pos_check)
 
     def _get_quarterly_rule(self) -> Optional[str]:
+        """ """
         if len(self.mdiffs) > 1:
             return None
 
@@ -359,12 +386,14 @@
         return {"cs": "QS", "bs": "BQS", "ce": "Q", "be": "BQ"}.get(pos_check)
 
     def _get_monthly_rule(self) -> Optional[str]:
+        """ """
         if len(self.mdiffs) > 1:
             return None
         pos_check = self.month_position_check()
         return {"cs": "MS", "bs": "BMS", "ce": "M", "be": "BM"}.get(pos_check)
 
     def _is_business_daily(self) -> bool:
+        """ """
         # quick check: cannot be business daily
         if self.day_deltas != [1, 3]:
             return False
@@ -380,6 +409,7 @@
         )
 
     def _get_wom_rule(self) -> Optional[str]:
+        """ """
         # FIXME: dont leave commented-out
         #         wdiffs = unique(np.diff(self.index.week))
         # We also need -47, -49, -48 to catch index spanning year boundary
@@ -404,7 +434,9 @@
 
 
 class _TimedeltaFrequencyInferer(_FrequencyInferer):
+    """ """
     def _infer_daily_rule(self):
+        """ """
         if self.is_unique:
             days = self.deltas[0] / _ONE_DAY
             if days % 7 == 0:
@@ -417,10 +449,36 @@
 
 
 def _is_multiple(us, mult: int) -> bool:
+    """
+
+    Parameters
+    ----------
+    us :
+        
+    mult: int :
+        
+
+    Returns
+    -------
+
+    """
     return us % mult == 0
 
 
 def _maybe_add_count(base: str, count: float) -> str:
+    """
+
+    Parameters
+    ----------
+    base: str :
+        
+    count: float :
+        
+
+    Returns
+    -------
+
+    """
     if count != 1:
         assert count == int(count)
         count = int(count)
@@ -434,8 +492,7 @@
 
 
 def is_subperiod(source, target) -> bool:
-    """
-    Returns True if downsampling is possible between source and target
+    """Returns True if downsampling is possible between source and target
     frequencies
 
     Parameters
@@ -447,7 +504,8 @@
 
     Returns
     -------
-    bool
+
+    
     """
 
     if target is None or source is None:
@@ -490,8 +548,7 @@
 
 
 def is_superperiod(source, target) -> bool:
-    """
-    Returns True if upsampling is possible between source and target
+    """Returns True if upsampling is possible between source and target
     frequencies
 
     Parameters
@@ -503,7 +560,8 @@
 
     Returns
     -------
-    bool
+
+    
     """
     if target is None or source is None:
         return False
@@ -548,17 +606,20 @@
 
 
 def _maybe_coerce_freq(code) -> str:
-    """ we might need to coerce a code to a rule_code
+    """we might need to coerce a code to a rule_code
     and uppercase it
 
     Parameters
     ----------
     source : string or DateOffset
         Frequency converting from
-
-    Returns
-    -------
-    str
+    code :
+        
+
+    Returns
+    -------
+
+    
     """
     assert code is not None
     if isinstance(code, DateOffset):
@@ -567,26 +628,83 @@
 
 
 def _quarter_months_conform(source: str, target: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    source: str :
+        
+    target: str :
+        
+
+    Returns
+    -------
+
+    """
     snum = MONTH_NUMBERS[source]
     tnum = MONTH_NUMBERS[target]
     return snum % 3 == tnum % 3
 
 
 def _is_annual(rule: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    rule: str :
+        
+
+    Returns
+    -------
+
+    """
     rule = rule.upper()
     return rule == "A" or rule.startswith("A-")
 
 
 def _is_quarterly(rule: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    rule: str :
+        
+
+    Returns
+    -------
+
+    """
     rule = rule.upper()
     return rule == "Q" or rule.startswith("Q-") or rule.startswith("BQ")
 
 
 def _is_monthly(rule: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    rule: str :
+        
+
+    Returns
+    -------
+
+    """
     rule = rule.upper()
     return rule == "M" or rule == "BM"
 
 
 def _is_weekly(rule: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    rule: str :
+        
+
+    Returns
+    -------
+
+    """
     rule = rule.upper()
     return rule == "W" or rule.startswith("W-")
