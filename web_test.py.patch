# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/web_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/web_test.py
@@ -58,45 +58,77 @@
 
 
 def relpath(*a):
+    """
+
+    Parameters
+    ----------
+    *a :
+        
+
+    Returns
+    -------
+
+    """
     return os.path.join(os.path.dirname(__file__), *a)
 
 
 class WebTestCase(AsyncHTTPTestCase):
     """Base class for web tests that also supports WSGI mode.
-
+    
     Override get_handlers and get_app_kwargs instead of get_app.
     This class is deprecated since WSGI mode is no longer supported.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def get_app(self):
+        """ """
         self.app = Application(self.get_handlers(), **self.get_app_kwargs())
         return self.app
 
     def get_handlers(self):
+        """ """
         raise NotImplementedError()
 
     def get_app_kwargs(self):
+        """ """
         return {}
 
 
 class SimpleHandlerTestCase(WebTestCase):
     """Simplified base class for tests that work with a single handler class.
-
+    
     To use, define a nested class named ``Handler``.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     Handler = None
 
     def get_handlers(self):
+        """ """
         return [("/", self.Handler)]
 
 
 class HelloHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.write("hello")
 
 
 class CookieTestRequestHandler(RequestHandler):
+    """ """
     # stub out enough methods to make the secure_cookie functions work
     def __init__(self, cookie_secret="0123456789", key_version=None):
         # don't call super.__init__
@@ -111,20 +143,49 @@
             )
 
     def get_cookie(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return self._cookies.get(name)
 
     def set_cookie(self, name, value, expires_days=None):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        value :
+            
+        expires_days :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self._cookies[name] = value
 
 
 # See SignedValueTest below for more.
 class SecureCookieV1Test(unittest.TestCase):
+    """ """
     def test_round_trip(self):
+        """ """
         handler = CookieTestRequestHandler()
         handler.set_secure_cookie("foo", b"bar", version=1)
         self.assertEqual(handler.get_secure_cookie("foo", min_version=1), b"bar")
 
     def test_cookie_tampering_future_timestamp(self):
+        """ """
         handler = CookieTestRequestHandler()
         # this string base64-encodes to '12345678'
         handler.set_secure_cookie("foo", binascii.a2b_hex(b"d76df8e7aefc"), version=1)
@@ -163,6 +224,7 @@
             self.assertTrue(handler.get_secure_cookie("foo", min_version=1) is None)
 
     def test_arbitrary_bytes(self):
+        """ """
         # Secure cookies accept arbitrary data (which is base64 encoded).
         # Note that normal cookies accept only a subset of ascii.
         handler = CookieTestRequestHandler()
@@ -172,14 +234,17 @@
 
 # See SignedValueTest below for more.
 class SecureCookieV2Test(unittest.TestCase):
+    """ """
     KEY_VERSIONS = {0: "ajklasdf0ojaisdf", 1: "aslkjasaolwkjsdf"}
 
     def test_round_trip(self):
+        """ """
         handler = CookieTestRequestHandler()
         handler.set_secure_cookie("foo", b"bar", version=2)
         self.assertEqual(handler.get_secure_cookie("foo", min_version=2), b"bar")
 
     def test_key_version_roundtrip(self):
+        """ """
         handler = CookieTestRequestHandler(
             cookie_secret=self.KEY_VERSIONS, key_version=0
         )
@@ -187,6 +252,7 @@
         self.assertEqual(handler.get_secure_cookie("foo"), b"bar")
 
     def test_key_version_roundtrip_differing_version(self):
+        """ """
         handler = CookieTestRequestHandler(
             cookie_secret=self.KEY_VERSIONS, key_version=1
         )
@@ -194,6 +260,7 @@
         self.assertEqual(handler.get_secure_cookie("foo"), b"bar")
 
     def test_key_version_increment_version(self):
+        """ """
         handler = CookieTestRequestHandler(
             cookie_secret=self.KEY_VERSIONS, key_version=0
         )
@@ -205,6 +272,7 @@
         self.assertEqual(new_handler.get_secure_cookie("foo"), b"bar")
 
     def test_key_version_invalidate_version(self):
+        """ """
         handler = CookieTestRequestHandler(
             cookie_secret=self.KEY_VERSIONS, key_version=0
         )
@@ -219,38 +287,58 @@
 
 
 class FinalReturnTest(WebTestCase):
+    """ """
     final_return = None  # type: Future
 
     def get_handlers(self):
+        """ """
         test = self
 
         class FinishHandler(RequestHandler):
+            """ """
             @gen.coroutine
             def get(self):
+                """ """
                 test.final_return = self.finish()
                 yield test.final_return
 
             @gen.coroutine
             def post(self):
+                """ """
                 self.write("hello,")
                 yield self.flush()
                 test.final_return = self.finish("world")
                 yield test.final_return
 
         class RenderHandler(RequestHandler):
+            """ """
             def create_template_loader(self, path):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 return DictLoader({"foo.html": "hi"})
 
             @gen.coroutine
             def get(self):
+                """ """
                 test.final_return = self.render("foo.html")
 
         return [("/finish", FinishHandler), ("/render", RenderHandler)]
 
     def get_app_kwargs(self):
+        """ """
         return dict(template_path="FinalReturnTest")
 
     def test_finish_method_return_future(self):
+        """ """
         response = self.fetch(self.get_url("/finish"))
         self.assertEqual(response.code, 200)
         self.assertIsInstance(self.final_return, Future)
@@ -262,15 +350,20 @@
         self.assertTrue(self.final_return.done())
 
     def test_render_method_return_future(self):
+        """ """
         response = self.fetch(self.get_url("/render"))
         self.assertEqual(response.code, 200)
         self.assertIsInstance(self.final_return, Future)
 
 
 class CookieTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class SetCookieHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 # Try setting cookies with different argument types
                 # to ensure that everything gets encoded correctly
                 self.set_cookie("str", "asdf")
@@ -278,25 +371,33 @@
                 self.set_cookie("bytes", b"zxcv")
 
         class GetCookieHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 cookie = self.get_cookie("foo", "default")
                 assert cookie is not None
                 self.write(cookie)
 
         class SetCookieDomainHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 # unicode domain and path arguments shouldn't break things
                 # either (see bug #285)
                 self.set_cookie("unicode_args", "blah", domain=u"foo.com", path=u"/foo")
 
         class SetCookieSpecialCharHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_cookie("equals", "a=b")
                 self.set_cookie("semicolon", "a;b")
                 self.set_cookie("quote", 'a"b')
 
         class SetCookieOverwriteHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_cookie("a", "b", domain="example.com")
                 self.set_cookie("c", "d", domain="example.com")
                 # A second call with the same name clobbers the first.
@@ -304,15 +405,21 @@
                 self.set_cookie("a", "e")
 
         class SetCookieMaxAgeHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_cookie("foo", "bar", max_age=10)
 
         class SetCookieExpiresDaysHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_cookie("foo", "bar", expires_days=10)
 
         class SetCookieFalsyFlags(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_cookie("a", "1", secure=True)
                 self.set_cookie("b", "1", secure=False)
                 self.set_cookie("c", "1", httponly=True)
@@ -330,6 +437,7 @@
         ]
 
     def test_set_cookie(self):
+        """ """
         response = self.fetch("/set")
         self.assertEqual(
             sorted(response.headers.get_list("Set-Cookie")),
@@ -337,6 +445,7 @@
         )
 
     def test_get_cookie(self):
+        """ """
         response = self.fetch("/get", headers={"Cookie": "foo=bar"})
         self.assertEqual(response.body, b"bar")
 
@@ -347,6 +456,7 @@
         self.assertEqual(response.body, b"default")
 
     def test_set_cookie_domain(self):
+        """ """
         response = self.fetch("/set_domain")
         self.assertEqual(
             response.headers.get_list("Set-Cookie"),
@@ -354,6 +464,7 @@
         )
 
     def test_cookie_special_char(self):
+        """ """
         response = self.fetch("/special_char")
         headers = sorted(response.headers.get_list("Set-Cookie"))
         self.assertEqual(len(headers), 3)
@@ -379,6 +490,7 @@
             self.assertEqual(response.body, utf8(expected))
 
     def test_set_cookie_overwrite(self):
+        """ """
         response = self.fetch("/set_overwrite")
         headers = response.headers.get_list("Set-Cookie")
         self.assertEqual(
@@ -386,11 +498,13 @@
         )
 
     def test_set_cookie_max_age(self):
+        """ """
         response = self.fetch("/set_max_age")
         headers = response.headers.get_list("Set-Cookie")
         self.assertEqual(sorted(headers), ["foo=bar; Max-Age=10; Path=/"])
 
     def test_set_cookie_expires_days(self):
+        """ """
         response = self.fetch("/set_expires_days")
         header = response.headers.get("Set-Cookie")
         assert header is not None
@@ -404,6 +518,7 @@
         self.assertTrue(abs((expires - header_expires).total_seconds()) < 10)
 
     def test_set_cookie_false_flags(self):
+        """ """
         response = self.fetch("/set_falsy_flags")
         headers = sorted(response.headers.get_list("Set-Cookie"))
         # The secure and httponly headers are capitalized in py35 and
@@ -415,20 +530,36 @@
 
 
 class AuthRedirectRequestHandler(RequestHandler):
+    """ """
     def initialize(self, login_url):
+        """
+
+        Parameters
+        ----------
+        login_url :
+            
+
+        Returns
+        -------
+
+        """
         self.login_url = login_url
 
     def get_login_url(self):
+        """ """
         return self.login_url
 
     @authenticated
     def get(self):
+        """ """
         # we'll never actually get here because the test doesn't follow redirects
         self.send_error(500)
 
 
 class AuthRedirectTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [
             ("/relative", AuthRedirectRequestHandler, dict(login_url="/login")),
             (
@@ -439,11 +570,13 @@
         ]
 
     def test_relative_auth_redirect(self):
+        """ """
         response = self.fetch(self.get_url("/relative"), follow_redirects=False)
         self.assertEqual(response.code, 302)
         self.assertEqual(response.headers["Location"], "/login?next=%2Frelative")
 
     def test_absolute_auth_redirect(self):
+        """ """
         response = self.fetch(self.get_url("/absolute"), follow_redirects=False)
         self.assertEqual(response.code, 302)
         self.assertTrue(
@@ -456,24 +589,41 @@
 
 
 class ConnectionCloseHandler(RequestHandler):
+    """ """
     def initialize(self, test):
+        """
+
+        Parameters
+        ----------
+        test :
+            
+
+        Returns
+        -------
+
+        """
         self.test = test
 
     @gen.coroutine
     def get(self):
+        """ """
         self.test.on_handler_waiting()
         yield self.test.cleanup_event.wait()
 
     def on_connection_close(self):
+        """ """
         self.test.on_connection_close()
 
 
 class ConnectionCloseTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         self.cleanup_event = Event()
         return [("/", ConnectionCloseHandler, dict(test=self))]
 
     def test_connection_close(self):
+        """ """
         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
         s.connect(("127.0.0.1", self.get_http_port()))
         self.stream = IOStream(s)
@@ -484,16 +634,30 @@
         self.io_loop.run_sync(lambda: gen.sleep(0))
 
     def on_handler_waiting(self):
+        """ """
         logging.debug("handler waiting")
         self.stream.close()
 
     def on_connection_close(self):
+        """ """
         logging.debug("connection closed")
         self.stop()
 
 
 class EchoHandler(RequestHandler):
+    """ """
     def get(self, *path_args):
+        """
+
+        Parameters
+        ----------
+        *path_args :
+            
+
+        Returns
+        -------
+
+        """
         # Type checks: web.py interfaces convert argument values to
         # unicode strings (by default, but see also decode_argument).
         # In httpserver.py (i.e. self.request.arguments), they're left
@@ -520,13 +684,27 @@
 
 
 class RequestEncodingTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [("/group/(.*)", EchoHandler), ("/slashes/([^/]*)/([^/]*)", EchoHandler)]
 
     def fetch_json(self, path):
+        """
+
+        Parameters
+        ----------
+        path :
+            
+
+        Returns
+        -------
+
+        """
         return json_decode(self.fetch(path).body)
 
     def test_group_question_mark(self):
+        """ """
         # Ensure that url-encoded question marks are handled properly
         self.assertEqual(
             self.fetch_json("/group/%3F"),
@@ -538,6 +716,7 @@
         )
 
     def test_group_encoding(self):
+        """ """
         # Path components and query arguments should be decoded the same way
         self.assertEqual(
             self.fetch_json("/group/%C3%A9?arg=%C3%A9"),
@@ -549,6 +728,7 @@
         )
 
     def test_slashes(self):
+        """ """
         # Slashes may be escaped to appear as a single "directory" in the path,
         # but they are then unescaped when passed to the get() method.
         self.assertEqual(
@@ -561,6 +741,7 @@
         )
 
     def test_error(self):
+        """ """
         # Percent signs (encoded as %25) should not mess up printf-style
         # messages in logs
         with ExpectLog(gen_log, ".*Invalid unicode"):
@@ -568,7 +749,9 @@
 
 
 class TypeCheckHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         self.errors = {}  # type: typing.Dict[str, str]
 
         self.check_type("status", self.get_status(), int)
@@ -596,23 +779,74 @@
         self.check_type("request_summary", self._request_summary(), str)
 
     def get(self, path_component):
+        """
+
+        Parameters
+        ----------
+        path_component :
+            
+
+        Returns
+        -------
+
+        """
         # path_component uses type unicode instead of str for consistency
         # with get_argument()
         self.check_type("path_component", path_component, unicode_type)
         self.write(self.errors)
 
     def post(self, path_component):
+        """
+
+        Parameters
+        ----------
+        path_component :
+            
+
+        Returns
+        -------
+
+        """
         self.check_type("path_component", path_component, unicode_type)
         self.write(self.errors)
 
     def check_type(self, name, obj, expected_type):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        obj :
+            
+        expected_type :
+            
+
+        Returns
+        -------
+
+        """
         actual_type = type(obj)
         if expected_type != actual_type:
             self.errors[name] = "expected %s, got %s" % (expected_type, actual_type)
 
 
 class DecodeArgHandler(RequestHandler):
+    """ """
     def decode_argument(self, value, name=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        name :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if type(value) != bytes:
             raise Exception("unexpected type for value: %r" % type(value))
         # use self.request.arguments directly to avoid recursion
@@ -622,7 +856,29 @@
             return value
 
     def get(self, arg):
+        """
+
+        Parameters
+        ----------
+        arg :
+            
+
+        Returns
+        -------
+
+        """
         def describe(s):
+            """
+
+            Parameters
+            ----------
+            s :
+                
+
+            Returns
+            -------
+
+            """
             if type(s) == bytes:
                 return ["bytes", native_str(binascii.b2a_hex(s))]
             elif type(s) == unicode_type:
@@ -633,22 +889,40 @@
 
 
 class LinkifyHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.render("linkify.html", message="http://example.com")
 
 
 class UIModuleResourceHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.render("page.html", entries=[1, 2])
 
 
 class OptionalPathHandler(RequestHandler):
+    """ """
     def get(self, path):
+        """
+
+        Parameters
+        ----------
+        path :
+            
+
+        Returns
+        -------
+
+        """
         self.write({"path": path})
 
 
 class MultiHeaderHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         self.set_header("x-overwrite", "1")
         self.set_header("X-Overwrite", 2)
         self.add_header("x-multi", 3)
@@ -656,7 +930,9 @@
 
 
 class RedirectHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         if self.get_argument("permanent", None) is not None:
             self.redirect("/", permanent=bool(int(self.get_argument("permanent"))))
         elif self.get_argument("status", None) is not None:
@@ -666,8 +942,10 @@
 
 
 class EmptyFlushCallbackHandler(RequestHandler):
+    """ """
     @gen.coroutine
     def get(self):
+        """ """
         # Ensure that the flush callback is run whether or not there
         # was any output.  The gen.Task and direct yield forms are
         # equivalent.
@@ -680,7 +958,9 @@
 
 
 class HeaderInjectionHandler(RequestHandler):
+    """ """
     def get(self):
+        """ """
         try:
             self.set_header("X-Foo", "foo\r\nX-Bar: baz")
             raise Exception("Didn't get expected exception")
@@ -692,7 +972,9 @@
 
 
 class GetArgumentHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         if self.get_argument("source", None) == "query":
             method = self.get_query_argument
         elif self.get_argument("source", None) == "body":
@@ -703,7 +985,9 @@
 
 
 class GetArgumentsHandler(RequestHandler):
+    """ """
     def prepare(self):
+        """ """
         self.finish(
             dict(
                 default=self.get_arguments("foo"),
@@ -715,9 +999,11 @@
 
 # This test was shared with wsgi_test.py; now the name is meaningless.
 class WSGISafeWebTest(WebTestCase):
+    """ """
     COOKIE_SECRET = "WebTest.COOKIE_SECRET"
 
     def get_app_kwargs(self):
+        """ """
         loader = DictLoader(
             {
                 "linkify.html": "{% module linkify(message) %}",
@@ -744,10 +1030,12 @@
         )
 
     def tearDown(self):
+        """ """
         super().tearDown()
         RequestHandler._template_loaders.clear()
 
     def get_handlers(self):
+        """ """
         urls = [
             url("/typecheck/(.*)", TypeCheckHandler, name="typecheck"),
             url("/decode_arg/(.*)", DecodeArgHandler, name="decode_arg"),
@@ -779,11 +1067,25 @@
         return urls
 
     def fetch_json(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(*args, **kwargs)
         response.rethrow()
         return json_decode(response.body)
 
     def test_types(self):
+        """ """
         cookie_value = to_unicode(
             create_signed_value(self.COOKIE_SECRET, "asdf", "qwer")
         )
@@ -801,6 +1103,7 @@
         )
 
     def test_decode_argument(self):
+        """ """
         # These urls all decode to the same thing
         urls = [
             "/decode_arg/%C3%A9?foo=%C3%A9&encoding=utf-8",
@@ -824,6 +1127,7 @@
         )
 
     def test_decode_argument_invalid_unicode(self):
+        """ """
         # test that invalid unicode in URLs causes 400, not 500
         with ExpectLog(gen_log, ".*Invalid unicode.*"):
             response = self.fetch("/typecheck/invalid%FF")
@@ -832,6 +1136,7 @@
             self.assertEqual(response.code, 400)
 
     def test_decode_argument_plus(self):
+        """ """
         # These urls are all equivalent.
         urls = [
             "/decode_arg/1%20%2B%201?foo=1%20%2B%201&encoding=utf-8",
@@ -847,6 +1152,7 @@
             )
 
     def test_reverse_url(self):
+        """ """
         self.assertEqual(self.app.reverse_url("decode_arg", "foo"), "/decode_arg/foo")
         self.assertEqual(self.app.reverse_url("decode_arg", 42), "/decode_arg/42")
         self.assertEqual(self.app.reverse_url("decode_arg", b"\xe9"), "/decode_arg/%E9")
@@ -858,12 +1164,14 @@
         )
 
     def test_uimodule_unescaped(self):
+        """ """
         response = self.fetch("/linkify")
         self.assertEqual(
             response.body, b'<a href="http://example.com">http://example.com</a>'
         )
 
     def test_uimodule_resources(self):
+        """ """
         response = self.fetch("/uimodule_resources")
         self.assertEqual(
             response.body,
@@ -892,15 +1200,18 @@
         )
 
     def test_optional_path(self):
+        """ """
         self.assertEqual(self.fetch_json("/optional_path/foo"), {u"path": u"foo"})
         self.assertEqual(self.fetch_json("/optional_path/"), {u"path": None})
 
     def test_multi_header(self):
+        """ """
         response = self.fetch("/multi_header")
         self.assertEqual(response.headers["x-overwrite"], "2")
         self.assertEqual(response.headers.get_list("x-multi"), ["3", "4"])
 
     def test_redirect(self):
+        """ """
         response = self.fetch("/redirect?permanent=1", follow_redirects=False)
         self.assertEqual(response.code, 301)
         response = self.fetch("/redirect?permanent=0", follow_redirects=False)
@@ -909,6 +1220,7 @@
         self.assertEqual(response.code, 307)
 
     def test_web_redirect(self):
+        """ """
         response = self.fetch("/web_redirect_permanent", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/web_redirect_newpath")
@@ -917,15 +1229,18 @@
         self.assertEqual(response.headers["Location"], "/web_redirect_newpath")
 
     def test_web_redirect_double_slash(self):
+        """ """
         response = self.fetch("//web_redirect_double_slash", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/web_redirect_newpath")
 
     def test_header_injection(self):
+        """ """
         response = self.fetch("/header_injection")
         self.assertEqual(response.body, b"ok")
 
     def test_get_argument(self):
+        """ """
         response = self.fetch("/get_argument?foo=bar")
         self.assertEqual(response.body, b"bar")
         response = self.fetch("/get_argument?foo=")
@@ -946,6 +1261,7 @@
         )
 
     def test_get_query_arguments(self):
+        """ """
         # send as a post so we can ensure the separation between query
         # string and body arguments.
         body = urllib.parse.urlencode(dict(foo="hello"))
@@ -961,6 +1277,7 @@
         self.assertEqual(response.body, b"default")
 
     def test_get_body_arguments(self):
+        """ """
         body = urllib.parse.urlencode(dict(foo="bar"))
         response = self.fetch(
             "/get_argument?source=body&foo=hello", method="POST", body=body
@@ -980,36 +1297,59 @@
         self.assertEqual(response.body, b"default")
 
     def test_no_gzip(self):
+        """ """
         response = self.fetch("/get_argument")
         self.assertNotIn("Accept-Encoding", response.headers.get("Vary", ""))
         self.assertNotIn("gzip", response.headers.get("Content-Encoding", ""))
 
 
 class NonWSGIWebTests(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [("/empty_flush", EmptyFlushCallbackHandler)]
 
     def test_empty_flush(self):
+        """ """
         response = self.fetch("/empty_flush")
         self.assertEqual(response.body, b"ok")
 
 
 class ErrorResponseTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class DefaultHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 if self.get_argument("status", None):
                     raise HTTPError(int(self.get_argument("status")))
                 1 / 0
 
         class WriteErrorHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 if self.get_argument("status", None):
                     self.send_error(int(self.get_argument("status")))
                 else:
                     1 / 0
 
             def write_error(self, status_code, **kwargs):
+                """
+
+                Parameters
+                ----------
+                status_code :
+                    
+                **kwargs :
+                    
+
+                Returns
+                -------
+
+                """
                 self.set_header("Content-Type", "text/plain")
                 if "exc_info" in kwargs:
                     self.write("Exception: %s" % kwargs["exc_info"][0].__name__)
@@ -1017,10 +1357,25 @@
                     self.write("Status: %d" % status_code)
 
         class FailedWriteErrorHandler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 1 / 0
 
             def write_error(self, status_code, **kwargs):
+                """
+
+                Parameters
+                ----------
+                status_code :
+                    
+                **kwargs :
+                    
+
+                Returns
+                -------
+
+                """
                 raise Exception("exception in write_error")
 
         return [
@@ -1030,6 +1385,7 @@
         ]
 
     def test_default(self):
+        """ """
         with ExpectLog(app_log, "Uncaught exception"):
             response = self.fetch("/default")
             self.assertEqual(response.code, 500)
@@ -1044,6 +1400,7 @@
             self.assertTrue(b"435: Unknown" in response.body)
 
     def test_write_error(self):
+        """ """
         with ExpectLog(app_log, "Uncaught exception"):
             response = self.fetch("/write_error")
             self.assertEqual(response.code, 500)
@@ -1054,6 +1411,7 @@
             self.assertEqual(b"Status: 503", response.body)
 
     def test_failed_write_error(self):
+        """ """
         with ExpectLog(app_log, "Uncaught exception"):
             response = self.fetch("/failed_write_error")
             self.assertEqual(response.code, 500)
@@ -1061,6 +1419,7 @@
 
 
 class StaticFileTest(WebTestCase):
+    """ """
     # The expected SHA-512 hash of robots.txt, used in tests that call
     # StaticFileHandler.get_version
     robots_txt_hash = (
@@ -1070,16 +1429,42 @@
     static_dir = os.path.join(os.path.dirname(__file__), "static")
 
     def get_handlers(self):
+        """ """
         class StaticUrlHandler(RequestHandler):
+            """ """
             def get(self, path):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 with_v = int(self.get_argument("include_version", "1"))
                 self.write(self.static_url(path, include_version=with_v))
 
         class AbsoluteStaticUrlHandler(StaticUrlHandler):
+            """ """
             include_host = True
 
         class OverrideStaticUrlHandler(RequestHandler):
+            """ """
             def get(self, path):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 do_include = bool(self.get_argument("include_host"))
                 self.include_host = not do_include
 
@@ -1107,9 +1492,11 @@
         ]
 
     def get_app_kwargs(self):
+        """ """
         return dict(static_path=relpath("static"))
 
     def test_static_files(self):
+        """ """
         response = self.fetch("/robots.txt")
         self.assertTrue(b"Disallow: /" in response.body)
 
@@ -1118,6 +1505,7 @@
         self.assertEqual(response.headers.get("Content-Type"), "text/plain")
 
     def test_static_compressed_files(self):
+        """ """
         response = self.fetch("/static/sample.xml.gz")
         self.assertEqual(response.headers.get("Content-Type"), "application/gzip")
         response = self.fetch("/static/sample.xml.bz2")
@@ -1131,10 +1519,12 @@
         )
 
     def test_static_url(self):
+        """ """
         response = self.fetch("/static_url/robots.txt")
         self.assertEqual(response.body, b"/static/robots.txt?v=" + self.robots_txt_hash)
 
     def test_absolute_static_url(self):
+        """ """
         response = self.fetch("/abs_static_url/robots.txt")
         self.assertEqual(
             response.body,
@@ -1142,27 +1532,52 @@
         )
 
     def test_relative_version_exclusion(self):
+        """ """
         response = self.fetch("/static_url/robots.txt?include_version=0")
         self.assertEqual(response.body, b"/static/robots.txt")
 
     def test_absolute_version_exclusion(self):
+        """ """
         response = self.fetch("/abs_static_url/robots.txt?include_version=0")
         self.assertEqual(response.body, utf8(self.get_url("/") + "static/robots.txt"))
 
     def test_include_host_override(self):
+        """ """
         self._trigger_include_host_check(False)
         self._trigger_include_host_check(True)
 
     def _trigger_include_host_check(self, include_host):
+        """
+
+        Parameters
+        ----------
+        include_host :
+            
+
+        Returns
+        -------
+
+        """
         path = "/override_static_url/robots.txt?include_host=%s"
         response = self.fetch(path % int(include_host))
         self.assertEqual(response.body, utf8(str(True)))
 
     def get_and_head(self, *args, **kwargs):
         """Performs a GET and HEAD request and returns the GET response.
-
+        
         Fails if any ``Content-*`` headers returned by the two requests
         differ.
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
         """
         head_response = self.fetch(*args, method="HEAD", **kwargs)
         get_response = self.fetch(*args, method="GET", **kwargs)
@@ -1180,6 +1595,7 @@
         return get_response
 
     def test_static_304_if_modified_since(self):
+        """ """
         response1 = self.get_and_head("/static/robots.txt")
         response2 = self.get_and_head(
             "/static/robots.txt",
@@ -1189,6 +1605,7 @@
         self.assertTrue("Content-Length" not in response2.headers)
 
     def test_static_304_if_none_match(self):
+        """ """
         response1 = self.get_and_head("/static/robots.txt")
         response2 = self.get_and_head(
             "/static/robots.txt", headers={"If-None-Match": response1.headers["Etag"]}
@@ -1196,6 +1613,7 @@
         self.assertEqual(response2.code, 304)
 
     def test_static_304_etag_modified_bug(self):
+        """ """
         response1 = self.get_and_head("/static/robots.txt")
         response2 = self.get_and_head(
             "/static/robots.txt",
@@ -1207,6 +1625,7 @@
         self.assertEqual(response2.code, 200)
 
     def test_static_if_modified_since_pre_epoch(self):
+        """ """
         # On windows, the functions that work with time_t do not accept
         # negative values, and at least one client (processing.js) seems
         # to use if-modified-since 1/1/1960 as a cache-busting technique.
@@ -1217,6 +1636,7 @@
         self.assertEqual(response.code, 200)
 
     def test_static_if_modified_since_time_zone(self):
+        """ """
         # Instead of the value from Last-Modified, make requests with times
         # chosen just before and after the known modification time
         # of the file to ensure that the right time zone is being used
@@ -1235,12 +1655,14 @@
         self.assertEqual(response.code, 304)
 
     def test_static_etag(self):
+        """ """
         response = self.get_and_head("/static/robots.txt")
         self.assertEqual(
             utf8(response.headers.get("Etag")), b'"' + self.robots_txt_hash + b'"'
         )
 
     def test_static_with_range(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=0-9"}
         )
@@ -1253,6 +1675,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes 0-9/26")
 
     def test_static_with_range_full_file(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=0-"}
         )
@@ -1266,6 +1689,7 @@
         self.assertEqual(response.headers.get("Content-Range"), None)
 
     def test_static_with_range_full_past_end(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=0-10000000"}
         )
@@ -1277,6 +1701,7 @@
         self.assertEqual(response.headers.get("Content-Range"), None)
 
     def test_static_with_range_partial_past_end(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=1-10000000"}
         )
@@ -1288,6 +1713,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes 1-25/26")
 
     def test_static_with_range_end_edge(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=22-"}
         )
@@ -1296,6 +1722,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes 22-25/26")
 
     def test_static_with_range_neg_end(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=-4"}
         )
@@ -1304,6 +1731,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes 22-25/26")
 
     def test_static_with_range_neg_past_start(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=-1000000"}
         )
@@ -1315,10 +1743,12 @@
         self.assertEqual(response.headers.get("Content-Range"), None)
 
     def test_static_invalid_range(self):
+        """ """
         response = self.get_and_head("/static/robots.txt", headers={"Range": "asdf"})
         self.assertEqual(response.code, 200)
 
     def test_static_unsatisfiable_range_zero_suffix(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=-0"}
         )
@@ -1326,6 +1756,7 @@
         self.assertEqual(response.code, 416)
 
     def test_static_unsatisfiable_range_invalid_start(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=26"}
         )
@@ -1333,6 +1764,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes */26")
 
     def test_static_unsatisfiable_range_end_less_than_start(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt", headers={"Range": "bytes=10-3"}
         )
@@ -1340,6 +1772,7 @@
         self.assertEqual(response.headers.get("Content-Range"), "bytes */26")
 
     def test_static_head(self):
+        """ """
         response = self.fetch("/static/robots.txt", method="HEAD")
         self.assertEqual(response.code, 200)
         # No body was returned, but we did get the right content length.
@@ -1350,6 +1783,7 @@
         )
 
     def test_static_head_range(self):
+        """ """
         response = self.fetch(
             "/static/robots.txt", method="HEAD", headers={"Range": "bytes=1-4"}
         )
@@ -1361,6 +1795,7 @@
         )
 
     def test_static_range_if_none_match(self):
+        """ """
         response = self.get_and_head(
             "/static/robots.txt",
             headers={
@@ -1376,10 +1811,12 @@
         )
 
     def test_static_404(self):
+        """ """
         response = self.get_and_head("/static/blarg")
         self.assertEqual(response.code, 404)
 
     def test_path_traversal_protection(self):
+        """ """
         # curl_httpclient processes ".." on the client side, so we
         # must test this with simple_httpclient.
         self.http_client.close()
@@ -1394,6 +1831,7 @@
 
     @unittest.skipIf(os.name != "posix", "non-posix OS")
     def test_root_static_path(self):
+        """ """
         # Sometimes people set the StaticFileHandler's path to '/'
         # to disable Tornado's path validation (in conjunction with
         # their own validation in get_absolute_path). Make sure
@@ -1406,46 +1844,71 @@
 
 
 class StaticDefaultFilenameTest(WebTestCase):
+    """ """
     def get_app_kwargs(self):
+        """ """
         return dict(
             static_path=relpath("static"),
             static_handler_args=dict(default_filename="index.html"),
         )
 
     def get_handlers(self):
+        """ """
         return []
 
     def test_static_default_filename(self):
+        """ """
         response = self.fetch("/static/dir/", follow_redirects=False)
         self.assertEqual(response.code, 200)
         self.assertEqual(b"this is the index\n", response.body)
 
     def test_static_default_redirect(self):
+        """ """
         response = self.fetch("/static/dir", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertTrue(response.headers["Location"].endswith("/static/dir/"))
 
 
 class StaticFileWithPathTest(WebTestCase):
+    """ """
     def get_app_kwargs(self):
+        """ """
         return dict(
             static_path=relpath("static"),
             static_handler_args=dict(default_filename="index.html"),
         )
 
     def get_handlers(self):
+        """ """
         return [("/foo/(.*)", StaticFileHandler, {"path": relpath("templates/")})]
 
     def test_serve(self):
+        """ """
         response = self.fetch("/foo/utf8.html")
         self.assertEqual(response.body, b"H\xc3\xa9llo\n")
 
 
 class CustomStaticFileTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class MyStaticFileHandler(StaticFileHandler):
+            """ """
             @classmethod
             def make_static_url(cls, settings, path):
+                """
+
+                Parameters
+                ----------
+                settings :
+                    
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 version_hash = cls.get_version(settings, path)
                 extension_index = path.rindex(".")
                 before_version = path[:extension_index]
@@ -1457,38 +1920,117 @@
                 )
 
             def parse_url_path(self, url_path):
+                """
+
+                Parameters
+                ----------
+                url_path :
+                    
+
+                Returns
+                -------
+
+                """
                 extension_index = url_path.rindex(".")
                 version_index = url_path.rindex(".", 0, extension_index)
                 return "%s%s" % (url_path[:version_index], url_path[extension_index:])
 
             @classmethod
             def get_absolute_path(cls, settings, path):
+                """
+
+                Parameters
+                ----------
+                settings :
+                    
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 return "CustomStaticFileTest:" + path
 
             def validate_absolute_path(self, root, absolute_path):
+                """
+
+                Parameters
+                ----------
+                root :
+                    
+                absolute_path :
+                    
+
+                Returns
+                -------
+
+                """
                 return absolute_path
 
             @classmethod
             def get_content(self, path, start=None, end=None):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+                start :
+                     (Default value = None)
+                end :
+                     (Default value = None)
+
+                Returns
+                -------
+
+                """
                 assert start is None and end is None
                 if path == "CustomStaticFileTest:foo.txt":
                     return b"bar"
                 raise Exception("unexpected path %r" % path)
 
             def get_content_size(self):
+                """ """
                 if self.absolute_path == "CustomStaticFileTest:foo.txt":
                     return 3
                 raise Exception("unexpected path %r" % self.absolute_path)
 
             def get_modified_time(self):
+                """ """
                 return None
 
             @classmethod
             def get_version(cls, settings, path):
+                """
+
+                Parameters
+                ----------
+                settings :
+                    
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 return "42"
 
         class StaticUrlHandler(RequestHandler):
+            """ """
             def get(self, path):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 self.write(self.static_url(path))
 
         self.static_handler_class = MyStaticFileHandler
@@ -1496,30 +2038,49 @@
         return [("/static_url/(.*)", StaticUrlHandler)]
 
     def get_app_kwargs(self):
+        """ """
         return dict(static_path="dummy", static_handler_class=self.static_handler_class)
 
     def test_serve(self):
+        """ """
         response = self.fetch("/static/foo.42.txt")
         self.assertEqual(response.body, b"bar")
 
     def test_static_url(self):
+        """ """
         with ExpectLog(gen_log, "Could not open static file", required=False):
             response = self.fetch("/static_url/foo.txt")
             self.assertEqual(response.body, b"/static/foo.42.txt")
 
 
 class HostMatchingTest(WebTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def initialize(self, reply):
+            """
+
+            Parameters
+            ----------
+            reply :
+                
+
+            Returns
+            -------
+
+            """
             self.reply = reply
 
         def get(self):
+            """ """
             self.write(self.reply)
 
     def get_handlers(self):
+        """ """
         return [("/foo", HostMatchingTest.Handler, {"reply": "wildcard"})]
 
     def test_host_matching(self):
+        """ """
         self.app.add_handlers(
             "www.example.com", [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})]
         )
@@ -1551,13 +2112,17 @@
 
 
 class DefaultHostMatchingTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return []
 
     def get_app_kwargs(self):
+        """ """
         return {"default_host": "www.example.com"}
 
     def test_default_host_matching(self):
+        """ """
         self.app.add_handlers(
             "www.example.com", [("/foo", HostMatchingTest.Handler, {"reply": "[0]"})]
         )
@@ -1585,9 +2150,23 @@
 
 
 class NamedURLSpecGroupsTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class EchoHandler(RequestHandler):
+            """ """
             def get(self, path):
+                """
+
+                Parameters
+                ----------
+                path :
+                    
+
+                Returns
+                -------
+
+                """
                 self.write(path)
 
         return [
@@ -1596,6 +2175,7 @@
         ]
 
     def test_named_urlspec_groups(self):
+        """ """
         response = self.fetch("/str/foo")
         self.assertEqual(response.body, b"foo")
 
@@ -1604,26 +2184,34 @@
 
 
 class ClearHeaderTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.set_header("h1", "foo")
             self.set_header("h2", "bar")
             self.clear_header("h1")
             self.clear_header("nonexistent")
 
     def test_clear_header(self):
+        """ """
         response = self.fetch("/")
         self.assertTrue("h1" not in response.headers)
         self.assertEqual(response.headers["h2"], "bar")
 
 
 class Header204Test(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.set_status(204)
             self.finish()
 
     def test_204_headers(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.code, 204)
         self.assertNotIn("Content-Length", response.headers)
@@ -1631,12 +2219,16 @@
 
 
 class Header304Test(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.set_header("Content-Language", "en_US")
             self.write("hello")
 
     def test_304_headers(self):
+        """ """
         response1 = self.fetch("/")
         self.assertEqual(response1.headers["Content-Length"], "5")
         self.assertEqual(response1.headers["Content-Language"], "en_US")
@@ -1652,8 +2244,11 @@
 
 
 class StatusReasonTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             reason = self.request.arguments.get("reason", [])
             self.set_status(
                 int(self.get_argument("code")),
@@ -1661,10 +2256,12 @@
             )
 
     def get_http_client(self):
+        """ """
         # simple_httpclient only: curl doesn't expose the reason string
         return SimpleAsyncHTTPClient()
 
     def test_status(self):
+        """ """
         response = self.fetch("/?code=304")
         self.assertEqual(response.code, 304)
         self.assertEqual(response.reason, "Not Modified")
@@ -1680,11 +2277,15 @@
 
 
 class DateHeaderTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.write("hello")
 
     def test_date_header(self):
+        """ """
         response = self.fetch("/")
         parsed = email.utils.parsedate(response.headers["Date"])
         assert parsed is not None
@@ -1695,60 +2296,87 @@
 
 
 class RaiseWithReasonTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             raise HTTPError(682, reason="Foo")
 
     def get_http_client(self):
+        """ """
         # simple_httpclient only: curl doesn't expose the reason string
         return SimpleAsyncHTTPClient()
 
     def test_raise_with_reason(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.code, 682)
         self.assertEqual(response.reason, "Foo")
         self.assertIn(b"682: Foo", response.body)
 
     def test_httperror_str(self):
+        """ """
         self.assertEqual(str(HTTPError(682, reason="Foo")), "HTTP 682: Foo")
 
     def test_httperror_str_from_httputil(self):
+        """ """
         self.assertEqual(str(HTTPError(682)), "HTTP 682: Unknown")
 
 
 class ErrorHandlerXSRFTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         # note that if the handlers list is empty we get the default_host
         # redirect fallback instead of a 404, so test with both an
         # explicitly defined error handler and an implicit 404.
         return [("/error", ErrorHandler, dict(status_code=417))]
 
     def get_app_kwargs(self):
+        """ """
         return dict(xsrf_cookies=True)
 
     def test_error_xsrf(self):
+        """ """
         response = self.fetch("/error", method="POST", body="")
         self.assertEqual(response.code, 417)
 
     def test_404_xsrf(self):
+        """ """
         response = self.fetch("/404", method="POST", body="")
         self.assertEqual(response.code, 404)
 
 
 class GzipTestCase(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             for v in self.get_arguments("vary"):
                 self.add_header("Vary", v)
             # Must write at least MIN_LENGTH bytes to activate compression.
             self.write("hello world" + ("!" * GZipContentEncoding.MIN_LENGTH))
 
     def get_app_kwargs(self):
+        """ """
         return dict(
             gzip=True, static_path=os.path.join(os.path.dirname(__file__), "static")
         )
 
     def assert_compressed(self, response):
+        """
+
+        Parameters
+        ----------
+        response :
+            
+
+        Returns
+        -------
+
+        """
         # simple_httpclient renames the content-encoding header;
         # curl_httpclient doesn't.
         self.assertEqual(
@@ -1759,11 +2387,13 @@
         )
 
     def test_gzip(self):
+        """ """
         response = self.fetch("/")
         self.assert_compressed(response)
         self.assertEqual(response.headers["Vary"], "Accept-Encoding")
 
     def test_gzip_static(self):
+        """ """
         # The streaming responses in StaticFileHandler have subtle
         # interactions with the gzip output so test this case separately.
         response = self.fetch("/robots.txt")
@@ -1771,11 +2401,13 @@
         self.assertEqual(response.headers["Vary"], "Accept-Encoding")
 
     def test_gzip_not_requested(self):
+        """ """
         response = self.fetch("/", use_gzip=False)
         self.assertNotIn("Content-Encoding", response.headers)
         self.assertEqual(response.headers["Vary"], "Accept-Encoding")
 
     def test_vary_already_present(self):
+        """ """
         response = self.fetch("/?vary=Accept-Language")
         self.assert_compressed(response)
         self.assertEqual(
@@ -1784,6 +2416,7 @@
         )
 
     def test_vary_already_present_multiple(self):
+        """ """
         # Regression test for https://github.com/tornadoweb/tornado/issues/1670
         response = self.fetch("/?vary=Accept-Language&vary=Cookie")
         self.assert_compressed(response)
@@ -1794,24 +2427,41 @@
 
 
 class PathArgsInPrepareTest(WebTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def prepare(self):
+            """ """
             self.write(dict(args=self.path_args, kwargs=self.path_kwargs))
 
         def get(self, path):
+            """
+
+            Parameters
+            ----------
+            path :
+                
+
+            Returns
+            -------
+
+            """
             assert path == "foo"
             self.finish()
 
     def get_handlers(self):
+        """ """
         return [("/pos/(.*)", self.Handler), ("/kw/(?P<path>.*)", self.Handler)]
 
     def test_pos(self):
+        """ """
         response = self.fetch("/pos/foo")
         response.rethrow()
         data = json_decode(response.body)
         self.assertEqual(data, {"args": ["foo"], "kwargs": {}})
 
     def test_kw(self):
+        """ """
         response = self.fetch("/kw/foo")
         response.rethrow()
         data = json_decode(response.body)
@@ -1819,12 +2469,16 @@
 
 
 class ClearAllCookiesTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.clear_all_cookies()
             self.write("ok")
 
     def test_clear_all_cookies(self):
+        """ """
         response = self.fetch("/", headers={"Cookie": "foo=bar; baz=xyzzy"})
         set_cookies = sorted(response.headers.get_list("Set-Cookie"))
         # Python 3.5 sends 'baz="";'; older versions use 'baz=;'
@@ -1837,12 +2491,16 @@
 
 
 class PermissionError(Exception):
+    """ """
     pass
 
 
 class ExceptionHandlerTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             exc = self.get_argument("exc")
             if exc == "http":
                 raise HTTPError(410, "no longer here")
@@ -1852,6 +2510,19 @@
                 raise PermissionError("not allowed")
 
         def write_error(self, status_code, **kwargs):
+            """
+
+            Parameters
+            ----------
+            status_code :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             if "exc_info" in kwargs:
                 typ, value, tb = kwargs["exc_info"]
                 if isinstance(value, PermissionError):
@@ -1861,12 +2532,28 @@
             RequestHandler.write_error(self, status_code, **kwargs)
 
         def log_exception(self, typ, value, tb):
+            """
+
+            Parameters
+            ----------
+            typ :
+                
+            value :
+                
+            tb :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(value, PermissionError):
                 app_log.warning("custom logging for PermissionError: %s", value.args[0])
             else:
                 RequestHandler.log_exception(self, typ, value, tb)
 
     def test_http_error(self):
+        """ """
         # HTTPErrors are logged as warnings with no stack trace.
         # TODO: extend ExpectLog to test this more precisely
         with ExpectLog(gen_log, ".*no longer here"):
@@ -1874,12 +2561,14 @@
             self.assertEqual(response.code, 410)
 
     def test_unknown_error(self):
+        """ """
         # Unknown errors are logged as errors with a stack trace.
         with ExpectLog(app_log, "Uncaught exception"):
             response = self.fetch("/?exc=zero")
             self.assertEqual(response.code, 500)
 
     def test_known_error(self):
+        """ """
         # log_exception can override logging behavior, and write_error
         # can override the response.
         with ExpectLog(app_log, "custom logging for PermissionError: not allowed"):
@@ -1888,14 +2577,33 @@
 
 
 class BuggyLoggingTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             1 / 0
 
         def log_exception(self, typ, value, tb):
+            """
+
+            Parameters
+            ----------
+            typ :
+                
+            value :
+                
+            tb :
+                
+
+            Returns
+            -------
+
+            """
             1 / 0
 
     def test_buggy_log_exception(self):
+        """ """
         # Something gets logged even though the application's
         # logger is broken.
         with ExpectLog(app_log, ".*"):
@@ -1905,21 +2613,57 @@
 class UIMethodUIModuleTest(SimpleHandlerTestCase):
     """Test that UI methods and modules are created correctly and
     associated with the handler.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.render("foo.html")
 
         def value(self):
+            """ """
             return self.get_argument("value")
 
     def get_app_kwargs(self):
+        """ """
         def my_ui_method(handler, x):
+            """
+
+            Parameters
+            ----------
+            handler :
+                
+            x :
+                
+
+            Returns
+            -------
+
+            """
             return "In my_ui_method(%s) with handler value %s." % (x, handler.value())
 
         class MyModule(UIModule):
+            """ """
             def render(self, x):
+                """
+
+                Parameters
+                ----------
+                x :
+                    
+
+                Returns
+                -------
+
+                """
                 return "In MyModule(%s) with handler value %s." % (
                     x,
                     typing.cast(UIMethodUIModuleTest.Handler, self.handler).value(),
@@ -1935,11 +2679,13 @@
         )
 
     def tearDown(self):
+        """ """
         super().tearDown()
         # TODO: fix template loader caching so this isn't necessary.
         RequestHandler._template_loaders.clear()
 
     def test_ui_method(self):
+        """ """
         response = self.fetch("/?value=asdf")
         self.assertEqual(
             response.body,
@@ -1949,8 +2695,11 @@
 
 
 class GetArgumentErrorTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             try:
                 self.get_argument("foo")
                 self.write({})
@@ -1958,6 +2707,7 @@
                 self.write({"arg_name": e.arg_name, "log_message": e.log_message})
 
     def test_catch_error(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(
             json_decode(response.body),
@@ -1966,21 +2716,28 @@
 
 
 class SetLazyPropertiesTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def prepare(self):
+            """ """
             self.current_user = "Ben"
             self.locale = locale.get("en_US")
 
         def get_user_locale(self):
+            """ """
             raise NotImplementedError()
 
         def get_current_user(self):
+            """ """
             raise NotImplementedError()
 
         def get(self):
+            """ """
             self.write("Hello %s (%s)" % (self.current_user, self.locale.code))
 
     def test_set_properties(self):
+        """ """
         # Ensure that current_user can be assigned to normally for apps
         # that want to forgo the lazy get_current_user property
         response = self.fetch("/")
@@ -1988,13 +2745,19 @@
 
 
 class GetCurrentUserTest(WebTestCase):
+    """ """
     def get_app_kwargs(self):
+        """ """
         class WithoutUserModule(UIModule):
+            """ """
             def render(self):
+                """ """
                 return ""
 
         class WithUserModule(UIModule):
+            """ """
             def render(self):
+                """ """
                 return str(self.current_user)
 
         loader = DictLoader(
@@ -2014,42 +2777,57 @@
         )
 
     def tearDown(self):
+        """ """
         super().tearDown()
         RequestHandler._template_loaders.clear()
 
     def get_handlers(self):
+        """ """
         class CurrentUserHandler(RequestHandler):
+            """ """
             def prepare(self):
+                """ """
                 self.has_loaded_current_user = False
 
             def get_current_user(self):
+                """ """
                 self.has_loaded_current_user = True
                 return ""
 
         class WithoutUserHandler(CurrentUserHandler):
+            """ """
             def get(self):
+                """ """
                 self.render_string("without_user.html")
                 self.finish(str(self.has_loaded_current_user))
 
         class WithUserHandler(CurrentUserHandler):
+            """ """
             def get(self):
+                """ """
                 self.render_string("with_user.html")
                 self.finish(str(self.has_loaded_current_user))
 
         class CurrentUserModuleHandler(CurrentUserHandler):
+            """ """
             def get_template_namespace(self):
+                """ """
                 # If RequestHandler.get_template_namespace is called, then
                 # get_current_user is evaluated. Until #820 is fixed, this
                 # is a small hack to circumvent the issue.
                 return self.ui
 
         class WithoutUserModuleHandler(CurrentUserModuleHandler):
+            """ """
             def get(self):
+                """ """
                 self.render_string("without_user_module.html")
                 self.finish(str(self.has_loaded_current_user))
 
         class WithUserModuleHandler(CurrentUserModuleHandler):
+            """ """
             def get(self):
+                """ """
                 self.render_string("with_user_module.html")
                 self.finish(str(self.has_loaded_current_user))
 
@@ -2062,28 +2840,35 @@
 
     @unittest.skip("needs fix")
     def test_get_current_user_is_lazy(self):
+        """ """
         # TODO: Make this test pass. See #820.
         response = self.fetch("/without_user")
         self.assertEqual(response.body, b"False")
 
     def test_get_current_user_works(self):
+        """ """
         response = self.fetch("/with_user")
         self.assertEqual(response.body, b"True")
 
     def test_get_current_user_from_ui_module_is_lazy(self):
+        """ """
         response = self.fetch("/without_user_module")
         self.assertEqual(response.body, b"False")
 
     def test_get_current_user_from_ui_module_works(self):
+        """ """
         response = self.fetch("/with_user_module")
         self.assertEqual(response.body, b"True")
 
 
 class UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         pass
 
     def test_unimplemented_standard_methods(self):
+        """ """
         for method in ["HEAD", "GET", "DELETE", "OPTIONS"]:
             response = self.fetch("/", method=method)
             self.assertEqual(response.code, 405)
@@ -2093,32 +2878,41 @@
 
 
 class UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def other(self):
+            """ """
             # Even though this method exists, it won't get called automatically
             # because it is not in SUPPORTED_METHODS.
             self.write("other")
 
     def test_unimplemented_patch(self):
+        """ """
         # PATCH is recently standardized; Tornado supports it by default
         # but wsgiref.validate doesn't like it.
         response = self.fetch("/", method="PATCH", body=b"")
         self.assertEqual(response.code, 405)
 
     def test_unimplemented_other(self):
+        """ """
         response = self.fetch("/", method="OTHER", allow_nonstandard_methods=True)
         self.assertEqual(response.code, 405)
 
 
 class AllHTTPMethodsTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def method(self):
+            """ """
             assert self.request.method is not None
             self.write(self.request.method)
 
         get = delete = options = post = put = method  # type: ignore
 
     def test_standard_methods(self):
+        """ """
         response = self.fetch("/", method="HEAD")
         self.assertEqual(response.body, b"")
         for method in ["GET", "DELETE", "OPTIONS"]:
@@ -2130,48 +2924,62 @@
 
 
 class PatchMethodTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + (  # type: ignore
             "OTHER",
         )
 
         def patch(self):
+            """ """
             self.write("patch")
 
         def other(self):
+            """ """
             self.write("other")
 
     def test_patch(self):
+        """ """
         response = self.fetch("/", method="PATCH", body=b"")
         self.assertEqual(response.body, b"patch")
 
     def test_other(self):
+        """ """
         response = self.fetch("/", method="OTHER", allow_nonstandard_methods=True)
         self.assertEqual(response.body, b"other")
 
 
 class FinishInPrepareTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def prepare(self):
+            """ """
             self.finish("done")
 
         def get(self):
+            """ """
             # It's difficult to assert for certain that a method did not
             # or will not be called in an asynchronous context, but this
             # will be logged noisily if it is reached.
             raise Exception("should not reach this method")
 
     def test_finish_in_prepare(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.body, b"done")
 
 
 class Default404Test(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         # If there are no handlers at all a default redirect handler gets added.
         return [("/foo", RequestHandler)]
 
     def test_404(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.code, 404)
         self.assertEqual(
@@ -2182,40 +2990,52 @@
 
 
 class Custom404Test(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [("/foo", RequestHandler)]
 
     def get_app_kwargs(self):
+        """ """
         class Custom404Handler(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_status(404)
                 self.write("custom 404 response")
 
         return dict(default_handler_class=Custom404Handler)
 
     def test_404(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.code, 404)
         self.assertEqual(response.body, b"custom 404 response")
 
 
 class DefaultHandlerArgumentsTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [("/foo", RequestHandler)]
 
     def get_app_kwargs(self):
+        """ """
         return dict(
             default_handler_class=ErrorHandler,
             default_handler_args=dict(status_code=403),
         )
 
     def test_403(self):
+        """ """
         response = self.fetch("/")
         self.assertEqual(response.code, 403)
 
 
 class HandlerByNameTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         # All three are equivalent.
         return [
             ("/hello1", HelloHandler),
@@ -2224,6 +3044,7 @@
         ]
 
     def test_handler_by_name(self):
+        """ """
         resp = self.fetch("/hello1")
         self.assertEqual(resp.body, b"hello")
         resp = self.fetch("/hello2")
@@ -2233,35 +3054,77 @@
 
 
 class StreamingRequestBodyTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         @stream_request_body
         class StreamingBodyHandler(RequestHandler):
+            """ """
             def initialize(self, test):
+                """
+
+                Parameters
+                ----------
+                test :
+                    
+
+                Returns
+                -------
+
+                """
                 self.test = test
 
             def prepare(self):
+                """ """
                 self.test.prepared.set_result(None)
 
             def data_received(self, data):
+                """
+
+                Parameters
+                ----------
+                data :
+                    
+
+                Returns
+                -------
+
+                """
                 self.test.data.set_result(data)
 
             def get(self):
+                """ """
                 self.test.finished.set_result(None)
                 self.write({})
 
         @stream_request_body
         class EarlyReturnHandler(RequestHandler):
+            """ """
             def prepare(self):
+                """ """
                 # If we finish the response in prepare, it won't continue to
                 # the (non-existent) data_received.
                 raise HTTPError(401)
 
         @stream_request_body
         class CloseDetectionHandler(RequestHandler):
+            """ """
             def initialize(self, test):
+                """
+
+                Parameters
+                ----------
+                test :
+                    
+
+                Returns
+                -------
+
+                """
                 self.test = test
 
             def on_connection_close(self):
+                """ """
                 super().on_connection_close()
                 self.test.close_future.set_result(None)
 
@@ -2272,6 +3135,19 @@
         ]
 
     def connect(self, url, connection_close):
+        """
+
+        Parameters
+        ----------
+        url :
+            
+        connection_close :
+            
+
+        Returns
+        -------
+
+        """
         # Use a raw connection so we can control the sending of data.
         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
         s.connect(("127.0.0.1", self.get_http_port()))
@@ -2284,6 +3160,7 @@
 
     @gen_test
     def test_streaming_body(self):
+        """ """
         self.prepared = Future()  # type: Future[None]
         self.data = Future()  # type: Future[bytes]
         self.finished = Future()  # type: Future[None]
@@ -2307,12 +3184,14 @@
 
     @gen_test
     def test_early_return(self):
+        """ """
         stream = self.connect(b"/early_return", connection_close=False)
         data = yield stream.read_until_close()
         self.assertTrue(data.startswith(b"HTTP/1.1 401"))
 
     @gen_test
     def test_early_return_with_data(self):
+        """ """
         stream = self.connect(b"/early_return", connection_close=False)
         stream.write(b"4\r\nasdf\r\n")
         data = yield stream.read_until_close()
@@ -2320,6 +3199,7 @@
 
     @gen_test
     def test_close_during_upload(self):
+        """ """
         self.close_future = Future()  # type: Future[None]
         stream = self.connect(b"/close_detection", connection_close=False)
         stream.close()
@@ -2332,13 +3212,36 @@
 # one has completed.
 @stream_request_body
 class BaseFlowControlHandler(RequestHandler):
+    """ """
     def initialize(self, test):
+        """
+
+        Parameters
+        ----------
+        test :
+            
+
+        Returns
+        -------
+
+        """
         self.test = test
         self.method = None
         self.methods = []  # type: typing.List[str]
 
     @contextlib.contextmanager
     def in_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         if self.method is not None:
             self.test.fail("entered method %s while in %s" % (method, self.method))
         self.method = method
@@ -2350,6 +3253,7 @@
 
     @gen.coroutine
     def prepare(self):
+        """ """
         # Note that asynchronous prepare() does not block data_received,
         # so we don't use in_method here.
         self.methods.append("prepare")
@@ -2357,23 +3261,38 @@
 
     @gen.coroutine
     def post(self):
+        """ """
         with self.in_method("post"):
             yield gen.moment
         self.write(dict(methods=self.methods))
 
 
 class BaseStreamingRequestFlowControlTest(object):
+    """ """
     def get_httpserver_options(self):
+        """ """
         # Use a small chunk size so flow control is relevant even though
         # all the data arrives at once.
         return dict(chunk_size=10, decompress_request=True)
 
     def get_http_client(self):
+        """ """
         # simple_httpclient only: curl doesn't support body_producer.
         return SimpleAsyncHTTPClient()
 
     # Test all the slightly different code paths for fixed, chunked, etc bodies.
     def test_flow_control_fixed_body(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch("/", body="abcdefghijklmnopqrstuvwxyz", method="POST")
         response.rethrow()
         self.assertEqual(
@@ -2390,10 +3309,32 @@
         )
 
     def test_flow_control_chunked_body(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         chunks = [b"abcd", b"efgh", b"ijkl"]
 
         @gen.coroutine
         def body_producer(write):
+            """
+
+            Parameters
+            ----------
+            write :
+                
+
+            Returns
+            -------
+
+            """
             for i in chunks:
                 yield write(i)
 
@@ -2413,6 +3354,17 @@
         )
 
     def test_flow_control_compressed_body(self: typing.Any):
+        """
+
+        Parameters
+        ----------
+        self: typing.Any :
+            
+
+        Returns
+        -------
+
+        """
         bytesio = BytesIO()
         gzip_file = gzip.GzipFile(mode="w", fileobj=bytesio)
         gzip_file.write(b"abcdefghijklmnopqrstuvwxyz")
@@ -2442,10 +3394,24 @@
 class DecoratedStreamingRequestFlowControlTest(
     BaseStreamingRequestFlowControlTest, WebTestCase
 ):
+    """ """
     def get_handlers(self):
+        """ """
         class DecoratedFlowControlHandler(BaseFlowControlHandler):
+            """ """
             @gen.coroutine
             def data_received(self, data):
+                """
+
+                Parameters
+                ----------
+                data :
+                    
+
+                Returns
+                -------
+
+                """
                 with self.in_method("data_received"):
                     yield gen.moment
 
@@ -2455,8 +3421,11 @@
 class NativeStreamingRequestFlowControlTest(
     BaseStreamingRequestFlowControlTest, WebTestCase
 ):
+    """ """
     def get_handlers(self):
+        """ """
         class NativeFlowControlHandler(BaseFlowControlHandler):
+            """ """
             async def data_received(self, data):
                 with self.in_method("data_received"):
                     import asyncio
@@ -2467,13 +3436,17 @@
 
 
 class IncorrectContentLengthTest(SimpleHandlerTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         test = self
         self.server_error = None
 
         # Manually set a content-length that doesn't match the actual content.
         class TooHigh(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_header("Content-Length", "42")
                 try:
                     self.finish("ok")
@@ -2482,7 +3455,9 @@
                     raise
 
         class TooLow(RequestHandler):
+            """ """
             def get(self):
+                """ """
                 self.set_header("Content-Length", "2")
                 try:
                     self.finish("hello")
@@ -2493,6 +3468,7 @@
         return [("/high", TooHigh), ("/low", TooLow)]
 
     def test_content_length_too_high(self):
+        """ """
         # When the content-length is too high, the connection is simply
         # closed without completing the response.  An error is logged on
         # the server.
@@ -2509,6 +3485,7 @@
         )
 
     def test_content_length_too_low(self):
+        """ """
         # When the content-length is too low, the connection is closed
         # without writing the last chunk, so the client never sees the request
         # complete (which would be a framing error).
@@ -2526,8 +3503,11 @@
 
 
 class ClientCloseTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             if self.request.version.startswith("HTTP/1"):
                 # Simulate a connection closed by the client during
                 # request processing.  The client will see an error, but the
@@ -2541,6 +3521,7 @@
                 self.write("requires HTTP/1.x")
 
     def test_client_close(self):
+        """ """
         with self.assertRaises((HTTPClientError, unittest.SkipTest)):  # type: ignore
             response = self.fetch("/", raise_error=True)
             if response.body == b"requires HTTP/1.x":
@@ -2549,16 +3530,20 @@
 
 
 class SignedValueTest(unittest.TestCase):
+    """ """
     SECRET = "It's a secret to everybody"
     SECRET_DICT = {0: "asdfbasdf", 1: "12312312", 2: "2342342"}
 
     def past(self):
+        """ """
         return self.present() - 86400 * 32
 
     def present(self):
+        """ """
         return 1300000000
 
     def test_known_values(self):
+        """ """
         signed_v1 = create_signed_value(
             SignedValueTest.SECRET, "key", "value", version=1, clock=self.present
         )
@@ -2591,6 +3576,7 @@
         self.assertEqual(decoded_v2, b"value")
 
     def test_name_swap(self):
+        """ """
         signed1 = create_signed_value(
             SignedValueTest.SECRET, "key1", "value", clock=self.present
         )
@@ -2608,6 +3594,7 @@
         self.assertIs(decoded2, None)
 
     def test_expired(self):
+        """ """
         signed = create_signed_value(
             SignedValueTest.SECRET, "key1", "value", clock=self.past
         )
@@ -2621,10 +3608,22 @@
         self.assertIs(decoded_present, None)
 
     def test_payload_tampering(self):
+        """ """
         # These cookies are variants of the one in test_known_values.
         sig = "3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152"
 
         def validate(prefix):
+            """
+
+            Parameters
+            ----------
+            prefix :
+                
+
+            Returns
+            -------
+
+            """
             return b"value" == decode_signed_value(
                 SignedValueTest.SECRET, "key", prefix + sig, clock=self.present
             )
@@ -2638,9 +3637,21 @@
         self.assertFalse(validate("2|1:0|10:1300000000|3:keey|8:dmFsdWU=|"))
 
     def test_signature_tampering(self):
+        """ """
         prefix = "2|1:0|10:1300000000|3:key|8:dmFsdWU=|"
 
         def validate(sig):
+            """
+
+            Parameters
+            ----------
+            sig :
+                
+
+            Returns
+            -------
+
+            """
             return b"value" == decode_signed_value(
                 SignedValueTest.SECRET, "key", prefix + sig, clock=self.present
             )
@@ -2670,6 +3681,7 @@
         )
 
     def test_non_ascii(self):
+        """ """
         value = b"\xe9"
         signed = create_signed_value(
             SignedValueTest.SECRET, "key", value, clock=self.present
@@ -2680,6 +3692,7 @@
         self.assertEqual(value, decoded)
 
     def test_key_versioning_read_write_default_key(self):
+        """ """
         value = b"\xe9"
         signed = create_signed_value(
             SignedValueTest.SECRET_DICT, "key", value, clock=self.present, key_version=0
@@ -2690,6 +3703,7 @@
         self.assertEqual(value, decoded)
 
     def test_key_versioning_read_write_non_default_key(self):
+        """ """
         value = b"\xe9"
         signed = create_signed_value(
             SignedValueTest.SECRET_DICT, "key", value, clock=self.present, key_version=1
@@ -2700,6 +3714,7 @@
         self.assertEqual(value, decoded)
 
     def test_key_versioning_invalid_key(self):
+        """ """
         value = b"\xe9"
         signed = create_signed_value(
             SignedValueTest.SECRET_DICT, "key", value, clock=self.present, key_version=0
@@ -2710,6 +3725,7 @@
         self.assertEqual(None, decoded)
 
     def test_key_version_retrieval(self):
+        """ """
         value = b"\xe9"
         signed = create_signed_value(
             SignedValueTest.SECRET_DICT, "key", value, clock=self.present, key_version=1
@@ -2719,8 +3735,11 @@
 
 
 class XSRFTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             version = int(self.get_argument("version", "2"))
             # This would be a bad idea in a real app, but in this test
             # it's fine.
@@ -2728,16 +3747,32 @@
             self.write(self.xsrf_token)
 
         def post(self):
+            """ """
             self.write("ok")
 
     def get_app_kwargs(self):
+        """ """
         return dict(xsrf_cookies=True)
 
     def setUp(self):
+        """ """
         super().setUp()
         self.xsrf_token = self.get_token()
 
     def get_token(self, old_token=None, version=None):
+        """
+
+        Parameters
+        ----------
+        old_token :
+             (Default value = None)
+        version :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if old_token is not None:
             headers = self.cookie_headers(old_token)
         else:
@@ -2749,16 +3784,29 @@
         return native_str(response.body)
 
     def cookie_headers(self, token=None):
+        """
+
+        Parameters
+        ----------
+        token :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if token is None:
             token = self.xsrf_token
         return {"Cookie": "_xsrf=" + token}
 
     def test_xsrf_fail_no_token(self):
+        """ """
         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
             response = self.fetch("/", method="POST", body=b"")
         self.assertEqual(response.code, 403)
 
     def test_xsrf_fail_body_no_cookie(self):
+        """ """
         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
             response = self.fetch(
                 "/",
@@ -2768,6 +3816,7 @@
         self.assertEqual(response.code, 403)
 
     def test_xsrf_fail_argument_invalid_format(self):
+        """ """
         with ExpectLog(gen_log, ".*'_xsrf' argument has invalid format"):
             response = self.fetch(
                 "/",
@@ -2778,6 +3827,7 @@
         self.assertEqual(response.code, 403)
 
     def test_xsrf_fail_cookie_invalid_format(self):
+        """ """
         with ExpectLog(gen_log, ".*XSRF cookie does not match POST"):
             response = self.fetch(
                 "/",
@@ -2788,6 +3838,7 @@
         self.assertEqual(response.code, 403)
 
     def test_xsrf_fail_cookie_no_body(self):
+        """ """
         with ExpectLog(gen_log, ".*'_xsrf' argument missing"):
             response = self.fetch(
                 "/", method="POST", body=b"", headers=self.cookie_headers()
@@ -2795,6 +3846,7 @@
         self.assertEqual(response.code, 403)
 
     def test_xsrf_success_short_token(self):
+        """ """
         response = self.fetch(
             "/",
             method="POST",
@@ -2804,6 +3856,7 @@
         self.assertEqual(response.code, 200)
 
     def test_xsrf_success_non_hex_token(self):
+        """ """
         response = self.fetch(
             "/",
             method="POST",
@@ -2813,6 +3866,7 @@
         self.assertEqual(response.code, 200)
 
     def test_xsrf_success_post_body(self):
+        """ """
         response = self.fetch(
             "/",
             method="POST",
@@ -2822,6 +3876,7 @@
         self.assertEqual(response.code, 200)
 
     def test_xsrf_success_query_string(self):
+        """ """
         response = self.fetch(
             "/?" + urllib.parse.urlencode(dict(_xsrf=self.xsrf_token)),
             method="POST",
@@ -2831,6 +3886,7 @@
         self.assertEqual(response.code, 200)
 
     def test_xsrf_success_header(self):
+        """ """
         response = self.fetch(
             "/",
             method="POST",
@@ -2843,6 +3899,7 @@
         self.assertEqual(response.code, 200)
 
     def test_distinct_tokens(self):
+        """ """
         # Every request gets a distinct token.
         NUM_TOKENS = 10
         tokens = set()
@@ -2851,6 +3908,7 @@
         self.assertEqual(len(tokens), NUM_TOKENS)
 
     def test_cross_user(self):
+        """ """
         token2 = self.get_token()
         # Each token can be used to authenticate its own request.
         for token in (self.xsrf_token, token2):
@@ -2876,6 +3934,7 @@
             self.assertEqual(response.code, 403)
 
     def test_refresh_token(self):
+        """ """
         token = self.xsrf_token
         tokens_seen = set([token])
         # A user's token is stable over time.  Refreshing the page in one tab
@@ -2896,6 +3955,7 @@
         self.assertEqual(len(tokens_seen), 6)
 
     def test_versioning(self):
+        """ """
         # Version 1 still produces distinct tokens per request.
         self.assertNotEqual(self.get_token(version=1), self.get_token(version=1))
 
@@ -2922,16 +3982,21 @@
 
 
 class XSRFCookieKwargsTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.write(self.xsrf_token)
 
     def get_app_kwargs(self):
+        """ """
         return dict(
             xsrf_cookies=True, xsrf_cookie_kwargs=dict(httponly=True, expires_days=2)
         )
 
     def test_xsrf_httponly(self):
+        """ """
         response = self.fetch("/")
         self.assertIn("httponly;", response.headers["Set-Cookie"].lower())
         self.assertIn("expires=", response.headers["Set-Cookie"].lower())
@@ -2948,8 +4013,11 @@
 
 
 class FinishExceptionTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.set_status(401)
             self.set_header("WWW-Authenticate", 'Basic realm="something"')
             if self.get_argument("finish_value", ""):
@@ -2959,6 +4027,7 @@
                 raise Finish()
 
     def test_finish_exception(self):
+        """ """
         for u in ["/", "/?finish_value=1"]:
             response = self.fetch(u)
             self.assertEqual(response.code, 401)
@@ -2969,20 +4038,27 @@
 
 
 class DecoratorTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class RemoveSlashHandler(RequestHandler):
+            """ """
             @removeslash
             def get(self):
+                """ """
                 pass
 
         class AddSlashHandler(RequestHandler):
+            """ """
             @addslash
             def get(self):
+                """ """
                 pass
 
         return [("/removeslash/", RemoveSlashHandler), ("/addslash", AddSlashHandler)]
 
     def test_removeslash(self):
+        """ """
         response = self.fetch("/removeslash/", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/removeslash")
@@ -2992,6 +4068,7 @@
         self.assertEqual(response.headers["Location"], "/removeslash?foo=bar")
 
     def test_addslash(self):
+        """ """
         response = self.fetch("/addslash", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/addslash/")
@@ -3002,62 +4079,101 @@
 
 
 class CacheTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         class EtagHandler(RequestHandler):
+            """ """
             def get(self, computed_etag):
+                """
+
+                Parameters
+                ----------
+                computed_etag :
+                    
+
+                Returns
+                -------
+
+                """
                 self.write(computed_etag)
 
             def compute_etag(self):
+                """ """
                 return self._write_buffer[0]
 
         return [("/etag/(.*)", EtagHandler)]
 
     def test_wildcard_etag(self):
+        """ """
         computed_etag = '"xyzzy"'
         etags = "*"
         self._test_etag(computed_etag, etags, 304)
 
     def test_strong_etag_match(self):
+        """ """
         computed_etag = '"xyzzy"'
         etags = '"xyzzy"'
         self._test_etag(computed_etag, etags, 304)
 
     def test_multiple_strong_etag_match(self):
+        """ """
         computed_etag = '"xyzzy1"'
         etags = '"xyzzy1", "xyzzy2"'
         self._test_etag(computed_etag, etags, 304)
 
     def test_strong_etag_not_match(self):
+        """ """
         computed_etag = '"xyzzy"'
         etags = '"xyzzy1"'
         self._test_etag(computed_etag, etags, 200)
 
     def test_multiple_strong_etag_not_match(self):
+        """ """
         computed_etag = '"xyzzy"'
         etags = '"xyzzy1", "xyzzy2"'
         self._test_etag(computed_etag, etags, 200)
 
     def test_weak_etag_match(self):
+        """ """
         computed_etag = '"xyzzy1"'
         etags = 'W/"xyzzy1"'
         self._test_etag(computed_etag, etags, 304)
 
     def test_multiple_weak_etag_match(self):
+        """ """
         computed_etag = '"xyzzy2"'
         etags = 'W/"xyzzy1", W/"xyzzy2"'
         self._test_etag(computed_etag, etags, 304)
 
     def test_weak_etag_not_match(self):
+        """ """
         computed_etag = '"xyzzy2"'
         etags = 'W/"xyzzy1"'
         self._test_etag(computed_etag, etags, 200)
 
     def test_multiple_weak_etag_not_match(self):
+        """ """
         computed_etag = '"xyzzy3"'
         etags = 'W/"xyzzy1", W/"xyzzy2"'
         self._test_etag(computed_etag, etags, 200)
 
     def _test_etag(self, computed_etag, etags, status_code):
+        """
+
+        Parameters
+        ----------
+        computed_etag :
+            
+        etags :
+            
+        status_code :
+            
+
+        Returns
+        -------
+
+        """
         response = self.fetch(
             "/etag/" + computed_etag, headers={"If-None-Match": etags}
         )
@@ -3065,8 +4181,11 @@
 
 
 class RequestSummaryTest(SimpleHandlerTestCase):
+    """ """
     class Handler(RequestHandler):
+        """ """
         def get(self):
+            """ """
             # remote_ip is optional, although it's set by
             # both HTTPServer and WSGIAdapter.
             # Clobber it to make sure it doesn't break logging.
@@ -3074,12 +4193,15 @@
             self.finish(self._request_summary())
 
     def test_missing_remote_ip(self):
+        """ """
         resp = self.fetch("/")
         self.assertEqual(resp.body, b"GET / (None)")
 
 
 class HTTPErrorTest(unittest.TestCase):
+    """ """
     def test_copy(self):
+        """ """
         e = HTTPError(403, reason="Go away")
         e2 = copy.copy(e)
         self.assertIsNot(e, e2)
@@ -3088,18 +4210,23 @@
 
 
 class ApplicationTest(AsyncTestCase):
+    """ """
     def test_listen(self):
+        """ """
         app = Application([])
         server = app.listen(0, address="127.0.0.1")
         server.stop()
 
 
 class URLSpecReverseTest(unittest.TestCase):
+    """ """
     def test_reverse(self):
+        """ """
         self.assertEqual("/favicon.ico", url(r"/favicon\.ico", None).reverse())
         self.assertEqual("/favicon.ico", url(r"^/favicon\.ico$", None).reverse())
 
     def test_non_reversible(self):
+        """ """
         # URLSpecs are non-reversible if they include non-constant
         # regex features outside capturing groups. Currently, this is
         # only strictly enforced for backslash-escaped character
@@ -3118,6 +4245,7 @@
                 pass
 
     def test_reverse_arguments(self):
+        """ """
         self.assertEqual(
             "/api/v1/foo/bar", url(r"^/api/v1/foo/(\w+)$", None).reverse("bar")
         )
@@ -3128,7 +4256,9 @@
 
 
 class RedirectHandlerTest(WebTestCase):
+    """ """
     def get_handlers(self):
+        """ """
         return [
             ("/src", WebRedirectHandler, {"url": "/dst"}),
             ("/src2", WebRedirectHandler, {"url": "/dst2?foo=bar"}),
@@ -3136,21 +4266,25 @@
         ]
 
     def test_basic_redirect(self):
+        """ """
         response = self.fetch("/src", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/dst")
 
     def test_redirect_with_argument(self):
+        """ """
         response = self.fetch("/src?foo=bar", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/dst?foo=bar")
 
     def test_redirect_with_appending_argument(self):
+        """ """
         response = self.fetch("/src2?foo2=bar2", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/dst2?foo=bar&foo2=bar2")
 
     def test_redirect_pattern(self):
+        """ """
         response = self.fetch("/a/b/c", follow_redirects=False)
         self.assertEqual(response.code, 301)
         self.assertEqual(response.headers["Location"], "/b/a/c")
