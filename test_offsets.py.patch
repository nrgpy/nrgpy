# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/tseries/offsets/test_offsets.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/tseries/offsets/test_offsets.py
@@ -66,6 +66,7 @@
 
 
 class WeekDay:
+    """ """
     # TODO: Remove: This is not used outside of tests
     MON = 0
     TUE = 1
@@ -83,6 +84,7 @@
 
 
 class Base:
+    """ """
     _offset: Optional[Type[DateOffset]] = None
     d = Timestamp(datetime(2008, 1, 2))
 
@@ -96,6 +98,21 @@
     ]
 
     def _get_offset(self, klass, value=1, normalize=False):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+        value :
+             (Default value = 1)
+        normalize :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         # create instance from offset class
         if klass is FY5253:
             klass = klass(
@@ -127,6 +144,17 @@
         return klass
 
     def test_apply_out_of_range(self, tz_naive_fixture):
+        """
+
+        Parameters
+        ----------
+        tz_naive_fixture :
+            
+
+        Returns
+        -------
+
+        """
         tz = tz_naive_fixture
         if self._offset is None:
             return
@@ -159,6 +187,7 @@
             pass
 
     def test_offsets_compare_equal(self):
+        """ """
         # root cause of GH#456: __ne__ was not implemented
         if self._offset is None:
             return
@@ -168,6 +197,7 @@
         assert offset1 == offset2
 
     def test_rsub(self):
+        """ """
         if self._offset is None or not hasattr(self, "offset2"):
             # i.e. skip for TestCommon and YQM subclasses that do not have
             # offset2 attr
@@ -175,6 +205,7 @@
         assert self.d - self.offset2 == (-self.offset2).apply(self.d)
 
     def test_radd(self):
+        """ """
         if self._offset is None or not hasattr(self, "offset2"):
             # i.e. skip for TestCommon and YQM subclasses that do not have
             # offset2 attr
@@ -182,6 +213,7 @@
         assert self.d + self.offset2 == self.offset2 + self.d
 
     def test_sub(self):
+        """ """
         if self._offset is None or not hasattr(self, "offset2"):
             # i.e. skip for TestCommon and YQM subclasses that do not have
             # offset2 attr
@@ -196,6 +228,7 @@
         assert self.d - self.offset2 == self.d - (2 * off - off)
 
     def testMult1(self):
+        """ """
         if self._offset is None or not hasattr(self, "offset1"):
             # i.e. skip for TestCommon and YQM subclasses that do not have
             # offset1 attr
@@ -204,12 +237,14 @@
         assert self.d + 5 * self.offset1 == self.d + self._offset(5)
 
     def testMult2(self):
+        """ """
         if self._offset is None:
             return
         assert self.d + (-5 * self._offset(-10)) == self.d + self._offset(50)
         assert self.d + (-3 * self._offset(-2)) == self.d + self._offset(6)
 
     def test_compare_str(self):
+        """ """
         # GH#23524
         # comparing to strings that cannot be cast to DateOffsets should
         #  not raise for __eq__ or __ne__
@@ -224,6 +259,7 @@
 
 
 class TestCommon(Base):
+    """ """
     # exected value created by Base._get_offset
     # are applied to 2011/01/01 09:00 (Saturday)
     # used for .apply and .rollforward
@@ -265,6 +301,17 @@
     }
 
     def test_immutable(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         # GH#21341 check that __setattr__ raises
         offset = self._get_offset(offset_types)
         with pytest.raises(AttributeError):
@@ -273,6 +320,17 @@
             offset.n = 91
 
     def test_return_type(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         offset = self._get_offset(offset_types)
 
         # make sure that we are returning a Timestamp
@@ -287,6 +345,17 @@
         assert (-offset).apply(NaT) is NaT
 
     def test_offset_n(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         offset = self._get_offset(offset_types)
         assert offset.n == 1
 
@@ -297,6 +366,17 @@
         assert mul_offset.n == 3
 
     def test_offset_timedelta64_arg(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         # check that offset._validate_n raises TypeError on a timedelt64
         #  object
         off = self._get_offset(offset_types)
@@ -306,6 +386,17 @@
             type(off)(n=td64, **off.kwds)
 
     def test_offset_mul_ndarray(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         off = self._get_offset(offset_types)
 
         expected = np.array([[off, off * 2], [off * 3, off * 4]])
@@ -317,6 +408,17 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_offset_freqstr(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         offset = self._get_offset(offset_types)
 
         freqstr = offset.freqstr
@@ -325,6 +427,25 @@
             assert offset.rule_code == code
 
     def _check_offsetfunc_works(self, offset, funcname, dt, expected, normalize=False):
+        """
+
+        Parameters
+        ----------
+        offset :
+            
+        funcname :
+            
+        dt :
+            
+        expected :
+            
+        normalize :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
 
         if normalize and issubclass(offset, Tick):
             # normalize=True disallowed for Tick subclasses GH#21427
@@ -399,6 +520,17 @@
                 assert result == expected_localize
 
     def test_apply(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         sdt = datetime(2011, 1, 1, 9, 0)
         ndt = np_datetime64_compat("2011-01-01 09:00Z")
 
@@ -412,6 +544,17 @@
             )
 
     def test_rollforward(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         expecteds = self.expecteds.copy()
 
         # result will not be changed if the target is on the offset
@@ -467,6 +610,17 @@
             )
 
     def test_rollback(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         expecteds = {
             "BusinessDay": Timestamp("2010-12-31 09:00:00"),
             "CustomBusinessDay": Timestamp("2010-12-31 09:00:00"),
@@ -542,6 +696,17 @@
             )
 
     def test_is_on_offset(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         dt = self.expecteds[offset_types.__name__]
         offset_s = self._get_offset(offset_types)
         assert offset_s.is_on_offset(dt)
@@ -561,6 +726,19 @@
         assert offset_n.is_on_offset(date)
 
     def test_add(self, offset_types, tz_naive_fixture):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+        tz_naive_fixture :
+            
+
+        Returns
+        -------
+
+        """
         tz = tz_naive_fixture
         dt = datetime(2011, 1, 1, 9, 0)
 
@@ -596,6 +774,19 @@
         assert result == expected_localize
 
     def test_add_empty_datetimeindex(self, offset_types, tz_naive_fixture):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+        tz_naive_fixture :
+            
+
+        Returns
+        -------
+
+        """
         # GH#12724, GH#30336
         offset_s = self._get_offset(offset_types)
 
@@ -636,6 +827,17 @@
         tm.assert_equal(result, dta)
 
     def test_pickle_v0_15_2(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         offsets = {
             "DateOffset": DateOffset(years=1),
             "MonthBegin": MonthBegin(1),
@@ -652,6 +854,17 @@
         tm.assert_dict_equal(offsets, result)
 
     def test_pickle_roundtrip(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         off = self._get_offset(offset_types)
         res = tm.round_trip_pickle(off)
         assert off == res
@@ -665,6 +878,17 @@
                 assert getattr(off, attr) == getattr(res, attr)
 
     def test_onOffset_deprecated(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         # GH#30340 use idiomatic naming
         off = self._get_offset(offset_types)
 
@@ -676,6 +900,17 @@
         assert result == expected
 
     def test_isAnchored_deprecated(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         # GH#30340 use idiomatic naming
         off = self._get_offset(offset_types)
 
@@ -686,27 +921,53 @@
         assert result == expected
 
     def test_offsets_hashable(self, offset_types):
+        """
+
+        Parameters
+        ----------
+        offset_types :
+            
+
+        Returns
+        -------
+
+        """
         # GH: 37267
         off = self._get_offset(offset_types)
         assert hash(off) is not None
 
 
 class TestDateOffset(Base):
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.d = Timestamp(datetime(2008, 1, 2))
         _offset_map.clear()
 
     def test_repr(self):
+        """ """
         repr(DateOffset())
         repr(DateOffset(2))
         repr(2 * DateOffset())
         repr(2 * DateOffset(months=2))
 
     def test_mul(self):
+        """ """
         assert DateOffset(2) == 2 * DateOffset(1)
         assert DateOffset(2) == DateOffset(1) * 2
 
     def test_constructor(self):
+        """ """
 
         assert (self.d + DateOffset(months=2)) == datetime(2008, 3, 2)
         assert (self.d - DateOffset(months=2)) == datetime(2007, 11, 2)
@@ -720,9 +981,11 @@
         assert (d + DateOffset(months=1)) == datetime(2008, 2, 29)
 
     def test_copy(self):
+        """ """
         assert DateOffset(months=2).copy() == DateOffset(months=2)
 
     def test_eq(self):
+        """ """
         offset1 = DateOffset(days=1)
         offset2 = DateOffset(days=365)
 
@@ -730,9 +993,21 @@
 
 
 class TestBusinessDay(Base):
+    """ """
     _offset = BDay
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.d = datetime(2008, 1, 1)
 
         self.offset = BDay()
@@ -740,12 +1015,14 @@
         self.offset2 = BDay(2)
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset) == "<BusinessDay>"
         assert repr(self.offset2) == "<2 * BusinessDays>"
 
@@ -756,37 +1033,47 @@
         assert repr(self.offset + timedelta(1)) == expected
 
     def test_with_offset(self):
+        """ """
         offset = self.offset + timedelta(hours=2)
 
         assert (self.d + offset) == datetime(2008, 1, 2, 2)
 
     def test_eq(self):
+        """ """
         assert self.offset2 == self.offset2
 
     def test_mul(self):
+        """ """
         pass
 
     def test_hash(self):
+        """ """
         assert hash(self.offset2) == hash(self.offset2)
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset2(self.d) == datetime(2008, 1, 3)
 
     def testRollback1(self):
+        """ """
         assert BDay(10).rollback(self.d) == self.d
 
     def testRollback2(self):
+        """ """
         assert BDay(10).rollback(datetime(2008, 1, 5)) == datetime(2008, 1, 4)
 
     def testRollforward1(self):
+        """ """
         assert BDay(10).rollforward(self.d) == self.d
 
     def testRollforward2(self):
+        """ """
         assert BDay(10).rollforward(datetime(2008, 1, 5)) == datetime(2008, 1, 7)
 
     def test_roll_date_object(self):
+        """ """
         offset = BDay()
 
         dt = date(2012, 9, 15)
@@ -805,6 +1092,7 @@
         assert result == datetime(2012, 9, 15)
 
     def test_is_on_offset(self):
+        """ """
         tests = [
             (BDay(), datetime(2008, 1, 1), True),
             (BDay(), datetime(2008, 1, 5), False),
@@ -884,11 +1172,23 @@
 
     @pytest.mark.parametrize("case", apply_cases)
     def test_apply(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     def test_apply_large_n(self):
+        """ """
         dt = datetime(2012, 10, 23)
 
         result = dt + BDay(10)
@@ -913,15 +1213,28 @@
         assert rs == xp
 
     def test_apply_corner(self):
+        """ """
         msg = "Only know how to combine business day with datetime or timedelta"
         with pytest.raises(ApplyTypeError, match=msg):
             BDay().apply(BMonthEnd())
 
 
 class TestBusinessHour(Base):
+    """ """
     _offset = BusinessHour
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.d = datetime(2014, 7, 1, 10, 00)
 
         self.offset1 = BusinessHour()
@@ -980,16 +1293,33 @@
         ],
     )
     def test_constructor_errors(self, start, end, match):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        end :
+            
+        match :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError, match=match):
             BusinessHour(start=start, end=end)
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset1) == "<BusinessHour: BH=09:00-17:00>"
         assert repr(self.offset2) == "<3 * BusinessHours: BH=09:00-17:00>"
         assert repr(self.offset3) == "<-1 * BusinessHour: BH=09:00-17:00>"
@@ -1003,6 +1333,7 @@
         assert repr(self.offset10) == "<-1 * BusinessHour: BH=13:00-17:00,23:00-02:00>"
 
     def test_with_offset(self):
+        """ """
         expected = Timestamp("2014-07-01 13:00")
 
         assert self.d + BusinessHour() * 3 == expected
@@ -1013,6 +1344,17 @@
         ["offset1", "offset2", "offset3", "offset4", "offset8", "offset9", "offset10"],
     )
     def test_eq_attribute(self, offset_name):
+        """
+
+        Parameters
+        ----------
+        offset_name :
+            
+
+        Returns
+        -------
+
+        """
         offset = getattr(self, offset_name)
         assert offset == offset
 
@@ -1027,6 +1369,19 @@
         ],
     )
     def test_eq(self, offset1, offset2):
+        """
+
+        Parameters
+        ----------
+        offset1 :
+            
+        offset2 :
+            
+
+        Returns
+        -------
+
+        """
         assert offset1 == offset2
 
     @pytest.mark.parametrize(
@@ -1045,6 +1400,19 @@
         ],
     )
     def test_neq(self, offset1, offset2):
+        """
+
+        Parameters
+        ----------
+        offset1 :
+            
+        offset2 :
+            
+
+        Returns
+        -------
+
+        """
         assert offset1 != offset2
 
     @pytest.mark.parametrize(
@@ -1052,10 +1420,22 @@
         ["offset1", "offset2", "offset3", "offset4", "offset8", "offset9", "offset10"],
     )
     def test_hash(self, offset_name):
+        """
+
+        Parameters
+        ----------
+        offset_name :
+            
+
+        Returns
+        -------
+
+        """
         offset = getattr(self, offset_name)
         assert offset == offset
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset1(self.d) == datetime(2014, 7, 1, 11)
@@ -1067,6 +1447,7 @@
             assert self.offset10(self.d) == datetime(2014, 7, 1, 1)
 
     def test_sub(self):
+        """ """
         # we have to override test_sub here because self.offset2 is not
         # defined as self._offset(2)
         off = self.offset2
@@ -1078,6 +1459,7 @@
         assert self.d - self.offset2 == self.d + self._offset(-3)
 
     def testRollback1(self):
+        """ """
         assert self.offset1.rollback(self.d) == self.d
         assert self.offset2.rollback(self.d) == self.d
         assert self.offset3.rollback(self.d) == self.d
@@ -1104,11 +1486,13 @@
         assert self._offset(5).rollback(self.d) == self.d
 
     def testRollback2(self):
+        """ """
         assert self._offset(-3).rollback(datetime(2014, 7, 5, 15, 0)) == datetime(
             2014, 7, 4, 17, 0
         )
 
     def testRollforward1(self):
+        """ """
         assert self.offset1.rollforward(self.d) == self.d
         assert self.offset2.rollforward(self.d) == self.d
         assert self.offset3.rollforward(self.d) == self.d
@@ -1135,11 +1519,13 @@
         assert self._offset(5).rollforward(self.d) == self.d
 
     def testRollforward2(self):
+        """ """
         assert self._offset(-3).rollforward(datetime(2014, 7, 5, 16, 0)) == datetime(
             2014, 7, 7, 9
         )
 
     def test_roll_date_object(self):
+        """ """
         offset = BusinessHour()
 
         dt = datetime(2014, 7, 6, 15, 0)
@@ -1205,6 +1591,17 @@
 
     @pytest.mark.parametrize("case", normalize_cases)
     def test_normalize(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for dt, expected in cases.items():
             assert offset.apply(dt) == expected
@@ -1302,6 +1699,17 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for dt, expected in cases.items():
             assert offset.is_on_offset(dt) == expected
@@ -1766,6 +2174,17 @@
 
     @pytest.mark.parametrize("case", opening_time_cases)
     def test_opening_time(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         _offsets, cases = case
         for offset in _offsets:
             for dt, (exp_next, exp_prev) in cases.items():
@@ -2111,6 +2530,17 @@
 
     @pytest.mark.parametrize("case", apply_cases)
     def test_apply(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
@@ -2231,11 +2661,23 @@
 
     @pytest.mark.parametrize("case", apply_large_n_cases)
     def test_apply_large_n(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     def test_apply_nanoseconds(self):
+        """ """
         tests = []
 
         tests.append(
@@ -2277,6 +2719,7 @@
                 assert_offset_equal(offset, base, expected)
 
     def test_datetimeindex(self):
+        """ """
         idx1 = date_range(start="2014-07-04 15:00", end="2014-07-08 10:00", freq="BH")
         idx2 = date_range(start="2014-07-04 15:00", periods=12, freq="BH")
         idx3 = date_range(end="2014-07-08 10:00", periods=12, freq="BH")
@@ -2327,10 +2770,22 @@
 
 
 class TestCustomBusinessHour(Base):
+    """ """
     _offset = CustomBusinessHour
     holidays = ["2014-06-27", datetime(2014, 6, 30), np.datetime64("2014-07-02")]
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         # 2014 Calendar to check custom holidays
         #   Sun Mon Tue Wed Thu Fri Sat
         #  6/22  23  24  25  26  27  28
@@ -2342,6 +2797,7 @@
         self.offset2 = CustomBusinessHour(holidays=self.holidays)
 
     def test_constructor_errors(self):
+        """ """
         from datetime import time as dt_time
 
         with pytest.raises(ValueError):
@@ -2352,22 +2808,26 @@
             CustomBusinessHour(start="14:00:05")
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset1) == "<CustomBusinessHour: CBH=09:00-17:00>"
         assert repr(self.offset2) == "<CustomBusinessHour: CBH=09:00-17:00>"
 
     def test_with_offset(self):
+        """ """
         expected = Timestamp("2014-07-01 13:00")
 
         assert self.d + CustomBusinessHour() * 3 == expected
         assert self.d + CustomBusinessHour(n=3) == expected
 
     def test_eq(self):
+        """ """
         for offset in [self.offset1, self.offset2]:
             assert offset == offset
 
@@ -2386,21 +2846,25 @@
         )
 
     def test_sub(self):
+        """ """
         # override the Base.test_sub implementation because self.offset2 is
         # defined differently in this class than the test expects
         pass
 
     def test_hash(self):
+        """ """
         assert hash(self.offset1) == hash(self.offset1)
         assert hash(self.offset2) == hash(self.offset2)
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset1(self.d) == datetime(2014, 7, 1, 11)
             assert self.offset2(self.d) == datetime(2014, 7, 1, 11)
 
     def testRollback1(self):
+        """ """
         assert self.offset1.rollback(self.d) == self.d
         assert self.offset2.rollback(self.d) == self.d
 
@@ -2413,11 +2877,13 @@
         assert self.offset2.rollback(d) == datetime(2014, 6, 26, 17)
 
     def testRollback2(self):
+        """ """
         assert self._offset(-3).rollback(datetime(2014, 7, 5, 15, 0)) == datetime(
             2014, 7, 4, 17, 0
         )
 
     def testRollforward1(self):
+        """ """
         assert self.offset1.rollforward(self.d) == self.d
         assert self.offset2.rollforward(self.d) == self.d
 
@@ -2426,11 +2892,13 @@
         assert self.offset2.rollforward(d) == datetime(2014, 7, 1, 9)
 
     def testRollforward2(self):
+        """ """
         assert self._offset(-3).rollforward(datetime(2014, 7, 5, 16, 0)) == datetime(
             2014, 7, 7, 9
         )
 
     def test_roll_date_object(self):
+        """ """
         offset = BusinessHour()
 
         dt = datetime(2014, 7, 6, 15, 0)
@@ -2498,11 +2966,23 @@
 
     @pytest.mark.parametrize("norm_cases", normalize_cases)
     def test_normalize(self, norm_cases):
+        """
+
+        Parameters
+        ----------
+        norm_cases :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = norm_cases
         for dt, expected in cases.items():
             assert offset.apply(dt) == expected
 
     def test_is_on_offset(self):
+        """ """
         tests = []
 
         tests.append(
@@ -2574,6 +3054,17 @@
 
     @pytest.mark.parametrize("apply_case", apply_cases)
     def test_apply(self, apply_case):
+        """
+
+        Parameters
+        ----------
+        apply_case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = apply_case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
@@ -2615,15 +3106,38 @@
 
     @pytest.mark.parametrize("nano_case", nano_cases)
     def test_apply_nanoseconds(self, nano_case):
+        """
+
+        Parameters
+        ----------
+        nano_case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = nano_case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
 
 class TestCustomBusinessDay(Base):
+    """ """
     _offset = CDay
 
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.d = datetime(2008, 1, 1)
         self.nd = np_datetime64_compat("2008-01-01 00:00:00Z")
 
@@ -2632,12 +3146,14 @@
         self.offset2 = CDay(2)
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset) == "<CustomBusinessDay>"
         assert repr(self.offset2) == "<2 * CustomBusinessDays>"
 
@@ -2648,38 +3164,48 @@
         assert repr(self.offset + timedelta(1)) == expected
 
     def test_with_offset(self):
+        """ """
         offset = self.offset + timedelta(hours=2)
 
         assert (self.d + offset) == datetime(2008, 1, 2, 2)
 
     def test_eq(self):
+        """ """
         assert self.offset2 == self.offset2
 
     def test_mul(self):
+        """ """
         pass
 
     def test_hash(self):
+        """ """
         assert hash(self.offset2) == hash(self.offset2)
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset2(self.d) == datetime(2008, 1, 3)
             assert self.offset2(self.nd) == datetime(2008, 1, 3)
 
     def testRollback1(self):
+        """ """
         assert CDay(10).rollback(self.d) == self.d
 
     def testRollback2(self):
+        """ """
         assert CDay(10).rollback(datetime(2008, 1, 5)) == datetime(2008, 1, 4)
 
     def testRollforward1(self):
+        """ """
         assert CDay(10).rollforward(self.d) == self.d
 
     def testRollforward2(self):
+        """ """
         assert CDay(10).rollforward(datetime(2008, 1, 5)) == datetime(2008, 1, 7)
 
     def test_roll_date_object(self):
+        """ """
         offset = CDay()
 
         dt = date(2012, 9, 15)
@@ -2704,6 +3230,17 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, d, expected = case
         assert_is_on_offset(offset, d, expected)
 
@@ -2778,11 +3315,23 @@
 
     @pytest.mark.parametrize("case", apply_cases)
     def test_apply(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     def test_apply_large_n(self):
+        """ """
         dt = datetime(2012, 10, 23)
 
         result = dt + CDay(10)
@@ -2802,6 +3351,7 @@
         assert rs == xp
 
     def test_apply_corner(self):
+        """ """
         msg = (
             "Only know how to combine trading day "
             "with datetime, datetime64 or timedelta"
@@ -2810,6 +3360,7 @@
             CDay().apply(BMonthEnd())
 
     def test_holidays(self):
+        """ """
         # Define a TradingDay offset
         holidays = ["2012-05-01", datetime(2013, 5, 1), np.datetime64("2014-05-01")]
         tday = CDay(holidays=holidays)
@@ -2820,6 +3371,7 @@
             assert rs == xp
 
     def test_weekmask(self):
+        """ """
         weekmask_saudi = "Sat Sun Mon Tue Wed"  # Thu-Fri Weekend
         weekmask_uae = "1111001"  # Fri-Sat Weekend
         weekmask_egypt = [1, 1, 1, 1, 0, 0, 1]  # Fri-Sat Weekend
@@ -2839,6 +3391,7 @@
         assert xp2 == dt + 2 * bday_egypt
 
     def test_weekmask_and_holidays(self):
+        """ """
         weekmask_egypt = "Sun Mon Tue Wed Thu"  # Fri-Sat Weekend
         holidays = ["2012-05-01", datetime(2013, 5, 1), np.datetime64("2014-05-01")]
         bday_egypt = CDay(holidays=holidays, weekmask=weekmask_egypt)
@@ -2848,12 +3401,25 @@
 
     @pytest.mark.filterwarnings("ignore:Non:pandas.errors.PerformanceWarning")
     def test_calendar(self):
+        """ """
         calendar = USFederalHolidayCalendar()
         dt = datetime(2014, 1, 17)
         assert_offset_equal(CDay(calendar=calendar), dt, datetime(2014, 1, 21))
 
     def test_roundtrip_pickle(self):
+        """ """
         def _check_roundtrip(obj):
+            """
+
+            Parameters
+            ----------
+            obj :
+                
+
+            Returns
+            -------
+
+            """
             unpickled = tm.round_trip_pickle(obj)
             assert unpickled == obj
 
@@ -2862,6 +3428,17 @@
         _check_roundtrip(self.offset * 2)
 
     def test_pickle_compat_0_14_1(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         hdays = [datetime(2013, 1, 1) for ele in range(4)]
         pth = datapath("tseries", "offsets", "data", "cday-0.14.1.pickle")
         cday0_14_1 = read_pickle(pth)
@@ -2870,7 +3447,19 @@
 
 
 class CustomBusinessMonthBase:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.d = datetime(2008, 1, 1)
 
         self.offset = self._offset()
@@ -2878,16 +3467,31 @@
         self.offset2 = self._offset(2)
 
     def test_eq(self):
+        """ """
         assert self.offset2 == self.offset2
 
     def test_mul(self):
+        """ """
         pass
 
     def test_hash(self):
+        """ """
         assert hash(self.offset2) == hash(self.offset2)
 
     def test_roundtrip_pickle(self):
+        """ """
         def _check_roundtrip(obj):
+            """
+
+            Parameters
+            ----------
+            obj :
+                
+
+            Returns
+            -------
+
+            """
             unpickled = tm.round_trip_pickle(obj)
             assert unpickled == obj
 
@@ -2896,39 +3500,48 @@
         _check_roundtrip(self._offset() * 2)
 
     def test_copy(self):
+        """ """
         # GH 17452
         off = self._offset(weekmask="Mon Wed Fri")
         assert off == off.copy()
 
 
 class TestCustomBusinessMonthEnd(CustomBusinessMonthBase, Base):
+    """ """
     _offset = CBMonthEnd
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset) == "<CustomBusinessMonthEnd>"
         assert repr(self.offset2) == "<2 * CustomBusinessMonthEnds>"
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset2(self.d) == datetime(2008, 2, 29)
 
     def testRollback1(self):
+        """ """
         assert CDay(10).rollback(datetime(2007, 12, 31)) == datetime(2007, 12, 31)
 
     def testRollback2(self):
+        """ """
         assert CBMonthEnd(10).rollback(self.d) == datetime(2007, 12, 31)
 
     def testRollforward1(self):
+        """ """
         assert CBMonthEnd(10).rollforward(self.d) == datetime(2008, 1, 31)
 
     def test_roll_date_object(self):
+        """ """
         offset = CBMonthEnd()
 
         dt = date(2012, 9, 15)
@@ -2953,6 +3566,17 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, d, expected = case
         assert_is_on_offset(offset, d, expected)
 
@@ -3009,11 +3633,23 @@
 
     @pytest.mark.parametrize("case", apply_cases)
     def test_apply(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     def test_apply_large_n(self):
+        """ """
         dt = datetime(2012, 10, 23)
 
         result = dt + CBMonthEnd(10)
@@ -3033,6 +3669,7 @@
         assert rs == xp
 
     def test_holidays(self):
+        """ """
         # Define a TradingDay offset
         holidays = ["2012-01-31", datetime(2012, 2, 28), np.datetime64("2012-02-29")]
         bm_offset = CBMonthEnd(holidays=holidays)
@@ -3042,6 +3679,7 @@
 
     @pytest.mark.filterwarnings("ignore:Non:pandas.errors.PerformanceWarning")
     def test_datetimeindex(self):
+        """ """
         from pandas.tseries.holiday import USFederalHolidayCalendar
 
         hcal = USFederalHolidayCalendar()
@@ -3053,33 +3691,41 @@
 
 
 class TestCustomBusinessMonthBegin(CustomBusinessMonthBase, Base):
+    """ """
     _offset = CBMonthBegin
 
     def test_different_normalize_equals(self):
+        """ """
         # GH#21404 changed __eq__ to return False when `normalize` does not match
         offset = self._offset()
         offset2 = self._offset(normalize=True)
         assert offset != offset2
 
     def test_repr(self):
+        """ """
         assert repr(self.offset) == "<CustomBusinessMonthBegin>"
         assert repr(self.offset2) == "<2 * CustomBusinessMonthBegins>"
 
     def test_call(self):
+        """ """
         with tm.assert_produces_warning(FutureWarning):
             # GH#34171 DateOffset.__call__ is deprecated
             assert self.offset2(self.d) == datetime(2008, 3, 3)
 
     def testRollback1(self):
+        """ """
         assert CDay(10).rollback(datetime(2007, 12, 31)) == datetime(2007, 12, 31)
 
     def testRollback2(self):
+        """ """
         assert CBMonthBegin(10).rollback(self.d) == datetime(2008, 1, 1)
 
     def testRollforward1(self):
+        """ """
         assert CBMonthBegin(10).rollforward(self.d) == datetime(2008, 1, 1)
 
     def test_roll_date_object(self):
+        """ """
         offset = CBMonthBegin()
 
         dt = date(2012, 9, 15)
@@ -3104,6 +3750,17 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, dt, expected = case
         assert_is_on_offset(offset, dt, expected)
 
@@ -3160,11 +3817,23 @@
 
     @pytest.mark.parametrize("case", apply_cases)
     def test_apply(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     def test_apply_large_n(self):
+        """ """
         dt = datetime(2012, 10, 23)
 
         result = dt + CBMonthBegin(10)
@@ -3185,6 +3854,7 @@
         assert rs == xp
 
     def test_holidays(self):
+        """ """
         # Define a TradingDay offset
         holidays = ["2012-02-01", datetime(2012, 2, 2), np.datetime64("2012-03-01")]
         bm_offset = CBMonthBegin(holidays=holidays)
@@ -3195,6 +3865,7 @@
 
     @pytest.mark.filterwarnings("ignore:Non:pandas.errors.PerformanceWarning")
     def test_datetimeindex(self):
+        """ """
         hcal = USFederalHolidayCalendar()
         cbmb = CBMonthBegin(calendar=hcal)
         assert date_range(start="20120101", end="20130101", freq=cbmb).tolist()[
@@ -3203,17 +3874,20 @@
 
 
 class TestWeek(Base):
+    """ """
     _offset = Week
     d = Timestamp(datetime(2008, 1, 2))
     offset1 = _offset()
     offset2 = _offset(2)
 
     def test_repr(self):
+        """ """
         assert repr(Week(weekday=0)) == "<Week: weekday=0>"
         assert repr(Week(n=-1, weekday=0)) == "<-1 * Week: weekday=0>"
         assert repr(Week(n=-2, weekday=0)) == "<-2 * Weeks: weekday=0>"
 
     def test_corner(self):
+        """ """
         with pytest.raises(ValueError):
             Week(weekday=7)
 
@@ -3221,6 +3895,7 @@
             Week(weekday=-1)
 
     def test_is_anchored(self):
+        """ """
         assert Week(weekday=0).is_anchored()
         assert not Week().is_anchored()
         assert not Week(2, weekday=2).is_anchored()
@@ -3283,12 +3958,34 @@
 
     @pytest.mark.parametrize("case", offset_cases)
     def test_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     @pytest.mark.parametrize("weekday", range(7))
     def test_is_on_offset(self, weekday):
+        """
+
+        Parameters
+        ----------
+        weekday :
+            
+
+        Returns
+        -------
+
+        """
         offset = Week(weekday=weekday)
 
         for day in range(1, 8):
@@ -3302,11 +3999,13 @@
 
 
 class TestWeekOfMonth(Base):
+    """ """
     _offset = WeekOfMonth
     offset1 = _offset()
     offset2 = _offset(2)
 
     def test_constructor(self):
+        """ """
         with pytest.raises(ValueError, match="^Week"):
             WeekOfMonth(n=1, week=4, weekday=0)
 
@@ -3320,11 +4019,13 @@
             WeekOfMonth(n=1, week=0, weekday=-7)
 
     def test_repr(self):
+        """ """
         assert (
             repr(WeekOfMonth(weekday=1, week=2)) == "<WeekOfMonth: week=2, weekday=1>"
         )
 
     def test_offset(self):
+        """ """
         date1 = datetime(2011, 1, 4)  # 1st Tuesday of Month
         date2 = datetime(2011, 1, 11)  # 2nd Tuesday of Month
         date3 = datetime(2011, 1, 18)  # 3rd Tuesday of Month
@@ -3396,17 +4097,30 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         week, weekday, dt, expected = case
         offset = WeekOfMonth(week=week, weekday=weekday)
         assert offset.is_on_offset(dt) == expected
 
 
 class TestLastWeekOfMonth(Base):
+    """ """
     _offset = LastWeekOfMonth
     offset1 = _offset()
     offset2 = _offset(2)
 
     def test_constructor(self):
+        """ """
         with pytest.raises(ValueError, match="^N cannot be 0"):
             LastWeekOfMonth(n=0, weekday=1)
 
@@ -3417,6 +4131,7 @@
             LastWeekOfMonth(n=1, weekday=7)
 
     def test_offset(self):
+        """ """
         # Saturday
         last_sat = datetime(2013, 8, 31)
         next_sat = datetime(2013, 9, 28)
@@ -3473,22 +4188,36 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         weekday, dt, expected = case
         offset = LastWeekOfMonth(weekday=weekday)
         assert offset.is_on_offset(dt) == expected
 
     def test_repr(self):
+        """ """
         assert (
             repr(LastWeekOfMonth(n=2, weekday=1)) == "<2 * LastWeekOfMonths: weekday=1>"
         )
 
 
 class TestSemiMonthEnd(Base):
+    """ """
     _offset = SemiMonthEnd
     offset1 = _offset()
     offset2 = _offset(2)
 
     def test_offset_whole_year(self):
+        """ """
         dates = (
             datetime(2007, 12, 31),
             datetime(2008, 1, 15),
@@ -3662,12 +4391,34 @@
 
     @pytest.mark.parametrize("case", offset_cases)
     def test_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     @pytest.mark.parametrize("case", offset_cases)
     def test_apply_index(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/34580
         offset, cases = case
         s = DatetimeIndex(cases.keys())
@@ -3693,11 +4444,33 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         dt, expected = case
         assert_is_on_offset(SemiMonthEnd(), dt, expected)
 
     @pytest.mark.parametrize("klass", [Series, DatetimeIndex])
     def test_vectorized_offset_addition(self, klass):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
+        """
         s = klass(
             [
                 Timestamp("2000-01-15 00:15:00", tz="US/Central"),
@@ -3748,11 +4521,13 @@
 
 
 class TestSemiMonthBegin(Base):
+    """ """
     _offset = SemiMonthBegin
     offset1 = _offset()
     offset2 = _offset(2)
 
     def test_offset_whole_year(self):
+        """ """
         dates = (
             datetime(2007, 12, 15),
             datetime(2008, 1, 1),
@@ -3930,12 +4705,34 @@
 
     @pytest.mark.parametrize("case", offset_cases)
     def test_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         for base, expected in cases.items():
             assert_offset_equal(offset, base, expected)
 
     @pytest.mark.parametrize("case", offset_cases)
     def test_apply_index(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         offset, cases = case
         s = DatetimeIndex(cases.keys())
 
@@ -3957,11 +4754,33 @@
 
     @pytest.mark.parametrize("case", on_offset_cases)
     def test_is_on_offset(self, case):
+        """
+
+        Parameters
+        ----------
+        case :
+            
+
+        Returns
+        -------
+
+        """
         dt, expected = case
         assert_is_on_offset(SemiMonthBegin(), dt, expected)
 
     @pytest.mark.parametrize("klass", [Series, DatetimeIndex])
     def test_vectorized_offset_addition(self, klass):
+        """
+
+        Parameters
+        ----------
+        klass :
+            
+
+        Returns
+        -------
+
+        """
         s = klass(
             [
                 Timestamp("2000-01-15 00:15:00", tz="US/Central"),
@@ -4010,6 +4829,7 @@
 
 
 def test_Easter():
+    """ """
     assert_offset_equal(Easter(), datetime(2010, 1, 1), datetime(2010, 4, 4))
     assert_offset_equal(Easter(), datetime(2010, 4, 5), datetime(2011, 4, 24))
     assert_offset_equal(Easter(2), datetime(2010, 1, 1), datetime(2011, 4, 24))
@@ -4026,7 +4846,9 @@
 
 
 class TestOffsetNames:
+    """ """
     def test_get_offset_name(self):
+        """ """
         assert BDay().freqstr == "B"
         assert BDay(2).freqstr == "2B"
         assert BMonthEnd().freqstr == "BM"
@@ -4040,6 +4862,7 @@
 
 
 def test_get_offset():
+    """ """
     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
         _get_offset("gibberish")
     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
@@ -4066,6 +4889,7 @@
 
 
 def test_get_offset_legacy():
+    """ """
     pairs = [("w@Sat", Week(weekday=5))]
     for name, expected in pairs:
         with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
@@ -4073,16 +4897,30 @@
 
 
 class TestOffsetAliases:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         _offset_map.clear()
 
     def test_alias_equality(self):
+        """ """
         for k, v in _offset_map.items():
             if v is None:
                 continue
             assert k == v.copy()
 
     def test_rule_code(self):
+        """ """
         lst = ["M", "MS", "BM", "BMS", "D", "B", "H", "T", "S", "L", "U"]
         for k in lst:
             assert k == _get_offset(k).rule_code
@@ -4120,6 +4958,7 @@
 
 
 def test_dateoffset_misc():
+    """ """
     oset = offsets.DateOffset(months=2, days=4)
     # it works
     oset.freqstr
@@ -4128,6 +4967,7 @@
 
 
 def test_freq_offsets():
+    """ """
     off = BDay(1, offset=timedelta(0, 1800))
     assert off.freqstr == "B+30Min"
 
@@ -4136,7 +4976,9 @@
 
 
 class TestReprNames:
+    """ """
     def test_str_for_named_is_name(self):
+        """ """
         # look at all the amazing combinations!
         month_prefixes = ["A", "AS", "BA", "BAS", "Q", "BQ", "BQS", "QS"]
         names = [
@@ -4167,15 +5009,24 @@
 
 
 def get_utc_offset_hours(ts):
+    """
+
+    Parameters
+    ----------
+    ts :
+        
+
+    Returns
+    -------
+
+    """
     # take a Timestamp and compute total hours of utc offset
     o = ts.utcoffset()
     return (o.days * 24 * 3600 + o.seconds) / 3600.0
 
 
 class TestDST:
-    """
-    test DateOffset additions over Daylight Savings Time
-    """
+    """test DateOffset additions over Daylight Savings Time"""
 
     # one microsecond before the DST transition
     ts_pre_fallback = "2013-11-03 01:59:59.999999"
@@ -4205,6 +5056,19 @@
     ]
 
     def _test_all_offsets(self, n, **kwds):
+        """
+
+        Parameters
+        ----------
+        n :
+            
+        **kwds :
+            
+
+        Returns
+        -------
+
+        """
         valid_offsets = (
             self.valid_date_offsets_plural
             if n > 1
@@ -4215,6 +5079,23 @@
             self._test_offset(offset_name=name, offset_n=n, **kwds)
 
     def _test_offset(self, offset_name, offset_n, tstart, expected_utc_offset):
+        """
+
+        Parameters
+        ----------
+        offset_name :
+            
+        offset_n :
+            
+        tstart :
+            
+        expected_utc_offset :
+            
+
+        Returns
+        -------
+
+        """
         offset = DateOffset(**{offset_name: offset_n})
 
         t = tstart + offset
@@ -4251,6 +5132,21 @@
             assert t == (tstart.tz_convert("UTC") + offset).tz_convert("US/Pacific")
 
     def _make_timestamp(self, string, hrs_offset, tz):
+        """
+
+        Parameters
+        ----------
+        string :
+            
+        hrs_offset :
+            
+        tz :
+            
+
+        Returns
+        -------
+
+        """
         if hrs_offset >= 0:
             offset_string = f"{hrs_offset:02d}00"
         else:
@@ -4258,6 +5154,7 @@
         return Timestamp(string + offset_string).tz_convert(tz)
 
     def test_springforward_plural(self):
+        """ """
         # test moving from standard to daylight savings
         for tz, utc_offsets in self.timezone_utc_offsets.items():
             hrs_pre = utc_offsets["utc_offset_standard"]
@@ -4269,6 +5166,7 @@
             )
 
     def test_fallback_singular(self):
+        """ """
         # in the case of singular offsets, we don't necessarily know which utc
         # offset the new Timestamp will wind up in (the tz for 1 month may be
         # different from 1 second) so we don't specify an expected_utc_offset
@@ -4281,6 +5179,7 @@
             )
 
     def test_springforward_singular(self):
+        """ """
         for tz, utc_offsets in self.timezone_utc_offsets.items():
             hrs_pre = utc_offsets["utc_offset_standard"]
             self._test_all_offsets(
@@ -4312,6 +5211,17 @@
 
     @pytest.mark.parametrize("tup", offset_classes)
     def test_all_offset_classes(self, tup):
+        """
+
+        Parameters
+        ----------
+        tup :
+            
+
+        Returns
+        -------
+
+        """
         offset, test_values = tup
 
         first = Timestamp(test_values[0], tz="US/Eastern") + offset()
@@ -4323,6 +5233,17 @@
 
 
 def test_valid_default_arguments(offset_types):
+    """
+
+    Parameters
+    ----------
+    offset_types :
+        
+
+    Returns
+    -------
+
+    """
     # GH#19142 check that the calling the constructors without passing
     # any keyword arguments produce valid offsets
     cls = offset_types
@@ -4331,6 +5252,19 @@
 
 @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
 def test_valid_month_attributes(kwd, month_classes):
+    """
+
+    Parameters
+    ----------
+    kwd :
+        
+    month_classes :
+        
+
+    Returns
+    -------
+
+    """
     # GH#18226
     cls = month_classes
     # check that we cannot create e.g. MonthEnd(weeks=3)
@@ -4339,6 +5273,17 @@
 
 
 def test_month_offset_name(month_classes):
+    """
+
+    Parameters
+    ----------
+    month_classes :
+        
+
+    Returns
+    -------
+
+    """
     # GH#33757 off.name with n != 1 should not raise AttributeError
     obj = month_classes(1)
     obj2 = month_classes(2)
@@ -4347,6 +5292,17 @@
 
 @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
 def test_valid_relativedelta_kwargs(kwd):
+    """
+
+    Parameters
+    ----------
+    kwd :
+        
+
+    Returns
+    -------
+
+    """
     # Check that all the arguments specified in liboffsets._relativedelta_kwds
     # are in fact valid relativedelta keyword args
     DateOffset(**{kwd: 1})
@@ -4354,6 +5310,19 @@
 
 @pytest.mark.parametrize("kwd", sorted(liboffsets._relativedelta_kwds))
 def test_valid_tick_attributes(kwd, tick_classes):
+    """
+
+    Parameters
+    ----------
+    kwd :
+        
+    tick_classes :
+        
+
+    Returns
+    -------
+
+    """
     # GH#18226
     cls = tick_classes
     # check that we cannot create e.g. Hour(weeks=3)
@@ -4362,6 +5331,7 @@
 
 
 def test_validate_n_error():
+    """ """
     with pytest.raises(TypeError):
         DateOffset(n="Doh!")
 
@@ -4373,12 +5343,34 @@
 
 
 def test_require_integers(offset_types):
+    """
+
+    Parameters
+    ----------
+    offset_types :
+        
+
+    Returns
+    -------
+
+    """
     cls = offset_types
     with pytest.raises(ValueError):
         cls(n=1.5)
 
 
 def test_tick_normalize_raises(tick_classes):
+    """
+
+    Parameters
+    ----------
+    tick_classes :
+        
+
+    Returns
+    -------
+
+    """
     # check that trying to create a Tick object with normalize=True raises
     # GH#21427
     cls = tick_classes
@@ -4387,6 +5379,7 @@
 
 
 def test_weeks_onoffset():
+    """ """
     # GH#18510 Week with weekday = None, normalize = False should always
     # be is_on_offset
     offset = Week(n=2, weekday=None)
@@ -4404,6 +5397,7 @@
 
 
 def test_weekofmonth_onoffset():
+    """ """
     # GH#18864
     # Make sure that nanoseconds don't trip up is_on_offset (and with it apply)
     offset = WeekOfMonth(n=2, week=2, weekday=0)
@@ -4421,6 +5415,7 @@
 
 
 def test_last_week_of_month_on_offset():
+    """ """
     # GH#19036, GH#18977 _adjust_dst was incorrect for LastWeekOfMonth
     offset = LastWeekOfMonth(n=4, weekday=6)
     ts = Timestamp("1917-05-27 20:55:27.084284178+0200", tz="Europe/Warsaw")
@@ -4437,6 +5432,7 @@
 
 
 def test_week_add_invalid():
+    """ """
     # Week with weekday should raise TypeError and _not_ AttributeError
     #  when adding invalid offset
     offset = Week(weekday=1)
@@ -4449,6 +5445,17 @@
     "attribute", ["hours", "days", "weeks", "months", "years"],
 )
 def test_dateoffset_immutable(attribute):
+    """
+
+    Parameters
+    ----------
+    attribute :
+        
+
+    Returns
+    -------
+
+    """
     offset = DateOffset(**{attribute: 0})
     msg = "DateOffset objects are immutable"
     with pytest.raises(AttributeError, match=msg):
