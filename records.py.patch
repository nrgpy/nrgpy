# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/records.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/records.py
@@ -86,7 +86,17 @@
 
 
 def find_duplicate(list):
-    """Find duplication in a list, return a list of duplicated elements"""
+    """Find duplication in a list, return a list of duplicated elements
+
+    Parameters
+    ----------
+    list :
+        
+
+    Returns
+    -------
+
+    """
     return [
         item
         for item, counts in _OrderedCounter(list).items()
@@ -96,17 +106,11 @@
 
 @set_module('numpy')
 class format_parser:
-    """
-    Class to convert formats, names, titles description to a dtype.
-
+    """Class to convert formats, names, titles description to a dtype.
+    
     After constructing the format_parser object, the dtype attribute is
     the converted data-type:
     ``dtype = format_parser(formats, names, titles).dtype``
-
-    Attributes
-    ----------
-    dtype : dtype
-        The converted data-type.
 
     Parameters
     ----------
@@ -132,26 +136,31 @@
         provided byte-order.  Otherwise, the default byte-order is
         used. For all available string specifiers, see `dtype.newbyteorder`.
 
+    Returns
+    -------
+
+    Attributes
+    ----------
+    dtype : dtype
+        The converted data-type.
     See Also
     --------
     dtype, typename, sctype2char
-
     Examples
     --------
+    
+    `names` and/or `titles` can be empty lists. If `titles` is an empty list,
+    titles will simply not appear. If `names` is empty, default field names
+    will be used.
     >>> np.format_parser(['<f8', '<i4', '<a5'], ['col1', 'col2', 'col3'],
     ...                  ['T1', 'T2', 'T3']).dtype
     dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'), (('T3', 'col3'), 'S5')])
-
-    `names` and/or `titles` can be empty lists. If `titles` is an empty list,
-    titles will simply not appear. If `names` is empty, default field names
-    will be used.
-
+    
     >>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
     ...                  []).dtype
     dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])
     >>> np.format_parser(['<f8', '<i4', '<a5'], [], []).dtype
     dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])
-
     """
 
     def __init__(self, formats, names, titles, aligned=False, byteorder=None):
@@ -160,7 +169,19 @@
         self._createdtype(byteorder)
 
     def _parseFormats(self, formats, aligned=False):
-        """ Parse the field formats """
+        """Parse the field formats
+
+        Parameters
+        ----------
+        formats :
+            
+        aligned :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
 
         if formats is None:
             raise ValueError("Need formats argument")
@@ -182,7 +203,19 @@
 
     def _setfieldnames(self, names, titles):
         """convert input field names into a list and assign to the _names
-        attribute """
+        attribute
+
+        Parameters
+        ----------
+        names :
+            
+        titles :
+            
+
+        Returns
+        -------
+
+        """
 
         if names:
             if type(names) in [list, tuple]:
@@ -217,6 +250,17 @@
             self._titles += [None] * (self._nfields - len(titles))
 
     def _createdtype(self, byteorder):
+        """
+
+        Parameters
+        ----------
+        byteorder :
+            
+
+        Returns
+        -------
+
+        """
         dtype = sb.dtype({
             'names': self._names,
             'formats': self._f_formats,
@@ -231,8 +275,7 @@
 
 
 class record(nt.void):
-    """A data-type scalar that allows field access as attribute lookup.
-    """
+    """A data-type scalar that allows field access as attribute lookup."""
 
     # manually set name and module so that this class's type shows up
     # as numpy.record when printed
@@ -317,7 +360,7 @@
 
 class recarray(ndarray):
     """Construct an ndarray that allows field access using attributes.
-
+    
     Arrays may have a data-types containing fields, analogous
     to columns in a spread sheet.  An example is ``[(x, int), (y, float)]``,
     where each entry in the array is a pair of ``(int, float)``.  Normally,
@@ -347,6 +390,11 @@
         the array will use the memory from the existing buffer.  In this case,
         the `offset` and `strides` keywords are available.
 
+    Returns
+    -------
+    rec : recarray
+        Empty array of the given shape and type.
+
     Other Parameters
     ----------------
     titles : tuple of str, optional
@@ -366,58 +414,53 @@
         Start reading buffer (`buf`) from this offset onwards.
     order : {'C', 'F'}, optional
         Row-major (C-style) or column-major (Fortran-style) order.
-
-    Returns
-    -------
-    rec : recarray
-        Empty array of the given shape and type.
-
     See Also
     --------
     rec.fromrecords : Construct a record array from data.
     record : fundamental data-type for `recarray`.
     format_parser : determine a data-type from formats, names, titles.
-
     Notes
     -----
     This constructor can be compared to ``empty``: it creates a new record
     array but does not fill it with data.  To create a record array from data,
     use one of the following methods:
-
+    
     1. Create a standard ndarray and convert it to a record array,
        using ``arr.view(np.recarray)``
     2. Use the `buf` keyword.
     3. Use `np.rec.fromrecords`.
-
     Examples
     --------
     Create an array with two fields, ``x`` and ``y``:
-
+    
+    
+    
+    View the array as a record array:
+    
+    
+    
+    
+    Create a new, empty record array:
     >>> x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '<f8'), ('y', '<i8')])
     >>> x
     array([(1., 2), (3., 4)], dtype=[('x', '<f8'), ('y', '<i8')])
-
+    
     >>> x['x']
     array([1., 3.])
-
-    View the array as a record array:
-
+    
     >>> x = x.view(np.recarray)
-
+    
     >>> x.x
     array([1., 3.])
-
+    
     >>> x.y
     array([2, 4])
-
-    Create a new, empty record array:
-
+    
     >>> np.recarray((2,),
     ... dtype=[('x', int), ('y', float), ('z', int)]) #doctest: +SKIP
     rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),
            (3471280, 1.2134086255804012e-316, 0)],
           dtype=[('x', '<i4'), ('y', '<f8'), ('z', '<i4')])
-
     """
 
     # manually set name and module so that this class's type shows
@@ -564,6 +607,19 @@
         return fmt % (lst, lf, repr_dtype)
 
     def field(self, attr, val=None):
+        """
+
+        Parameters
+        ----------
+        attr :
+            
+        val :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if isinstance(attr, int):
             names = ndarray.__getattribute__(self, 'dtype').names
             attr = names[attr]
@@ -582,6 +638,17 @@
 
 
 def _deprecate_shape_0_as_None(shape):
+    """
+
+    Parameters
+    ----------
+    shape :
+        
+
+    Returns
+    -------
+
+    """
     if shape == 0:
         warnings.warn(
             "Passing `shape=0` to have the shape be inferred is deprecated, "
@@ -603,14 +670,24 @@
         List of array-like objects (such as lists, tuples,
         and ndarrays).
     dtype : data-type, optional
-        valid dtype for all arrays
+        valid dtype for all arrays (Default value = None)
     shape : int or tuple of ints, optional
         Shape of the resulting array. If not provided, inferred from
-        ``arrayList[0]``.
+        ``arrayList[0]``. (Default value = None)
     formats, names, titles, aligned, byteorder :
         If `dtype` is ``None``, these arguments are passed to
         `numpy.format_parser` to construct a dtype. See that function for
         detailed documentation.
+    formats :
+         (Default value = None)
+    names :
+         (Default value = None)
+    titles :
+         (Default value = None)
+    aligned :
+         (Default value = False)
+    byteorder :
+         (Default value = None)
 
     Returns
     -------
@@ -696,17 +773,26 @@
         data in the same field may be heterogeneous - they will be promoted
         to the highest data type.
     dtype : data-type, optional
-        valid dtype for all arrays
+        valid dtype for all arrays (Default value = None)
     shape : int or tuple of ints, optional
-        shape of each array.
+        shape of each array. (Default value = None)
     formats, names, titles, aligned, byteorder :
         If `dtype` is ``None``, these arguments are passed to
         `numpy.format_parser` to construct a dtype. See that function for
         detailed documentation.
-
         If both `formats` and `dtype` are None, then this will auto-detect
         formats. Use list of tuples rather than list of lists for faster
         processing.
+    formats :
+         (Default value = None)
+    names :
+         (Default value = None)
+    titles :
+         (Default value = None)
+    aligned :
+         (Default value = False)
+    byteorder :
+         (Default value = None)
 
     Returns
     -------
@@ -772,8 +858,8 @@
 
 def fromstring(datastring, dtype=None, shape=None, offset=0, formats=None,
                names=None, titles=None, aligned=False, byteorder=None):
-    r"""Create a record array from binary data
-
+    """r"""Create a record array from binary data
+    
     Note that despite the name of this function it does not accept `str`
     instances.
 
@@ -782,16 +868,25 @@
     datastring : bytes-like
         Buffer of binary data
     dtype : data-type, optional
-        Valid dtype for all arrays
+        Valid dtype for all arrays (Default value = None)
     shape : int or tuple of ints, optional
-        Shape of each array.
+        Shape of each array. (Default value = None)
     offset : int, optional
-        Position in the buffer to start reading from.
+        Position in the buffer to start reading from. (Default value = 0)
     formats, names, titles, aligned, byteorder :
         If `dtype` is ``None``, these arguments are passed to
         `numpy.format_parser` to construct a dtype. See that function for
         detailed documentation.
-
+    formats :
+         (Default value = None)
+    names :
+         (Default value = None)
+    titles :
+         (Default value = None)
+    aligned :
+         (Default value = False)
+    byteorder :
+         (Default value = None)
 
     Returns
     -------
@@ -802,14 +897,13 @@
     See Also
     --------
     numpy.frombuffer
-
     Examples
     --------
     >>> a = b'\x01\x02\x03abc'
     >>> np.core.records.fromstring(a, dtype='u1,u1,u1,S3')
     rec.array([(1, 2, 3, b'abc')],
             dtype=[('f0', 'u1'), ('f1', 'u1'), ('f2', 'u1'), ('f3', 'S3')])
-
+    
     >>> grades_dtype = [('Name', (np.str_, 10)), ('Marks', np.float64),
     ...                 ('GradeLevel', np.int32)]
     >>> grades_array = np.array([('Sam', 33.3, 3), ('Mike', 44.4, 5),
@@ -817,13 +911,12 @@
     >>> np.core.records.fromstring(grades_array.tobytes(), dtype=grades_dtype)
     rec.array([('Sam', 33.3, 3), ('Mike', 44.4, 5), ('Aadi', 66.6, 6)],
             dtype=[('Name', '<U10'), ('Marks', '<f8'), ('GradeLevel', '<i4')])
-
+    
     >>> s = '\x01\x02\x03abc'
     >>> np.core.records.fromstring(s, dtype='u1,u1,u1,S3')
     Traceback (most recent call last)
        ...
     TypeError: a bytes-like object is required, not 'str'
-    """
 
     if dtype is None and formats is None:
         raise TypeError("fromstring() needs a 'dtype' or 'formats' argument")
@@ -845,6 +938,17 @@
     return _array
 
 def get_remaining_size(fd):
+    """
+
+    Parameters
+    ----------
+    fd :
+        
+
+    Returns
+    -------
+
+    """
     try:
         fn = fd.fileno()
     except AttributeError:
@@ -864,15 +968,25 @@
         else it is assumed to be a file object. The file object must
         support random access (i.e. it must have tell and seek methods).
     dtype : data-type, optional
-        valid dtype for all arrays
+        valid dtype for all arrays (Default value = None)
     shape : int or tuple of ints, optional
-        shape of each array.
+        shape of each array. (Default value = None)
     offset : int, optional
-        Position in the file to start reading from.
+        Position in the file to start reading from. (Default value = 0)
     formats, names, titles, aligned, byteorder :
         If `dtype` is ``None``, these arguments are passed to
         `numpy.format_parser` to construct a dtype. See that function for
         detailed documentation
+    formats :
+         (Default value = None)
+    names :
+         (Default value = None)
+    titles :
+         (Default value = None)
+    aligned :
+         (Default value = False)
+    byteorder :
+         (Default value = None)
 
     Returns
     -------
@@ -953,6 +1067,35 @@
 def array(obj, dtype=None, shape=None, offset=0, strides=None, formats=None,
           names=None, titles=None, aligned=False, byteorder=None, copy=True):
     """Construct a record array from a wide-variety of objects.
+
+    Parameters
+    ----------
+    obj :
+        
+    dtype :
+         (Default value = None)
+    shape :
+         (Default value = None)
+    offset :
+         (Default value = 0)
+    strides :
+         (Default value = None)
+    formats :
+         (Default value = None)
+    names :
+         (Default value = None)
+    titles :
+         (Default value = None)
+    aligned :
+         (Default value = False)
+    byteorder :
+         (Default value = None)
+    copy :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
 
     if ((isinstance(obj, (type(None), str)) or isfileobj(obj)) and
