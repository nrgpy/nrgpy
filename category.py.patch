# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexes/category.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexes/category.py
@@ -69,9 +69,8 @@
     overwrite=True,
 )
 class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
-    """
-    Index based on an underlying :class:`Categorical`.
-
+    """Index based on an underlying :class:`Categorical`.
+    
     CategoricalIndex, like Categorical, can only take on a limited,
     and usually fixed, number of possible values (`categories`). Also,
     like Categorical, it might have an order, but numerical operations
@@ -98,12 +97,22 @@
     name : object, optional
         Name to be stored in the index.
 
+    Returns
+    -------
+
+    Raises
+    ------
+    ValueError
+        If the categories do not validate.
+    TypeError
+        If an explicit ``ordered=True`` is given but no `categories` and the
+        `values` are not sortable.
+
     Attributes
     ----------
     codes
     categories
     ordered
-
     Methods
     -------
     rename_categories
@@ -115,42 +124,32 @@
     as_ordered
     as_unordered
     map
-
-    Raises
-    ------
-    ValueError
-        If the categories do not validate.
-    TypeError
-        If an explicit ``ordered=True`` is given but no `categories` and the
-        `values` are not sortable.
-
     See Also
     --------
     Index : The base pandas Index type.
     Categorical : A categorical array.
     CategoricalDtype : Type for categorical data.
-
     Notes
     -----
     See the `user guide
     <https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#categoricalindex>`_
     for more.
-
     Examples
     --------
+    
+    ``CategoricalIndex`` can also be instantiated from a ``Categorical``:
+    
+    
+    Ordered ``CategoricalIndex`` can have a min and max value.
     >>> pd.CategoricalIndex(["a", "b", "c", "a", "b", "c"])
     CategoricalIndex(['a', 'b', 'c', 'a', 'b', 'c'],
                      categories=['a', 'b', 'c'], ordered=False, dtype='category')
-
-    ``CategoricalIndex`` can also be instantiated from a ``Categorical``:
-
+    
     >>> c = pd.Categorical(["a", "b", "c", "a", "b", "c"])
     >>> pd.CategoricalIndex(c)
     CategoricalIndex(['a', 'b', 'c', 'a', 'b', 'c'],
                      categories=['a', 'b', 'c'], ordered=False, dtype='category')
-
-    Ordered ``CategoricalIndex`` can have a min and max value.
-
+    
     >>> ci = pd.CategoricalIndex(
     ...     ["a", "b", "c", "a", "b", "c"], ordered=True, categories=["c", "b", "a"]
     ... )
@@ -169,6 +168,7 @@
 
     @property
     def _engine_type(self):
+        """ """
         # self.codes can have dtype int8, int16, int32 or int64, so we need
         # to return the corresponding engine type (libindex.Int8Engine, etc.).
         return {
@@ -213,20 +213,23 @@
         return cls._simple_new(data, name=name)
 
     def _create_from_codes(self, codes, dtype=None, name=None):
-        """
-        *this is an internal non-public method*
-
+        """*this is an internal non-public method*
+        
         create the correct categorical from codes
 
         Parameters
         ----------
         codes : new codes
-        dtype: CategoricalDtype, defaults to existing
+            
+        dtype : CategoricalDtype, defaults to existing
+             (Default value = None)
         name : optional name attribute, defaults to existing
-
-        Returns
-        -------
-        CategoricalIndex
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if dtype is None:
             dtype = self.dtype
@@ -237,6 +240,19 @@
 
     @classmethod
     def _simple_new(cls, values: Categorical, name: Label = None):
+        """
+
+        Parameters
+        ----------
+        values: Categorical :
+            
+        name: Label :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         assert isinstance(values, Categorical), type(values)
         result = object.__new__(cls)
 
@@ -252,6 +268,19 @@
 
     @doc(Index._shallow_copy)
     def _shallow_copy(self, values=None, name: Label = no_default):
+        """
+
+        Parameters
+        ----------
+        values :
+             (Default value = None)
+        name: Label :
+             (Default value = no_default)
+
+        Returns
+        -------
+
+        """
         name = self.name if name is no_default else name
 
         if values is not None:
@@ -260,15 +289,20 @@
         return super()._shallow_copy(values=values, name=name)
 
     def _is_dtype_compat(self, other) -> bool:
-        """
-        *this is an internal non-public method*
-
+        """*this is an internal non-public method*
+        
         provide a comparison between the dtype of self and other (coercing if
         needed)
 
-        Raises
-        ------
-        TypeError if the dtypes are not compatible
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        
         """
         if is_categorical_dtype(other):
             if isinstance(other, CategoricalIndex):
@@ -291,14 +325,17 @@
         return other
 
     def equals(self, other) -> bool:
-        """
-        Determine if two CategoricalIndex objects contain the same elements.
-
-        Returns
-        -------
-        bool
-            If two CategoricalIndex objects have equal elements True,
-            otherwise False.
+        """Determine if two CategoricalIndex objects contain the same elements.
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        
         """
         if self.is_(other):
             return True
@@ -321,12 +358,11 @@
 
     @property
     def _formatter_func(self):
+        """ """
         return self.categories._formatter_func
 
     def _format_attrs(self):
-        """
-        Return a list of tuples of the (attr,formatted_value)
-        """
+        """ """
         max_categories = (
             10
             if get_option("display.max_categories") == 0
@@ -348,6 +384,19 @@
         return attrs
 
     def _format_with_header(self, header: List[str], na_rep: str = "NaN") -> List[str]:
+        """
+
+        Parameters
+        ----------
+        header: List[str] :
+            
+        na_rep: str :
+             (Default value = "NaN")
+
+        Returns
+        -------
+
+        """
         from pandas.io.formats.printing import pprint_thing
 
         result = [
@@ -360,15 +409,17 @@
 
     @property
     def inferred_type(self) -> str:
+        """ """
         return "categorical"
 
     @property
     def values(self):
-        """ return the underlying data, which is a Categorical """
+        """ """
         return self._data
 
     @property
     def _has_complex_internals(self) -> bool:
+        """ """
         # used to avoid libreduction code paths, which raise or require conversion
         return True
 
@@ -382,6 +433,19 @@
 
     @doc(Index.astype)
     def astype(self, dtype, copy=True):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if dtype is not None:
             dtype = pandas_dtype(dtype)
 
@@ -399,16 +463,30 @@
 
     @cache_readonly
     def _isnan(self):
-        """ return if each value is nan"""
+        """ """
         return self._data.codes == -1
 
     @doc(Index.fillna)
     def fillna(self, value, downcast=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        downcast :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self._assert_can_do_op(value)
         return CategoricalIndex(self._data.fillna(value), name=self.name)
 
     @cache_readonly
     def _engine(self):
+        """ """
         # we are going to look things up with the codes themselves.
         # To avoid a reference cycle, bind `codes` to a local variable, so
         # `self` is not passed into the lambda.
@@ -417,6 +495,17 @@
 
     @doc(Index.unique)
     def unique(self, level=None):
+        """
+
+        Parameters
+        ----------
+        level :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if level is not None:
             self._validate_index_level(level)
         result = self._values.unique()
@@ -426,20 +515,55 @@
 
     @doc(Index.duplicated)
     def duplicated(self, keep="first"):
+        """
+
+        Parameters
+        ----------
+        keep :
+             (Default value = "first")
+
+        Returns
+        -------
+
+        """
         codes = self.codes.astype("i8")
         return duplicated_int64(codes, keep)
 
     def _to_safe_for_reshape(self):
-        """ convert to object if we are a categorical """
+        """convert to object if we are a categorical"""
         return self.astype("object")
 
     def _maybe_cast_indexer(self, key):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        """
         code = self.categories.get_loc(key)
         code = self.codes.dtype.type(code)
         return code
 
     @doc(Index.where)
     def where(self, cond, other=None):
+        """
+
+        Parameters
+        ----------
+        cond :
+            
+        other :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # TODO: Investigate an alternative implementation with
         # 1. copy the underlying Categorical
         # 2. setitem with `cond` and `other`
@@ -451,16 +575,25 @@
         return type(self)._simple_new(cat, name=self.name)
 
     def reindex(self, target, method=None, level=None, limit=None, tolerance=None):
-        """
-        Create index with target's values (move/add/delete values as necessary)
-
-        Returns
-        -------
-        new_index : pd.Index
-            Resulting index
-        indexer : np.ndarray or None
-            Indices of output values in original index
-
+        """Create index with target's values (move/add/delete values as necessary)
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        level :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         if method is not None:
             raise NotImplementedError(
@@ -517,9 +650,17 @@
         return new_target, indexer
 
     def _reindex_non_unique(self, target):
-        """
-        reindex from a non-unique; which CategoricalIndex's are almost
+        """reindex from a non-unique; which CategoricalIndex's are almost
         always
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
         """
         new_target, indexer = self.reindex(target)
         new_indexer = None
@@ -539,6 +680,23 @@
 
     @Appender(_index_shared_docs["get_indexer"] % _index_doc_kwargs)
     def get_indexer(self, target, method=None, limit=None, tolerance=None):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        tolerance :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         method = missing.clean_reindex_fill_method(method)
         target = ibase.ensure_index(target)
 
@@ -575,6 +733,17 @@
 
     @Appender(_index_shared_docs["get_indexer_non_unique"] % _index_doc_kwargs)
     def get_indexer_non_unique(self, target):
+        """
+
+        Parameters
+        ----------
+        target :
+            
+
+        Returns
+        -------
+
+        """
         target = ibase.ensure_index(target)
 
         if isinstance(target, CategoricalIndex):
@@ -591,6 +760,17 @@
 
     @doc(Index._convert_list_indexer)
     def _convert_list_indexer(self, keyarr):
+        """
+
+        Parameters
+        ----------
+        keyarr :
+            
+
+        Returns
+        -------
+
+        """
         # Return our indexer or raise if all of the values are not included in
         # the categories
 
@@ -608,6 +788,17 @@
 
     @doc(Index._convert_arr_indexer)
     def _convert_arr_indexer(self, keyarr):
+        """
+
+        Parameters
+        ----------
+        keyarr :
+            
+
+        Returns
+        -------
+
+        """
         keyarr = com.asarray_tuplesafe(keyarr)
 
         if self.categories._defer_to_indexing:
@@ -617,10 +808,33 @@
 
     @doc(Index._convert_index_indexer)
     def _convert_index_indexer(self, keyarr):
+        """
+
+        Parameters
+        ----------
+        keyarr :
+            
+
+        Returns
+        -------
+
+        """
         return self._shallow_copy(keyarr)
 
     def take_nd(self, *args, **kwargs):
-        """Alias for `take`"""
+        """Alias for `take`
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         warnings.warn(
             "CategoricalIndex.take_nd is deprecated, use CategoricalIndex.take instead",
             FutureWarning,
@@ -630,20 +844,34 @@
 
     @doc(Index._maybe_cast_slice_bound)
     def _maybe_cast_slice_bound(self, label, side, kind):
+        """
+
+        Parameters
+        ----------
+        label :
+            
+        side :
+            
+        kind :
+            
+
+        Returns
+        -------
+
+        """
         if kind == "loc":
             return label
 
         return super()._maybe_cast_slice_bound(label, side, kind)
 
     def map(self, mapper):
-        """
-        Map values using input correspondence (a dict, Series, or function).
-
+        """Map values using input correspondence (a dict, Series, or function).
+        
         Maps the values (their categories, not the codes) of the index to new
         categories. If the mapping correspondence is one-to-one the result is a
         :class:`~pandas.CategoricalIndex` which has the same order property as
         the original, otherwise an :class:`~pandas.Index` is returned.
-
+        
         If a `dict` or :class:`~pandas.Series` is used any unmapped category is
         mapped to `NaN`. Note that if this happens an :class:`~pandas.Index`
         will be returned.
@@ -666,9 +894,18 @@
             :class:`~pandas.Series`.
         Series.apply : Apply more complex functions on a
             :class:`~pandas.Series`.
-
         Examples
         --------
+        
+        If the mapping is one-to-one the ordering of the categories is
+        preserved:
+        
+        
+        If the mapping is not one-to-one an :class:`~pandas.Index` is returned:
+        
+        
+        If a `dict` is used, all unmapped categories are mapped to `NaN` and
+        the result is an :class:`~pandas.Index`:
         >>> idx = pd.CategoricalIndex(['a', 'b', 'c'])
         >>> idx
         CategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],
@@ -679,10 +916,7 @@
         >>> idx.map({'a': 'first', 'b': 'second', 'c': 'third'})
         CategoricalIndex(['first', 'second', 'third'], categories=['first',
                          'second', 'third'], ordered=False, dtype='category')
-
-        If the mapping is one-to-one the ordering of the categories is
-        preserved:
-
+        
         >>> idx = pd.CategoricalIndex(['a', 'b', 'c'], ordered=True)
         >>> idx
         CategoricalIndex(['a', 'b', 'c'], categories=['a', 'b', 'c'],
@@ -690,15 +924,10 @@
         >>> idx.map({'a': 3, 'b': 2, 'c': 1})
         CategoricalIndex([3, 2, 1], categories=[3, 2, 1], ordered=True,
                          dtype='category')
-
-        If the mapping is not one-to-one an :class:`~pandas.Index` is returned:
-
+        
         >>> idx.map({'a': 'first', 'b': 'second', 'c': 'first'})
         Index(['first', 'second', 'first'], dtype='object')
-
-        If a `dict` is used, all unmapped categories are mapped to `NaN` and
-        the result is an :class:`~pandas.Index`:
-
+        
         >>> idx.map({'a': 'first', 'b': 'second'})
         Index(['first', 'second', nan], dtype='object')
         """
@@ -706,33 +935,39 @@
         return Index(mapped, name=self.name)
 
     def delete(self, loc):
-        """
-        Make new Index with passed location(-s) deleted
+        """Make new Index with passed location(-s) deleted
+
+        Parameters
+        ----------
+        loc :
+            
+
+        Returns
+        -------
+
+        
+        """
+        return self._create_from_codes(np.delete(self.codes, loc))
+
+    def insert(self, loc: int, item):
+        """Make new Index inserting new item at location. Follows
+        Python list.append semantics for negative values
+
+        Parameters
+        ----------
+        loc : int
+            
+        item : object
+            
+        loc: int :
+            
 
         Returns
         -------
         new_index : Index
-        """
-        return self._create_from_codes(np.delete(self.codes, loc))
-
-    def insert(self, loc: int, item):
-        """
-        Make new Index inserting new item at location. Follows
-        Python list.append semantics for negative values
-
-        Parameters
-        ----------
-        loc : int
-        item : object
-
-        Returns
-        -------
-        new_index : Index
-
-        Raises
-        ------
-        ValueError if the item is not in the categories
-
+            
+
+        
         """
         code = self.categories.get_indexer([item])
         if (code == -1) and not (is_scalar(item) and isna(item)):
@@ -746,6 +981,19 @@
         return self._create_from_codes(codes)
 
     def _concat(self, to_concat, name):
+        """
+
+        Parameters
+        ----------
+        to_concat :
+            
+        name :
+            
+
+        Returns
+        -------
+
+        """
         # if calling index is category, don't check dtype of others
         codes = np.concatenate([self._is_dtype_compat(c).codes for c in to_concat])
         result = self._create_from_codes(codes, name=name)
@@ -754,7 +1002,21 @@
         return result
 
     def _delegate_method(self, name: str, *args, **kwargs):
-        """ method delegation to the ._values """
+        """method delegation to the ._values
+
+        Parameters
+        ----------
+        name: str :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         method = getattr(self._values, name)
         if "inplace" in kwargs:
             raise ValueError("cannot use inplace with CategoricalIndex")
@@ -766,6 +1028,19 @@
     def _wrap_joined_index(
         self, joined: np.ndarray, other: "CategoricalIndex"
     ) -> "CategoricalIndex":
+        """
+
+        Parameters
+        ----------
+        joined: np.ndarray :
+            
+        other: "CategoricalIndex" :
+            
+
+        Returns
+        -------
+
+        """
         name = get_op_result_name(self, other)
         return self._create_from_codes(joined, name=name)
 
