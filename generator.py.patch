# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/parso/pgen2/generator.py
+++ b/..//venv/lib/python3.8/site-packages/parso/pgen2/generator.py
@@ -32,13 +32,19 @@
 
 
 class Grammar(object):
-    """
-    Once initialized, this class supplies the grammar tables for the
+    """Once initialized, this class supplies the grammar tables for the
     parsing engine implemented by parse.py.  The parsing engine
     accesses the instance variables directly.
-
+    
     The only important part in this parsers are dfas and transitions between
     dfas.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, start_nonterminal, rule_to_dfas, reserved_syntax_strings):
@@ -48,9 +54,15 @@
 
 
 class DFAPlan(object):
-    """
-    Plans are used for the parser to create stack nodes and do the proper
+    """Plans are used for the parser to create stack nodes and do the proper
     DFA state transitions.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, next_dfa, dfa_pushes=[]):
         self.next_dfa = next_dfa
@@ -61,14 +73,20 @@
 
 
 class DFAState(object):
-    """
-    The DFAState object is the core class for pretty much anything. DFAState
+    """The DFAState object is the core class for pretty much anything. DFAState
     are the vertices of an ordered graph while arcs and transitions are the
     edges.
-
+    
     Arcs are the initial edges, where most DFAStates are not connected and
     transitions are then calculated to connect the DFA state machines that have
     different nonterminals.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, from_rule, nfa_set, final):
         assert isinstance(nfa_set, set)
@@ -87,12 +105,38 @@
         self.is_final = final in nfa_set
 
     def add_arc(self, next_, label):
+        """
+
+        Parameters
+        ----------
+        next_ :
+            
+        label :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(label, str)
         assert label not in self.arcs
         assert isinstance(next_, DFAState)
         self.arcs[label] = next_
 
     def unifystate(self, old, new):
+        """
+
+        Parameters
+        ----------
+        old :
+            
+        new :
+            
+
+        Returns
+        -------
+
+        """
         for label, next_ in self.arcs.items():
             if next_ is old:
                 self.arcs[label] = new
@@ -120,10 +164,16 @@
 
 
 class ReservedString(object):
-    """
-    Most grammars will have certain keywords and operators that are mentioned
+    """Most grammars will have certain keywords and operators that are mentioned
     in the grammar as strings (e.g. "if") and not token types (e.g. NUMBER).
     This class basically is the former.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, value):
@@ -134,13 +184,21 @@
 
 
 def _simplify_dfas(dfas):
-    """
-    This is not theoretically optimal, but works well enough.
+    """This is not theoretically optimal, but works well enough.
     Algorithm: repeatedly look for two states that have the same
     set of arcs (same labels pointing to the same nodes) and
     unify them, until things stop changing.
-
+    
     dfas is a list of DFAState instances
+
+    Parameters
+    ----------
+    dfas :
+        
+
+    Returns
+    -------
+
     """
     changes = True
     while changes:
@@ -158,11 +216,21 @@
 
 
 def _make_dfas(start, finish):
-    """
-    Uses the powerset construction algorithm to create DFA states from sets of
+    """Uses the powerset construction algorithm to create DFA states from sets of
     NFA states.
-
+    
     Also does state reduction if some states are not needed.
+
+    Parameters
+    ----------
+    start :
+        
+    finish :
+        
+
+    Returns
+    -------
+
     """
     # To turn an NFA into a DFA, we define the states of the DFA
     # to correspond to *sets* of states of the NFA.  Then do some
@@ -171,6 +239,19 @@
     assert isinstance(finish, NFAState)
 
     def addclosure(nfa_state, base_nfa_set):
+        """
+
+        Parameters
+        ----------
+        nfa_state :
+            
+        base_nfa_set :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(nfa_state, NFAState)
         if nfa_state in base_nfa_set:
             return
@@ -208,6 +289,19 @@
 
 
 def _dump_nfa(start, finish):
+    """
+
+    Parameters
+    ----------
+    start :
+        
+    finish :
+        
+
+    Returns
+    -------
+
+    """
     print("Dump of NFA for", start.from_rule)
     todo = [start]
     for i, state in enumerate(todo):
@@ -226,6 +320,17 @@
 
 
 def _dump_dfas(dfas):
+    """
+
+    Parameters
+    ----------
+    dfas :
+        
+
+    Returns
+    -------
+
+    """
     print("Dump of DFA for", dfas[0].from_rule)
     for i, state in enumerate(dfas):
         print("  State", i, state.is_final and "(final)" or "")
@@ -234,13 +339,23 @@
 
 
 def generate_grammar(bnf_grammar, token_namespace):
-    """
-    ``bnf_text`` is a grammar in extended BNF (using * for repetition, + for
+    """``bnf_text`` is a grammar in extended BNF (using * for repetition, + for
     at-least-once repetition, [] for optional parts, | for alternatives and ()
     for grouping).
-
+    
     It's not EBNF according to ISO/IEC 14977. It's a dialect Python uses in its
     own parser.
+
+    Parameters
+    ----------
+    bnf_grammar :
+        
+    token_namespace :
+        
+
+    Returns
+    -------
+
     """
     rule_to_dfas = {}
     start_nonterminal = None
@@ -276,9 +391,21 @@
 
 
 def _make_transition(token_namespace, reserved_syntax_strings, label):
-    """
-    Creates a reserved string ("if", "for", "*", ...) or returns the token type
+    """Creates a reserved string ("if", "for", "*", ...) or returns the token type
     (NUMBER, STRING, ...) for a given grammar terminal.
+
+    Parameters
+    ----------
+    token_namespace :
+        
+    reserved_syntax_strings :
+        
+    label :
+        
+
+    Returns
+    -------
+
     """
     if label[0].isalpha():
         # A named token (e.g. NAME, NUMBER, STRING)
@@ -296,9 +423,17 @@
 
 
 def _calculate_tree_traversal(nonterminal_to_dfas):
-    """
-    By this point we know how dfas can move around within a stack node, but we
+    """By this point we know how dfas can move around within a stack node, but we
     don't know how we can add a new stack node (nonterminal transitions).
+
+    Parameters
+    ----------
+    nonterminal_to_dfas :
+        
+
+    Returns
+    -------
+
     """
     # Map from grammar rule (nonterminal) name to a set of tokens.
     first_plans = {}
@@ -346,9 +481,21 @@
 
 
 def _calculate_first_plans(nonterminal_to_dfas, first_plans, nonterminal):
-    """
-    Calculates the first plan in the first_plans dictionary for every given
+    """Calculates the first plan in the first_plans dictionary for every given
     nonterminal. This is going to be used to know when to create stack nodes.
+
+    Parameters
+    ----------
+    nonterminal_to_dfas :
+        
+    first_plans :
+        
+    nonterminal :
+        
+
+    Returns
+    -------
+
     """
     dfas = nonterminal_to_dfas[nonterminal]
     new_first_plans = {}
