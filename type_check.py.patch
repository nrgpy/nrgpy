# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/type_check.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/type_check.py
@@ -25,10 +25,9 @@
 
 @set_module('numpy')
 def mintypecode(typechars, typeset='GDFgdf', default='d'):
-    """
-    Return the character for the minimum-size type to which given types can
+    """Return the character for the minimum-size type to which given types can
     be safely cast.
-
+    
     The returned type character must represent the smallest size dtype such
     that an array of the returned type can handle the data from an array of
     all types in `typechars` (or if `typechars` is an array, then its
@@ -54,7 +53,6 @@
     See Also
     --------
     dtype, sctype2char, maximum_sctype
-
     Examples
     --------
     >>> np.mintypecode(['d', 'f', 'S'])
@@ -62,10 +60,9 @@
     >>> x = np.array([1.1, 2-3.j])
     >>> np.mintypecode(x)
     'D'
-
+    
     >>> np.mintypecode('abceh', default='G')
     'G'
-
     """
     typecodes = ((isinstance(t, str) and t) or asarray(t).dtype.char
                  for t in typechars)
@@ -78,13 +75,25 @@
 
 
 def _asfarray_dispatcher(a, dtype=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    dtype :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_asfarray_dispatcher)
 def asfarray(a, dtype=_nx.float_):
-    """
-    Return an array converted to a float type.
+    """Return an array converted to a float type.
 
     Parameters
     ----------
@@ -92,7 +101,7 @@
         The input array.
     dtype : str or dtype object, optional
         Float type code to coerce input array `a`.  If `dtype` is one of the
-        'int' dtypes, it is replaced with float64.
+        'int' dtypes, it is replaced with float64. (Default value = _nx.float_)
 
     Returns
     -------
@@ -107,7 +116,6 @@
     array([2.,  3.])
     >>> np.asfarray([2, 3], dtype='int8')
     array([2.,  3.])
-
     """
     if not _nx.issubdtype(dtype, _nx.inexact):
         dtype = _nx.float_
@@ -115,13 +123,23 @@
 
 
 def _real_dispatcher(val):
+    """
+
+    Parameters
+    ----------
+    val :
+        
+
+    Returns
+    -------
+
+    """
     return (val,)
 
 
 @array_function_dispatch(_real_dispatcher)
 def real(val):
-    """
-    Return the real part of the complex argument.
+    """Return the real part of the complex argument.
 
     Parameters
     ----------
@@ -138,7 +156,6 @@
     See Also
     --------
     real_if_close, imag, angle
-
     Examples
     --------
     >>> a = np.array([1+2j, 3+4j, 5+6j])
@@ -152,7 +169,6 @@
     array([9.+2.j,  8.+4.j,  7.+6.j])
     >>> np.real(1 + 1j)
     1.0
-
     """
     try:
         return val.real
@@ -161,13 +177,23 @@
 
 
 def _imag_dispatcher(val):
+    """
+
+    Parameters
+    ----------
+    val :
+        
+
+    Returns
+    -------
+
+    """
     return (val,)
 
 
 @array_function_dispatch(_imag_dispatcher)
 def imag(val):
-    """
-    Return the imaginary part of the complex argument.
+    """Return the imaginary part of the complex argument.
 
     Parameters
     ----------
@@ -184,7 +210,6 @@
     See Also
     --------
     real, angle, real_if_close
-
     Examples
     --------
     >>> a = np.array([1+2j, 3+4j, 5+6j])
@@ -195,7 +220,6 @@
     array([1. +8.j,  3.+10.j,  5.+12.j])
     >>> np.imag(1 + 1j)
     1.0
-
     """
     try:
         return val.imag
@@ -204,14 +228,24 @@
 
 
 def _is_type_dispatcher(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     return (x,)
 
 
 @array_function_dispatch(_is_type_dispatcher)
 def iscomplex(x):
-    """
-    Returns a bool array, where True if input element is complex.
-
+    """Returns a bool array, where True if input element is complex.
+    
     What is tested is whether the input has a non-zero imaginary part, not if
     the input type is complex.
 
@@ -230,12 +264,10 @@
     isreal
     iscomplexobj : Return True if x is a complex type or an array of complex
                    numbers.
-
     Examples
     --------
     >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
     array([ True, False, False, False, False,  True])
-
     """
     ax = asanyarray(x)
     if issubclass(ax.dtype.type, _nx.complexfloating):
@@ -246,9 +278,8 @@
 
 @array_function_dispatch(_is_type_dispatcher)
 def isreal(x):
-    """
-    Returns a bool array, where True if input element is real.
-
+    """Returns a bool array, where True if input element is real.
+    
     If element has complex type with zero complex part, the return value
     for that element is True.
 
@@ -266,21 +297,18 @@
     --------
     iscomplex
     isrealobj : Return True if x is not a complex type.
-
     Examples
     --------
     >>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
     array([False,  True,  True,  True,  True, False])
-
     """
     return imag(x) == 0
 
 
 @array_function_dispatch(_is_type_dispatcher)
 def iscomplexobj(x):
-    """
-    Check for a complex type or an array of complex numbers.
-
+    """Check for a complex type or an array of complex numbers.
+    
     The type of the input is checked, not the value. Even if the input
     has an imaginary part equal to zero, `iscomplexobj` evaluates to True.
 
@@ -298,7 +326,6 @@
     See Also
     --------
     isrealobj, iscomplex
-
     Examples
     --------
     >>> np.iscomplexobj(1)
@@ -307,7 +334,6 @@
     True
     >>> np.iscomplexobj([3, 1+0j, True])
     True
-
     """
     try:
         dtype = x.dtype
@@ -319,9 +345,8 @@
 
 @array_function_dispatch(_is_type_dispatcher)
 def isrealobj(x):
-    """
-    Return True if x is a not complex type or an array of complex numbers.
-
+    """Return True if x is a not complex type or an array of complex numbers.
+    
     The type of the input is checked, not the value. So even if the input
     has an imaginary part equal to zero, `isrealobj` evaluates to False
     if the data type is complex.
@@ -339,7 +364,6 @@
     See Also
     --------
     iscomplexobj, isreal
-
     Examples
     --------
     >>> np.isrealobj(1)
@@ -348,39 +372,67 @@
     False
     >>> np.isrealobj([3, 1+0j, True])
     False
-
     """
     return not iscomplexobj(x)
 
 #-----------------------------------------------------------------------------
 
 def _getmaxmin(t):
+    """
+
+    Parameters
+    ----------
+    t :
+        
+
+    Returns
+    -------
+
+    """
     from numpy.core import getlimits
     f = getlimits.finfo(t)
     return f.max, f.min
 
 
 def _nan_to_num_dispatcher(x, copy=None, nan=None, posinf=None, neginf=None):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+    copy :
+         (Default value = None)
+    nan :
+         (Default value = None)
+    posinf :
+         (Default value = None)
+    neginf :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (x,)
 
 
 @array_function_dispatch(_nan_to_num_dispatcher)
 def nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None):
-    """
-    Replace NaN with zero and infinity with large finite numbers (default
-    behaviour) or with the numbers defined by the user using the `nan`, 
+    """Replace NaN with zero and infinity with large finite numbers (default
+    behaviour) or with the numbers defined by the user using the `nan`,
     `posinf` and/or `neginf` keywords.
-
+    
     If `x` is inexact, NaN is replaced by zero or by the user defined value in
-    `nan` keyword, infinity is replaced by the largest finite floating point 
-    values representable by ``x.dtype`` or by the user defined value in 
-    `posinf` keyword and -infinity is replaced by the most negative finite 
-    floating point values representable by ``x.dtype`` or by the user defined 
+    `nan` keyword, infinity is replaced by the largest finite floating point
+    values representable by ``x.dtype`` or by the user defined value in
+    `posinf` keyword and -infinity is replaced by the most negative finite
+    floating point values representable by ``x.dtype`` or by the user defined
     value in `neginf` keyword.
-
+    
     For complex dtypes, the above is applied to each of the real and
     imaginary components of `x` separately.
-
+    
     If `x` is not inexact, then no replacements are made.
 
     Parameters
@@ -392,27 +444,21 @@
         in-place (False). The in-place operation only occurs if
         casting to an array does not require a copy.
         Default is True.
-        
         .. versionadded:: 1.13
     nan : int, float, optional
-        Value to be used to fill NaN values. If no value is passed 
+        Value to be used to fill NaN values. If no value is passed
         then NaN values will be replaced with 0.0.
-        
-        .. versionadded:: 1.17
+        .. versionadded:: 1.17 (Default value = 0.0)
     posinf : int, float, optional
-        Value to be used to fill positive infinity values. If no value is 
+        Value to be used to fill positive infinity values. If no value is
         passed then positive infinity values will be replaced with a very
         large number.
-        
-        .. versionadded:: 1.17
+        .. versionadded:: 1.17 (Default value = None)
     neginf : int, float, optional
-        Value to be used to fill negative infinity values. If no value is 
+        Value to be used to fill negative infinity values. If no value is
         passed then negative infinity values will be replaced with a very
         small (or negative) number.
-        
-        .. versionadded:: 1.17
-
-        
+        .. versionadded:: 1.17 (Default value = None)
 
     Returns
     -------
@@ -427,12 +473,10 @@
     isposinf : Shows which elements are positive infinity.
     isnan : Shows which elements are Not a Number (NaN).
     isfinite : Shows which elements are finite (not NaN, not infinity)
-
     Notes
     -----
     NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
     (IEEE 754). This means that Not a Number is not equivalent to infinity.
-
     Examples
     --------
     >>> np.nan_to_num(np.inf)
@@ -446,7 +490,7 @@
     array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
            -1.28000000e+002,  1.28000000e+002])
     >>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
-    array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, 
+    array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,
            -1.2800000e+02,  1.2800000e+02])
     >>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
     array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
@@ -486,15 +530,27 @@
 #-----------------------------------------------------------------------------
 
 def _real_if_close_dispatcher(a, tol=None):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+    tol :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return (a,)
 
 
 @array_function_dispatch(_real_if_close_dispatcher)
 def real_if_close(a, tol=100):
-    """
-    If input is complex with all imaginary parts close to zero, return 
+    """If input is complex with all imaginary parts close to zero, return
     real parts.
-
+    
     "Close to zero" is defined as `tol` * (machine epsilon of the type for
     `a`).
 
@@ -504,7 +560,7 @@
         Input array.
     tol : float
         Tolerance in machine epsilons for the complex part of the elements
-        in the array.
+        in the array. (Default value = 100)
 
     Returns
     -------
@@ -515,24 +571,21 @@
     See Also
     --------
     real, imag, angle
-
     Notes
     -----
     Machine epsilon varies from machine to machine and between data types
     but Python floats on most platforms have a machine epsilon equal to
     2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print
     out the machine epsilon for floats.
-
     Examples
     --------
     >>> np.finfo(float).eps
     2.2204460492503131e-16 # may vary
-
+    
     >>> np.real_if_close([2.1 + 4e-14j, 5.2 + 3e-15j], tol=1000)
     array([2.1, 5.2])
     >>> np.real_if_close([2.1 + 4e-13j, 5.2 + 3e-15j], tol=1000)
     array([2.1+4.e-13j, 5.2 + 3e-15j])
-
     """
     a = asanyarray(a)
     if not issubclass(a.dtype.type, _nx.complexfloating):
@@ -547,6 +600,17 @@
 
 
 def _asscalar_dispatcher(a):
+    """
+
+    Parameters
+    ----------
+    a :
+        
+
+    Returns
+    -------
+
+    """
     # 2018-10-10, 1.16
     warnings.warn('np.asscalar(a) is deprecated since NumPy v1.16, use '
                   'a.item() instead', DeprecationWarning, stacklevel=3)
@@ -555,11 +619,10 @@
 
 @array_function_dispatch(_asscalar_dispatcher)
 def asscalar(a):
-    """
-    Convert an array of size 1 to its scalar equivalent.
-
+    """Convert an array of size 1 to its scalar equivalent.
+    
     .. deprecated:: 1.16
-
+    
         Deprecated, use `numpy.ndarray.item()` instead.
 
     Parameters
@@ -608,8 +671,7 @@
 
 @set_module('numpy')
 def typename(char):
-    """
-    Return a description for the given data type code.
+    """Return a description for the given data type code.
 
     Parameters
     ----------
@@ -624,7 +686,6 @@
     See Also
     --------
     dtype, typecodes
-
     Examples
     --------
     >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
@@ -654,7 +715,6 @@
     h  :  short
     l  :  long integer
     q  :  long long integer
-
     """
     return _namefromtype[char]
 
@@ -673,19 +733,29 @@
 
 
 def _common_type_dispatcher(*arrays):
+    """
+
+    Parameters
+    ----------
+    *arrays :
+        
+
+    Returns
+    -------
+
+    """
     return arrays
 
 
 @array_function_dispatch(_common_type_dispatcher)
 def common_type(*arrays):
-    """
-    Return a scalar type which is common to the input arrays.
-
+    """Return a scalar type which is common to the input arrays.
+    
     The return type will always be an inexact (i.e. floating point) scalar
     type, even if all the arrays are integer arrays. If one of the inputs is
     an integer array, the minimum precision type that is returned is a
     64-bit floating point dtype.
-
+    
     All input arrays except int64 and uint64 can be safely cast to the
     returned dtype without loss of information.
 
@@ -693,6 +763,8 @@
     ----------
     array1, array2, ... : ndarrays
         Input arrays.
+    *arrays :
+        
 
     Returns
     -------
@@ -702,7 +774,6 @@
     See Also
     --------
     dtype, mintypecode
-
     Examples
     --------
     >>> np.common_type(np.arange(2, dtype=np.float32))
@@ -711,7 +782,6 @@
     <class 'numpy.float64'>
     >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
     <class 'numpy.complex128'>
-
     """
     is_complex = False
     precision = 0
