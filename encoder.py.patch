# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/requests_toolbelt/multipart/encoder.py
+++ b/..//venv/lib/python3.8/site-packages/requests_toolbelt/multipart/encoder.py
@@ -23,54 +23,52 @@
 
 class MultipartEncoder(object):
 
-    """
-
-    The ``MultipartEncoder`` object is a generic interface to the engine that
+    """The ``MultipartEncoder`` object is a generic interface to the engine that
     will create a ``multipart/form-data`` body for you.
-
+    
     The basic usage is:
-
+    
     .. code-block:: python
-
+    
         import requests
         from requests_toolbelt import MultipartEncoder
-
+    
         encoder = MultipartEncoder({'field': 'value',
                                     'other_field', 'other_value'})
         r = requests.post('https://httpbin.org/post', data=encoder,
                           headers={'Content-Type': encoder.content_type})
-
+    
     If you do not need to take advantage of streaming the post body, you can
     also do:
-
+    
     .. code-block:: python
-
+    
         r = requests.post('https://httpbin.org/post',
                           data=encoder.to_string(),
                           headers={'Content-Type': encoder.content_type})
-
+    
     If you want the encoder to use a specific order, you can use an
     OrderedDict or more simply, a list of tuples:
-
+    
     .. code-block:: python
-
+    
         encoder = MultipartEncoder([('field', 'value'),
                                     ('other_field', 'other_value')])
-
+    
     .. versionchanged:: 0.4.0
-
+    
     You can also provide tuples as part values as you would provide them to
     requests' ``files`` parameter.
-
+    
     .. code-block:: python
-
+    
         encoder = MultipartEncoder({
             'field': ('file_name', b'{"a": "b"}', 'application/json',
                       {'X-My-Header': 'my-value'})
         ])
-
+    
     .. warning::
-
+    
         This object will end up directly in :mod:`httplib`. Currently,
         :mod:`httplib` has a hard-coded read size of **8192 bytes**. This
         means that it will loop until the file has been read and your upload
@@ -78,9 +76,15 @@
         being considered for this object to allow you, the user, to specify
         what size should be returned on a read. If you have opinions on this,
         please weigh in on `this issue`_.
-
+    
     .. _this issue:
         https://github.com/requests/toolbelt/issues/75
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -130,19 +134,26 @@
     @property
     def len(self):
         """Length of the multipart/form-data body.
-
+        
         requests will first attempt to get the length of the body by calling
         ``len(body)`` and then by checking for the ``len`` attribute.
-
+        
         On 32-bit systems, the ``__len__`` method cannot return anything
         larger than an integer (in C) can hold. If the total size of the body
         is even slightly larger than 4GB users will see an OverflowError. This
         manifested itself in `bug #80`_.
-
+        
         As such, we now calculate the length lazily as a property.
-
+        
         .. _bug #80:
             https://github.com/requests/toolbelt/issues/80
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # If _len isn't already calculated, calculate, return, and set it
         return self._len or self._calculate_length()
@@ -151,10 +162,16 @@
         return '<MultipartEncoder: {0!r}>'.format(self.fields)
 
     def _calculate_length(self):
-        """
-        This uses the parts to calculate the length of the body.
-
+        """This uses the parts to calculate the length of the body.
+        
         This returns the calculated length so __len__ can be lazy.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         boundary_len = len(self.boundary)  # Length of --{boundary}
         # boundary length + header length + body length + len('\r\n') * 2
@@ -165,27 +182,47 @@
 
     def _calculate_load_amount(self, read_size):
         """This calculates how many bytes need to be added to the buffer.
-
+        
         When a consumer read's ``x`` from the buffer, there are two cases to
         satisfy:
-
+        
             1. Enough data in the buffer to return the requested amount
             2. Not enough data
-
+        
         This function uses the amount of unread bytes in the buffer and
         determines how much the Encoder has to load before it can return the
         requested amount of bytes.
 
-        :param int read_size: the number of bytes the consumer requests
-        :returns: int -- the number of bytes that must be loaded into the
+        Parameters
+        ----------
+        int :
+            read_size: the number of bytes the consumer requests
+        read_size :
+            
+
+        Returns
+        -------
+        type
+            int -- the number of bytes that must be loaded into the
             buffer before the read can be satisfied. This will be strictly
             non-negative
+
         """
         amount = read_size - total_len(self._buffer)
         return amount if amount > 0 else 0
 
     def _load(self, amount):
-        """Load ``amount`` number of bytes into the buffer."""
+        """Load ``amount`` number of bytes into the buffer.
+
+        Parameters
+        ----------
+        amount :
+            
+
+        Returns
+        -------
+
+        """
         self._buffer.smart_truncate()
         part = self._current_part or self._next_part()
         while amount == -1 or amount > 0:
@@ -206,6 +243,7 @@
                 amount -= written
 
     def _next_part(self):
+        """ """
         try:
             p = self._current_part = next(self._iter_parts)
         except StopIteration:
@@ -213,6 +251,7 @@
         return p
 
     def _iter_fields(self):
+        """ """
         _fields = self.fields
         if hasattr(self.fields, 'items'):
             _fields = list(self.fields.items())
@@ -238,9 +277,16 @@
 
     def _prepare_parts(self):
         """This uses the fields provided by the user and creates Part objects.
-
+        
         It populates the `parts` attribute and uses that to create a
         generator for iteration.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         enc = self.encoding
         self.parts = [Part.from_field(f, enc) for f in self._iter_fields()]
@@ -249,9 +295,19 @@
     def _write(self, bytes_to_write):
         """Write the bytes to the end of the buffer.
 
-        :param bytes bytes_to_write: byte-string (or bytearray) to append to
+        Parameters
+        ----------
+        bytes :
+            bytes_to_write: byte-string (or bytearray) to append to
             the buffer
-        :returns: int -- the number of bytes written
+        bytes_to_write :
+            
+
+        Returns
+        -------
+        type
+            int -- the number of bytes written
+
         """
         return self._buffer.append(bytes_to_write)
 
@@ -267,31 +323,48 @@
         return 2
 
     def _write_headers(self, headers):
-        """Write the current part's headers to the buffer."""
+        """Write the current part's headers to the buffer.
+
+        Parameters
+        ----------
+        headers :
+            
+
+        Returns
+        -------
+
+        """
         return self._write(encode_with(headers, self.encoding))
 
     @property
     def content_type(self):
+        """ """
         return str(
             'multipart/form-data; boundary={0}'.format(self.boundary_value)
             )
 
     def to_string(self):
         """Return the entirety of the data in the encoder.
-
+        
         .. note::
-
+        
             This simply reads all of the data it can. If you have started
             streaming or reading data from the encoder, this method will only
             return whatever data is left in the encoder.
-
+        
         .. note::
-
+        
             This method affects the internal state of the encoder. Calling
             this method will exhaust the encoder.
 
-        :returns: the multipart message
-        :rtype: bytes
+        Parameters
+        ----------
+
+        Returns
+        -------
+        bytes
+            the multipart message
+
         """
 
         return self.read()
@@ -299,10 +372,20 @@
     def read(self, size=-1):
         """Read data from the streaming encoder.
 
-        :param int size: (optional), If provided, ``read`` will return exactly
+        Parameters
+        ----------
+        int :
+            size: (optional), If provided, ``read`` will return exactly
             that many bytes. If it is not provided, it will return the
             remaining bytes.
-        :returns: bytes
+        size :
+             (Default value = -1)
+
+        Returns
+        -------
+        type
+            bytes
+
         """
         if self.finished:
             return self._buffer.read(size)
@@ -316,51 +399,61 @@
 
 
 def IDENTITY(monitor):
+    """
+
+    Parameters
+    ----------
+    monitor :
+        
+
+    Returns
+    -------
+
+    """
     return monitor
 
 
 class MultipartEncoderMonitor(object):
 
-    """
-    An object used to monitor the progress of a :class:`MultipartEncoder`.
-
+    """An object used to monitor the progress of a :class:`MultipartEncoder`.
+    
     The :class:`MultipartEncoder` should only be responsible for preparing and
     streaming the data. For anyone who wishes to monitor it, they shouldn't be
     using that instance to manage that as well. Using this class, they can
     monitor an encoder and register a callback. The callback receives the
     instance of the monitor.
-
+    
     To use this monitor, you construct your :class:`MultipartEncoder` as you
     normally would.
-
+    
     .. code-block:: python
-
+    
         from requests_toolbelt import (MultipartEncoder,
                                        MultipartEncoderMonitor)
         import requests
-
+    
         def callback(monitor):
             # Do something with this information
             pass
-
+    
         m = MultipartEncoder(fields={'field0': 'value0'})
         monitor = MultipartEncoderMonitor(m, callback)
         headers = {'Content-Type': monitor.content_type}
         r = requests.post('https://httpbin.org/post', data=monitor,
                           headers=headers)
-
+    
     Alternatively, if your use case is very simple, you can use the following
     pattern.
-
+    
     .. code-block:: python
-
+    
         from requests_toolbelt import MultipartEncoderMonitor
         import requests
-
+    
         def callback(monitor):
             # Do something with this information
             pass
-
+    
         monitor = MultipartEncoderMonitor.from_fields(
             fields={'field0': 'value0'}, callback
             )
@@ -368,6 +461,12 @@
         r = requests.post('https://httpbin.org/post', data=monitor,
                           headers=headers)
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, encoder, callback=None):
@@ -387,17 +486,47 @@
     @classmethod
     def from_fields(cls, fields, boundary=None, encoding='utf-8',
                     callback=None):
+        """
+
+        Parameters
+        ----------
+        fields :
+            
+        boundary :
+             (Default value = None)
+        encoding :
+             (Default value = 'utf-8')
+        callback :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         encoder = MultipartEncoder(fields, boundary, encoding)
         return cls(encoder, callback)
 
     @property
     def content_type(self):
+        """ """
         return self.encoder.content_type
 
     def to_string(self):
+        """ """
         return self.read()
 
     def read(self, size=-1):
+        """
+
+        Parameters
+        ----------
+        size :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
         string = self.encoder.read(size)
         self.bytes_read += len(string)
         self.callback(self)
@@ -407,10 +536,23 @@
 def encode_with(string, encoding):
     """Encoding ``string`` with ``encoding`` if necessary.
 
-    :param str string: If string is a bytes object, it will not encode it.
+    Parameters
+    ----------
+    str :
+        string: If string is a bytes object, it will not encode it.
         Otherwise, this function will encode it with the provided encoding.
-    :param str encoding: The encoding with which to encode string.
-    :returns: encoded bytes object
+    str :
+        encoding: The encoding with which to encode string.
+    string :
+        
+    encoding :
+        
+
+    Returns
+    -------
+    type
+        encoded bytes object
+
     """
     if not (string is None or isinstance(string, bytes)):
         return string.encode(encoding)
@@ -418,7 +560,19 @@
 
 
 def readable_data(data, encoding):
-    """Coerce the data to an object with a ``read`` method."""
+    """Coerce the data to an object with a ``read`` method.
+
+    Parameters
+    ----------
+    data :
+        
+    encoding :
+        
+
+    Returns
+    -------
+
+    """
     if hasattr(data, 'read'):
         return data
 
@@ -426,6 +580,17 @@
 
 
 def total_len(o):
+    """
+
+    Parameters
+    ----------
+    o :
+        
+
+    Returns
+    -------
+
+    """
     if hasattr(o, '__len__'):
         return len(o)
 
@@ -448,10 +613,19 @@
 @contextlib.contextmanager
 def reset(buffer):
     """Keep track of the buffer's current position and write to the end.
-
+    
     This is a context manager meant to be used when adding data to the buffer.
     It eliminates the need for every function to be concerned with the
     position of the cursor in the buffer.
+
+    Parameters
+    ----------
+    buffer :
+        
+
+    Returns
+    -------
+
     """
     original_position = buffer.tell()
     buffer.seek(0, 2)
@@ -460,7 +634,19 @@
 
 
 def coerce_data(data, encoding):
-    """Ensure that every object's __len__ behaves uniformly."""
+    """Ensure that every object's __len__ behaves uniformly.
+
+    Parameters
+    ----------
+    data :
+        
+    encoding :
+        
+
+    Returns
+    -------
+
+    """
     if not isinstance(data, CustomBytesIO):
         if hasattr(data, 'getvalue'):
             return CustomBytesIO(data.getvalue(), encoding)
@@ -475,12 +661,24 @@
 
 
 def to_list(fields):
+    """
+
+    Parameters
+    ----------
+    fields :
+        
+
+    Returns
+    -------
+
+    """
     if hasattr(fields, 'items'):
         return list(fields.items())
     return list(fields)
 
 
 class Part(object):
+    """ """
     def __init__(self, headers, body):
         self.headers = headers
         self.body = body
@@ -489,7 +687,19 @@
 
     @classmethod
     def from_field(cls, field, encoding):
-        """Create a part from a Request Field generated by urllib3."""
+        """Create a part from a Request Field generated by urllib3.
+
+        Parameters
+        ----------
+        field :
+            
+        encoding :
+            
+
+        Returns
+        -------
+
+        """
         headers = encode_with(field.render_headers(), encoding)
         body = coerce_data(field.data, encoding)
         return cls(headers, body)
@@ -497,8 +707,15 @@
     def bytes_left_to_write(self):
         """Determine if there are bytes left to write.
 
-        :returns: bool -- ``True`` if there are bytes left to write, otherwise
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            bool -- ``True`` if there are bytes left to write, otherwise
             ``False``
+
         """
         to_read = 0
         if self.headers_unread:
@@ -508,13 +725,26 @@
 
     def write_to(self, buffer, size):
         """Write the requested amount of bytes to the buffer provided.
-
+        
         The number of bytes written may exceed size on the first read since we
         load the headers ambitiously.
 
-        :param CustomBytesIO buffer: buffer we want to write bytes to
-        :param int size: number of bytes requested to be written to the buffer
-        :returns: int -- number of bytes actually written
+        Parameters
+        ----------
+        CustomBytesIO :
+            buffer: buffer we want to write bytes to
+        int :
+            size: number of bytes requested to be written to the buffer
+        buffer :
+            
+        size :
+            
+
+        Returns
+        -------
+        type
+            int -- number of bytes actually written
+
         """
         written = 0
         if self.headers_unread:
@@ -531,11 +761,13 @@
 
 
 class CustomBytesIO(io.BytesIO):
+    """ """
     def __init__(self, buffer=None, encoding='utf-8'):
         buffer = encode_with(buffer, encoding)
         super(CustomBytesIO, self).__init__(buffer)
 
     def _get_end(self):
+        """ """
         current_pos = self.tell()
         self.seek(0, 2)
         length = self.tell()
@@ -544,15 +776,28 @@
 
     @property
     def len(self):
+        """ """
         length = self._get_end()
         return length - self.tell()
 
     def append(self, bytes):
+        """
+
+        Parameters
+        ----------
+        bytes :
+            
+
+        Returns
+        -------
+
+        """
         with reset(self):
             written = self.write(bytes)
         return written
 
     def smart_truncate(self):
+        """ """
         to_be_read = total_len(self)
         already_read = self._get_end() - to_be_read
 
@@ -565,32 +810,45 @@
 
 
 class FileWrapper(object):
+    """ """
     def __init__(self, file_object):
         self.fd = file_object
 
     @property
     def len(self):
+        """ """
         return total_len(self.fd) - self.fd.tell()
 
     def read(self, length=-1):
+        """
+
+        Parameters
+        ----------
+        length :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
         return self.fd.read(length)
 
 
 class FileFromURLWrapper(object):
     """File from URL wrapper.
-
+    
     The :class:`FileFromURLWrapper` object gives you the ability to stream file
     from provided URL in chunks by :class:`MultipartEncoder`.
     Provide a stateless solution for streaming file from one server to another.
     You can use the :class:`FileFromURLWrapper` without a session or with
     a session as demonstated by the examples below:
-
+    
     .. code-block:: python
         # no session
-
+    
         import requests
         from requests_toolbelt import MultipartEncoder, FileFromURLWrapper
-
+    
         url = 'https://httpbin.org/image/png'
         streaming_encoder = MultipartEncoder(
             fields={
@@ -601,13 +859,13 @@
             'https://httpbin.org/post', data=streaming_encoder,
             headers={'Content-Type': streaming_encoder.content_type}
         )
-
+    
     .. code-block:: python
         # using a session
-
+    
         import requests
         from requests_toolbelt import MultipartEncoder, FileFromURLWrapper
-
+    
         session = requests.Session()
         url = 'https://httpbin.org/image/png'
         streaming_encoder = MultipartEncoder(
@@ -620,6 +878,12 @@
             headers={'Content-Type': streaming_encoder.content_type}
         )
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, file_url, session=None):
@@ -629,7 +893,17 @@
         self.raw_data = requested_file.raw
 
     def _request_for_file(self, file_url):
-        """Make call for file under provided URL."""
+        """Make call for file under provided URL.
+
+        Parameters
+        ----------
+        file_url :
+            
+
+        Returns
+        -------
+
+        """
         response = self.session.get(file_url, stream=True)
         content_length = response.headers.get('content-length', None)
         if content_length is None:
@@ -648,7 +922,17 @@
         return response
 
     def read(self, chunk_size):
-        """Read file in chunks."""
+        """Read file in chunks.
+
+        Parameters
+        ----------
+        chunk_size :
+            
+
+        Returns
+        -------
+
+        """
         chunk_size = chunk_size if chunk_size >= 0 else self.len
         chunk = self.raw_data.read(chunk_size) or b''
         self.len -= len(chunk) if chunk else 0  # left to read
