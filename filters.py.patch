# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/filters.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/filters.py
@@ -20,39 +20,100 @@
 
 
 class AbstractFilter(object):
+    """ """
     _until_position = None
 
     def _filter(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         if self._until_position is not None:
             return [n for n in names if n.start_pos < self._until_position]
         return names
 
     @abstractmethod
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     @abstractmethod
     def values(self):
+        """ """
         raise NotImplementedError
 
 
 class FilterWrapper(object):
+    """ """
     name_wrapper_class = None
 
     def __init__(self, wrapped_filter):
         self._wrapped_filter = wrapped_filter
 
     def wrap_names(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         return [self.name_wrapper_class(name) for name in names]
 
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return self.wrap_names(self._wrapped_filter.get(name))
 
     def values(self):
+        """ """
         return self.wrap_names(self._wrapped_filter.values())
 
 
 def _get_definition_names(used_names, name_key):
+    """
+
+    Parameters
+    ----------
+    used_names :
+        
+    name_key :
+        
+
+    Returns
+    -------
+
+    """
     try:
         for_module = _definition_name_cache[used_names]
     except KeyError:
@@ -69,6 +130,7 @@
 
 
 class AbstractUsedNamesFilter(AbstractFilter):
+    """ """
     name_class = TreeNameDefinition
 
     def __init__(self, parent_context, parser_scope):
@@ -78,14 +140,37 @@
         self.parent_context = parent_context
 
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return self._convert_names(self._filter(
             _get_definition_names(self._used_names, name),
         ))
 
     def _convert_names(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         return [self.name_class(self.parent_context, name) for name in names]
 
     def values(self):
+        """ """
         return self._convert_names(
             name
             for name_key in self._used_names
@@ -99,6 +184,7 @@
 
 
 class ParserTreeFilter(AbstractUsedNamesFilter):
+    """ """
     def __init__(self, parent_context, node_context=None, until_position=None,
                  origin_scope=None):
         """
@@ -115,11 +201,33 @@
         self._until_position = until_position
 
     def _filter(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         names = super(ParserTreeFilter, self)._filter(names)
         names = [n for n in names if self._is_name_reachable(n)]
         return list(self._check_flows(names))
 
     def _is_name_reachable(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         parent = name.parent
         if parent.type == 'trailer':
             return False
@@ -127,6 +235,17 @@
         return get_cached_parent_scope(self._used_names, base_node) == self._parser_scope
 
     def _check_flows(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         for name in sorted(names, key=lambda name: name.start_pos, reverse=True):
             check = flow_analysis.reachability_check(
                 context=self._node_context,
@@ -142,6 +261,7 @@
 
 
 class _FunctionExecutionFilter(ParserTreeFilter):
+    """ """
     def __init__(self, parent_context, function_value, until_position, origin_scope):
         super(_FunctionExecutionFilter, self).__init__(
             parent_context,
@@ -151,10 +271,34 @@
         self._function_value = function_value
 
     def _convert_param(self, param, name):
+        """
+
+        Parameters
+        ----------
+        param :
+            
+        name :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     @to_list
     def _convert_names(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         for name in names:
             param = search_ancestor(name, 'param')
             # Here we don't need to check if the param is a default/annotation,
@@ -167,21 +311,61 @@
 
 
 class FunctionExecutionFilter(_FunctionExecutionFilter):
+    """ """
     def __init__(self, *args, **kwargs):
         self._arguments = kwargs.pop('arguments')  # Python 2
         super(FunctionExecutionFilter, self).__init__(*args, **kwargs)
 
     def _convert_param(self, param, name):
+        """
+
+        Parameters
+        ----------
+        param :
+            
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return ParamName(self._function_value, name, self._arguments)
 
 
 class AnonymousFunctionExecutionFilter(_FunctionExecutionFilter):
+    """ """
     def _convert_param(self, param, name):
+        """
+
+        Parameters
+        ----------
+        param :
+            
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return AnonymousParamName(self._function_value, name)
 
 
 class GlobalNameFilter(AbstractUsedNamesFilter):
+    """ """
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             names = self._used_names[name]
         except KeyError:
@@ -190,11 +374,23 @@
 
     @to_list
     def _filter(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         for name in names:
             if name.parent.type == 'global_stmt':
                 yield name
 
     def values(self):
+        """ """
         return self._convert_names(
             name for name_list in self._used_names.values()
             for name in self._filter(name_list)
@@ -202,10 +398,22 @@
 
 
 class DictFilter(AbstractFilter):
+    """ """
     def __init__(self, dct):
         self._dct = dct
 
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         try:
             value = self._convert(name, self._dct[name])
         except KeyError:
@@ -214,7 +422,9 @@
             return list(self._filter([value]))
 
     def values(self):
+        """ """
         def yielder():
+            """ """
             for item in self._dct.items():
                 try:
                     yield self._convert(*item)
@@ -223,6 +433,19 @@
         return self._filter(yielder())
 
     def _convert(self, name, value):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        value :
+            
+
+        Returns
+        -------
+
+        """
         return value
 
     def __repr__(self):
@@ -231,13 +454,26 @@
 
 
 class MergedFilter(object):
+    """ """
     def __init__(self, *filters):
         self._filters = filters
 
     def get(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return [n for filter in self._filters for n in filter.get(name)]
 
     def values(self):
+        """ """
         return [n for filter in self._filters for n in filter.values()]
 
     def __repr__(self):
@@ -254,16 +490,34 @@
         self._method = method
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         # TODO add TypeError if params are given/or not correct.
         return self._method(self._value, arguments)
 
 
 class SpecialMethodFilter(DictFilter):
-    """
-    A filter for methods that are defined in this module on the corresponding
+    """A filter for methods that are defined in this module on the corresponding
     classes like Generator (for __next__, etc).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     class SpecialMethodName(AbstractNameDefinition):
+        """ """
         api_type = u'function'
 
         def __init__(self, parent_context, string_name, value, builtin_value):
@@ -278,6 +532,7 @@
             self._builtin_value = builtin_value
 
         def infer(self):
+            """ """
             for filter in self._builtin_value.get_filters():
                 # We can take the first index, because on builtin methods there's
                 # always only going to be one name. The same is true for the
@@ -304,10 +559,24 @@
         """
 
     def _convert(self, name, value):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        value :
+            
+
+        Returns
+        -------
+
+        """
         return self.SpecialMethodName(self.value, name, value, self._builtin_value)
 
 
 class _OverwriteMeta(type):
+    """ """
     def __init__(cls, name, bases, dct):
         super(_OverwriteMeta, cls).__init__(name, bases, dct)
 
@@ -327,7 +596,21 @@
 
 
 class _AttributeOverwriteMixin(object):
+    """ """
     def get_filters(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         yield SpecialMethodFilter(self, self.overwritten_methods, self._wrapped_value)
 
         for filter in self._wrapped_value.get_filters(*args, **kwargs):
@@ -336,17 +619,43 @@
 
 class LazyAttributeOverwrite(use_metaclass(_OverwriteMeta, _AttributeOverwriteMixin,
                                            LazyValueWrapper)):
+    """ """
     def __init__(self, inference_state):
         self.inference_state = inference_state
 
 
 class AttributeOverwrite(use_metaclass(_OverwriteMeta, _AttributeOverwriteMixin,
                                        ValueWrapper)):
+    """ """
     pass
 
 
 def publish_method(method_name, python_version_match=None):
+    """
+
+    Parameters
+    ----------
+    method_name :
+        
+    python_version_match :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     def decorator(func):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         dct = func.__dict__.setdefault('registered_overwritten_methods', {})
         dct[method_name] = func, python_version_match
         return func
