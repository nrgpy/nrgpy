# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/routing.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/routing.py
@@ -29,19 +29,36 @@
 `Router` subclass must implement a ``find_handler`` method to provide
 a suitable `~.httputil.HTTPMessageDelegate` instance to handle the
 request:
+    """ """
 
 .. code-block:: python
 
     class CustomRouter(Router):
+        """ """
         def find_handler(self, request, **kwargs):
+            """
+
+            Parameters
+            ----------
+            request :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             # some routing logic providing a suitable HTTPMessageDelegate instance
             return MessageDelegate(request.connection)
 
     class MessageDelegate(HTTPMessageDelegate):
+        """ """
         def __init__(self, connection):
             self.connection = connection
 
         def finish(self):
+            """ """
             self.connection.write_headers(
                 ResponseStartLine("HTTP/1.1", 200, "OK"),
                 HTTPHeaders({"Content-Length": "2"}),
@@ -69,21 +86,59 @@
     resources = {}
 
     class GetResource(RequestHandler):
+        """ """
         def get(self, path):
+            """
+
+            Parameters
+            ----------
+            path :
+                
+
+            Returns
+            -------
+
+            """
             if path not in resources:
                 raise HTTPError(404)
 
             self.finish(resources[path])
 
     class PostResource(RequestHandler):
+        """ """
         def post(self, path):
+            """
+
+            Parameters
+            ----------
+            path :
+                
+
+            Returns
+            -------
+
+            """
             resources[path] = self.request.body
 
     class HTTPMethodRouter(Router):
+        """ """
         def __init__(self, app):
             self.app = app
 
         def find_handler(self, request, **kwargs):
+            """
+
+            Parameters
+            ----------
+            request :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             handler = GetResource if request.method == "GET" else PostResource
             return self.app.get_handler_delegate(request, handler, path_args=[request.path])
 
@@ -113,7 +168,21 @@
     ])
 
     class ConnectionDelegate(HTTPServerConnectionDelegate):
+        """ """
         def start_request(self, server_conn, request_conn):
+            """
+
+            Parameters
+            ----------
+            server_conn :
+                
+            request_conn :
+                
+
+            Returns
+            -------
+
+            """
             return MessageDelegate(request_conn)
 
 2) A callable accepting a single argument of `~.httputil.HTTPServerRequest` type:
@@ -125,6 +194,17 @@
     ])
 
     def request_callable(request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         request.write(b"HTTP/1.1 200 OK\\r\\nContent-Length: 2\\r\\n\\r\\nOK")
         request.finish()
 
@@ -196,37 +276,82 @@
         """Must be implemented to return an appropriate instance of `~.httputil.HTTPMessageDelegate`
         that can serve the request.
         Routing implementations may pass additional kwargs to extend the routing logic.
-
+        
         :arg httputil.HTTPServerRequest request: current HTTP request.
         :arg kwargs: additional keyword arguments passed by routing implementation.
-        :returns: an instance of `~.httputil.HTTPMessageDelegate` that will be used to
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+        type
+            an instance of `~.httputil.HTTPMessageDelegate` that will be used to
             process the request.
+
         """
         raise NotImplementedError()
 
     def start_request(
         self, server_conn: object, request_conn: httputil.HTTPConnection
     ) -> httputil.HTTPMessageDelegate:
+        """
+
+        Parameters
+        ----------
+        server_conn: object :
+            
+        request_conn: httputil.HTTPConnection :
+            
+
+        Returns
+        -------
+
+        """
         return _RoutingDelegate(self, server_conn, request_conn)
 
 
 class ReversibleRouter(Router):
     """Abstract router interface for routers that can handle named routes
     and support reversing them to original urls.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def reverse_url(self, name: str, *args: Any) -> Optional[str]:
         """Returns url string for a given route name and arguments
         or ``None`` if no match is found.
-
+        
         :arg str name: route name.
         :arg args: url parameters.
-        :returns: parametrized url string for a given route name (or ``None``).
+
+        Parameters
+        ----------
+        name: str :
+            
+        *args: Any :
+            
+
+        Returns
+        -------
+        type
+            parametrized url string for a given route name (or ``None``).
+
         """
         raise NotImplementedError()
 
 
 class _RoutingDelegate(httputil.HTTPMessageDelegate):
+    """ """
     def __init__(
         self, router: Router, server_conn: object, request_conn: httputil.HTTPConnection
     ) -> None:
@@ -240,6 +365,21 @@
         start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],
         headers: httputil.HTTPHeaders,
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        start_line: Union[httputil.RequestStartLine :
+            
+        httputil.ResponseStartLine] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(start_line, httputil.RequestStartLine)
         request = httputil.HTTPServerRequest(
             connection=self.request_conn,
@@ -260,23 +400,38 @@
         return self.delegate.headers_received(start_line, headers)
 
     def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
+        """
         assert self.delegate is not None
         return self.delegate.data_received(chunk)
 
     def finish(self) -> None:
+        """ """
         assert self.delegate is not None
         self.delegate.finish()
 
     def on_connection_close(self) -> None:
+        """ """
         assert self.delegate is not None
         self.delegate.on_connection_close()
 
 
 class _DefaultMessageDelegate(httputil.HTTPMessageDelegate):
+    """ """
     def __init__(self, connection: httputil.HTTPConnection) -> None:
         self.connection = connection
 
     def finish(self) -> None:
+        """ """
         self.connection.write_headers(
             httputil.ResponseStartLine("HTTP/1.1", 404, "Not Found"),
             httputil.HTTPHeaders(),
@@ -333,9 +488,18 @@
 
     def add_rules(self, rules: _RuleList) -> None:
         """Appends new rules to the router.
-
+        
         :arg rules: a list of Rule instances (or tuples of arguments, which are
             passed to Rule constructor).
+
+        Parameters
+        ----------
+        rules: _RuleList :
+            
+
+        Returns
+        -------
+
         """
         for rule in rules:
             if isinstance(rule, (tuple, list)):
@@ -349,15 +513,38 @@
 
     def process_rule(self, rule: "Rule") -> "Rule":
         """Override this method for additional preprocessing of each rule.
-
+        
         :arg Rule rule: a rule to be processed.
-        :returns: the same or modified Rule instance.
+
+        Parameters
+        ----------
+        rule: "Rule" :
+            
+
+        Returns
+        -------
+        type
+            the same or modified Rule instance.
+
         """
         return rule
 
     def find_handler(
         self, request: httputil.HTTPServerRequest, **kwargs: Any
     ) -> Optional[httputil.HTTPMessageDelegate]:
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         for rule in self.rules:
             target_params = rule.matcher.match(request)
             if target_params is not None:
@@ -379,11 +566,24 @@
         """Returns an instance of `~.httputil.HTTPMessageDelegate` for a
         Rule's target. This method is called by `~.find_handler` and can be
         extended to provide additional target types.
-
+        
         :arg target: a Rule's target.
         :arg httputil.HTTPServerRequest request: current request.
         :arg target_params: additional parameters that can be useful
             for `~.httputil.HTTPMessageDelegate` creation.
+
+        Parameters
+        ----------
+        target: Any :
+            
+        request: httputil.HTTPServerRequest :
+            
+        **target_params: Any :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(target, Router):
             return target.find_handler(request, **target_params)
@@ -403,10 +603,17 @@
 
 class ReversibleRuleRouter(ReversibleRouter, RuleRouter):
     """A rule-based router that implements ``reverse_url`` method.
-
+    
     Each rule added to this router may have a ``name`` attribute that can be
     used to reconstruct an original uri. The actual reconstruction takes place
     in a rule's matcher (see `Matcher.reverse`).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, rules: Optional[_RuleList] = None) -> None:
@@ -414,6 +621,17 @@
         super().__init__(rules)
 
     def process_rule(self, rule: "Rule") -> "Rule":
+        """
+
+        Parameters
+        ----------
+        rule: "Rule" :
+            
+
+        Returns
+        -------
+
+        """
         rule = super().process_rule(rule)
 
         if rule.name:
@@ -426,6 +644,19 @@
         return rule
 
     def reverse_url(self, name: str, *args: Any) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        *args: Any :
+            
+
+        Returns
+        -------
+
+        """
         if name in self.named_rules:
             return self.named_rules[name].matcher.reverse(*args)
 
@@ -475,6 +706,17 @@
         self.name = name
 
     def reverse(self, *args: Any) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        *args: Any :
+            
+
+        Returns
+        -------
+
+        """
         return self.matcher.reverse(*args)
 
     def __repr__(self) -> str:
@@ -492,18 +734,39 @@
 
     def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:
         """Matches current instance against the request.
-
+        
         :arg httputil.HTTPServerRequest request: current HTTP request
-        :returns: a dict of parameters to be passed to the target handler
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+
+        Returns
+        -------
+        type
+            a dict of parameters to be passed to the target handler
             (for example, ``handler_kwargs``, ``path_args``, ``path_kwargs``
             can be passed for proper `~.web.RequestHandler` instantiation).
             An empty dict is a valid (and common) return value to indicate a match
             when the argument-passing features are not used.
-            ``None`` must be returned to indicate that there is no match."""
+            ``None`` must be returned to indicate that there is no match.
+
+        """
         raise NotImplementedError()
 
     def reverse(self, *args: Any) -> Optional[str]:
-        """Reconstructs full url from matcher instance and additional arguments."""
+        """Reconstructs full url from matcher instance and additional arguments.
+
+        Parameters
+        ----------
+        *args: Any :
+            
+
+        Returns
+        -------
+
+        """
         return None
 
 
@@ -511,6 +774,17 @@
     """Matches any request."""
 
     def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+
+        Returns
+        -------
+
+        """
         return {}
 
 
@@ -526,6 +800,17 @@
             self.host_pattern = host_pattern
 
     def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+
+        Returns
+        -------
+
+        """
         if self.host_pattern.match(request.host_name):
             return {}
 
@@ -535,6 +820,13 @@
 class DefaultHostMatches(Matcher):
     """Matches requests from host that is equal to application's default_host.
     Always returns no match if ``X-Real-Ip`` header is present.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, application: Any, host_pattern: Pattern) -> None:
@@ -542,6 +834,17 @@
         self.host_pattern = host_pattern
 
     def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+
+        Returns
+        -------
+
+        """
         # Look for default host if not behind load balancer (for debugging)
         if "X-Real-Ip" not in request.headers:
             if self.host_pattern.match(self.application.default_host):
@@ -568,6 +871,17 @@
         self._path, self._group_count = self._find_groups()
 
     def match(self, request: httputil.HTTPServerRequest) -> Optional[Dict[str, Any]]:
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+
+        Returns
+        -------
+
+        """
         match = self.regex.match(request.path)
         if match is None:
             return None
@@ -591,6 +905,17 @@
         return dict(path_args=path_args, path_kwargs=path_kwargs)
 
     def reverse(self, *args: Any) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        *args: Any :
+            
+
+        Returns
+        -------
+
+        """
         if self._path is None:
             raise ValueError("Cannot reverse url regex " + self.regex.pattern)
         assert len(args) == self._group_count, (
@@ -607,9 +932,16 @@
 
     def _find_groups(self) -> Tuple[Optional[str], Optional[int]]:
         """Returns a tuple (reverse string, group count) for a url.
-
+        
         For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method
         would return ('/%s/%s/', 2).
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pattern = self.regex.pattern
         if pattern.startswith("^"):
@@ -648,10 +980,17 @@
 
 class URLSpec(Rule):
     """Specifies mappings between URLs and handlers.
-
+    
     .. versionchanged: 4.5
        `URLSpec` is now a subclass of a `Rule` with `PathMatches` matcher and is preserved for
        backwards compatibility.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -697,20 +1036,51 @@
 
 @overload
 def _unquote_or_none(s: str) -> bytes:
+    """
+
+    Parameters
+    ----------
+    s: str :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 @overload  # noqa: F811
 def _unquote_or_none(s: None) -> None:
+    """
+
+    Parameters
+    ----------
+    s: None :
+        
+
+    Returns
+    -------
+
+    """
     pass
 
 
 def _unquote_or_none(s: Optional[str]) -> Optional[bytes]:  # noqa: F811
     """None-safe wrapper around url_unescape to handle unmatched optional
     groups correctly.
-
+    
     Note that args are passed as bytes so the handler can decide what
     encoding to use.
+
+    Parameters
+    ----------
+    s: Optional[str] :
+        
+
+    Returns
+    -------
+
     """
     if s is None:
         return s
