# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/nanops.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/nanops.py
@@ -40,6 +40,17 @@
 
 
 def set_use_bottleneck(v: bool = True) -> None:
+    """
+
+    Parameters
+    ----------
+    v: bool :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     # set/unset to use bottleneck
     global _USE_BOTTLENECK
     if _BOTTLENECK_INSTALLED:
@@ -50,16 +61,41 @@
 
 
 class disallow:
+    """ """
     def __init__(self, *dtypes):
         super().__init__()
         self.dtypes = tuple(pandas_dtype(dtype).type for dtype in dtypes)
 
     def check(self, obj) -> bool:
+        """
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         return hasattr(obj, "dtype") and issubclass(obj.dtype.type, self.dtypes)
 
     def __call__(self, f: F) -> F:
         @functools.wraps(f)
         def _f(*args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             obj_iter = itertools.chain(args, kwargs.values())
             if any(self.check(obj) for obj in obj_iter):
                 f_name = f.__name__.replace("nan", "")
@@ -82,6 +118,7 @@
 
 
 class bottleneck_switch:
+    """ """
     def __init__(self, name=None, **kwargs):
         self.name = name
         self.kwargs = kwargs
@@ -98,6 +135,23 @@
         def f(
             values: np.ndarray, axis: Optional[int] = None, skipna: bool = True, **kwds
         ):
+            """
+
+            Parameters
+            ----------
+            values: np.ndarray :
+                
+            axis: Optional[int] :
+                 (Default value = None)
+            skipna: bool :
+                 (Default value = True)
+            **kwds :
+                
+
+            Returns
+            -------
+
+            """
             if len(self.kwargs) > 0:
                 for k, v in self.kwargs.items():
                     if k not in kwds:
@@ -134,6 +188,19 @@
 
 
 def _bn_ok_dtype(dtype: DtypeObj, name: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    dtype: DtypeObj :
+        
+    name: str :
+        
+
+    Returns
+    -------
+
+    """
     # Bottleneck chokes on datetime64, PeriodDtype (or and EA)
     if not is_object_dtype(dtype) and not needs_i8_conversion(dtype):
 
@@ -153,6 +220,17 @@
 
 
 def _has_infs(result) -> bool:
+    """
+
+    Parameters
+    ----------
+    result :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(result, np.ndarray):
         if result.dtype == "f8":
             return lib.has_infs_f8(result.ravel("K"))
@@ -168,7 +246,23 @@
 def _get_fill_value(
     dtype: DtypeObj, fill_value: Optional[Scalar] = None, fill_value_typ=None
 ):
-    """ return the correct fill value for the dtype of the values """
+    """
+
+    Parameters
+    ----------
+    dtype: DtypeObj :
+        
+    fill_value: Optional[Scalar] :
+         (Default value = None)
+    fill_value_typ :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        
+
+    """
     if fill_value is not None:
         return fill_value
     if _na_ok_dtype(dtype):
@@ -193,20 +287,19 @@
 def _maybe_get_mask(
     values: np.ndarray, skipna: bool, mask: Optional[np.ndarray]
 ) -> Optional[np.ndarray]:
-    """
-    Compute a mask if and only if necessary.
-
+    """Compute a mask if and only if necessary.
+    
     This function will compute a mask iff it is necessary. Otherwise,
     return the provided mask (potentially None) when a mask does not need to be
     computed.
-
+    
     A mask is never necessary if the values array is of boolean or integer
     dtypes, as these are incapable of storing NaNs. If passing a NaN-capable
     dtype that is interpretable as either boolean or integer data (eg,
     timedelta64), a mask must be provided.
-
+    
     If the skipna parameter is False, a new mask will not be computed.
-
+    
     The mask is computed using isna() by default. Setting invert=True selects
     notna() as the masking function.
 
@@ -218,10 +311,17 @@
         boolean for whether NaNs should be skipped
     mask : Optional[ndarray]
         nan-mask if known
-
-    Returns
-    -------
-    Optional[np.ndarray]
+    values: np.ndarray :
+        
+    skipna: bool :
+        
+    mask: Optional[np.ndarray] :
+        
+
+    Returns
+    -------
+
+    
     """
     if mask is None:
         if is_bool_dtype(values.dtype) or is_integer_dtype(values.dtype):
@@ -241,12 +341,11 @@
     fill_value_typ: Optional[str] = None,
     mask: Optional[np.ndarray] = None,
 ) -> Tuple[np.ndarray, Optional[np.ndarray], np.dtype, np.dtype, Any]:
-    """
-    Utility to get the values view, mask, dtype, dtype_max, and fill_value.
-
+    """Utility to get the values view, mask, dtype, dtype_max, and fill_value.
+    
     If both mask and fill_value/fill_value_typ are not None and skipna is True,
     the values array will be copied.
-
+    
     For input arrays of boolean or integer dtypes, copies will only occur if a
     precomputed mask, a fill_value/fill_value_typ, and skipna=True are
     provided.
@@ -263,19 +362,21 @@
         Set to '+inf' or '-inf' to handle dtype-specific infinities
     mask : Optional[np.ndarray]
         nan-mask if known
-
-    Returns
-    -------
-    values : ndarray
-        Potential copy of input value array
-    mask : Optional[ndarray[bool]]
-        Mask for values, if deemed necessary to compute
-    dtype : np.dtype
-        dtype for values
-    dtype_max : np.dtype
-        platform independent dtype
-    fill_value : Any
-        fill value used
+    values: np.ndarray :
+        
+    skipna: bool :
+        
+    fill_value: Any :
+         (Default value = None)
+    fill_value_typ: Optional[str] :
+         (Default value = None)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
+
+    Returns
+    -------
+
+    
     """
     # In _get_values is only called from within nanops, and in all cases
     #  with scalar fill_value.  This guarantee is important for the
@@ -320,13 +421,38 @@
 
 
 def _na_ok_dtype(dtype: DtypeObj) -> bool:
+    """
+
+    Parameters
+    ----------
+    dtype: DtypeObj :
+        
+
+    Returns
+    -------
+
+    """
     if needs_i8_conversion(dtype):
         return False
     return not issubclass(dtype.type, np.integer)
 
 
 def _wrap_results(result, dtype: DtypeObj, fill_value=None):
-    """ wrap our results if needed """
+    """wrap our results if needed
+
+    Parameters
+    ----------
+    result :
+        
+    dtype: DtypeObj :
+        
+    fill_value :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if is_datetime64_any_dtype(dtype):
         if fill_value is None:
             # GH#24293
@@ -359,20 +485,23 @@
 def _na_for_min_count(
     values: np.ndarray, axis: Optional[int]
 ) -> Union[Scalar, np.ndarray]:
-    """
-    Return the missing value for `values`.
+    """Return the missing value for `values`.
 
     Parameters
     ----------
     values : ndarray
+        
     axis : int or None
         axis for the reduction, required if values.ndim > 1.
-
-    Returns
-    -------
-    result : scalar or ndarray
-        For 1-D values, returns a scalar of the correct missing type.
-        For 2-D values, returns a 1-D array where each element is missing.
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+        
+
+    Returns
+    -------
+
+    
     """
     # we either return np.nan or pd.NaT
     if is_numeric_dtype(values):
@@ -399,20 +528,31 @@
     skipna: bool = True,
     mask: Optional[np.ndarray] = None,
 ) -> bool:
-    """
-    Check if any elements along an axis evaluate to True.
+    """Check if any elements along an axis evaluate to True.
 
     Parameters
     ----------
     values : ndarray
+        
     axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
     result : bool
+        
 
     Examples
     --------
@@ -420,7 +560,7 @@
     >>> s = pd.Series([1, 2])
     >>> nanops.nanany(s)
     True
-
+    
     >>> import pandas.core.nanops as nanops
     >>> s = pd.Series([np.nan])
     >>> nanops.nanany(s)
@@ -436,20 +576,31 @@
     skipna: bool = True,
     mask: Optional[np.ndarray] = None,
 ) -> bool:
-    """
-    Check if all elements along an axis evaluate to True.
+    """Check if all elements along an axis evaluate to True.
 
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
     result : bool
+        
 
     Examples
     --------
@@ -457,7 +608,7 @@
     >>> s = pd.Series([1, 2, np.nan])
     >>> nanops.nanall(s)
     True
-
+    
     >>> import pandas.core.nanops as nanops
     >>> s = pd.Series([1, 0])
     >>> nanops.nanall(s)
@@ -475,21 +626,35 @@
     min_count: int = 0,
     mask: Optional[np.ndarray] = None,
 ) -> float:
-    """
-    Sum the elements along an axis ignoring NaNs
+    """Sum the elements along an axis ignoring NaNs
 
     Parameters
     ----------
     values : ndarray[dtype]
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
-    min_count: int, default 0
+        
+    min_count : int, default 0
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    min_count: int :
+         (Default value = 0)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
     result : dtype
+        
 
     Examples
     --------
@@ -520,16 +685,26 @@
     skipna: bool = True,
     mask: Optional[np.ndarray] = None,
 ) -> float:
-    """
-    Compute the mean of the element along an axis ignoring NaNs
+    """Compute the mean of the element along an axis ignoring NaNs
 
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -579,13 +754,17 @@
 @bottleneck_switch()
 def nanmedian(values, axis=None, skipna=True, mask=None):
     """
+
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+         (Default value = None)
     skipna : bool, default True
+         (Default value = True)
     mask : ndarray[bool], optional
-        nan-mask if known
+        nan-mask if known (Default value = None)
 
     Returns
     -------
@@ -602,6 +781,17 @@
     """
 
     def get_median(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         mask = notna(x)
         if not skipna and not mask.all():
             return np.nan
@@ -656,8 +846,7 @@
     ddof: int,
     dtype: Dtype = float,
 ) -> Tuple[Union[int, np.ndarray], Union[int, np.ndarray]]:
-    """
-    Get the count of non-null values along an axis, accounting
+    """Get the count of non-null values along an axis, accounting
     for degrees of freedom.
 
     Parameters
@@ -672,11 +861,21 @@
         degrees of freedom
     dtype : type, optional
         type to use for count
-
-    Returns
-    -------
-    count : scalar or array
-    d : scalar or array
+    value_counts: Tuple[int] :
+        
+    mask: Optional[np.ndarray] :
+        
+    axis: Optional[int] :
+        
+    ddof: int :
+        
+    dtype: Dtype :
+         (Default value = float)
+
+    Returns
+    -------
+
+    
     """
     dtype = _get_dtype(dtype)
     count = _get_counts(value_counts, mask, axis, dtype=dtype)
@@ -698,19 +897,21 @@
 @disallow("M8")
 @bottleneck_switch(ddof=1)
 def nanstd(values, axis=None, skipna=True, ddof=1, mask=None):
-    """
-    Compute the standard deviation along given axis while ignoring NaNs
+    """Compute the standard deviation along given axis while ignoring NaNs
 
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+         (Default value = None)
     skipna : bool, default True
+         (Default value = True)
     ddof : int, default 1
         Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
-        where N represents the number of elements.
+        where N represents the number of elements. (Default value = 1)
     mask : ndarray[bool], optional
-        nan-mask if known
+        nan-mask if known (Default value = None)
 
     Returns
     -------
@@ -735,19 +936,21 @@
 @disallow("M8", "m8")
 @bottleneck_switch(ddof=1)
 def nanvar(values, axis=None, skipna=True, ddof=1, mask=None):
-    """
-    Compute the variance along given axis while ignoring NaNs
+    """Compute the variance along given axis while ignoring NaNs
 
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+         (Default value = None)
     skipna : bool, default True
+         (Default value = True)
     ddof : int, default 1
         Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
-        where N represents the number of elements.
+        where N represents the number of elements. (Default value = 1)
     mask : ndarray[bool], optional
-        nan-mask if known
+        nan-mask if known (Default value = None)
 
     Returns
     -------
@@ -809,19 +1012,31 @@
     ddof: int = 1,
     mask: Optional[np.ndarray] = None,
 ) -> float:
-    """
-    Compute the standard error in the mean along given axis while ignoring NaNs
+    """Compute the standard error in the mean along given axis while ignoring NaNs
 
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     ddof : int, default 1
         Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
         where N represents the number of elements.
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    ddof: int :
+         (Default value = 1)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -851,6 +1066,19 @@
 
 
 def _nanminmax(meth, fill_value_typ):
+    """
+
+    Parameters
+    ----------
+    meth :
+        
+    fill_value_typ :
+        
+
+    Returns
+    -------
+
+    """
     @bottleneck_switch(name="nan" + meth)
     def reduction(
         values: np.ndarray,
@@ -858,6 +1086,23 @@
         skipna: bool = True,
         mask: Optional[np.ndarray] = None,
     ) -> Dtype:
+        """
+
+        Parameters
+        ----------
+        values: np.ndarray :
+            
+        axis: Optional[int] :
+             (Default value = None)
+        skipna: bool :
+             (Default value = True)
+        mask: Optional[np.ndarray] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         values, mask, dtype, dtype_max, fill_value = _get_values(
             values, skipna, fill_value_typ=fill_value_typ, mask=mask
@@ -890,13 +1135,25 @@
     mask: Optional[np.ndarray] = None,
 ) -> Union[int, np.ndarray]:
     """
+
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -909,7 +1166,7 @@
     >>> arr = np.array([1, 2, 3, np.nan, 4])
     >>> nanops.nanargmax(arr)
     4
-
+    
     >>> arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
     >>> arr[2:, 2] = np.nan
     >>> arr
@@ -934,13 +1191,25 @@
     mask: Optional[np.ndarray] = None,
 ) -> Union[int, np.ndarray]:
     """
+
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -953,7 +1222,7 @@
     >>> arr = np.array([1, 2, 3, np.nan, 4])
     >>> nanops.nanargmin(arr)
     0
-
+    
     >>> arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
     >>> arr[2:, 0] = np.nan
     >>> arr
@@ -977,9 +1246,8 @@
     skipna: bool = True,
     mask: Optional[np.ndarray] = None,
 ) -> float:
-    """
-    Compute the sample skewness.
-
+    """Compute the sample skewness.
+    
     The statistic computed here is the adjusted Fisher-Pearson standardized
     moment coefficient G1. The algorithm computes this coefficient directly
     from the second and third central moment.
@@ -987,10 +1255,21 @@
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -1061,9 +1340,8 @@
     skipna: bool = True,
     mask: Optional[np.ndarray] = None,
 ) -> float:
-    """
-    Compute the sample excess kurtosis
-
+    """Compute the sample excess kurtosis
+    
     The statistic computed here is the adjusted Fisher-Pearson standardized
     moment coefficient G2, computed directly from the second and fourth
     central moment.
@@ -1071,10 +1349,21 @@
     Parameters
     ----------
     values : ndarray
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -1156,14 +1445,29 @@
     mask: Optional[np.ndarray] = None,
 ) -> float:
     """
+
     Parameters
     ----------
     values : ndarray[dtype]
-    axis: int, optional
+        
+    axis : int, optional
+        
     skipna : bool, default True
-    min_count: int, default 0
+        
+    min_count : int, default 0
+        
     mask : ndarray[bool], optional
         nan-mask if known
+    values: np.ndarray :
+        
+    axis: Optional[int] :
+         (Default value = None)
+    skipna: bool :
+         (Default value = True)
+    min_count: int :
+         (Default value = 0)
+    mask: Optional[np.ndarray] :
+         (Default value = None)
 
     Returns
     -------
@@ -1189,6 +1493,23 @@
 def _maybe_arg_null_out(
     result: np.ndarray, axis: Optional[int], mask: Optional[np.ndarray], skipna: bool
 ) -> Union[np.ndarray, int]:
+    """
+
+    Parameters
+    ----------
+    result: np.ndarray :
+        
+    axis: Optional[int] :
+        
+    mask: Optional[np.ndarray] :
+        
+    skipna: bool :
+        
+
+    Returns
+    -------
+
+    """
     # helper function for nanargmin/nanargmax
     if mask is None:
         return result
@@ -1216,8 +1537,7 @@
     axis: Optional[int],
     dtype: Dtype = float,
 ) -> Union[int, float, np.ndarray]:
-    """
-    Get the count of non-null values along an axis
+    """Get the count of non-null values along an axis
 
     Parameters
     ----------
@@ -1229,10 +1549,21 @@
         axis to count along
     dtype : type, optional
         type to use for count
-
-    Returns
-    -------
-    count : scalar or array
+    values_shape: Tuple[int :
+        
+    ...] :
+        
+    mask: Optional[np.ndarray] :
+        
+    axis: Optional[int] :
+        
+    dtype: Dtype :
+         (Default value = float)
+
+    Returns
+    -------
+
+    
     """
     dtype = _get_dtype(dtype)
     if axis is None:
@@ -1263,10 +1594,26 @@
     min_count: int = 1,
 ) -> float:
     """
-    Returns
-    -------
-    Dtype
-        The product of all elements on a given axis. ( NaNs are treated as 1)
+
+    Parameters
+    ----------
+    result: np.ndarray :
+        
+    axis: Optional[int] :
+        
+    mask: Optional[np.ndarray] :
+        
+    shape: Tuple[int :
+        
+    ...] :
+        
+    min_count: int :
+         (Default value = 1)
+
+    Returns
+    -------
+
+    
     """
     if mask is not None and axis is not None and getattr(result, "ndim", False):
         null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0
@@ -1290,8 +1637,7 @@
 def check_below_min_count(
     shape: Tuple[int, ...], mask: Optional[np.ndarray], min_count: int
 ) -> bool:
-    """
-    Check for the `min_count` keyword. Returns True if below `min_count` (when
+    """Check for the `min_count` keyword. Returns True if below `min_count` (when
     missing value should be returned from the reduction).
 
     Parameters
@@ -1302,10 +1648,19 @@
         Boolean numpy array (typically of same shape as `shape`) or None.
     min_count : int
         Keyword passed through from sum/prod call.
-
-    Returns
-    -------
-    bool
+    shape: Tuple[int :
+        
+    ...] :
+        
+    mask: Optional[np.ndarray] :
+        
+    min_count: int :
+        
+
+    Returns
+    -------
+
+    
     """
     if min_count > 0:
         if mask is None:
@@ -1319,6 +1674,17 @@
 
 
 def _zero_out_fperr(arg):
+    """
+
+    Parameters
+    ----------
+    arg :
+        
+
+    Returns
+    -------
+
+    """
     # #18044 reference this behavior to fix rolling skew/kurt issue
     if isinstance(arg, np.ndarray):
         with np.errstate(invalid="ignore"):
@@ -1331,8 +1697,22 @@
 def nancorr(
     a: np.ndarray, b: np.ndarray, method="pearson", min_periods: Optional[int] = None,
 ):
-    """
-    a, b: ndarrays
+    """a, b: ndarrays
+
+    Parameters
+    ----------
+    a: np.ndarray :
+        
+    b: np.ndarray :
+        
+    method :
+         (Default value = "pearson")
+    min_periods: Optional[int] :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if len(a) != len(b):
         raise AssertionError("Operands to nancorr must have same size")
@@ -1353,10 +1733,34 @@
 
 
 def get_corr_func(method):
+    """
+
+    Parameters
+    ----------
+    method :
+        
+
+    Returns
+    -------
+
+    """
     if method == "kendall":
         from scipy.stats import kendalltau
 
         def func(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return kendalltau(a, b)[0]
 
         return func
@@ -1364,12 +1768,38 @@
         from scipy.stats import spearmanr
 
         def func(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return spearmanr(a, b)[0]
 
         return func
     elif method == "pearson":
 
         def func(a, b):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            b :
+                
+
+            Returns
+            -------
+
+            """
             return np.corrcoef(a, b)[0, 1]
 
         return func
@@ -1389,6 +1819,23 @@
     min_periods: Optional[int] = None,
     ddof: Optional[int] = 1,
 ):
+    """
+
+    Parameters
+    ----------
+    a: np.ndarray :
+        
+    b: np.ndarray :
+        
+    min_periods: Optional[int] :
+         (Default value = None)
+    ddof: Optional[int] :
+         (Default value = 1)
+
+    Returns
+    -------
+
+    """
     if len(a) != len(b):
         raise AssertionError("Operands to nancov must have same size")
 
@@ -1407,6 +1854,17 @@
 
 
 def _ensure_numeric(x):
+    """
+
+    Parameters
+    ----------
+    x :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(x, np.ndarray):
         if is_integer_dtype(x) or is_bool_dtype(x):
             x = x.astype(np.float64)
@@ -1439,7 +1897,31 @@
 
 
 def make_nancomp(op):
+    """
+
+    Parameters
+    ----------
+    op :
+        
+
+    Returns
+    -------
+
+    """
     def f(x, y):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+        y :
+            
+
+        Returns
+        -------
+
+        """
         xmask = isna(x)
         ymask = isna(y)
         mask = xmask | ymask
@@ -1468,23 +1950,32 @@
 def _nanpercentile_1d(
     values: np.ndarray, mask: np.ndarray, q, na_value: Scalar, interpolation
 ) -> Union[Scalar, np.ndarray]:
-    """
-    Wrapper for np.percentile that skips missing values, specialized to
+    """Wrapper for np.percentile that skips missing values, specialized to
     1-dimensional case.
 
     Parameters
     ----------
     values : array over which to find quantiles
+        
     mask : ndarray[bool]
         locations in values that should be considered missing
     q : scalar or array of quantile indices to find
+        
     na_value : scalar
         value to return for empty or all-null values
     interpolation : str
-
-    Returns
-    -------
-    quantiles : scalar or array
+        
+    values: np.ndarray :
+        
+    mask: np.ndarray :
+        
+    na_value: Scalar :
+        
+
+    Returns
+    -------
+
+    
     """
     # mask is Union[ExtensionArray, ndarray]
     values = values[~mask]
@@ -1507,24 +1998,37 @@
     ndim: int,
     interpolation,
 ):
-    """
-    Wrapper for np.percentile that skips missing values.
+    """Wrapper for np.percentile that skips missing values.
 
     Parameters
     ----------
     values : array over which to find quantiles
+        
     q : scalar or array of quantile indices to find
+        
     axis : {0, 1}
+        
     na_value : scalar
         value to return for empty or all-null values
     mask : ndarray[bool]
         locations in values that should be considered missing
     ndim : {1, 2}
+        
     interpolation : str
-
-    Returns
-    -------
-    quantiles : scalar or array
+        
+    values: np.ndarray :
+        
+    axis: int :
+        
+    mask: np.ndarray :
+        
+    ndim: int :
+        
+
+    Returns
+    -------
+
+    
     """
     if values.dtype.kind in ["m", "M"]:
         # need to cast to integer to avoid rounding errors in numpy
@@ -1559,18 +2063,25 @@
 
 
 def na_accum_func(values: ArrayLike, accum_func, skipna: bool) -> ArrayLike:
-    """
-    Cumulative function with skipna support.
+    """Cumulative function with skipna support.
 
     Parameters
     ----------
     values : np.ndarray or ExtensionArray
+        
     accum_func : {np.cumprod, np.maximum.accumulate, np.cumsum, np.minimum.accumulate}
+        
     skipna : bool
-
-    Returns
-    -------
-    np.ndarray or ExtensionArray
+        
+    values: ArrayLike :
+        
+    skipna: bool :
+        
+
+    Returns
+    -------
+
+    
     """
     mask_a, mask_b = {
         np.cumprod: (1.0, np.nan),
