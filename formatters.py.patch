# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/core/formatters.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/core/formatters.py
@@ -32,6 +32,7 @@
 
 
 class DisplayFormatter(Configurable):
+    """ """
 
     active_types = List(Unicode(),
         help="""List of currently active mime-types to display.
@@ -42,10 +43,22 @@
 
     @default('active_types')
     def _active_types_default(self):
+        """ """
         return self.format_types
 
     @observe('active_types')
     def _active_types_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         for key, formatter in self.formatters.items():
             if key in change['new']:
                 formatter.enabled = True
@@ -55,11 +68,13 @@
     ipython_display_formatter = ForwardDeclaredInstance('FormatterABC')
     @default('ipython_display_formatter')
     def _default_formatter(self):
+        """ """
         return IPythonDisplayFormatter(parent=self)
 
     mimebundle_formatter = ForwardDeclaredInstance('FormatterABC')
     @default('mimebundle_formatter')
     def _default_mime_formatter(self):
+        """ """
         return MimeBundleFormatter(parent=self)
 
     # A dict of formatter whose keys are format types (MIME types) and whose
@@ -88,11 +103,11 @@
 
     def format(self, obj, include=None, exclude=None):
         """Return a format data dict for an object.
-
+        
         By default all format types will be computed.
-
+        
         The following MIME types are usually implemented:
-
+        
         * text/plain
         * text/html
         * text/markdown
@@ -111,34 +126,31 @@
         include : list, tuple or set; optional
             A list of format type strings (MIME types) to include in the
             format data dict. If this is set *only* the format types included
-            in this list will be computed.
+            in this list will be computed. (Default value = None)
         exclude : list, tuple or set; optional
             A list of format type string (MIME types) to exclude in the format
             data dict. If this is set all format types will be computed,
             except for those included in this argument.
-            Mimetypes present in exclude will take precedence over the ones in include
+            Mimetypes present in exclude will take precedence over the ones in include (Default value = None)
 
         Returns
         -------
         (format_dict, metadata_dict) : tuple of two dicts
-        
             format_dict is a dictionary of key/value pairs, one of each format that was
             generated for the object. The keys are the format types, which
             will usually be MIME type strings and the values and JSON'able
             data structure containing the raw data for the representation in
             that format.
-            
             metadata_dict is a dictionary of metadata about each mime-type output.
             Its keys will be a strict subset of the keys in format_dict.
 
         Notes
         -----
-
+        
             If an object implement `_repr_mimebundle_` as well as various
             `_repr_*_`, the data returned by `_repr_mimebundle_` will take
             precedence and the corresponding `_repr_*_` for this mimetype will
             not be called.
-
         """
         format_dict = {}
         md_dict = {}
@@ -194,7 +206,7 @@
 
     @property
     def format_types(self):
-        """Return the format types (MIME types) of the active formatters."""
+        """ """
         return list(self.formatters.keys())
 
 
@@ -205,8 +217,17 @@
 
 def _safe_repr(obj):
     """Try to return a repr of an object
-
+    
     always returns a string, at least.
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
     """
     try:
         return repr(obj)
@@ -219,7 +240,21 @@
 
 @decorator
 def catch_format_error(method, self, *args, **kwargs):
-    """show traceback on failed format call"""
+    """show traceback on failed format call
+
+    Parameters
+    ----------
+    method :
+        
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     try:
         r = method(self, *args, **kwargs)
     except NotImplementedError:
@@ -237,12 +272,19 @@
 
 
 class FormatterABC(metaclass=abc.ABCMeta):
-    """ Abstract base class for Formatters.
-
+    """Abstract base class for Formatters.
+    
     A formatter is a callable class that is responsible for computing the
     raw format data for a particular format type (MIME type). For example,
     an HTML formatter would have a format type of `text/html` and would return
     the HTML representation of the object when called.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # The format type of the data returned, usually a MIME type.
@@ -262,9 +304,18 @@
 
 
 def _mod_name_key(typ):
-    """Return a (__module__, __name__) tuple for a type.
-    
-    Used as key in Formatter.deferred_printers.
+    """
+
+    Parameters
+    ----------
+    typ :
+        
+
+    Returns
+    -------
+    type
+        Used as key in Formatter.deferred_printers.
+
     """
     module = getattr(typ, '__module__', None)
     name = getattr(typ, '__name__', None)
@@ -272,7 +323,19 @@
 
 
 def _get_type(obj):
-    """Return the type of an instance (old and new-style)"""
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     return getattr(obj, '__class__', None) or type(obj)
 
 
@@ -286,27 +349,35 @@
 
 class BaseFormatter(Configurable):
     """A base formatter class that is configurable.
-
+    
     This formatter should usually be used as the base class of all formatters.
     It is a traited :class:`Configurable` class and includes an extensible
     API for users to determine how their objects are formatted. The following
     logic is used to find a function to format an given object.
-
+    
     1. The object is introspected to see if it has a method with the name
        :attr:`print_method`. If is does, that object is passed to that method
        for formatting.
     2. If no print method is found, three internal dictionaries are consulted
        to find print method: :attr:`singleton_printers`, :attr:`type_printers`
        and :attr:`deferred_printers`.
-
+    
     Users should use these dictionaries to register functions that will be
     used to compute the format data for their objects (if those objects don't
     have the special print methods). The easiest way of using these
     dictionaries is through the :meth:`for_type` and :meth:`for_type_by_name`
     methods.
-
+    
     If no function/callable is found to compute the format data, ``None`` is
-    returned and this format type is not used.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        
+
     """
 
     format_type = Unicode('text/plain')
@@ -358,8 +429,19 @@
     
     def _check_return(self, r, obj):
         """Check that a return value is appropriate
-        
-        Return the value if so, None otherwise, warning if invalid.
+
+        Parameters
+        ----------
+        r :
+            
+        obj :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         if r is None or isinstance(r, self._return_type) or \
             (isinstance(r, tuple) and r and isinstance(r[0], self._return_type)):
@@ -373,19 +455,18 @@
     
     def lookup(self, obj):
         """Look up the formatter for a given instance.
-        
+
         Parameters
         ----------
-        obj  : object instance
+        obj : object instance
+            
 
         Returns
         -------
         f : callable
             The registered formatting callable for the type.
 
-        Raises
-        ------
-        KeyError if the type has not been registered.
+        
         """
         # look for singleton first
         obj_id = id(obj)
@@ -399,16 +480,15 @@
 
         Parameters
         ----------
-        typ  : type or '__module__.__name__' string for a type
+        typ : type or '__module__.__name__' string for a type
+            
 
         Returns
         -------
         f : callable
             The registered formatting callable for the type.
 
-        Raises
-        ------
-        KeyError if the type has not been registered.
+        
         """
         if isinstance(typ, str):
             typ_key = tuple(typ.rsplit('.',1))
@@ -430,7 +510,7 @@
 
     def for_type(self, typ, func=None):
         """Add a format function for a given type.
-        
+
         Parameters
         ----------
         typ : type or '__module__.__name__' string for a type
@@ -441,16 +521,13 @@
             and will return the raw data in this formatter's format.
             Subclasses may use a different call signature for the
             `func` argument.
-            
             If `func` is None or not specified, there will be no change,
-            only returning the current value.
-        
+            only returning the current value. (Default value = None)
+
         Returns
         -------
-        oldfunc : callable
-            The currently registered callable.
-            If you are registering a new formatter,
-            this will be the previous value (to enable restoring later).
+
+        
         """
         # if string given, interpret as 'pkg.module.class_name'
         if isinstance(typ, str):
@@ -484,16 +561,13 @@
             and will return the raw data in this formatter's format.
             Subclasses may use a different call signature for the
             `func` argument.
-            
             If `func` is None or unspecified, there will be no change,
-            only returning the current value.
-        
+            only returning the current value. (Default value = None)
+
         Returns
         -------
-        oldfunc : callable
-            The currently registered callable.
-            If you are registering a new formatter,
-            this will be the previous value (to enable restoring later).
+
+        
         """
         key = (type_module, type_name)
         
@@ -512,17 +586,16 @@
         Parameters
         ----------
         typ : type or '__module__.__name__' string for a type
+            
         default : object
-            value to be returned if no formatter is registered for typ.
+            value to be returned if no formatter is registered for typ. (Default value = _raise_key_error)
 
         Returns
         -------
         obj : object
             The last registered object for the type.
 
-        Raises
-        ------
-        KeyError if the type is not registered and default is not specified.
+        
         """
         
         if isinstance(typ, str):
@@ -548,10 +621,16 @@
         return old
 
     def _in_deferred_types(self, cls):
-        """
-        Check if the given class is specified in the deferred type registry.
-
+        """Check if the given class is specified in the deferred type registry.
+        
         Successful matches will be moved to the regular type registry for future use.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         mod = getattr(cls, '__module__', None)
         name = getattr(cls, '__name__', None)
@@ -566,26 +645,33 @@
 
 class PlainTextFormatter(BaseFormatter):
     """The default pretty-printer.
-
+    
     This uses :mod:`IPython.lib.pretty` to compute the format data of
     the object. If the object cannot be pretty printed, :func:`repr` is used.
     See the documentation of :mod:`IPython.lib.pretty` for details on
     how to write pretty printers.  Here is a simple example::
-
+    
         def dtype_pprinter(obj, p, cycle):
             if cycle:
-                return p.text('dtype(...)')
-            if hasattr(obj, 'fields'):
-                if obj.fields is None:
-                    p.text(repr(obj))
-                else:
-                    p.begin_group(7, 'dtype([')
-                    for i, field in enumerate(obj.descr):
-                        if i > 0:
-                            p.text(',')
-                            p.breakable()
-                        p.pretty(field)
-                    p.end_group(7, '])')
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        if hasattr(obj, 'fields'):
+        if obj.fields is None:
+        p.text(repr(obj))
+        else:
+        p.begin_group(7, 'dtype([')
+        for i, field in enumerate(obj.descr):
+        if i > 0:
+        p.text(',')
+        p.breakable()
+        p.pretty(field)
+        p.end_group(7, '])')
+
     """
 
     # The format type of data returned.
@@ -625,16 +711,25 @@
     @observe('float_precision')
     def _float_precision_changed(self, change):
         """float_precision changed, set float_format accordingly.
-
+        
         float_precision can be set by int or str.
         This will set float_format, after interpreting input.
         If numpy has been imported, numpy print precision will also be set.
-
+        
         integer `n` sets format to '%.nf', otherwise, format set directly.
-
+        
         An empty string returns to defaults (repr for float, 8 for numpy).
-
+        
         This parameter can be set via the '%precision' magic.
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
         """
 
         new = change['new']
@@ -672,16 +767,19 @@
     # Use the default pretty printers from IPython.lib.pretty.
     @default('singleton_printers')
     def _singleton_printers_default(self):
+        """ """
         return pretty._singleton_pprinters.copy()
 
     @default('type_printers')
     def _type_printers_default(self):
+        """ """
         d = pretty._type_pprinters.copy()
         d[float] = lambda obj,p,cycle: p.text(self.float_format%obj)
         return d
 
     @default('deferred_printers')
     def _deferred_printers_default(self):
+        """ """
         return pretty._deferred_type_pprinters.copy()
 
     #### FormatterABC interface ####
@@ -706,15 +804,22 @@
 
 class HTMLFormatter(BaseFormatter):
     """An HTML formatter.
-
+    
     To define the callables that compute the HTML representation of your
     objects, define a :meth:`_repr_html_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be a valid HTML snippet that
     could be injected into an existing DOM. It should *not* include the
     ```<html>`` or ```<body>`` tags.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('text/html')
 
@@ -723,13 +828,20 @@
 
 class MarkdownFormatter(BaseFormatter):
     """A Markdown formatter.
-
+    
     To define the callables that compute the Markdown representation of your
     objects, define a :meth:`_repr_markdown_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be a valid Markdown.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('text/markdown')
 
@@ -737,15 +849,22 @@
 
 class SVGFormatter(BaseFormatter):
     """An SVG formatter.
-
+    
     To define the callables that compute the SVG representation of your
     objects, define a :meth:`_repr_svg_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be valid SVG enclosed in
     ```<svg>``` tags, that could be injected into an existing DOM. It should
     *not* include the ```<html>`` or ```<body>`` tags.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('image/svg+xml')
 
@@ -754,14 +873,21 @@
 
 class PNGFormatter(BaseFormatter):
     """A PNG formatter.
-
+    
     To define the callables that compute the PNG representation of your
     objects, define a :meth:`_repr_png_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be raw PNG data, *not*
     base64 encoded.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('image/png')
 
@@ -772,14 +898,21 @@
 
 class JPEGFormatter(BaseFormatter):
     """A JPEG formatter.
-
+    
     To define the callables that compute the JPEG representation of your
     objects, define a :meth:`_repr_jpeg_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be raw JPEG data, *not*
     base64 encoded.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('image/jpeg')
 
@@ -790,15 +923,22 @@
 
 class LatexFormatter(BaseFormatter):
     """A LaTeX formatter.
-
+    
     To define the callables that compute the LaTeX representation of your
     objects, define a :meth:`_repr_latex_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be a valid LaTeX equation,
     enclosed in either ```$```, ```$$``` or another LaTeX equation
     environment.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('text/latex')
 
@@ -807,14 +947,21 @@
 
 class JSONFormatter(BaseFormatter):
     """A JSON string formatter.
-
+    
     To define the callables that compute the JSONable representation of
     your objects, define a :meth:`_repr_json_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be a JSONable list or dict.
     JSON scalars (None, number, string) are not allowed, only dict or list containers.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('application/json')
     _return_type = (list, dict)
@@ -823,8 +970,19 @@
     
     def _check_return(self, r, obj):
         """Check that a return value is appropriate
-        
-        Return the value if so, None otherwise, warning if invalid.
+
+        Parameters
+        ----------
+        r :
+            
+        obj :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         if r is None:
             return
@@ -847,14 +1005,21 @@
 
 class JavascriptFormatter(BaseFormatter):
     """A Javascript formatter.
-
+    
     To define the callables that compute the Javascript representation of
     your objects, define a :meth:`_repr_javascript_` method or use the
     :meth:`for_type` or :meth:`for_type_by_name` methods to register functions
     that handle this.
-
+    
     The return value of this formatter should be valid Javascript code and
     should *not* be enclosed in ```<script>``` tags.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('application/javascript')
 
@@ -863,14 +1028,21 @@
 
 class PDFFormatter(BaseFormatter):
     """A PDF formatter.
-
+    
     To define the callables that compute the PDF representation of your
     objects, define a :meth:`_repr_pdf_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     The return value of this formatter should be raw PDF data, *not*
     base64 encoded.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     format_type = Unicode('application/pdf')
 
@@ -889,13 +1061,20 @@
     
     This display formatter has highest priority.
     If it fires, no other display formatter will be called.
-
+    
     Prior to IPython 6.1, `_ipython_display_` was the only way to display custom mime-types
     without registering a new Formatter.
     
     IPython 6.1 introduces `_repr_mimebundle_` for displaying custom mime-types,
     so `_ipython_display_` should only be used for objects that require unusual
     display patterns, such as multiple display calls.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     print_method = ObjectName('_ipython_display_')
     _return_type = (type(None), bool)
@@ -921,23 +1100,43 @@
 
 class MimeBundleFormatter(BaseFormatter):
     """A Formatter for arbitrary mime-types.
-
+    
     Unlike other `_repr_<mimetype>_` methods,
     `_repr_mimebundle_` should return mime-bundle data,
     either the mime-keyed `data` dictionary or the tuple `(data, metadata)`.
     Any mime-type is valid.
-
+    
     To define the callables that compute the mime-bundle representation of your
     objects, define a :meth:`_repr_mimebundle_` method or use the :meth:`for_type`
     or :meth:`for_type_by_name` methods to register functions that handle
     this.
-
+    
     .. versionadded:: 6.1
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     print_method = ObjectName('_repr_mimebundle_')
     _return_type = dict
     
     def _check_return(self, r, obj):
+        """
+
+        Parameters
+        ----------
+        r :
+            
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         r = super(MimeBundleFormatter, self)._check_return(r, obj)
         # always return (data, metadata):
         if r is None:
@@ -990,30 +1189,22 @@
 
 def format_display_data(obj, include=None, exclude=None):
     """Return a format data dict for an object.
-
+    
     By default all format types will be computed.
 
     Parameters
     ----------
     obj : object
         The Python object whose format data will be computed.
-
-    Returns
-    -------
-    format_dict : dict
-        A dictionary of key/value pairs, one or each format that was
-        generated for the object. The keys are the format types, which
-        will usually be MIME type strings and the values and JSON'able
-        data structure containing the raw data for the representation in
-        that format.
-    include : list or tuple, optional
-        A list of format type strings (MIME types) to include in the
-        format data dict. If this is set *only* the format types included
-        in this list will be computed.
-    exclude : list or tuple, optional
-        A list of format type string (MIME types) to exclude in the format
-        data dict. If this is set all format types will be computed,
-        except for those included in this argument.
+    include :
+         (Default value = None)
+    exclude :
+         (Default value = None)
+
+    Returns
+    -------
+
+    
     """
     from .interactiveshell import InteractiveShell
 
