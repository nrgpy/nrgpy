# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/ctypeslib.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/ctypeslib.py
@@ -65,14 +65,19 @@
 
 if ctypes is None:
     def _dummy(*args, **kwds):
-        """
-        Dummy object that raises an ImportError if ctypes is not available.
-
-        Raises
-        ------
-        ImportError
-            If ctypes is not available.
-
+        """Dummy object that raises an ImportError if ctypes is not available.
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwds :
+            
+
+        Returns
+        -------
+
+        
         """
         raise ImportError("ctypes is not available.")
     ctypes_load_library = _dummy
@@ -89,10 +94,8 @@
 
     # Adapted from Albert Strasheim
     def load_library(libname, loader_path):
-        """
-        It is possible to load a library using
-        >>> lib = ctypes.cdll[<full_path_name>] # doctest: +SKIP
-
+        """It is possible to load a library using
+        
         But there are cross-platform considerations, such as library file extensions,
         plus the fact Windows will just load the first library it finds with that name.
         NumPy supplies the load_library function as a convenience.
@@ -108,13 +111,10 @@
         Returns
         -------
         ctypes.cdll[libpath] : library object
-           A ctypes library object
-
-        Raises
-        ------
-        OSError
-            If there is no library with the expected extension, or the
-            library is defective and cannot be loaded.
+            A ctypes library object
+
+        
+        >>> lib = ctypes.cdll[<full_path_name>] # doctest: +SKIP
         """
         if ctypes.__version__ < '1.0.1':
             import warnings
@@ -158,6 +158,17 @@
                                     'load_library')
 
 def _num_fromflags(flaglist):
+    """
+
+    Parameters
+    ----------
+    flaglist :
+        
+
+    Returns
+    -------
+
+    """
     num = 0
     for val in flaglist:
         num += _flagdict[val]
@@ -166,6 +177,17 @@
 _flagnames = ['C_CONTIGUOUS', 'F_CONTIGUOUS', 'ALIGNED', 'WRITEABLE',
               'OWNDATA', 'UPDATEIFCOPY', 'WRITEBACKIFCOPY']
 def _flags_fromnum(num):
+    """
+
+    Parameters
+    ----------
+    num :
+        
+
+    Returns
+    -------
+
+    """
     res = []
     for key in _flagnames:
         value = _flagdict[key]
@@ -175,8 +197,20 @@
 
 
 class _ndptr(_ndptr_base):
+    """ """
     @classmethod
     def from_param(cls, obj):
+        """
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(obj, ndarray):
             raise TypeError("argument must be an ndarray")
         if cls._dtype_ is not None \
@@ -196,26 +230,44 @@
 
 
 class _concrete_ndptr(_ndptr):
-    """
-    Like _ndptr, but with `_shape_` and `_dtype_` specified.
-
+    """Like _ndptr, but with `_shape_` and `_dtype_` specified.
+    
     Notably, this means the pointer has enough information to reconstruct
     the array, which is not generally true.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def _check_retval_(self):
-        """
-        This method is called when this class is used as the .restype
+        """This method is called when this class is used as the .restype
         attribute for a shared-library function, to automatically wrap the
         pointer into an array.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self.contents
 
     @property
     def contents(self):
-        """
-        Get an ndarray viewing the data pointed to by this pointer.
-
+        """Get an ndarray viewing the data pointed to by this pointer.
+        
         This mirrors the `contents` attribute of a normal ctypes pointer
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         full_dtype = _dtype((self._dtype_, self._shape_))
         full_ctype = ctypes.c_char * full_dtype.itemsize
@@ -227,9 +279,8 @@
 #  use with ctypes argtypes mechanism
 _pointer_type_cache = {}
 def ndpointer(dtype=None, ndim=None, shape=None, flags=None):
-    """
-    Array-checking restype/argtypes.
-
+    """Array-checking restype/argtypes.
+    
     An ndpointer instance is used to describe an ndarray in restypes
     and argtypes specifications.  This approach is more flexible than
     using, for example, ``POINTER(c_double)``, since several restrictions
@@ -241,21 +292,20 @@
     Parameters
     ----------
     dtype : data-type, optional
-        Array data-type.
+        Array data-type. (Default value = None)
     ndim : int, optional
-        Number of array dimensions.
+        Number of array dimensions. (Default value = None)
     shape : tuple of ints, optional
-        Array shape.
+        Array shape. (Default value = None)
     flags : str or tuple of str
         Array flags; may be one or more of:
-
-          - C_CONTIGUOUS / C / CONTIGUOUS
-          - F_CONTIGUOUS / F / FORTRAN
-          - OWNDATA / O
-          - WRITEABLE / W
-          - ALIGNED / A
-          - WRITEBACKIFCOPY / X
-          - UPDATEIFCOPY / U
+        - C_CONTIGUOUS / C / CONTIGUOUS
+        - F_CONTIGUOUS / F / FORTRAN
+        - OWNDATA / O
+        - WRITEABLE / W
+        - ALIGNED / A
+        - WRITEBACKIFCOPY / X
+        - UPDATEIFCOPY / U (Default value = None)
 
     Returns
     -------
@@ -276,7 +326,6 @@
     ... #doctest: +SKIP
     >>> clib.somefunc(np.array([1, 2, 3], dtype=np.float64))
     ... #doctest: +SKIP
-
     """
 
     # normalize dtype to an Optional[dtype]
@@ -346,7 +395,19 @@
 
 if ctypes is not None:
     def _ctype_ndarray(element_type, shape):
-        """ Create an ndarray of the given element type and shape """
+        """Create an ndarray of the given element type and shape
+
+        Parameters
+        ----------
+        element_type :
+            
+        shape :
+            
+
+        Returns
+        -------
+
+        """
         for dim in shape[::-1]:
             element_type = dim * element_type
             # prevent the type name include np.ctypeslib
@@ -355,9 +416,7 @@
 
 
     def _get_scalar_type_map():
-        """
-        Return a dictionary mapping native endian scalar dtype to ctypes types
-        """
+        """ """
         ct = ctypes
         simple_types = [
             ct.c_byte, ct.c_short, ct.c_int, ct.c_long, ct.c_longlong,
@@ -372,6 +431,17 @@
 
 
     def _ctype_from_dtype_scalar(dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # swapping twice ensure that `=` is promoted to <, >, or |
         dtype_with_endian = dtype.newbyteorder('S').newbyteorder('S')
         dtype_native = dtype.newbyteorder('=')
@@ -391,12 +461,34 @@
 
 
     def _ctype_from_dtype_subarray(dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         element_dtype, shape = dtype.subdtype
         ctype = _ctype_from_dtype(element_dtype)
         return _ctype_ndarray(ctype, shape)
 
 
     def _ctype_from_dtype_structured(dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # extract offsets of each field
         field_data = []
         for name in dtype.names:
@@ -451,6 +543,17 @@
 
 
     def _ctype_from_dtype(dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         if dtype.fields is not None:
             return _ctype_from_dtype_structured(dtype)
         elif dtype.subdtype is not None:
@@ -460,7 +563,7 @@
 
 
     def as_ctypes_type(dtype):
-        r"""
+        """r"""
         Convert a dtype into a ctypes type.
 
         Parameters
@@ -481,33 +584,41 @@
         Notes
         -----
         This function does not losslessly round-trip in either direction.
-
+        
         ``np.dtype(as_ctypes_type(dt))`` will:
-
+        
          - insert padding fields
          - reorder fields to be sorted by offset
          - discard field titles
-
+        
         ``as_ctypes_type(np.dtype(ctype))`` will:
-
+        
          - discard the class names of `ctypes.Structure`\ s and
            `ctypes.Union`\ s
          - convert single-element `ctypes.Union`\ s into single-element
            `ctypes.Structure`\ s
          - insert padding fields
-
-        """
         return _ctype_from_dtype(_dtype(dtype))
 
 
     def as_array(obj, shape=None):
-        """
-        Create a numpy array from a ctypes array or POINTER.
-
+        """Create a numpy array from a ctypes array or POINTER.
+        
         The numpy array shares the memory with the ctypes object.
-
+        
         The shape parameter must be given if converting from a ctypes POINTER.
         The shape parameter is ignored if converting from a ctypes array
+
+        Parameters
+        ----------
+        obj :
+            
+        shape :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if isinstance(obj, ctypes._Pointer):
             # convert pointers to an array of the desired shape
@@ -523,7 +634,17 @@
 
     def as_ctypes(obj):
         """Create and return a ctypes object from a numpy array.  Actually
-        anything that exposes the __array_interface__ is accepted."""
+        anything that exposes the __array_interface__ is accepted.
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         ai = obj.__array_interface__
         if ai["strides"]:
             raise TypeError("strided arrays not supported")
