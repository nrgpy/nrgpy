# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/locks.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/locks.py
@@ -30,12 +30,19 @@
 
 class _TimeoutGarbageCollector(object):
     """Base class for objects that periodically clean up timed-out waiters.
-
+    
     Avoids memory leak in a common pattern like:
-
+    
         while True:
             yield condition.wait(short_timeout)
             print('looping....')
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self) -> None:
@@ -43,6 +50,7 @@
         self._timeouts = 0
 
     def _garbage_collect(self) -> None:
+        """ """
         # Occasionally clear timed-out waiters.
         self._timeouts += 1
         if self._timeouts > 100:
@@ -52,62 +60,69 @@
 
 class Condition(_TimeoutGarbageCollector):
     """A condition allows one or more coroutines to wait until notified.
-
+    
     Like a standard `threading.Condition`, but does not need an underlying lock
     that is acquired and released.
-
+    
     With a `Condition`, coroutines can wait to be notified by other coroutines:
-
+    
     .. testcode::
-
+    
         from tornado import gen
         from tornado.ioloop import IOLoop
         from tornado.locks import Condition
-
+    
         condition = Condition()
-
+    
         async def waiter():
             print("I'll wait right here")
             await condition.wait()
             print("I'm done waiting")
-
+    
         async def notifier():
             print("About to notify")
             condition.notify()
             print("Done notifying")
-
+    
         async def runner():
             # Wait for waiter() and notifier() in parallel
             await gen.multi([waiter(), notifier()])
-
+    
         IOLoop.current().run_sync(runner)
-
+    
     .. testoutput::
-
+    
         I'll wait right here
         About to notify
         Done notifying
         I'm done waiting
-
+    
     `wait` takes an optional ``timeout`` argument, which is either an absolute
     timestamp::
-
+    
         io_loop = IOLoop.current()
-
+    
         # Wait up to 1 second for a notification.
         await condition.wait(timeout=io_loop.time() + 1)
-
+    
     ...or a `datetime.timedelta` for a timeout relative to the current time::
-
+    
         # Wait up to 1 second.
         await condition.wait(timeout=datetime.timedelta(seconds=1))
-
+    
     The method returns False if there's no notification before the deadline.
-
+    
     .. versionchanged:: 5.0
        Previously, waiters could be notified synchronously from within
        `notify`. Now, the notification will always be received on the
        next iteration of the `.IOLoop`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self) -> None:
@@ -124,15 +139,27 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[bool]:
         """Wait for `.notify`.
-
+        
         Returns a `.Future` that resolves ``True`` if the condition is notified,
         or ``False`` after a timeout.
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         waiter = Future()  # type: Future[bool]
         self._waiters.append(waiter)
         if timeout:
 
             def on_timeout() -> None:
+                """ """
                 if not waiter.done():
                     future_set_result_unless_cancelled(waiter, False)
                 self._garbage_collect()
@@ -143,7 +170,17 @@
         return waiter
 
     def notify(self, n: int = 1) -> None:
-        """Wake ``n`` waiters."""
+        """Wake ``n`` waiters.
+
+        Parameters
+        ----------
+        n: int :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         waiters = []  # Waiters we plan to run right now.
         while n and self._waiters:
             waiter = self._waiters.popleft()
@@ -161,42 +198,49 @@
 
 class Event(object):
     """An event blocks coroutines until its internal flag is set to True.
-
+    
     Similar to `threading.Event`.
-
+    
     A coroutine can wait for an event to be set. Once it is set, calls to
     ``yield event.wait()`` will not block unless the event has been cleared:
-
+    
     .. testcode::
-
+    
         from tornado import gen
         from tornado.ioloop import IOLoop
         from tornado.locks import Event
-
+    
         event = Event()
-
+    
         async def waiter():
             print("Waiting for event")
             await event.wait()
             print("Not waiting this time")
             await event.wait()
             print("Done")
-
+    
         async def setter():
             print("About to set the event")
             event.set()
-
+    
         async def runner():
             await gen.multi([waiter(), setter()])
-
+    
         IOLoop.current().run_sync(runner)
-
+    
     .. testoutput::
-
+    
         Waiting for event
         About to set the event
         Not waiting this time
         Done
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self) -> None:
@@ -210,13 +254,20 @@
         )
 
     def is_set(self) -> bool:
-        """Return ``True`` if the internal flag is true."""
+        """ """
         return self._value
 
     def set(self) -> None:
         """Set the internal flag to ``True``. All waiters are awakened.
-
+        
         Calling `.wait` once the flag is set will not block.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not self._value:
             self._value = True
@@ -227,8 +278,15 @@
 
     def clear(self) -> None:
         """Reset the internal flag to ``False``.
-
+        
         Calls to `.wait` will block until `.set` is called.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self._value = False
 
@@ -236,9 +294,20 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[None]:
         """Block until the internal flag is true.
-
+        
         Returns an awaitable, which raises `tornado.util.TimeoutError` after a
         timeout.
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         fut = Future()  # type: Future[None]
         if self._value:
@@ -261,11 +330,18 @@
 
 class _ReleasingContextManager(object):
     """Releases a Lock or Semaphore at the end of a "with" statement.
-
+    
         with (yield semaphore.acquire()):
             pass
-
+    
         # Now semaphore.release() has been called.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, obj: Any) -> None:
@@ -285,97 +361,102 @@
 
 class Semaphore(_TimeoutGarbageCollector):
     """A lock that can be acquired a fixed number of times before blocking.
-
+    
     A Semaphore manages a counter representing the number of `.release` calls
     minus the number of `.acquire` calls, plus an initial value. The `.acquire`
     method blocks if necessary until it can return without making the counter
     negative.
-
+    
     Semaphores limit access to a shared resource. To allow access for two
     workers at a time:
-
+    
     .. testsetup:: semaphore
-
+    
        from collections import deque
-
+    
        from tornado import gen
        from tornado.ioloop import IOLoop
        from tornado.concurrent import Future
-
+    
        # Ensure reliable doctest output: resolve Futures one at a time.
        futures_q = deque([Future() for _ in range(3)])
-
+    
        async def simulator(futures):
            for f in futures:
                # simulate the asynchronous passage of time
                await gen.sleep(0)
                await gen.sleep(0)
                f.set_result(None)
-
+    
        IOLoop.current().add_callback(simulator, list(futures_q))
-
+    
        def use_some_resource():
-           return futures_q.popleft()
-
-    .. testcode:: semaphore
-
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        .. testcode:: semaphore
+        
         from tornado import gen
         from tornado.ioloop import IOLoop
         from tornado.locks import Semaphore
-
+        
         sem = Semaphore(2)
-
+        
         async def worker(worker_id):
-            await sem.acquire()
-            try:
-                print("Worker %d is working" % worker_id)
-                await use_some_resource()
-            finally:
-                print("Worker %d is done" % worker_id)
-                sem.release()
-
+        await sem.acquire()
+        try:
+        print("Worker %d is working" % worker_id)
+        await use_some_resource()
+        finally:
+        print("Worker %d is done" % worker_id)
+        sem.release()
+        
         async def runner():
-            # Join all workers.
-            await gen.multi([worker(i) for i in range(3)])
-
+        # Join all workers.
+        await gen.multi([worker(i) for i in range(3)])
+        
         IOLoop.current().run_sync(runner)
-
-    .. testoutput:: semaphore
-
+        
+        .. testoutput:: semaphore
+        
         Worker 0 is working
         Worker 1 is working
         Worker 0 is done
         Worker 2 is working
         Worker 1 is done
         Worker 2 is done
-
-    Workers 0 and 1 are allowed to run concurrently, but worker 2 waits until
-    the semaphore has been released once, by worker 0.
-
-    The semaphore can be used as an async context manager::
-
+        
+        Workers 0 and 1 are allowed to run concurrently, but worker 2 waits until
+        the semaphore has been released once, by worker 0.
+        
+        The semaphore can be used as an async context manager::
+        
         async def worker(worker_id):
-            async with sem:
-                print("Worker %d is working" % worker_id)
-                await use_some_resource()
-
-            # Now the semaphore has been released.
-            print("Worker %d is done" % worker_id)
-
-    For compatibility with older versions of Python, `.acquire` is a
-    context manager, so ``worker`` could also be written as::
-
+        async with sem:
+        print("Worker %d is working" % worker_id)
+        await use_some_resource()
+        
+        # Now the semaphore has been released.
+        print("Worker %d is done" % worker_id)
+        
+        For compatibility with older versions of Python, `.acquire` is a
+        context manager, so ``worker`` could also be written as::
+        
         @gen.coroutine
         def worker(worker_id):
-            with (yield sem.acquire()):
-                print("Worker %d is working" % worker_id)
-                yield use_some_resource()
-
-            # Now the semaphore has been released.
-            print("Worker %d is done" % worker_id)
-
-    .. versionchanged:: 4.3
-       Added ``async with`` support in Python 3.5.
+        with (yield sem.acquire()):
+        print("Worker %d is working" % worker_id)
+        yield use_some_resource()
+        
+        # Now the semaphore has been released.
+        print("Worker %d is done" % worker_id)
+        
+        .. versionchanged:: 4.3
+        Added ``async with`` support in Python 3.5.
 
     """
 
@@ -416,9 +497,20 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[_ReleasingContextManager]:
         """Decrement the counter. Returns an awaitable.
-
+        
         Block if the counter is zero and wait for a `.release`. The awaitable
         raises `.TimeoutError` after the deadline.
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         waiter = Future()  # type: Future[_ReleasingContextManager]
         if self._value > 0:
@@ -429,6 +521,7 @@
             if timeout:
 
                 def on_timeout() -> None:
+                    """ """
                     if not waiter.done():
                         waiter.set_exception(gen.TimeoutError())
                     self._garbage_collect()
@@ -465,11 +558,18 @@
 
 class BoundedSemaphore(Semaphore):
     """A semaphore that prevents release() being called too many times.
-
+    
     If `.release` would increment the semaphore's value past the initial
     value, it raises `ValueError`. Semaphores are mostly used to guard
     resources with limited capacity, so a semaphore released too many times
     is a sign of a bug.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, value: int = 1) -> None:
@@ -485,15 +585,29 @@
 
 class Lock(object):
     """A lock for coroutines.
-
+    
     A Lock begins unlocked, and `acquire` locks it immediately. While it is
     locked, a coroutine that yields `acquire` waits until another coroutine
     calls `release`.
-
+    
     Releasing an unlocked lock raises `RuntimeError`.
-
+    
     A Lock can be used as an async context manager with the ``async
     with`` statement:
+    
+    
+    For compatibility with older versions of Python, the `.acquire`
+    method asynchronously returns a regular context manager:
+    
+    
+    .. versionchanged:: 4.3
+       Added ``async with`` support in Python 3.5.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     >>> from tornado import locks
     >>> lock = locks.Lock()
@@ -504,20 +618,13 @@
     ...        pass
     ...
     ...    # Now the lock is released.
-
-    For compatibility with older versions of Python, the `.acquire`
-    method asynchronously returns a regular context manager:
-
+    
     >>> async def f2():
     ...    with (yield lock.acquire()):
     ...        # Do something holding the lock.
     ...        pass
     ...
     ...    # Now the lock is released.
-
-    .. versionchanged:: 4.3
-       Added ``async with`` support in Python 3.5.
-
     """
 
     def __init__(self) -> None:
@@ -530,18 +637,36 @@
         self, timeout: Optional[Union[float, datetime.timedelta]] = None
     ) -> Awaitable[_ReleasingContextManager]:
         """Attempt to lock. Returns an awaitable.
-
+        
         Returns an awaitable, which raises `tornado.util.TimeoutError` after a
         timeout.
+
+        Parameters
+        ----------
+        timeout: Optional[Union[float :
+            
+        datetime.timedelta]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         return self._block.acquire(timeout)
 
     def release(self) -> None:
         """Unlock.
-
+        
         The first coroutine in line waiting for `acquire` gets the lock.
-
+        
         If not locked, raise a `RuntimeError`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         try:
             self._block.release()
