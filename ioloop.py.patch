# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/ioloop.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/ioloop.py
@@ -64,10 +64,13 @@
 
 
 class _Selectable(Protocol):
+    """ """
     def fileno(self) -> int:
+        """ """
         pass
 
     def close(self) -> None:
+        """ """
         pass
 
 
@@ -77,78 +80,84 @@
 
 class IOLoop(Configurable):
     """An I/O event loop.
-
+    
     As of Tornado 6.0, `IOLoop` is a wrapper around the `asyncio` event
     loop.
-
+    
     Example usage for a simple TCP server:
-
+    
     .. testcode::
-
+    
         import errno
         import functools
         import socket
-
+    
         import tornado.ioloop
         from tornado.iostream import IOStream
-
+    
         async def handle_connection(connection, address):
             stream = IOStream(connection)
             message = await stream.read_until_close()
             print("message from client:", message.decode().strip())
-
+    
         def connection_ready(sock, fd, events):
             while True:
                 try:
                     connection, address = sock.accept()
                 except BlockingIOError:
-                    return
-                connection.setblocking(0)
-                io_loop = tornado.ioloop.IOLoop.current()
-                io_loop.spawn_callback(handle_connection, connection, address)
-
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        connection.setblocking(0)
+        io_loop = tornado.ioloop.IOLoop.current()
+        io_loop.spawn_callback(handle_connection, connection, address)
+        
         if __name__ == '__main__':
-            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
-            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-            sock.setblocking(0)
-            sock.bind(("", 8888))
-            sock.listen(128)
-
-            io_loop = tornado.ioloop.IOLoop.current()
-            callback = functools.partial(connection_ready, sock)
-            io_loop.add_handler(sock.fileno(), callback, io_loop.READ)
-            io_loop.start()
-
-    .. testoutput::
-       :hide:
-
-    By default, a newly-constructed `IOLoop` becomes the thread's current
-    `IOLoop`, unless there already is a current `IOLoop`. This behavior
-    can be controlled with the ``make_current`` argument to the `IOLoop`
-    constructor: if ``make_current=True``, the new `IOLoop` will always
-    try to become current and it raises an error if there is already a
-    current instance. If ``make_current=False``, the new `IOLoop` will
-    not try to become current.
-
-    In general, an `IOLoop` cannot survive a fork or be shared across
-    processes in any way. When multiple processes are being used, each
-    process should create its own `IOLoop`, which also implies that
-    any objects which depend on the `IOLoop` (such as
-    `.AsyncHTTPClient`) must also be created in the child processes.
-    As a guideline, anything that starts processes (including the
-    `tornado.process` and `multiprocessing` modules) should do so as
-    early as possible, ideally the first thing the application does
-    after loading its configuration in ``main()``.
-
-    .. versionchanged:: 4.2
-       Added the ``make_current`` keyword argument to the `IOLoop`
-       constructor.
-
-    .. versionchanged:: 5.0
-
-       Uses the `asyncio` event loop by default. The
-       ``IOLoop.configure`` method cannot be used on Python 3 except
-       to redundantly specify the `asyncio` event loop.
+        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
+        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        sock.setblocking(0)
+        sock.bind(("", 8888))
+        sock.listen(128)
+        
+        io_loop = tornado.ioloop.IOLoop.current()
+        callback = functools.partial(connection_ready, sock)
+        io_loop.add_handler(sock.fileno(), callback, io_loop.READ)
+        io_loop.start()
+        
+        .. testoutput::
+        :hide:
+        
+        By default, a newly-constructed `IOLoop` becomes the thread's current
+        `IOLoop`, unless there already is a current `IOLoop`. This behavior
+        can be controlled with the ``make_current`` argument to the `IOLoop`
+        constructor: if ``make_current=True``, the new `IOLoop` will always
+        try to become current and it raises an error if there is already a
+        current instance. If ``make_current=False``, the new `IOLoop` will
+        not try to become current.
+        
+        In general, an `IOLoop` cannot survive a fork or be shared across
+        processes in any way. When multiple processes are being used, each
+        process should create its own `IOLoop`, which also implies that
+        any objects which depend on the `IOLoop` (such as
+        `.AsyncHTTPClient`) must also be created in the child processes.
+        As a guideline, anything that starts processes (including the
+        `tornado.process` and `multiprocessing` modules) should do so as
+        early as possible, ideally the first thing the application does
+        after loading its configuration in ``main()``.
+        
+        .. versionchanged:: 4.2
+        Added the ``make_current`` keyword argument to the `IOLoop`
+        constructor.
+        
+        .. versionchanged:: 5.0
+        
+        Uses the `asyncio` event loop by default. The
+        ``IOLoop.configure`` method cannot be used on Python 3 except
+        to redundantly specify the `asyncio` event loop.
 
     """
 
@@ -165,6 +174,23 @@
     def configure(
         cls, impl: "Union[None, str, Type[Configurable]]", **kwargs: Any
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        impl: "Union[None :
+            
+        str :
+            
+        Type[Configurable]]" :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         if asyncio is not None:
             from tornado.platform.asyncio import BaseAsyncIOLoop
 
@@ -179,9 +205,9 @@
     @staticmethod
     def instance() -> "IOLoop":
         """Deprecated alias for `IOLoop.current()`.
-
+        
         .. versionchanged:: 5.0
-
+        
            Previously, this method returned a global singleton
            `IOLoop`, in contrast with the per-thread `IOLoop` returned
            by `current()`. In nearly all cases the two were the same
@@ -193,37 +219,57 @@
            using the cross-thread communications aspect of
            `instance()` should instead set their own global variable
            to point to the `IOLoop` they want to use.
-
+        
         .. deprecated:: 5.0
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return IOLoop.current()
 
     def install(self) -> None:
         """Deprecated alias for `make_current()`.
-
+        
         .. versionchanged:: 5.0
-
+        
            Previously, this method would set this `IOLoop` as the
            global singleton used by `IOLoop.instance()`. Now that
            `instance()` is an alias for `current()`, `install()`
            is an alias for `make_current()`.
-
+        
         .. deprecated:: 5.0
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.make_current()
 
     @staticmethod
     def clear_instance() -> None:
         """Deprecated alias for `clear_current()`.
-
+        
         .. versionchanged:: 5.0
-
+        
            Previously, this method would clear the `IOLoop` used as
            the global singleton by `IOLoop.instance()`. Now that
            `instance()` is an alias for `current()`,
            `clear_instance()` is an alias for `clear_current()`.
-
+        
         .. deprecated:: 5.0
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         IOLoop.clear_current()
@@ -231,21 +277,33 @@
     @typing.overload
     @staticmethod
     def current() -> "IOLoop":
+        """ """
         pass
 
     @typing.overload
     @staticmethod
     def current(instance: bool = True) -> Optional["IOLoop"]:  # noqa: F811
+        """
+
+        Parameters
+        ----------
+        instance: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         pass
 
     @staticmethod
     def current(instance: bool = True) -> Optional["IOLoop"]:  # noqa: F811
         """Returns the current thread's `IOLoop`.
-
+        
         If an `IOLoop` is currently running or has been marked as
         current by `make_current`, returns that instance.  If there is
         no current `IOLoop` and ``instance`` is true, creates one.
-
+        
         .. versionchanged:: 4.1
            Added ``instance`` argument to control the fallback to
            `IOLoop.instance()`.
@@ -258,6 +316,15 @@
            an alias for this method). ``instance=False`` is deprecated,
            since even if we do not create an `IOLoop`, this method
            may initialize the asyncio loop.
+
+        Parameters
+        ----------
+        instance: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         try:
             loop = asyncio.get_event_loop()
@@ -278,19 +345,26 @@
 
     def make_current(self) -> None:
         """Makes this the `IOLoop` for the current thread.
-
+        
         An `IOLoop` automatically becomes current for its thread
         when it is started, but it is sometimes useful to call
         `make_current` explicitly before starting the `IOLoop`,
         so that code run at startup time can find the right
         instance.
-
+        
         .. versionchanged:: 4.1
            An `IOLoop` created while there is no current `IOLoop`
            will automatically become current.
-
+        
         .. versionchanged:: 5.0
            This method also sets the current `asyncio` event loop.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # The asyncio event loops override this method.
         raise NotImplementedError()
@@ -298,11 +372,18 @@
     @staticmethod
     def clear_current() -> None:
         """Clears the `IOLoop` for the current thread.
-
+        
         Intended primarily for use by test frameworks in between tests.
-
+        
         .. versionchanged:: 5.0
            This method also clears the current `asyncio` event loop.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         old = IOLoop.current(instance=False)
         if old is not None:
@@ -312,22 +393,42 @@
 
     def _clear_current_hook(self) -> None:
         """Instance method called when an IOLoop ceases to be current.
-
+        
         May be overridden by subclasses as a counterpart to make_current.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
     @classmethod
     def configurable_base(cls) -> Type[Configurable]:
+        """ """
         return IOLoop
 
     @classmethod
     def configurable_default(cls) -> Type[Configurable]:
+        """ """
         from tornado.platform.asyncio import AsyncIOLoop
 
         return AsyncIOLoop
 
     def initialize(self, make_current: Optional[bool] = None) -> None:
+        """
+
+        Parameters
+        ----------
+        make_current: Optional[bool] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if make_current is None:
             if IOLoop.current(instance=False) is None:
                 self.make_current()
@@ -340,28 +441,37 @@
 
     def close(self, all_fds: bool = False) -> None:
         """Closes the `IOLoop`, freeing any resources used.
-
+        
         If ``all_fds`` is true, all file descriptors registered on the
         IOLoop will be closed (not just the ones created by the
         `IOLoop` itself).
-
+        
         Many applications will only use a single `IOLoop` that runs for the
         entire lifetime of the process.  In that case closing the `IOLoop`
         is not necessary since everything will be cleaned up when the
         process exits.  `IOLoop.close` is provided mainly for scenarios
         such as unit tests, which create and destroy a large number of
         ``IOLoops``.
-
+        
         An `IOLoop` must be completely stopped before it can be closed.  This
         means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must
         be allowed to return before attempting to call `IOLoop.close()`.
         Therefore the call to `close` will usually appear just after
         the call to `start` rather than near the call to `stop`.
-
+        
         .. versionchanged:: 3.1
            If the `IOLoop` implementation supports non-integer objects
            for "file descriptors", those objects will have their
            ``close`` method when ``all_fds`` is true.
+
+        Parameters
+        ----------
+        all_fds: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
@@ -369,56 +479,144 @@
     def add_handler(
         self, fd: int, handler: Callable[[int, int], None], events: int
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        fd: int :
+            
+        handler: Callable[[int :
+            
+        int] :
+            
+        None] :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     @typing.overload  # noqa: F811
     def add_handler(
         self, fd: _S, handler: Callable[[_S, int], None], events: int
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        fd: _S :
+            
+        handler: Callable[[_S :
+            
+        int] :
+            
+        None] :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def add_handler(  # noqa: F811
         self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int
     ) -> None:
         """Registers the given handler to receive the given events for ``fd``.
-
+        
         The ``fd`` argument may either be an integer file descriptor or
         a file-like object with a ``fileno()`` and ``close()`` method.
-
+        
         The ``events`` argument is a bitwise or of the constants
         ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.
-
+        
         When an event occurs, ``handler(fd, events)`` will be run.
-
+        
         .. versionchanged:: 4.0
            Added the ability to pass file-like objects in addition to
            raw file descriptors.
+
+        Parameters
+        ----------
+        # noqa: F811self :
+            
+        fd: Union[int :
+            
+        _Selectable] :
+            
+        handler: Callable[... :
+            
+        None] :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def update_handler(self, fd: Union[int, _Selectable], events: int) -> None:
         """Changes the events we listen for ``fd``.
-
+        
         .. versionchanged:: 4.0
            Added the ability to pass file-like objects in addition to
            raw file descriptors.
+
+        Parameters
+        ----------
+        fd: Union[int :
+            
+        _Selectable] :
+            
+        events: int :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def remove_handler(self, fd: Union[int, _Selectable]) -> None:
         """Stop listening for events on ``fd``.
-
+        
         .. versionchanged:: 4.0
            Added the ability to pass file-like objects in addition to
            raw file descriptors.
+
+        Parameters
+        ----------
+        fd: Union[int :
+            
+        _Selectable] :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def start(self) -> None:
         """Starts the I/O loop.
-
+        
         The loop will run until one of the callbacks calls `stop()`, which
         will make the loop stop after the current event iteration completes.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
@@ -430,8 +628,15 @@
         found" message rather than the actual log entry, so we
         must explicitly configure logging if we've made it this
         far without anything.
-
+        
         This method should be called from start() in subclasses.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not any(
             [
@@ -444,50 +649,67 @@
 
     def stop(self) -> None:
         """Stop the I/O loop.
-
+        
         If the event loop is not currently running, the next call to `start()`
         will return immediately.
-
+        
         Note that even after `stop` has been called, the `IOLoop` is not
         completely stopped until `IOLoop.start` has also returned.
         Some work that was scheduled before the call to `stop` may still
         be run before the `IOLoop` shuts down.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def run_sync(self, func: Callable, timeout: Optional[float] = None) -> Any:
         """Starts the `IOLoop`, runs the given function, and stops the loop.
-
+        
         The function must return either an awaitable object or
         ``None``. If the function returns an awaitable object, the
         `IOLoop` will run until the awaitable is resolved (and
         `run_sync()` will return the awaitable's result). If it raises
         an exception, the `IOLoop` will stop and the exception will be
         re-raised to the caller.
-
+        
         The keyword-only argument ``timeout`` may be used to set
         a maximum duration for the function.  If the timeout expires,
         a `tornado.util.TimeoutError` is raised.
-
+        
         This method is useful to allow asynchronous calls in a
         ``main()`` function::
-
+        
             async def main():
                 # do stuff...
-
+        
             if __name__ == '__main__':
                 IOLoop.current().run_sync(main)
-
+        
         .. versionchanged:: 4.3
-           Returning a non-``None``, non-awaitable value is now an error.
-
-        .. versionchanged:: 5.0
-           If a timeout occurs, the ``func`` coroutine will be cancelled.
+
+        Parameters
+        ----------
+        func: Callable :
+            
+        timeout: Optional[float] :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            .. versionchanged:: 5.0
+            If a timeout occurs, the ``func`` coroutine will be cancelled.
 
         """
         future_cell = [None]  # type: List[Optional[Future]]
 
         def run() -> None:
+            """ """
             try:
                 result = func()
                 if result is not None:
@@ -512,6 +734,7 @@
         if timeout is not None:
 
             def timeout_callback() -> None:
+                """ """
                 # If we can cancel the future, do so and wait on it. If not,
                 # Just stop the loop and return with the task still pending.
                 # (If we neither cancel nor wait for the task, a warning
@@ -531,14 +754,20 @@
 
     def time(self) -> float:
         """Returns the current time according to the `IOLoop`'s clock.
-
+        
         The return value is a floating-point number relative to an
         unspecified time in the past.
-
+        
         Historically, the IOLoop could be customized to use e.g.
         `time.monotonic` instead of `time.time`, but this is not
         currently supported and so this method is equivalent to
         `time.time`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         return time.time()
@@ -551,29 +780,48 @@
         **kwargs: Any
     ) -> object:
         """Runs the ``callback`` at the time ``deadline`` from the I/O loop.
-
+        
         Returns an opaque handle that may be passed to
         `remove_timeout` to cancel.
-
+        
         ``deadline`` may be a number denoting a time (on the same
         scale as `IOLoop.time`, normally `time.time`), or a
         `datetime.timedelta` object for a deadline relative to the
         current time.  Since Tornado 4.0, `call_later` is a more
         convenient alternative for the relative case since it does not
         require a timedelta object.
-
+        
         Note that it is not safe to call `add_timeout` from other threads.
         Instead, you must use `add_callback` to transfer control to the
         `IOLoop`'s thread, and then call `add_timeout` from there.
-
+        
         Subclasses of IOLoop must implement either `add_timeout` or
         `call_at`; the default implementations of each will call
         the other.  `call_at` is usually easier to implement, but
         subclasses that wish to maintain compatibility with Tornado
         versions prior to 4.0 must use `add_timeout` instead.
-
+        
         .. versionchanged:: 4.0
            Now passes through ``*args`` and ``**kwargs`` to the callback.
+
+        Parameters
+        ----------
+        deadline: Union[float :
+            
+        datetime.timedelta] :
+            
+        callback: Callable[... :
+            
+        None] :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(deadline, numbers.Real):
             return self.call_at(deadline, callback, *args, **kwargs)
@@ -588,14 +836,31 @@
         self, delay: float, callback: Callable[..., None], *args: Any, **kwargs: Any
     ) -> object:
         """Runs the ``callback`` after ``delay`` seconds have passed.
-
+        
         Returns an opaque handle that may be passed to `remove_timeout`
         to cancel.  Note that unlike the `asyncio` method of the same
         name, the returned object does not have a ``cancel()`` method.
-
+        
         See `add_timeout` for comments on thread-safety and subclassing.
-
+        
         .. versionadded:: 4.0
+
+        Parameters
+        ----------
+        delay: float :
+            
+        callback: Callable[... :
+            
+        None] :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         return self.call_at(self.time() + delay, callback, *args, **kwargs)
 
@@ -603,41 +868,80 @@
         self, when: float, callback: Callable[..., None], *args: Any, **kwargs: Any
     ) -> object:
         """Runs the ``callback`` at the absolute time designated by ``when``.
-
+        
         ``when`` must be a number using the same reference point as
         `IOLoop.time`.
-
+        
         Returns an opaque handle that may be passed to `remove_timeout`
         to cancel.  Note that unlike the `asyncio` method of the same
         name, the returned object does not have a ``cancel()`` method.
-
+        
         See `add_timeout` for comments on thread-safety and subclassing.
-
+        
         .. versionadded:: 4.0
+
+        Parameters
+        ----------
+        when: float :
+            
+        callback: Callable[... :
+            
+        None] :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         return self.add_timeout(when, callback, *args, **kwargs)
 
     def remove_timeout(self, timeout: object) -> None:
         """Cancels a pending timeout.
-
+        
         The argument is a handle as returned by `add_timeout`.  It is
         safe to call `remove_timeout` even if the callback has already
         been run.
+
+        Parameters
+        ----------
+        timeout: object :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def add_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:
         """Calls the given callback on the next I/O loop iteration.
-
+        
         It is safe to call this method from any thread at any time,
         except from a signal handler.  Note that this is the **only**
         method in `IOLoop` that makes this thread-safety guarantee; all
         other interaction with the `IOLoop` must be done from that
         `IOLoop`'s thread.  `add_callback()` may be used to transfer
         control from other threads to the `IOLoop`'s thread.
-
+        
         To add a callback from a signal handler, see
         `add_callback_from_signal`.
+
+        Parameters
+        ----------
+        callback: Callable :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
@@ -645,18 +949,44 @@
         self, callback: Callable, *args: Any, **kwargs: Any
     ) -> None:
         """Calls the given callback on the next I/O loop iteration.
-
+        
         Safe for use from a Python signal handler; should not be used
         otherwise.
+
+        Parameters
+        ----------
+        callback: Callable :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def spawn_callback(self, callback: Callable, *args: Any, **kwargs: Any) -> None:
         """Calls the given callback on the next IOLoop iteration.
-
+        
         As of Tornado 6.0, this method is equivalent to `add_callback`.
-
+        
         .. versionadded:: 4.0
+
+        Parameters
+        ----------
+        callback: Callable :
+            
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         self.add_callback(callback, *args, **kwargs)
 
@@ -667,13 +997,28 @@
     ) -> None:
         """Schedules a callback on the ``IOLoop`` when the given
         `.Future` is finished.
-
+        
         The callback is invoked with one argument, the
         `.Future`.
-
+        
         This method only accepts `.Future` objects and not other
         awaitables (unlike most of Tornado where the two are
         interchangeable).
+
+        Parameters
+        ----------
+        future: "Union[Future[_T] :
+            
+        concurrent.futures.Future[_T]]" :
+            
+        callback: Callable[["Future[_T]"] :
+            
+        None] :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(future, Future):
             # Note that we specifically do not want the inline behavior of
@@ -703,10 +1048,25 @@
     ) -> Awaitable[_T]:
         """Runs a function in a ``concurrent.futures.Executor``. If
         ``executor`` is ``None``, the IO loop's default executor will be used.
-
+        
         Use `functools.partial` to pass keyword arguments to ``func``.
-
+        
         .. versionadded:: 5.0
+
+        Parameters
+        ----------
+        executor: Optional[concurrent.futures.Executor] :
+            
+        func: Callable[... :
+            
+        _T] :
+            
+        *args: Any :
+            
+
+        Returns
+        -------
+
         """
         if executor is None:
             if not hasattr(self, "_executor"):
@@ -725,17 +1085,37 @@
 
     def set_default_executor(self, executor: concurrent.futures.Executor) -> None:
         """Sets the default executor to use with :meth:`run_in_executor`.
-
+        
         .. versionadded:: 5.0
+
+        Parameters
+        ----------
+        executor: concurrent.futures.Executor :
+            
+
+        Returns
+        -------
+
         """
         self._executor = executor
 
     def _run_callback(self, callback: Callable[[], Any]) -> None:
         """Runs a callback with error handling.
-
+        
         .. versionchanged:: 6.0
-
+        
            CancelledErrors are no longer logged.
+
+        Parameters
+        ----------
+        callback: Callable[[] :
+            
+        Any] :
+            
+
+        Returns
+        -------
+
         """
         try:
             ret = callback()
@@ -761,14 +1141,24 @@
             app_log.error("Exception in callback %r", callback, exc_info=True)
 
     def _discard_future_result(self, future: Future) -> None:
-        """Avoid unhandled-exception warnings from spawned coroutines."""
+        """Avoid unhandled-exception warnings from spawned coroutines.
+
+        Parameters
+        ----------
+        future: Future :
+            
+
+        Returns
+        -------
+
+        """
         future.result()
 
     def split_fd(
         self, fd: Union[int, _Selectable]
     ) -> Tuple[int, Union[int, _Selectable]]:
-        # """Returns an (fd, obj) pair from an ``fd`` parameter.
-
+        """# """Returns an (fd, obj) pair from an ``fd`` parameter.
+        
         # We accept both raw file descriptors and file-like objects as
         # input to `add_handler` and related methods.  When a file-like
         # object is passed, we must retain the object itself so we can
@@ -776,28 +1166,48 @@
         # poller interfaces favor file descriptors (they will accept
         # file-like objects and call ``fileno()`` for you, but they
         # always return the descriptor itself).
-
+        
         # This method is provided for use by `IOLoop` subclasses and should
         # not generally be used by application code.
-
+        
         # .. versionadded:: 4.0
-        # """
+        #
+
+        Parameters
+        ----------
+        fd: Union[int :
+            
+        _Selectable] :
+            
+
+        Returns
+        -------
         if isinstance(fd, int):
             return fd, fd
         return fd.fileno(), fd
 
     def close_fd(self, fd: Union[int, _Selectable]) -> None:
-        # """Utility method to close an ``fd``.
-
+        """# """Utility method to close an ``fd``.
+        
         # If ``fd`` is a file-like object, we close it directly; otherwise
         # we use `os.close`.
-
+        
         # This method is provided for use by `IOLoop` subclasses (in
         # implementations of ``IOLoop.close(all_fds=True)`` and should
         # not generally be used by application code.
-
+        
         # .. versionadded:: 4.0
-        # """
+        #
+
+        Parameters
+        ----------
+        fd: Union[int :
+            
+        _Selectable] :
+            
+
+        Returns
+        -------
         try:
             if isinstance(fd, int):
                 os.close(fd)
@@ -838,11 +1248,11 @@
 
 class PeriodicCallback(object):
     """Schedules the given callback to be called periodically.
-
+    
     The callback is called every ``callback_time`` milliseconds.
     Note that the timeout is given in milliseconds, while most other
     time-related functions in Tornado use seconds.
-
+    
     If ``jitter`` is specified, each callback time will be randomly selected
     within a window of ``jitter * callback_time`` milliseconds.
     Jitter can be used to reduce alignment of events with similar periods.
@@ -850,17 +1260,24 @@
     The window is centered on ``callback_time`` so the total number of calls
     within a given interval should not be significantly affected by adding
     jitter.
-
+    
     If the callback runs for longer than ``callback_time`` milliseconds,
     subsequent invocations will be skipped to get back on schedule.
-
+    
     `start` must be called after the `PeriodicCallback` is created.
-
+    
     .. versionchanged:: 5.0
        The ``io_loop`` argument (deprecated since version 4.1) has been removed.
-
+    
     .. versionchanged:: 5.1
        The ``jitter`` argument is added.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -893,12 +1310,20 @@
 
     def is_running(self) -> bool:
         """Returns ``True`` if this `.PeriodicCallback` has been started.
-
+        
         .. versionadded:: 4.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._running
 
     def _run(self) -> None:
+        """ """
         if not self._running:
             return
         try:
@@ -909,11 +1334,23 @@
             self._schedule_next()
 
     def _schedule_next(self) -> None:
+        """ """
         if self._running:
             self._update_next(self.io_loop.time())
             self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)
 
     def _update_next(self, current_time: float) -> None:
+        """
+
+        Parameters
+        ----------
+        current_time: float :
+            
+
+        Returns
+        -------
+
+        """
         callback_time_sec = self.callback_time / 1000.0
         if self.jitter:
             # apply jitter fraction
