# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/arrow/arrays.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/arrow/arrays.py
@@ -25,6 +25,7 @@
 
 @register_extension_dtype
 class ArrowBoolDtype(ExtensionDtype):
+    """ """
 
     type = np.bool_
     kind = "b"
@@ -33,22 +34,18 @@
 
     @classmethod
     def construct_array_type(cls) -> Type["ArrowBoolArray"]:
-        """
-        Return the array type associated with this dtype.
-
-        Returns
-        -------
-        type
-        """
+        """Return the array type associated with this dtype."""
         return ArrowBoolArray
 
     @property
     def _is_boolean(self) -> bool:
+        """ """
         return True
 
 
 @register_extension_dtype
 class ArrowStringDtype(ExtensionDtype):
+    """ """
 
     type = str
     kind = "U"
@@ -57,29 +54,61 @@
 
     @classmethod
     def construct_array_type(cls) -> Type["ArrowStringArray"]:
-        """
-        Return the array type associated with this dtype.
-
-        Returns
-        -------
-        type
-        """
+        """Return the array type associated with this dtype."""
         return ArrowStringArray
 
 
 class ArrowExtensionArray(ExtensionArray):
+    """ """
     @classmethod
     def from_scalars(cls, values):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+
+        Returns
+        -------
+
+        """
         arr = pa.chunked_array([pa.array(np.asarray(values))])
         return cls(arr)
 
     @classmethod
     def from_array(cls, arr):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(arr, pa.Array)
         return cls(pa.chunked_array([arr]))
 
     @classmethod
     def _from_sequence(cls, scalars, dtype=None, copy=False):
+        """
+
+        Parameters
+        ----------
+        scalars :
+            
+        dtype :
+             (Default value = None)
+        copy :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return cls.from_scalars(scalars)
 
     def __repr__(self):
@@ -96,6 +125,19 @@
         return len(self._data)
 
     def astype(self, dtype, copy=True):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         # needed to fix this astype for the Series constructor.
         if isinstance(dtype, type(self.dtype)) and dtype == self.dtype:
             if copy:
@@ -105,9 +147,23 @@
 
     @property
     def dtype(self):
+        """ """
         return self._dtype
 
     def _boolean_op(self, other, op):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        op :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(other, type(self)):
             raise NotImplementedError()
 
@@ -130,6 +186,7 @@
 
     @property
     def nbytes(self):
+        """ """
         return sum(
             x.size
             for chunk in self._data.chunks
@@ -138,10 +195,26 @@
         )
 
     def isna(self):
+        """ """
         nas = pd.isna(self._data.to_pandas())
         return type(self).from_scalars(nas)
 
     def take(self, indices, allow_fill=False, fill_value=None):
+        """
+
+        Parameters
+        ----------
+        indices :
+            
+        allow_fill :
+             (Default value = False)
+        fill_value :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         data = self._data.to_pandas()
 
         if allow_fill and fill_value is None:
@@ -151,10 +224,22 @@
         return self._from_sequence(result, dtype=self.dtype)
 
     def copy(self):
+        """ """
         return type(self)(copy.copy(self._data))
 
     @classmethod
     def _concat_same_type(cls, to_concat):
+        """
+
+        Parameters
+        ----------
+        to_concat :
+            
+
+        Returns
+        -------
+
+        """
         chunks = list(itertools.chain.from_iterable(x._data.chunks for x in to_concat))
         arr = pa.chunked_array(chunks)
         return cls(arr)
@@ -163,6 +248,21 @@
         return type(self).from_scalars(~self._data.to_pandas())
 
     def _reduce(self, name: str, skipna: bool = True, **kwargs):
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        skipna: bool :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if skipna:
             arr = self[~self.isna()]
         else:
@@ -175,15 +275,42 @@
         return op(**kwargs)
 
     def any(self, axis=0, out=None):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = 0)
+        out :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Explicitly return a plain bool to reproduce GH-34660
         return bool(self._data.to_pandas().any())
 
     def all(self, axis=0, out=None):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = 0)
+        out :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # Explicitly return a plain bool to reproduce GH-34660
         return bool(self._data.to_pandas().all())
 
 
 class ArrowBoolArray(ArrowExtensionArray):
+    """ """
     def __init__(self, values):
         if not isinstance(values, pa.ChunkedArray):
             raise ValueError
@@ -194,6 +321,7 @@
 
 
 class ArrowStringArray(ArrowExtensionArray):
+    """ """
     def __init__(self, values):
         if not isinstance(values, pa.ChunkedArray):
             raise ValueError
