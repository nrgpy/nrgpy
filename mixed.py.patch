# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/mixed.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/compiled/mixed.py
@@ -27,21 +27,27 @@
 
 
 class MixedObject(ValueWrapper):
-    """
-    A ``MixedObject`` is used in two ways:
-
+    """A ``MixedObject`` is used in two ways:
+    
     1. It uses the default logic of ``parser.python.tree`` objects,
     2. except for getattr calls and signatures. The names dicts are generated
        in a fashion like ``CompiledValue``.
-
+    
     This combined logic makes it possible to provide more powerful REPL
     completion. It allows side effects that are not noticable with the default
     parser structure to still be completeable.
-
+    
     The biggest difference from CompiledValue to MixedObject is that we are
     generally dealing with Python code and not with C code. This will generate
     fewer special cases, because we in Python you don't have the same freedoms
     to modify the runtime.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     def __init__(self, compiled_value, tree_value):
         super(MixedObject, self).__init__(tree_value)
@@ -49,16 +55,41 @@
         self.access_handle = compiled_value.access_handle
 
     def get_filters(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         yield MixedObjectFilter(
             self.inference_state, self.compiled_value, self._wrapped_value)
 
     def get_signatures(self):
+        """ """
         # Prefer `inspect.signature` over somehow analyzing Python code. It
         # should be very precise, especially for stuff like `partial`.
         return self.compiled_value.get_signatures()
 
     @inference_state_method_cache(default=NO_VALUES)
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         # Fallback to the wrapped value if to stub returns no values.
         values = to_stub(self._wrapped_value)
         if not values:
@@ -66,6 +97,17 @@
         return values.py__call__(arguments)
 
     def get_safe_value(self, default=_sentinel):
+        """
+
+        Parameters
+        ----------
+        default :
+             (Default value = _sentinel)
+
+        Returns
+        -------
+
+        """
         if default is _sentinel:
             return self.compiled_value.get_safe_value()
         else:
@@ -73,21 +115,36 @@
 
     @property
     def array_type(self):
+        """ """
         return self.compiled_value.array_type
 
     def get_key_values(self):
+        """ """
         return self.compiled_value.get_key_values()
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         python_object = self.compiled_value.access_handle.access._obj
         if type(python_object) in ALLOWED_GETITEM_TYPES:
             return self.compiled_value.py__simple_getitem__(index)
         return self._wrapped_value.py__simple_getitem__(index)
 
     def negate(self):
+        """ """
         return self.compiled_value.negate()
 
     def _as_context(self):
+        """ """
         if self.parent_context is None:
             return MixedModuleContext(self)
         return MixedContext(self)
@@ -101,25 +158,27 @@
 
 
 class MixedContext(CompiledContext, TreeContextMixin):
+    """ """
     @property
     def compiled_value(self):
+        """ """
         return self._value.compiled_value
 
 
 class MixedModuleContext(CompiledModuleContext, MixedContext):
+    """ """
     pass
 
 
 class MixedName(NameWrapper):
-    """
-    The ``CompiledName._compiled_value`` is our MixedObject.
-    """
+    """The ``CompiledName._compiled_value`` is our MixedObject."""
     def __init__(self, wrapped_name, parent_tree_value):
         super(MixedName, self).__init__(wrapped_name)
         self._parent_tree_value = parent_tree_value
 
     @property
     def start_pos(self):
+        """ """
         values = list(self.infer())
         if not values:
             # This means a start_pos that doesn't exist (compiled objects).
@@ -128,6 +187,7 @@
 
     @memoize_method
     def infer(self):
+        """ """
         compiled_value = self._wrapped_name.infer_compiled_value()
         tree_value = self._parent_tree_value
         if tree_value.is_instance() or tree_value.is_class():
@@ -140,11 +200,23 @@
 
 
 class MixedObjectFilter(compiled.CompiledValueFilter):
+    """ """
     def __init__(self, inference_state, compiled_value, tree_value):
         super(MixedObjectFilter, self).__init__(inference_state, compiled_value)
         self._tree_value = tree_value
 
     def _create_name(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return MixedName(
             super(MixedObjectFilter, self)._create_name(name),
             self._tree_value,
@@ -153,6 +225,19 @@
 
 @inference_state_function_cache()
 def _load_module(inference_state, path):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    path :
+        
+
+    Returns
+    -------
+
+    """
     return inference_state.parse(
         path=path,
         cache=True,
@@ -162,7 +247,17 @@
 
 
 def _get_object_to_check(python_object):
-    """Check if inspect.getfile has a chance to find the source."""
+    """Check if inspect.getfile has a chance to find the source.
+
+    Parameters
+    ----------
+    python_object :
+        
+
+    Returns
+    -------
+
+    """
     if sys.version_info[0] > 2:
         try:
             python_object = unwrap(python_object)
@@ -186,6 +281,19 @@
 
 
 def _find_syntax_node_name(inference_state, python_object):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    python_object :
+        
+
+    Returns
+    -------
+
+    """
     original_object = python_object
     try:
         python_object = _get_object_to_check(python_object)
@@ -261,6 +369,21 @@
 
 @inference_state_function_cache()
 def _create(inference_state, compiled_value, module_context):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    compiled_value :
+        
+    module_context :
+        
+
+    Returns
+    -------
+
+    """
     # TODO accessing this is bad, but it probably doesn't matter that much,
     # because we're working with interpreteters only here.
     python_object = compiled_value.access_handle.access._obj
