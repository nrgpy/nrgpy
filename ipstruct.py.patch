# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/utils/ipstruct.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/utils/ipstruct.py
@@ -27,15 +27,22 @@
 
 class Struct(dict):
     """A dict subclass with attribute style access.
-
+    
     This dict subclass has a a few extra features:
-
+    
     * Attribute style access.
     * Protection of class members (like keys, items) when using attribute
       style access.
     * The ability to restrict assignment to only existing keys.
     * Intelligent merging.
     * Overloaded operators.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     _allownew = True
     def __init__(self, *args, **kw):
@@ -229,29 +236,28 @@
         return outdict
 
     def dict(self):
+        """ """
         return self
 
     def copy(self):
-        """Return a copy as a Struct.
-
-        Examples
-        --------
-
-        >>> s = Struct(a=10,b=30)
-        >>> s2 = s.copy()
-        >>> type(s2) is Struct
-        True
-        """
+        """Return a copy as a Struct."""
         return Struct(dict.copy(self))
 
     def hasattr(self, key):
         """hasattr function available as a method.
-
+        
         Implemented like has_key.
 
-        Examples
-        --------
-
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        Examples
+        --------
         >>> s = Struct(a=10)
         >>> s.hasattr('a')
         True
@@ -264,20 +270,29 @@
 
     def allow_new_attr(self, allow = True):
         """Set whether new attributes can be created in this Struct.
-
+        
         This can be used to catch typos by verifying that the attribute user
         tries to change already exists in this Struct.
+
+        Parameters
+        ----------
+        allow :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         object.__setattr__(self, '_allownew', allow)
 
     def merge(self, __loc_data__=None, __conflict_solve=None, **kw):
         """Merge two Structs with customizable conflict resolution.
-
+        
         This is similar to :meth:`update`, but much more flexible. First, a
         dict is made from data+key=value pairs. When merging this dict with
         the Struct S, the optional dictionary 'conflict' is used to decide
         what to do.
-
+        
         If conflict is not given, the default behavior is to preserve any keys
         with their current value (the opposite of the :meth:`update` method's
         behavior).
@@ -291,64 +306,70 @@
             resolve the conflict and the values are lists of strings naming
             the keys the conflict resolution function applies to.  Instead of
             a list of strings a space separated string can be used, like
-            'a b c'.
+            'a b c'. (Default value = None)
         kw : dict
             Additional key, value pairs to merge in
+        __loc_data__ :
+             (Default value = None)
+        **kw :
+            
+
+        Returns
+        -------
 
         Notes
         -----
-
+        
         The `__conflict_solve` dict is a dictionary of binary functions which will be used to
         solve key conflicts.  Here is an example::
-
+        
             __conflict_solve = dict(
                 func1=['a','b','c'],
                 func2=['d','e']
             )
-
+        
         In this case, the function :func:`func1` will be used to resolve
         keys 'a', 'b' and 'c' and the function :func:`func2` will be used for
         keys 'd' and 'e'.  This could also be written as::
-
+        
             __conflict_solve = dict(func1='a b c',func2='d e')
-
+        
         These functions will be called for each key they apply to with the
         form::
-
+        
             func1(self['a'], other['a'])
-
+        
         The return value is used as the final merged value.
-
+        
         As a convenience, merge() provides five (the most commonly needed)
         pre-defined policies: preserve, update, add, add_flip and add_s. The
         easiest explanation is their implementation::
-
+        
             preserve = lambda old,new: old
             update   = lambda old,new: new
             add      = lambda old,new: old + new
             add_flip = lambda old,new: new + old  # note change of order!
             add_s    = lambda old,new: old + ' ' + new  # only for str!
-
+        
         You can use those four words (as strings) as keys instead
         of defining them as functions, and the merge method will substitute
         the appropriate functions for you.
-
+        
         For more complicated conflict resolution policies, you still need to
         construct your own functions.
-
-        Examples
-        --------
-
+        Examples
+        --------
+        
         This show the default policy:
-
+        
+        
+        Now, show how to specify a conflict dict:
         >>> s = Struct(a=10,b=30)
         >>> s2 = Struct(a=20,c=40)
         >>> s.merge(s2)
         >>> sorted(s.items())
         [('a', 10), ('b', 30), ('c', 40)]
-
-        Now, show how to specify a conflict dict:
-
+        
         >>> s = Struct(a=10,b=30)
         >>> s2 = Struct(a=20,b=40)
         >>> conflict = {'update':'a','add':'b'}
