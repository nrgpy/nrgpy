# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/api/completion.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/api/completion.py
@@ -26,11 +26,28 @@
 
 
 class ParamNameWithEquals(ParamNameWrapper):
+    """ """
     def get_public_name(self):
+        """ """
         return self.string_name + '='
 
 
 def _get_signature_param_names(signatures, positional_count, used_kwargs):
+    """
+
+    Parameters
+    ----------
+    signatures :
+        
+    positional_count :
+        
+    used_kwargs :
+        
+
+    Returns
+    -------
+
+    """
     # Add named params
     for call_sig in signatures:
         for i, p in enumerate(call_sig.params):
@@ -45,6 +62,21 @@
 
 
 def _must_be_kwarg(signatures, positional_count, used_kwargs):
+    """
+
+    Parameters
+    ----------
+    signatures :
+        
+    positional_count :
+        
+    used_kwargs :
+        
+
+    Returns
+    -------
+
+    """
     if used_kwargs:
         return True
 
@@ -68,6 +100,27 @@
 
 
 def filter_names(inference_state, completion_names, stack, like_name, fuzzy, cached_name):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    completion_names :
+        
+    stack :
+        
+    like_name :
+        
+    fuzzy :
+        
+    cached_name :
+        
+
+    Returns
+    -------
+
+    """
     comp_dct = set()
     if settings.case_insensitive_completion:
         like_name = like_name.lower()
@@ -96,19 +149,55 @@
 
 
 def _remove_duplicates(completions, other_completions):
+    """
+
+    Parameters
+    ----------
+    completions :
+        
+    other_completions :
+        
+
+    Returns
+    -------
+
+    """
     names = {d.name for d in other_completions}
     return [c for c in completions if c.name not in names]
 
 
 def get_user_context(module_context, position):
-    """
-    Returns the scope in which the user resides. This includes flows.
+    """Returns the scope in which the user resides. This includes flows.
+
+    Parameters
+    ----------
+    module_context :
+        
+    position :
+        
+
+    Returns
+    -------
+
     """
     leaf = module_context.tree_node.get_leaf_for_position(position, include_prefixes=True)
     return module_context.create_context(leaf)
 
 
 def get_flow_scope_node(module_node, position):
+    """
+
+    Parameters
+    ----------
+    module_node :
+        
+    position :
+        
+
+    Returns
+    -------
+
+    """
     node = module_node.get_leaf_for_position(position, include_prefixes=True)
     while not isinstance(node, (tree.Scope, tree.Flow)):
         node = node.parent
@@ -118,12 +207,28 @@
 
 @plugin_manager.decorate()
 def complete_param_names(context, function_name, decorator_nodes):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    function_name :
+        
+    decorator_nodes :
+        
+
+    Returns
+    -------
+
+    """
     # Basically there's no way to do param completion. The plugins are
     # responsible for this.
     return []
 
 
 class Completion:
+    """ """
     def __init__(self, inference_state, module_context, code_lines, position,
                  signatures_callback, fuzzy=False):
         self._inference_state = inference_state
@@ -141,6 +246,7 @@
         self._fuzzy = fuzzy
 
     def complete(self):
+        """ """
         leaf = self._module_node.get_leaf_for_position(
             self._original_position,
             include_prefixes=True
@@ -184,18 +290,25 @@
         )
 
     def _complete_python(self, leaf):
-        """
-        Analyzes the current context of a completion and decides what to
-        return.
-
-        Technically this works by generating a parser stack and analysing the
-        current stack for possible grammar nodes.
-
-        Possible enhancements:
-        - global/nonlocal search global
-        - yield from / raise from <- could be only exceptions/generators
-        - In args: */**: no completion
-        - In params (also lambda): no completion before =
+        """Analyzes the current context of a completion and decides what to
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+        type
+            Technically this works by generating a parser stack and analysing the
+            current stack for possible grammar nodes.
+            
+            Possible enhancements:
+            - global/nonlocal search global
+            - yield from / raise from <- could be only exceptions/generators
+            - In args: */**: no completion
+            - In params (also lambda): no completion before =
+
         """
 
         grammar = self._inference_state.grammar
@@ -324,6 +437,7 @@
         return cached_name, completion_names
 
     def _is_parameter_completion(self):
+        """ """
         tos = self.stack[-1]
         if tos.nonterminal == 'lambdef' and len(tos.nodes) == 1:
             # We are at the position `lambda `, where basically the next node
@@ -337,6 +451,17 @@
         return tos.nonterminal in ('typedargslist', 'varargslist') and tos.nodes[-1] == ','
 
     def _complete_params(self, leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         stack_node = self.stack[-2]
         if stack_node.nonterminal == 'parameters':
             stack_node = self.stack[-3]
@@ -360,12 +485,26 @@
         return []
 
     def _complete_keywords(self, allowed_transitions, only_values):
+        """
+
+        Parameters
+        ----------
+        allowed_transitions :
+            
+        only_values :
+            
+
+        Returns
+        -------
+
+        """
         for k in allowed_transitions:
             if isinstance(k, str) and k.isalpha():
                 if not only_values or k in ('True', 'False', 'None'):
                     yield keywords.KeywordName(self._inference_state, k)
 
     def _complete_global_scope(self):
+        """ """
         context = get_user_context(self._module_context, self._position)
         debug.dbg('global completion scope: %s', context)
         flow_scope_node = get_flow_scope_node(self._module_node, self._position)
@@ -380,6 +519,17 @@
         return completion_names
 
     def _complete_trailer(self, previous_leaf):
+        """
+
+        Parameters
+        ----------
+        previous_leaf :
+            
+
+        Returns
+        -------
+
+        """
         inferred_context = self._module_context.create_context(previous_leaf)
         values = infer_call_of_leaf(inferred_context, previous_leaf)
         debug.dbg('trailer completion values: %s', values, color='MAGENTA')
@@ -398,18 +548,52 @@
         return cached_name, self._complete_trailer_for_values(values)
 
     def _complete_trailer_for_values(self, values):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+
+        Returns
+        -------
+
+        """
         user_context = get_user_context(self._module_context, self._position)
 
         return complete_trailer(user_context, values)
 
     def _get_importer_names(self, names, level=0, only_modules=True):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+        level :
+             (Default value = 0)
+        only_modules :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         names = [n.value for n in names]
         i = imports.Importer(self._inference_state, names, self._module_context, level)
         return i.completion_names(self._inference_state, only_modules=only_modules)
 
     def _complete_inherited(self, is_function=True):
-        """
-        Autocomplete inherited methods when overriding in child class.
+        """Autocomplete inherited methods when overriding in child class.
+
+        Parameters
+        ----------
+        is_function :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         leaf = self._module_node.get_leaf_for_position(self._position, include_prefixes=True)
         cls = tree.search_ancestor(leaf, 'classdef')
@@ -432,16 +616,37 @@
                     yield name
 
     def _complete_in_string(self, start_leaf, string):
-        """
-        To make it possible for people to have completions in doctests or
+        """To make it possible for people to have completions in doctests or
         generally in "Python" code in docstrings, we use the following
         heuristic:
-
+        
         - Having an indented block of code
         - Having some doctest code that starts with `>>>`
         - Having backticks that doesn't have whitespace inside it
+
+        Parameters
+        ----------
+        start_leaf :
+            
+        string :
+            
+
+        Returns
+        -------
+
         """
         def iter_relevant_lines(lines):
+            """
+
+            Parameters
+            ----------
+            lines :
+                
+
+            Returns
+            -------
+
+            """
             include_next_line = False
             for l in code_lines:
                 if include_next_line or l.startswith('>>>') or l.startswith(' '):
@@ -464,6 +669,17 @@
         return []
 
     def _complete_code_lines(self, code_lines):
+        """
+
+        Parameters
+        ----------
+        code_lines :
+            
+
+        Returns
+        -------
+
+        """
         module_node = self._inference_state.grammar.parse(''.join(code_lines))
         module_value = ModuleValue(
             self._inference_state,
@@ -482,6 +698,17 @@
 
 
 def _gather_nodes(stack):
+    """
+
+    Parameters
+    ----------
+    stack :
+        
+
+    Returns
+    -------
+
+    """
     nodes = []
     for stack_node in stack:
         if stack_node.dfa.from_rule == 'small_stmt':
@@ -495,7 +722,31 @@
 
 
 def _extract_string_while_in_string(leaf, position):
+    """
+
+    Parameters
+    ----------
+    leaf :
+        
+    position :
+        
+
+    Returns
+    -------
+
+    """
     def return_part_of_leaf(leaf):
+        """
+
+        Parameters
+        ----------
+        leaf :
+            
+
+        Returns
+        -------
+
+        """
         kwargs = {}
         if leaf.line == position[0]:
             kwargs['endpos'] = position[1] - leaf.column
@@ -543,6 +794,19 @@
 
 
 def complete_trailer(user_context, values):
+    """
+
+    Parameters
+    ----------
+    user_context :
+        
+    values :
+        
+
+    Returns
+    -------
+
+    """
     completion_names = []
     for value in values:
         for filter in value.get_filters(origin_scope=user_context.tree_node):
@@ -560,24 +824,33 @@
 
 
 def _complete_getattr(user_context, instance):
-    """
-    A heuristic to make completion for proxy objects work. This is not
+    """A heuristic to make completion for proxy objects work. This is not
     intended to work in all cases. It works exactly in this case:
-
+    
         def __getattr__(self, name):
             ...
-            return getattr(any_object, name)
-
-    It is important that the return contains getattr directly, otherwise it
-    won't work anymore. It's really just a stupid heuristic. It will not
-    work if you write e.g. `return (getatr(o, name))`, because of the
-    additional parentheses. It will also not work if you move the getattr
-    to some other place that is not the return statement itself.
-
-    It is intentional that it doesn't work in all cases. Generally it's
-    really hard to do even this case (as you can see below). Most people
-    will write it like this anyway and the other ones, well they are just
-    out of luck I guess :) ~dave.
+
+    Parameters
+    ----------
+    user_context :
+        
+    instance :
+        
+
+    Returns
+    -------
+    type
+        It is important that the return contains getattr directly, otherwise it
+        won't work anymore. It's really just a stupid heuristic. It will not
+        work if you write e.g. `return (getatr(o, name))`, because of the
+        additional parentheses. It will also not work if you move the getattr
+        to some other place that is not the return statement itself.
+        
+        It is intentional that it doesn't work in all cases. Generally it's
+        really hard to do even this case (as you can see below). Most people
+        will write it like this anyway and the other ones, well they are just
+        out of luck I guess :) ~dave.
+
     """
     names = (instance.get_function_slot_names(u'__getattr__')
              or instance.get_function_slot_names(u'__getattribute__'))
@@ -626,6 +899,33 @@
 def search_in_module(inference_state, module_context, names, wanted_names,
                      wanted_type, complete=False, fuzzy=False,
                      ignore_imports=False, convert=False):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    module_context :
+        
+    names :
+        
+    wanted_names :
+        
+    wanted_type :
+        
+    complete :
+         (Default value = False)
+    fuzzy :
+         (Default value = False)
+    ignore_imports :
+         (Default value = False)
+    convert :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     for s in wanted_names[:-1]:
         new_names = []
         for n in names:
