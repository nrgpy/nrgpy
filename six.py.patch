# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/six.py
+++ b/..//venv/lib/python3.8/site-packages/six.py
@@ -58,6 +58,7 @@
     else:
         # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
         class X(object):
+            """ """
 
             def __len__(self):
                 return 1 << 31
@@ -73,17 +74,40 @@
 
 
 def _add_doc(func, doc):
-    """Add documentation to a function."""
+    """Add documentation to a function.
+
+    Parameters
+    ----------
+    func :
+        
+    doc :
+        
+
+    Returns
+    -------
+
+    """
     func.__doc__ = doc
 
 
 def _import_module(name):
-    """Import module, returning the module after the last dot."""
+    """Import module, returning the module after the last dot.
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     __import__(name)
     return sys.modules[name]
 
 
 class _LazyDescr(object):
+    """ """
 
     def __init__(self, name):
         self.name = name
@@ -101,6 +125,7 @@
 
 
 class MovedModule(_LazyDescr):
+    """ """
 
     def __init__(self, name, old, new=None):
         super(MovedModule, self).__init__(name)
@@ -112,6 +137,7 @@
             self.mod = old
 
     def _resolve(self):
+        """ """
         return _import_module(self.mod)
 
     def __getattr__(self, attr):
@@ -122,6 +148,7 @@
 
 
 class _LazyModule(types.ModuleType):
+    """ """
 
     def __init__(self, name):
         super(_LazyModule, self).__init__(name)
@@ -137,6 +164,7 @@
 
 
 class MovedAttribute(_LazyDescr):
+    """ """
 
     def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
         super(MovedAttribute, self).__init__(name)
@@ -157,17 +185,24 @@
             self.attr = old_attr
 
     def _resolve(self):
+        """ """
         module = _import_module(self.mod)
         return getattr(module, self.attr)
 
 
 class _SixMetaPathImporter(object):
 
-    """
-    A meta path importer to import six.moves and its submodules.
-
+    """A meta path importer to import six.moves and its submodules.
+    
     This class implements a PEP302 finder and loader. It should be compatible
     with Python 2.5 and all existing versions of Python3
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, six_module_name):
@@ -175,13 +210,50 @@
         self.known_modules = {}
 
     def _add_module(self, mod, *fullnames):
+        """
+
+        Parameters
+        ----------
+        mod :
+            
+        *fullnames :
+            
+
+        Returns
+        -------
+
+        """
         for fullname in fullnames:
             self.known_modules[self.name + "." + fullname] = mod
 
     def _get_module(self, fullname):
+        """
+
+        Parameters
+        ----------
+        fullname :
+            
+
+        Returns
+        -------
+
+        """
         return self.known_modules[self.name + "." + fullname]
 
     def find_module(self, fullname, path=None):
+        """
+
+        Parameters
+        ----------
+        fullname :
+            
+        path :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if fullname in self.known_modules:
             return self
         return None
@@ -193,6 +265,17 @@
             raise ImportError("This loader does not know module " + fullname)
 
     def load_module(self, fullname):
+        """
+
+        Parameters
+        ----------
+        fullname :
+            
+
+        Returns
+        -------
+
+        """
         try:
             # in case of a reload
             return sys.modules[fullname]
@@ -208,17 +291,35 @@
 
     def is_package(self, fullname):
         """
-        Return true, if the named module is a package.
-
-        We need this method to get correct spec objects with
-        Python 3.4 (see PEP451)
+
+        Parameters
+        ----------
+        fullname :
+            
+
+        Returns
+        -------
+        type
+            We need this method to get correct spec objects with
+            Python 3.4 (see PEP451)
+
         """
         return hasattr(self.__get_module(fullname), "__path__")
 
     def get_code(self, fullname):
-        """Return None
-
-        Required, if is_package is implemented"""
+        """
+
+        Parameters
+        ----------
+        fullname :
+            
+
+        Returns
+        -------
+        type
+            Required, if is_package is implemented
+
+        """
         self.__get_module(fullname)  # eventually raises ImportError
         return None
     get_source = get_code  # same as get_code
@@ -492,12 +593,32 @@
 
 
 def add_move(move):
-    """Add an item to six.moves."""
+    """Add an item to six.moves.
+
+    Parameters
+    ----------
+    move :
+        
+
+    Returns
+    -------
+
+    """
     setattr(_MovedItems, move.name, move)
 
 
 def remove_move(name):
-    """Remove item from six.moves."""
+    """Remove item from six.moves.
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     try:
         delattr(_MovedItems, name)
     except AttributeError:
@@ -529,6 +650,17 @@
     advance_iterator = next
 except NameError:
     def advance_iterator(it):
+        """
+
+        Parameters
+        ----------
+        it :
+            
+
+        Returns
+        -------
+
+        """
         return it.next()
 next = advance_iterator
 
@@ -537,32 +669,102 @@
     callable = callable
 except NameError:
     def callable(obj):
+        """
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
 
 
 if PY3:
     def get_unbound_function(unbound):
+        """
+
+        Parameters
+        ----------
+        unbound :
+            
+
+        Returns
+        -------
+
+        """
         return unbound
 
     create_bound_method = types.MethodType
 
     def create_unbound_method(func, cls):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         return func
 
     Iterator = object
 else:
     def get_unbound_function(unbound):
+        """
+
+        Parameters
+        ----------
+        unbound :
+            
+
+        Returns
+        -------
+
+        """
         return unbound.im_func
 
     def create_bound_method(func, obj):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         return types.MethodType(func, obj, obj.__class__)
 
     def create_unbound_method(func, cls):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         return types.MethodType(func, None, cls)
 
     class Iterator(object):
+        """ """
 
         def next(self):
+            """ """
             return type(self).__next__(self)
 
     callable = callable
@@ -580,15 +782,67 @@
 
 if PY3:
     def iterkeys(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return iter(d.keys(**kw))
 
     def itervalues(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return iter(d.values(**kw))
 
     def iteritems(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return iter(d.items(**kw))
 
     def iterlists(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return iter(d.lists(**kw))
 
     viewkeys = operator.methodcaller("keys")
@@ -598,15 +852,67 @@
     viewitems = operator.methodcaller("items")
 else:
     def iterkeys(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return d.iterkeys(**kw)
 
     def itervalues(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return d.itervalues(**kw)
 
     def iteritems(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return d.iteritems(**kw)
 
     def iterlists(d, **kw):
+        """
+
+        Parameters
+        ----------
+        d :
+            
+        **kw :
+            
+
+        Returns
+        -------
+
+        """
         return d.iterlists(**kw)
 
     viewkeys = operator.methodcaller("viewkeys")
@@ -625,9 +931,31 @@
 
 if PY3:
     def b(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return s.encode("latin-1")
 
     def u(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return s
     unichr = chr
     import struct
@@ -651,18 +979,64 @@
         _assertNotRegex = "assertNotRegex"
 else:
     def b(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return s
     # Workaround for standalone backslash
 
     def u(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
     unichr = unichr
     int2byte = chr
 
     def byte2int(bs):
+        """
+
+        Parameters
+        ----------
+        bs :
+            
+
+        Returns
+        -------
+
+        """
         return ord(bs[0])
 
     def indexbytes(buf, i):
+        """
+
+        Parameters
+        ----------
+        buf :
+            
+        i :
+            
+
+        Returns
+        -------
+
+        """
         return ord(buf[i])
     iterbytes = functools.partial(itertools.imap, ord)
     import StringIO
@@ -676,18 +1050,70 @@
 
 
 def assertCountEqual(self, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return getattr(self, _assertCountEqual)(*args, **kwargs)
 
 
 def assertRaisesRegex(self, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return getattr(self, _assertRaisesRegex)(*args, **kwargs)
 
 
 def assertRegex(self, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return getattr(self, _assertRegex)(*args, **kwargs)
 
 
 def assertNotRegex(self, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return getattr(self, _assertNotRegex)(*args, **kwargs)
 
 
@@ -695,6 +1121,21 @@
     exec_ = getattr(moves.builtins, "exec")
 
     def reraise(tp, value, tb=None):
+        """
+
+        Parameters
+        ----------
+        tp :
+            
+        value :
+            
+        tb :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         try:
             if value is None:
                 value = tp()
@@ -707,7 +1148,21 @@
 
 else:
     def exec_(_code_, _globs_=None, _locs_=None):
-        """Execute code in a namespace."""
+        """Execute code in a namespace.
+
+        Parameters
+        ----------
+        _code_ :
+            
+        _globs_ :
+             (Default value = None)
+        _locs_ :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if _globs_ is None:
             frame = sys._getframe(1)
             _globs_ = frame.f_globals
@@ -735,18 +1190,54 @@
 """)
 else:
     def raise_from(value, from_value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        from_value :
+            
+
+        Returns
+        -------
+
+        """
         raise value
 
 
 print_ = getattr(moves.builtins, "print", None)
 if print_ is None:
     def print_(*args, **kwargs):
-        """The new-style print function for Python 2.4 and 2.5."""
+        """The new-style print function for Python 2.4 and 2.5.
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         fp = kwargs.pop("file", sys.stdout)
         if fp is None:
             return
 
         def write(data):
+            """
+
+            Parameters
+            ----------
+            data :
+                
+
+            Returns
+            -------
+
+            """
             if not isinstance(data, basestring):
                 data = str(data)
             # If the file has an encoding, encode unicode with it.
@@ -797,6 +1288,19 @@
     _print = print_
 
     def print_(*args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         fp = kwargs.get("file", sys.stdout)
         flush = kwargs.pop("flush", False)
         _print(*args, **kwargs)
@@ -814,6 +1318,23 @@
     def _update_wrapper(wrapper, wrapped,
                         assigned=functools.WRAPPER_ASSIGNMENTS,
                         updated=functools.WRAPPER_UPDATES):
+        """
+
+        Parameters
+        ----------
+        wrapper :
+            
+        wrapped :
+            
+        assigned :
+             (Default value = functools.WRAPPER_ASSIGNMENTS)
+        updated :
+             (Default value = functools.WRAPPER_UPDATES)
+
+        Returns
+        -------
+
+        """
         for attr in assigned:
             try:
                 value = getattr(wrapped, attr)
@@ -829,6 +1350,21 @@
 
     def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
               updated=functools.WRAPPER_UPDATES):
+        """
+
+        Parameters
+        ----------
+        wrapped :
+            
+        assigned :
+             (Default value = functools.WRAPPER_ASSIGNMENTS)
+        updated :
+             (Default value = functools.WRAPPER_UPDATES)
+
+        Returns
+        -------
+
+        """
         return functools.partial(_update_wrapper, wrapped=wrapped,
                                  assigned=assigned, updated=updated)
     wraps.__doc__ = functools.wraps.__doc__
@@ -838,11 +1374,24 @@
 
 
 def with_metaclass(meta, *bases):
-    """Create a base class with a metaclass."""
+    """Create a base class with a metaclass.
+
+    Parameters
+    ----------
+    meta :
+        
+    *bases :
+        
+
+    Returns
+    -------
+
+    """
     # This requires a bit of explanation: the basic idea is to make a dummy
     # metaclass for one level of class instantiation that replaces itself with
     # the actual metaclass.
     class metaclass(type):
+        """ """
 
         def __new__(cls, name, this_bases, d):
             if sys.version_info[:2] >= (3, 7):
@@ -862,8 +1411,19 @@
 
 
 def add_metaclass(metaclass):
-    """Class decorator for creating a class with a metaclass."""
+    """Class decorator for creating a class with a metaclass.
+
+    Parameters
+    ----------
+    metaclass :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(cls):
+        """ """
         orig_vars = cls.__dict__.copy()
         slots = orig_vars.get('__slots__')
         if slots is not None:
@@ -881,14 +1441,27 @@
 
 def ensure_binary(s, encoding='utf-8', errors='strict'):
     """Coerce **s** to six.binary_type.
-
+    
     For Python 2:
       - `unicode` -> encoded to `str`
       - `str` -> `str`
-
+    
     For Python 3:
       - `str` -> encoded to `bytes`
       - `bytes` -> `bytes`
+
+    Parameters
+    ----------
+    s :
+        
+    encoding :
+         (Default value = 'utf-8')
+    errors :
+         (Default value = 'strict')
+
+    Returns
+    -------
+
     """
     if isinstance(s, binary_type):
         return s
@@ -899,14 +1472,27 @@
 
 def ensure_str(s, encoding='utf-8', errors='strict'):
     """Coerce *s* to `str`.
-
+    
     For Python 2:
       - `unicode` -> encoded to `str`
       - `str` -> `str`
-
+    
     For Python 3:
       - `str` -> `str`
       - `bytes` -> decoded to `str`
+
+    Parameters
+    ----------
+    s :
+        
+    encoding :
+         (Default value = 'utf-8')
+    errors :
+         (Default value = 'strict')
+
+    Returns
+    -------
+
     """
     # Optimization: Fast return for the common case.
     if type(s) is str:
@@ -922,14 +1508,27 @@
 
 def ensure_text(s, encoding='utf-8', errors='strict'):
     """Coerce *s* to six.text_type.
-
+    
     For Python 2:
       - `unicode` -> `unicode`
       - `str` -> `unicode`
-
+    
     For Python 3:
       - `str` -> `str`
       - `bytes` -> decoded to `str`
+
+    Parameters
+    ----------
+    s :
+        
+    encoding :
+         (Default value = 'utf-8')
+    errors :
+         (Default value = 'strict')
+
+    Returns
+    -------
+
     """
     if isinstance(s, binary_type):
         return s.decode(encoding, errors)
@@ -940,12 +1539,21 @@
 
 
 def python_2_unicode_compatible(klass):
-    """
-    A class decorator that defines __unicode__ and __str__ methods under Python 2.
+    """A class decorator that defines __unicode__ and __str__ methods under Python 2.
     Under Python 3 it does nothing.
-
+    
     To support Python 2 and 3 with a single code base, define a __str__ method
-    returning text and apply this decorator to the class.
+
+    Parameters
+    ----------
+    klass :
+        
+
+    Returns
+    -------
+    type
+        
+
     """
     if PY2:
         if '__str__' not in klass.__dict__:
