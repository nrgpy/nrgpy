# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/core/tests/test_completer.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/core/tests/test_completer.py
@@ -36,6 +36,7 @@
 
 @contextmanager
 def greedy_completion():
+    """ """
     ip = get_ipython()
     greedy_original = ip.Completer.greedy
     try:
@@ -46,6 +47,7 @@
 
 
 def test_protect_filename():
+    """ """
     if sys.platform == "win32":
         pairs = [
             ("abc", "abc"),
@@ -87,6 +89,19 @@
 
 
 def check_line_split(splitter, test_specs):
+    """
+
+    Parameters
+    ----------
+    splitter :
+        
+    test_specs :
+        
+
+    Returns
+    -------
+
+    """
     for part1, part2, split in test_specs:
         cursor_pos = len(part1)
         line = part1 + part2
@@ -119,11 +134,13 @@
 
 
 class NamedInstanceMetaclass(type):
+    """ """
     def __getitem__(cls, item):
         return cls.get_instance(item)
 
 
 class NamedInstanceClass(metaclass=NamedInstanceMetaclass):
+    """ """
     def __init__(self, name):
         if not hasattr(self.__class__, "instances"):
             self.__class__.instances = {}
@@ -131,30 +148,44 @@
 
     @classmethod
     def _ipython_key_completions_(cls):
+        """ """
         return cls.instances.keys()
 
     @classmethod
     def get_instance(cls, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         return cls.instances[name]
 
 
 class KeyCompletable:
+    """ """
     def __init__(self, things=()):
         self.things = things
 
     def _ipython_key_completions_(self):
+        """ """
         return list(self.things)
 
 
 class TestCompleter(unittest.TestCase):
+    """ """
     def setUp(self):
-        """
-        We want to silence all PendingDeprecationWarning when testing the completer
-        """
+        """We want to silence all PendingDeprecationWarning when testing the completer"""
         self._assertwarns = self.assertWarns(PendingDeprecationWarning)
         self._assertwarns.__enter__()
 
     def tearDown(self):
+        """ """
         try:
             self._assertwarns.__exit__(None, None, None)
         except AssertionError:
@@ -165,12 +196,26 @@
         ip = get_ipython()
 
         class A:
+            """ """
             pass
 
         ip.user_ns["x"] = A()
 
         @complete_object.register(A)
         def complete_A(a, existing_completions):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+            existing_completions :
+                
+
+            Returns
+            -------
+
+            """
             raise TypeError("this should be silenced")
 
         ip.complete("x.")
@@ -183,6 +228,17 @@
         assert matches.index('input') < matches.index('int')
 
         def complete_example(a):
+            """
+
+            Parameters
+            ----------
+            a :
+                
+
+            Returns
+            -------
+
+            """
             return ['example2', 'example1']
 
         ip.Completer.custom_completers.add_re('ex*', complete_example)
@@ -190,6 +246,7 @@
         assert matches.index('example2') < matches.index('example1')
 
     def test_unicode_completions(self):
+        """ """
         ip = get_ipython()
         # Some strings that trigger different types of completion.  Check them both
         # in str and unicode forms
@@ -204,6 +261,7 @@
             nt.assert_true(isinstance(matches, list))
 
     def test_latex_completions(self):
+        """ """
         from IPython.core.latex_symbols import latex_symbols
         import random
 
@@ -225,15 +283,14 @@
         nt.assert_in("\\aleph", matches)
 
     def test_latex_no_results(self):
-        """
-        forward latex should really return nothing in either field if nothing is found.
-        """
+        """forward latex should really return nothing in either field if nothing is found."""
         ip = get_ipython()
         text, matches = ip.Completer.latex_matches("\\really_i_should_match_nothing")
         nt.assert_equal(text, "")
         nt.assert_equal(matches, [])
 
     def test_back_latex_completion(self):
+        """ """
         ip = get_ipython()
 
         # do not return more than 1 matches fro \beta, only the latex one.
@@ -241,12 +298,14 @@
         nt.assert_equal(matches, ['\\beta'])
 
     def test_back_unicode_completion(self):
+        """ """
         ip = get_ipython()
 
         name, matches = ip.complete("\\â…¤")
         nt.assert_equal(matches, ["\\ROMAN NUMERAL FIVE"])
 
     def test_forward_unicode_completion(self):
+        """ """
         ip = get_ipython()
 
         name, matches = ip.complete("\\ROMAN NUMERAL FIVE")
@@ -258,6 +317,7 @@
         sys.platform == "win32", "Fails if there is a C:\\j... path"
     )
     def test_no_ascii_back_completion(self):
+        """ """
         ip = get_ipython()
         with TemporaryWorkingDirectory():  # Avoid any filename completions
             # single ascii letter that don't have yet completions
@@ -266,10 +326,13 @@
                 nt.assert_equal(matches, [])
 
     class CompletionSplitterTestCase(unittest.TestCase):
+        """ """
         def setUp(self):
+            """ """
             self.sp = completer.CompletionSplitter()
 
         def test_delim_setting(self):
+            """ """
             self.sp.delims = " "
             nt.assert_equal(self.sp.delims, " ")
             nt.assert_equal(self.sp._delim_expr, r"[\ ]")
@@ -281,25 +344,32 @@
             check_line_split(self.sp, t)
 
     def test_has_open_quotes1(self):
-        for s in ["'", "'''", "'hi' '"]:
+        """for s in ["'", "'''", "'hi' '"]:
             nt.assert_equal(completer.has_open_quotes(s), "'")
-
-    def test_has_open_quotes2(self):
+        
+            def test_has_open_quotes2(self):
         for s in ['"', '"""', '"hi" "']:
             nt.assert_equal(completer.has_open_quotes(s), '"')
-
-    def test_has_open_quotes3(self):
+        
+            def test_has_open_quotes3(self):
         for s in ["''", "''' '''", "'hi' 'ipython'"]:
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             nt.assert_false(completer.has_open_quotes(s))
 
     def test_has_open_quotes4(self):
-        for s in ['""', '""" """', '"hi" "ipython"']:
+        """for s in ['""', '""" """', '"hi" "ipython"']:"""
             nt.assert_false(completer.has_open_quotes(s))
 
     @decorators.knownfailureif(
         sys.platform == "win32", "abspath completions fail on Windows"
     )
     def test_abspath_file_completions(self):
+        """ """
         ip = get_ipython()
         with TemporaryDirectory() as tmpdir:
             prefix = os.path.join(tmpdir, "foo")
@@ -319,6 +389,7 @@
             nt.assert_equal(c, comp)
 
     def test_local_file_completions(self):
+        """ """
         ip = get_ipython()
         with TemporaryWorkingDirectory():
             prefix = "./foo"
@@ -338,6 +409,7 @@
             nt.assert_true(comp.issubset(set(c)))
 
     def test_quoted_file_completions(self):
+        """ """
         ip = get_ipython()
         with TemporaryWorkingDirectory():
             name = "foo'bar"
@@ -368,9 +440,15 @@
             nt.assert_equal(c, [escaped])
 
     def test_all_completions_dups(self):
-        """
-        Make sure the output of `IPCompleter.all_completions` does not have
+        """Make sure the output of `IPCompleter.all_completions` does not have
         duplicated prefixes.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         ip = get_ipython()
         c = ip.Completer
@@ -386,12 +464,29 @@
                 assert matches == ['TestClass.a', 'TestClass.a1'], jedi_status
 
     def test_jedi(self):
-        """
-        A couple of issue we had with Jedi
-        """
+        """A couple of issue we had with Jedi"""
         ip = get_ipython()
 
         def _test_complete(reason, s, comp, start=None, end=None):
+            """
+
+            Parameters
+            ----------
+            reason :
+                
+            s :
+                
+            comp :
+                
+            start :
+                 (Default value = None)
+            end :
+                 (Default value = None)
+
+            Returns
+            -------
+
+            """
             l = len(s)
             start = start if start is not None else l
             end = end if end is not None else l
@@ -402,6 +497,21 @@
                 assert_in(Completion(start, end, comp), completions, reason)
 
         def _test_not_complete(reason, s, comp):
+            """
+
+            Parameters
+            ----------
+            reason :
+                
+            s :
+                
+            comp :
+                
+
+            Returns
+            -------
+
+            """
             l = len(s)
             with provisionalcompleter():
                 ip.Completer.use_jedi = True
@@ -421,9 +531,7 @@
         yield _test_not_complete, "does not mix types", 'a=(1,"foo");a[0].', "capitalize"
 
     def test_completion_have_signature(self):
-        """
-        Lets make sure jedi is capable of pulling out the signature of the function we are completing.
-        """
+        """Lets make sure jedi is capable of pulling out the signature of the function we are completing."""
         ip = get_ipython()
         with provisionalcompleter():
             ip.Completer.use_jedi = True
@@ -436,14 +544,13 @@
         ), "Signature of function was not found by completer"
 
     def test_deduplicate_completions(self):
-        """
-        Test that completions are correctly deduplicated (even if ranges are not the same)
-        """
+        """Test that completions are correctly deduplicated (even if ranges are not the same)"""
         ip = get_ipython()
         ip.ex(
             textwrap.dedent(
                 """
         class Z:
+            """ """
             zoo = 1
         """
             )
@@ -459,13 +566,18 @@
         assert l[0].text == "zoo"  # and not `it.accumulate`
 
     def test_greedy_completions(self):
-        """
-        Test the capability of the Greedy completer. 
-
+        """Test the capability of the Greedy completer.
+        
         Most of the test here does not really show off the greedy completer, for proof
-        each of the text below now pass with Jedi. The greedy completer is capable of more. 
-
+        each of the text below now pass with Jedi. The greedy completer is capable of more.
+        
         See the :any:`test_dict_key_completion_contexts`
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         ip = get_ipython()
@@ -474,6 +586,25 @@
         nt.assert_false(".real" in c, "Shouldn't have completed on a[0]: %s" % c)
 
         def _(line, cursor_pos, expect, message, completion):
+            """
+
+            Parameters
+            ----------
+            line :
+                
+            cursor_pos :
+                
+            expect :
+                
+            message :
+                
+            completion :
+                
+
+            Returns
+            -------
+
+            """
             with greedy_completion(), provisionalcompleter():
                 ip.Completer.use_jedi = False
                 _, c = ip.complete(".", line=line, cursor_pos=cursor_pos)
@@ -497,6 +628,7 @@
             )
 
     def test_omit__names(self):
+        """ """
         # also happens to test IPCompleter as a configurable
         ip = get_ipython()
         ip._hidden_attr = 1
@@ -558,9 +690,7 @@
         del ip._x
 
     def test_limit_to__all__False_ok(self):
-        """
-        Limit to all is deprecated, once we remove it this test can go away. 
-        """
+        """Limit to all is deprecated, once we remove it this test can go away."""
         ip = get_ipython()
         c = ip.Completer
         c.use_jedi = False
@@ -573,20 +703,25 @@
         nt.assert_in("d.x", matches)
 
     def test_get__all__entries_ok(self):
+        """ """
         class A:
+            """ """
             __all__ = ["x", 1]
 
         words = completer.get__all__entries(A())
         nt.assert_equal(words, ["x"])
 
     def test_get__all__entries_no__all__ok(self):
+        """ """
         class A:
+            """ """
             pass
 
         words = completer.get__all__entries(A())
         nt.assert_equal(words, [])
 
     def test_func_kw_completions(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
         c.use_jedi = False
@@ -603,6 +738,7 @@
         nt.assert_in("key=", matches)
 
     def test_default_arguments_from_docstring(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
         kwd = c._default_arguments_from_docstring("min(iterable[, key=func]) -> value")
@@ -619,6 +755,7 @@
         nt.assert_equal(kwd, ["ncall", "resume", "nsplit"])
 
     def test_line_magics(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
         s, matches = c.complete(None, "lsmag")
@@ -627,10 +764,24 @@
         nt.assert_in("%lsmagic", matches)
 
     def test_cell_magics(self):
+        """ """
         from IPython.core.magic import register_cell_magic
 
         @register_cell_magic
         def _foo_cellm(line, cell):
+            """
+
+            Parameters
+            ----------
+            line :
+                
+            cell :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         ip = get_ipython()
@@ -642,10 +793,24 @@
         nt.assert_in("%%_foo_cellm", matches)
 
     def test_line_cell_magics(self):
+        """ """
         from IPython.core.magic import register_line_cell_magic
 
         @register_line_cell_magic
         def _bar_cellm(line, cell):
+            """
+
+            Parameters
+            ----------
+            line :
+                
+            cell :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
         ip = get_ipython()
@@ -666,6 +831,7 @@
         nt.assert_in("%%_bar_cellm", matches)
 
     def test_magic_completion_order(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
 
@@ -674,6 +840,7 @@
         nt.assert_equal(matches, ["%timeit", "%%timeit"])
 
     def test_magic_completion_shadowing(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
         c.use_jedi = False
@@ -694,9 +861,15 @@
         nt.assert_equal(matches, ["%matplotlib"])
 
     def test_magic_completion_shadowing_explicit(self):
-        """
-        If the user try to complete a shadowed magic, and explicit % start should
+        """If the user try to complete a shadowed magic, and explicit % start should
         still return the completions.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         ip = get_ipython()
         c = ip.Completer
@@ -713,6 +886,7 @@
         nt.assert_equal(matches, ["%matplotlib"])
 
     def test_magic_config(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
 
@@ -742,6 +916,7 @@
         nt.assert_list_equal(["AliasManager.default_aliases"], matches)
 
     def test_magic_color(self):
+        """ """
         ip = get_ipython()
         c = ip.Completer
 
@@ -761,9 +936,15 @@
         nt.assert_list_equal(["NoColor"], matches)
 
     def test_match_dict_keys(self):
-        """
-        Test that match_dict_keys works on a couple of use case does return what
+        """Test that match_dict_keys works on a couple of use case does return what
         expected, and does not crash
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         delims = " \t\n`!@#$^&*()=+[{]}\\|;:'\",<>?"
 
@@ -872,12 +1053,24 @@
         ip.user_ns["d"] = d
 
         class C:
+            """ """
             data = d
 
         ip.user_ns["C"] = C
         ip.user_ns["get"] = lambda: d
 
         def assert_no_completion(**kwargs):
+            """
+
+            Parameters
+            ----------
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             _, matches = complete(**kwargs)
             nt.assert_not_in("abc", matches)
             nt.assert_not_in("abc'", matches)
@@ -886,6 +1079,17 @@
             nt.assert_not_in("'abc']", matches)
 
         def assert_completion(**kwargs):
+            """
+
+            Parameters
+            ----------
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             _, matches = complete(**kwargs)
             nt.assert_in("'abc'", matches)
             nt.assert_not_in("'abc']", matches)
@@ -903,6 +1107,17 @@
 
         # greedy flag
         def assert_completion(**kwargs):
+            """
+
+            Parameters
+            ----------
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             _, matches = complete(**kwargs)
             nt.assert_in("get()['abc']", matches)
 
@@ -1026,6 +1241,7 @@
         _, matches = complete(line_buffer="d['\\")  # incomplete escape
 
     def test_object_key_completion(self):
+        """ """
         ip = get_ipython()
         ip.user_ns["key_completable"] = KeyCompletable(["qwerty", "qwick"])
 
@@ -1034,6 +1250,7 @@
         nt.assert_in("qwick", matches)
 
     def test_class_key_completion(self):
+        """ """
         ip = get_ipython()
         NamedInstanceClass("qwerty")
         NamedInstanceClass("qwick")
@@ -1044,20 +1261,20 @@
         nt.assert_in("qwick", matches)
 
     def test_tryimport(self):
-        """
-        Test that try-import don't crash on trailing dot, and import modules before
-        """
+        """Test that try-import don't crash on trailing dot, and import modules before"""
         from IPython.core.completerlib import try_import
 
         assert try_import("IPython.")
 
     def test_aimport_module_completer(self):
+        """ """
         ip = get_ipython()
         _, matches = ip.complete("i", "%aimport i")
         nt.assert_in("io", matches)
         nt.assert_not_in("int", matches)
 
     def test_nested_import_module_completer(self):
+        """ """
         ip = get_ipython()
         _, matches = ip.complete(None, "import IPython.co", 17)
         nt.assert_in("IPython.core", matches)
@@ -1065,18 +1282,21 @@
         nt.assert_not_in("IPython.display", matches)
 
     def test_import_module_completer(self):
+        """ """
         ip = get_ipython()
         _, matches = ip.complete("i", "import i")
         nt.assert_in("io", matches)
         nt.assert_not_in("int", matches)
 
     def test_from_module_completer(self):
+        """ """
         ip = get_ipython()
         _, matches = ip.complete("B", "from io import B", 16)
         nt.assert_in("BytesIO", matches)
         nt.assert_not_in("BaseException", matches)
 
     def test_snake_case_completion(self):
+        """ """
         ip = get_ipython()
         ip.Completer.use_jedi = False
         ip.user_ns["some_three"] = 3
@@ -1086,6 +1306,7 @@
         nt.assert_in("some_four", matches)
 
     def test_mix_terms(self):
+        """ """
         ip = get_ipython()
         from textwrap import dedent
 
@@ -1094,13 +1315,51 @@
             dedent(
                 """
             class Test:
+                """ """
                 def meth(self, meth_arg1):
+                    """
+
+                    Parameters
+                    ----------
+                    meth_arg1 :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     print("meth")
 
                 def meth_1(self, meth1_arg1, meth1_arg2):
+                    """
+
+                    Parameters
+                    ----------
+                    meth1_arg1 :
+                        
+                    meth1_arg2 :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     print("meth1")
 
                 def meth_2(self, meth2_arg1, meth2_arg2):
+                    """
+
+                    Parameters
+                    ----------
+                    meth2_arg1 :
+                        
+                    meth2_arg2 :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     print("meth2")
             test = Test()
             """
