# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/_ufunc_config.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/_ufunc_config.py
@@ -31,9 +31,8 @@
 
 @set_module('numpy')
 def seterr(all=None, divide=None, over=None, under=None, invalid=None):
-    """
-    Set how floating-point errors are handled.
-
+    """Set how floating-point errors are handled.
+    
     Note that operations on integer scalar types (such as `int16`) are
     handled like floating point, and are affected by these settings.
 
@@ -41,23 +40,21 @@
     ----------
     all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
         Set treatment for all types of floating-point errors at once:
-
         - ignore: Take no action when the exception occurs.
         - warn: Print a `RuntimeWarning` (via the Python `warnings` module).
         - raise: Raise a `FloatingPointError`.
         - call: Call a function specified using the `seterrcall` function.
         - print: Print a warning directly to ``stdout``.
         - log: Record error in a Log object specified by `seterrcall`.
-
         The default is not to change the current behavior.
     divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
-        Treatment for division by zero.
+        Treatment for division by zero. (Default value = None)
     over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
-        Treatment for floating-point overflow.
+        Treatment for floating-point overflow. (Default value = None)
     under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
-        Treatment for floating-point underflow.
+        Treatment for floating-point underflow. (Default value = None)
     invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
-        Treatment for invalid floating-point operation.
+        Treatment for invalid floating-point operation. (Default value = None)
 
     Returns
     -------
@@ -68,20 +65,18 @@
     --------
     seterrcall : Set a callback function for the 'call' mode.
     geterr, geterrcall, errstate
-
     Notes
     -----
     The floating-point exceptions are defined in the IEEE 754 standard [1]_:
-
+    
     - Division by zero: infinite result obtained from finite numbers.
     - Overflow: result too large to be expressed.
     - Underflow: result so close to zero that some precision
       was lost.
     - Invalid operation: result is not an expressible number, typically
       indicates that a NaN was produced.
-
+    
     .. [1] https://en.wikipedia.org/wiki/IEEE_754
-
     Examples
     --------
     >>> old_settings = np.seterr(all='ignore')  #seterr to known value
@@ -89,7 +84,7 @@
     {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
     >>> np.seterr(**old_settings)  # reset to default
     {'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}
-
+    
     >>> np.int16(32000) * np.int16(3)
     30464
     >>> old_settings = np.seterr(all='warn', over='raise')
@@ -97,14 +92,13 @@
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     FloatingPointError: overflow encountered in short_scalars
-
+    
     >>> from collections import OrderedDict
     >>> old_settings = np.seterr(all='print')
     >>> OrderedDict(np.geterr())
     OrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])
     >>> np.int16(32000) * np.int16(3)
     30464
-
     """
 
     pyvals = umath.geterrobj()
@@ -131,8 +125,10 @@
 
 @set_module('numpy')
 def geterr():
-    """
-    Get the current way of handling floating-point errors.
+    """Get the current way of handling floating-point errors.
+
+    Parameters
+    ----------
 
     Returns
     -------
@@ -145,12 +141,10 @@
     See Also
     --------
     geterrcall, seterr, seterrcall
-
     Notes
     -----
     For complete documentation of the types of floating-point exceptions and
     treatment options, see `seterr`.
-
     Examples
     --------
     >>> from collections import OrderedDict
@@ -158,13 +152,12 @@
     [('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]
     >>> np.arange(3.) / np.arange(3.)
     array([nan,  1.,  1.])
-
+    
     >>> oldsettings = np.seterr(all='warn', over='raise')
     >>> OrderedDict(sorted(np.geterr().items()))
     OrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])
     >>> np.arange(3.) / np.arange(3.)
     array([nan,  1.,  1.])
-
     """
     maskvalue = umath.geterrobj()[1]
     mask = 7
@@ -182,14 +175,17 @@
 
 @set_module('numpy')
 def setbufsize(size):
-    """
-    Set the size of the buffer used in ufuncs.
-
-    Parameters
-    ----------
-    size : int
-        Size of buffer.
-
+    """Set the size of the buffer used in ufuncs.
+
+    Parameters
+    ----------
+    size :
+        
+
+    Returns
+    -------
+
+    
     """
     if size > 10e6:
         raise ValueError("Buffer size, %s, is too big." % size)
@@ -207,27 +203,18 @@
 
 @set_module('numpy')
 def getbufsize():
-    """
-    Return the size of the buffer used in ufuncs.
-
-    Returns
-    -------
-    getbufsize : int
-        Size of ufunc buffer in bytes.
-
-    """
+    """Return the size of the buffer used in ufuncs."""
     return umath.geterrobj()[0]
 
 
 @set_module('numpy')
 def seterrcall(func):
-    """
-    Set the floating-point error callback function or log object.
-
+    """Set the floating-point error callback function or log object.
+    
     There are two ways to capture floating-point error messages.  The first
     is to set the error-handler to 'call', using `seterr`.  Then, set
     the function to call using this function.
-
+    
     The second is to set the error-handler to 'log', using `seterr`.
     Floating-point errors then trigger a call to the 'write' method of
     the provided object.
@@ -237,17 +224,13 @@
     func : callable f(err, flag) or object with write method
         Function to call upon floating-point errors ('call'-mode) or
         object whose 'write' method is used to log such message ('log'-mode).
-
         The call function takes two arguments. The first is a string describing
         the type of error (such as "divide by zero", "overflow", "underflow",
         or "invalid value"), and the second is the status flag.  The flag is a
         byte, whose four least-significant bits indicate the type of error, one
         of "divide", "over", "under", "invalid"::
-
-          [0 0 0 0 divide over under invalid]
-
+        [0 0 0 0 divide over under invalid]
         In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.
-
         If an object is provided, its write method should take one argument,
         a string.
 
@@ -259,48 +242,49 @@
     See Also
     --------
     seterr, geterr, geterrcall
-
     Examples
     --------
     Callback upon error:
-
+    
+    
+    
+    
+    
+    Log error message:
     >>> def err_handler(type, flag):
     ...     print("Floating point error (%s), with flag %s" % (type, flag))
     ...
-
+    
     >>> saved_handler = np.seterrcall(err_handler)
     >>> save_err = np.seterr(all='call')
     >>> from collections import OrderedDict
-
+    
     >>> np.array([1, 2, 3]) / 0.0
     Floating point error (divide by zero), with flag 1
     array([inf, inf, inf])
-
+    
     >>> np.seterrcall(saved_handler)
     <function err_handler at 0x...>
     >>> OrderedDict(sorted(np.seterr(**save_err).items()))
     OrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])
-
-    Log error message:
-
+    
     >>> class Log:
     ...     def write(self, msg):
     ...         print("LOG: %s" % msg)
     ...
-
+    
     >>> log = Log()
     >>> saved_handler = np.seterrcall(log)
     >>> save_err = np.seterr(all='log')
-
+    
     >>> np.array([1, 2, 3]) / 0.0
     LOG: Warning: divide by zero encountered in true_divide
     array([inf, inf, inf])
-
+    
     >>> np.seterrcall(saved_handler)
     <numpy.core.numeric.Log object at 0x...>
     >>> OrderedDict(sorted(np.seterr(**save_err).items()))
     OrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])
-
     """
     if func is not None and not isinstance(func, collections.abc.Callable):
         if (not hasattr(func, 'write') or
@@ -315,15 +299,17 @@
 
 @set_module('numpy')
 def geterrcall():
-    """
-    Return the current callback function used on floating-point errors.
-
+    """Return the current callback function used on floating-point errors.
+    
     When the error handling for a floating-point error (one of "divide",
     "over", "under", or "invalid") is set to 'call' or 'log', the function
     that is called or the log instance that is written to is returned by
     `geterrcall`. This function or log instance has been set with
     `seterrcall`.
 
+    Parameters
+    ----------
+
     Returns
     -------
     errobj : callable, log instance or None
@@ -333,16 +319,14 @@
     See Also
     --------
     seterrcall, seterr, geterr
-
     Notes
     -----
     For complete documentation of the types of floating-point exceptions and
     treatment options, see `seterr`.
-
     Examples
     --------
     >>> np.geterrcall()  # we did not yet set a handler, returns None
-
+    
     >>> oldsettings = np.seterr(all='call')
     >>> def err_handler(type, flag):
     ...     print("Floating point error (%s), with flag %s" % (type, flag))
@@ -350,16 +334,16 @@
     >>> np.array([1, 2, 3]) / 0.0
     Floating point error (divide by zero), with flag 1
     array([inf, inf, inf])
-
+    
     >>> cur_handler = np.geterrcall()
     >>> cur_handler is err_handler
     True
-
     """
     return umath.geterrobj()[2]
 
 
 class _unspecified:
+    """ """
     pass
 
 
@@ -368,16 +352,15 @@
 
 @set_module('numpy')
 class errstate(contextlib.ContextDecorator):
-    """
-    errstate(**kwargs)
-
+    """errstate(**kwargs)
+    
     Context manager for floating-point error handling.
-
+    
     Using an instance of `errstate` as a context manager allows statements in
     that context to execute with a known error handling behavior. Upon entering
     the context the error handling is set with `seterr` and `seterrcall`, and
     upon exiting it is reset to what it was before.
-
+    
     ..  versionchanged:: 1.17.0
         `errstate` is also usable as a function decorator, saving
         a level of indentation if an entire function is wrapped.
@@ -391,26 +374,31 @@
         treatment for the particular error. Possible values are
         {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.
 
+    Returns
+    -------
+
     See Also
     --------
     seterr, geterr, seterrcall, geterrcall
-
     Notes
     -----
     For complete documentation of the types of floating-point exceptions and
     treatment options, see `seterr`.
-
     Examples
     --------
+    
+    
+    
+    Outside the context the error handling behavior has not changed:
     >>> from collections import OrderedDict
     >>> olderr = np.seterr(all='ignore')  # Set error handling to known state.
-
+    
     >>> np.arange(3) / 0.
     array([nan, inf, inf])
     >>> with np.errstate(divide='warn'):
     ...     np.arange(3) / 0.
     array([nan, inf, inf])
-
+    
     >>> np.sqrt(-1)
     nan
     >>> with np.errstate(invalid='raise'):
@@ -418,12 +406,9 @@
     Traceback (most recent call last):
       File "<stdin>", line 2, in <module>
     FloatingPointError: invalid value encountered in sqrt
-
-    Outside the context the error handling behavior has not changed:
-
+    
     >>> OrderedDict(sorted(np.geterr().items()))
     OrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])
-
     """
 
     def __init__(self, *, call=_Unspecified, **kwargs):
@@ -442,6 +427,7 @@
 
 
 def _setdef():
+    """ """
     defval = [UFUNC_BUFSIZE_DEFAULT, ERR_DEFAULT, None]
     umath.seterrobj(defval)
 
