# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/internals/test_internals.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/internals/test_internals.py
@@ -19,6 +19,7 @@
 
 @pytest.fixture
 def mgr():
+    """ """
     return create_mgr(
         "a: f8; b: object; c: f8; d: object; e: f8;"
         "f: bool; g: i8; h: complex; i: datetime-1; j: datetime-2;"
@@ -27,6 +28,19 @@
 
 
 def assert_block_equal(left, right):
+    """
+
+    Parameters
+    ----------
+    left :
+        
+    right :
+        
+
+    Returns
+    -------
+
+    """
     tm.assert_numpy_array_equal(left.values, right.values)
     assert left.dtype == right.dtype
     assert isinstance(left.mgr_locs, BlockPlacement)
@@ -35,6 +49,17 @@
 
 
 def get_numeric_mat(shape):
+    """
+
+    Parameters
+    ----------
+    shape :
+        
+
+    Returns
+    -------
+
+    """
     arr = np.arange(shape[0])
     return np.lib.stride_tricks.as_strided(
         x=arr, shape=shape, strides=(arr.itemsize,) + (0,) * (len(shape) - 1)
@@ -45,9 +70,8 @@
 
 
 def create_block(typestr, placement, item_shape=None, num_offset=0):
-    """
-    Supported typestr:
-
+    """Supported typestr:
+    
         * float, f8, f4, f2
         * int, i8, i4, i2, i1
         * uint, u8, u4, u2, u1
@@ -59,6 +83,20 @@
         * sparse (SparseArray with fill_value=0.0)
         * sparse_na (SparseArray with fill_value=np.nan)
         * category, category2
+
+    Parameters
+    ----------
+    typestr :
+        
+    placement :
+        
+    item_shape :
+         (Default value = None)
+    num_offset :
+         (Default value = 0)
+
+    Returns
+    -------
 
     """
     placement = BlockPlacement(placement)
@@ -130,6 +168,19 @@
 
 
 def create_single_mgr(typestr, num_rows=None):
+    """
+
+    Parameters
+    ----------
+    typestr :
+        
+    num_rows :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if num_rows is None:
         num_rows = N
 
@@ -140,24 +191,33 @@
 
 
 def create_mgr(descr, item_shape=None):
-    """
-    Construct BlockManager from string description.
-
+    """Construct BlockManager from string description.
+    
     String description syntax looks similar to np.matrix initializer.  It looks
     like this::
-
+    
         a,b,c: f8; d,e,f: i8
-
+    
     Rules are rather simple:
-
+    
     * see list of supported datatypes in `create_block` method
     * components are semicolon-separated
     * each component is `NAME,NAME,NAME: DTYPE_ID`
     * whitespace around colons & semicolons are removed
     * components with same DTYPE_ID are combined into single block
     * to force multiple blocks with same dtype, use '-SUFFIX'::
-
+    
         'a:f8-1; b:f8-2; c:f8-foobar'
+
+    Parameters
+    ----------
+    descr :
+        
+    item_shape :
+         (Default value = None)
+
+    Returns
+    -------
 
     """
     if item_shape is None:
@@ -202,18 +262,43 @@
 
 
 class TestBlock:
+    """ """
     def setup_method(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         self.fblock = create_block("float", [0, 2, 4])
         self.cblock = create_block("complex", [7])
         self.oblock = create_block("object", [1, 3])
         self.bool_block = create_block("bool", [5])
 
     def test_constructor(self):
+        """ """
         int32block = create_block("i4", [0])
         assert int32block.dtype == np.int32
 
     def test_pickle(self):
+        """ """
         def _check(blk):
+            """
+
+            Parameters
+            ----------
+            blk :
+                
+
+            Returns
+            -------
+
+            """
             assert_block_equal(tm.round_trip_pickle(blk), blk)
 
         _check(self.fblock)
@@ -222,22 +307,26 @@
         _check(self.bool_block)
 
     def test_mgr_locs(self):
+        """ """
         assert isinstance(self.fblock.mgr_locs, BlockPlacement)
         tm.assert_numpy_array_equal(
             self.fblock.mgr_locs.as_array, np.array([0, 2, 4], dtype=np.int64)
         )
 
     def test_attrs(self):
+        """ """
         assert self.fblock.shape == self.fblock.values.shape
         assert self.fblock.dtype == self.fblock.values.dtype
         assert len(self.fblock) == len(self.fblock.values)
 
     def test_copy(self):
+        """ """
         cop = self.fblock.copy()
         assert cop is not self.fblock
         assert_block_equal(self.fblock, cop)
 
     def test_delete(self):
+        """ """
         newb = self.fblock.copy()
         newb.delete(0)
         assert isinstance(newb.mgr_locs, BlockPlacement)
@@ -268,12 +357,15 @@
 
 
 class TestBlockManager:
+    """ """
     def test_attrs(self):
+        """ """
         mgr = create_mgr("a,b,c: f8-1; d,e,f: f8-2")
         assert mgr.nblocks == 2
         assert len(mgr) == 6
 
     def test_is_mixed_dtype(self):
+        """ """
         assert not create_mgr("a,b:f8").is_mixed_type
         assert not create_mgr("a:f8-1; b:f8-2").is_mixed_type
 
@@ -281,6 +373,7 @@
         assert create_mgr("a,b:f8; c,d: object").is_mixed_type
 
     def test_duplicate_ref_loc_failure(self):
+        """ """
         tmp_mgr = create_mgr("a:bool; a: f8")
 
         axes, blocks = tmp_mgr.axes, tmp_mgr.blocks
@@ -302,6 +395,17 @@
         mgr.iget(1)
 
     def test_pickle(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
 
         mgr2 = tm.round_trip_pickle(mgr)
         tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))
@@ -316,11 +420,23 @@
 
     @pytest.mark.parametrize("mgr_string", ["a,a,a:f8", "a: f8; a: i8"])
     def test_non_unique_pickle(self, mgr_string):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+
+        Returns
+        -------
+
+        """
         mgr = create_mgr(mgr_string)
         mgr2 = tm.round_trip_pickle(mgr)
         tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))
 
     def test_categorical_block_pickle(self):
+        """ """
         mgr = create_mgr("a: category")
         mgr2 = tm.round_trip_pickle(mgr)
         tm.assert_frame_equal(DataFrame(mgr), DataFrame(mgr2))
@@ -330,6 +446,7 @@
         tm.assert_series_equal(Series(smgr), Series(smgr2))
 
     def test_iget(self):
+        """ """
         cols = Index(list("abc"))
         values = np.random.rand(3, 3)
         block = make_block(values=values.copy(), placement=np.arange(3))
@@ -340,6 +457,7 @@
         tm.assert_almost_equal(mgr.iget(2).internal_values(), values[2])
 
     def test_set(self):
+        """ """
         mgr = create_mgr("a,b,c: int", item_shape=(3,))
 
         mgr.insert(len(mgr.items), "d", np.array(["foo"] * 3))
@@ -354,6 +472,17 @@
         )
 
     def test_set_change_dtype(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         mgr.insert(len(mgr.items), "baz", np.zeros(N, dtype=bool))
 
         mgr.iset(mgr.items.get_loc("baz"), np.repeat("foo", N))
@@ -373,6 +502,17 @@
         assert mgr2.iget(idx).dtype == np.float_
 
     def test_copy(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         cp = mgr.copy(deep=False)
         for blk, cp_blk in zip(mgr.blocks, cp.blocks):
 
@@ -396,11 +536,13 @@
                 assert cp_blk.values.base is None and blk.values.base is None
 
     def test_sparse(self):
+        """ """
         mgr = create_mgr("a: sparse-1; b: sparse-2")
         # what to test here?
         assert mgr.as_array().dtype == np.float64
 
     def test_sparse_mixed(self):
+        """ """
         mgr = create_mgr("a: sparse-1; b: sparse-2; c: f8")
         assert len(mgr.blocks) == 3
         assert isinstance(mgr, BlockManager)
@@ -412,6 +554,19 @@
         [("c: f4; d: f2", np.float32), ("c: f4; d: f2; e: f8", np.float64)],
     )
     def test_as_array_float(self, mgr_string, dtype):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         mgr = create_mgr(mgr_string)
         assert mgr.as_array().dtype == dtype
 
@@ -424,14 +579,29 @@
         ],
     )
     def test_as_array_int_bool(self, mgr_string, dtype):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         mgr = create_mgr(mgr_string)
         assert mgr.as_array().dtype == dtype
 
     def test_as_array_datetime(self):
+        """ """
         mgr = create_mgr("h: datetime-1; g: datetime-2")
         assert mgr.as_array().dtype == "M8[ns]"
 
     def test_as_array_datetime_tz(self):
+        """ """
         mgr = create_mgr("h: M8[ns, US/Eastern]; g: M8[ns, CET]")
         assert mgr.iget(0).dtype == "datetime64[ns, US/Eastern]"
         assert mgr.iget(1).dtype == "datetime64[ns, CET]"
@@ -439,6 +609,17 @@
 
     @pytest.mark.parametrize("t", ["float16", "float32", "float64", "int32", "int64"])
     def test_astype(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         # coerce all
         mgr = create_mgr("c: f4; d: f2; e: f8")
 
@@ -466,8 +647,21 @@
             assert tmgr.iget(3).dtype.type == t
 
     def test_convert(self):
+        """ """
         def _compare(old_mgr, new_mgr):
-            """ compare the blocks, numeric compare ==, object don't """
+            """compare the blocks, numeric compare ==, object don't
+
+            Parameters
+            ----------
+            old_mgr :
+                
+            new_mgr :
+                
+
+            Returns
+            -------
+
+            """
             old_blocks = set(old_mgr.blocks)
             new_blocks = set(new_mgr.blocks)
             assert len(old_blocks) == len(new_blocks)
@@ -524,6 +718,7 @@
         assert new_mgr.iget(8).dtype == np.float16
 
     def test_invalid_ea_block(self):
+        """ """
         with pytest.raises(AssertionError, match="block.size != values.size"):
             create_mgr("a: category; b: category")
 
@@ -531,6 +726,7 @@
             create_mgr("a: category2; b: category2")
 
     def test_interleave(self):
+        """ """
         # self
         for dtype in ["f8", "i8", "object", "bool", "complex", "M8[ns]", "m8[ns]"]:
             mgr = create_mgr(f"a: {dtype}")
@@ -562,6 +758,19 @@
         ],
     )
     def test_interleave_dtype(self, mgr_string, dtype):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # will be converted according the actual dtype of the underlying
         mgr = create_mgr("a: category")
         assert mgr.as_array().dtype == "i8"
@@ -599,6 +808,17 @@
         assert mgr.as_array().dtype == "object"
 
     def test_consolidate_ordering_issues(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         mgr.iset(mgr.items.get_loc("f"), tm.randn(N))
         mgr.iset(mgr.items.get_loc("d"), tm.randn(N))
         mgr.iset(mgr.items.get_loc("b"), tm.randn(N))
@@ -616,6 +836,7 @@
         )
 
     def test_reindex_items(self):
+        """ """
         # mgr is not consolidated, f8 & f8-2 blocks
         mgr = create_mgr("a: f8; b: i8; c: f8; d: i8; e: f8; f: bool; g: f8-2")
 
@@ -636,6 +857,7 @@
         )
 
     def test_get_numeric_data(self):
+        """ """
         mgr = create_mgr(
             "int: int; float: float; complex: complex;"
             "str: object; bool: bool; obj: object; dt: datetime",
@@ -672,6 +894,7 @@
         )
 
     def test_get_bool_data(self):
+        """ """
         mgr = create_mgr(
             "int: int; float: float; complex: complex;"
             "str: object; bool: bool; obj: object; dt: datetime",
@@ -701,12 +924,24 @@
         )
 
     def test_unicode_repr_doesnt_raise(self):
+        """ """
         repr(create_mgr("b,\u05d0: object"))
 
     @pytest.mark.parametrize(
         "mgr_string", ["a,b,c: i8-1; d,e,f: i8-2", "a,a,a: i8-1; b,b,b: i8-2"]
     )
     def test_equals(self, mgr_string):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+
+        Returns
+        -------
+
+        """
         # unique items
         bm1 = create_mgr(mgr_string)
         bm2 = BlockManager(bm1.blocks[::-1], bm1.axes)
@@ -723,6 +958,17 @@
         ],
     )
     def test_equals_block_order_different_dtypes(self, mgr_string):
+        """
+
+        Parameters
+        ----------
+        mgr_string :
+            
+
+        Returns
+        -------
+
+        """
         # GH 9330
         bm = create_mgr(mgr_string)
         block_perms = itertools.permutations(bm.blocks)
@@ -732,11 +978,23 @@
             assert bm_this.equals(bm)
 
     def test_single_mgr_ctor(self):
+        """ """
         mgr = create_single_mgr("f8", num_rows=5)
         assert mgr.as_array().tolist() == [0.0, 1.0, 2.0, 3.0, 4.0]
 
     @pytest.mark.parametrize("value", [1, "True", [1, 2, 3], 5.0])
     def test_validate_bool_args(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         bm1 = create_mgr("a,b,c: i8-1; d,e,f: i8-2")
 
         msg = (
@@ -748,6 +1006,7 @@
 
 
 class TestIndexing:
+    """ """
     # Nosetests-style data-driven tests.
     #
     # This test applies different indexing routines to block managers and
@@ -768,7 +1027,33 @@
 
     @pytest.mark.parametrize("mgr", MANAGERS)
     def test_get_slice(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         def assert_slice_ok(mgr, axis, slobj):
+            """
+
+            Parameters
+            ----------
+            mgr :
+                
+            axis :
+                
+            slobj :
+                
+
+            Returns
+            -------
+
+            """
             mat = mgr.as_array()
 
             # we maybe using an ndarray to test slicing and
@@ -814,7 +1099,33 @@
 
     @pytest.mark.parametrize("mgr", MANAGERS)
     def test_take(self, mgr):
+        """
+
+        Parameters
+        ----------
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         def assert_take_ok(mgr, axis, indexer):
+            """
+
+            Parameters
+            ----------
+            mgr :
+                
+            axis :
+                
+            indexer :
+                
+
+            Returns
+            -------
+
+            """
             mat = mgr.as_array()
             taken = mgr.take(indexer, axis)
             tm.assert_numpy_array_equal(
@@ -835,7 +1146,37 @@
     @pytest.mark.parametrize("mgr", MANAGERS)
     @pytest.mark.parametrize("fill_value", [None, np.nan, 100.0])
     def test_reindex_axis(self, fill_value, mgr):
+        """
+
+        Parameters
+        ----------
+        fill_value :
+            
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         def assert_reindex_axis_is_ok(mgr, axis, new_labels, fill_value):
+            """
+
+            Parameters
+            ----------
+            mgr :
+                
+            axis :
+                
+            new_labels :
+                
+            fill_value :
+                
+
+            Returns
+            -------
+
+            """
             mat = mgr.as_array()
             indexer = mgr.axes[axis].get_indexer_for(new_labels)
 
@@ -868,7 +1209,39 @@
     @pytest.mark.parametrize("mgr", MANAGERS)
     @pytest.mark.parametrize("fill_value", [None, np.nan, 100.0])
     def test_reindex_indexer(self, fill_value, mgr):
+        """
+
+        Parameters
+        ----------
+        fill_value :
+            
+        mgr :
+            
+
+        Returns
+        -------
+
+        """
         def assert_reindex_indexer_is_ok(mgr, axis, new_labels, indexer, fill_value):
+            """
+
+            Parameters
+            ----------
+            mgr :
+                
+            axis :
+                
+            new_labels :
+                
+            indexer :
+                
+            fill_value :
+                
+
+            Returns
+            -------
+
+            """
             mat = mgr.as_array()
             reindexed_mat = algos.take_nd(mat, indexer, axis, fill_value=fill_value)
             reindexed = mgr.reindex_indexer(
@@ -918,6 +1291,7 @@
 
 
 class TestBlockPlacement:
+    """ """
     @pytest.mark.parametrize(
         "slc, expected",
         [
@@ -929,10 +1303,34 @@
         ],
     )
     def test_slice_len(self, slc, expected):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         assert len(BlockPlacement(slc)) == expected
 
     @pytest.mark.parametrize("slc", [slice(1, 1, 0), slice(1, 2, 0)])
     def test_zero_step_raises(self, slc):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+
+        Returns
+        -------
+
+        """
         msg = "slice step cannot be zero"
         with pytest.raises(ValueError, match=msg):
             BlockPlacement(slc)
@@ -955,6 +1353,17 @@
         ],
     )
     def test_unbounded_slice_raises(self, slc):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+
+        Returns
+        -------
+
+        """
         msg = "unbounded slice"
         with pytest.raises(ValueError, match=msg):
             BlockPlacement(slc)
@@ -970,6 +1379,17 @@
         ],
     )
     def test_not_slice_like_slices(self, slc):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+
+        Returns
+        -------
+
+        """
         assert not BlockPlacement(slc).is_slice_like
 
     @pytest.mark.parametrize(
@@ -984,6 +1404,19 @@
         ],
     )
     def test_array_to_slice_conversion(self, arr, slc):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+        slc :
+            
+
+        Returns
+        -------
+
+        """
         assert BlockPlacement(arr).as_slice == slc
 
     @pytest.mark.parametrize(
@@ -1001,6 +1434,17 @@
         ],
     )
     def test_not_slice_like_arrays(self, arr):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+
+        Returns
+        -------
+
+        """
         assert not BlockPlacement(arr).is_slice_like
 
     @pytest.mark.parametrize(
@@ -1008,6 +1452,19 @@
         [(slice(0, 3), [0, 1, 2]), (slice(0, 0), []), (slice(3, 0), [])],
     )
     def test_slice_iter(self, slc, expected):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         assert list(BlockPlacement(slc)) == expected
 
     @pytest.mark.parametrize(
@@ -1020,11 +1477,25 @@
         ],
     )
     def test_slice_to_array_conversion(self, slc, arr):
+        """
+
+        Parameters
+        ----------
+        slc :
+            
+        arr :
+            
+
+        Returns
+        -------
+
+        """
         tm.assert_numpy_array_equal(
             BlockPlacement(slc).as_array, np.asarray(arr, dtype=np.int64)
         )
 
     def test_blockplacement_add(self):
+        """ """
         bpl = BlockPlacement(slice(0, 5))
         assert bpl.add(1).as_slice == slice(1, 6, 1)
         assert bpl.add(np.arange(5)).as_slice == slice(0, 10, 2)
@@ -1047,16 +1518,43 @@
         ],
     )
     def test_blockplacement_add_int(self, val, inc, expected):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+        inc :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         assert list(BlockPlacement(val).add(inc)) == expected
 
     @pytest.mark.parametrize("val", [slice(1, 4), [1, 2, 4]])
     def test_blockplacement_add_int_raises(self, val):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+
+        Returns
+        -------
+
+        """
         msg = "iadd causes length change"
         with pytest.raises(ValueError, match=msg):
             BlockPlacement(val).add(-10)
 
 
 class DummyElement:
+    """ """
     def __init__(self, value, dtype):
         self.value = value
         self.dtype = np.dtype(dtype)
@@ -1071,18 +1569,55 @@
         return str(self)
 
     def astype(self, dtype, copy=False):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         self.dtype = dtype
         return self
 
     def view(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         return type(self)(self.value.view(dtype), dtype)
 
     def any(self, axis=None):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return bool(self.value)
 
 
 class TestCanHoldElement:
+    """ """
     def test_datetime_block_can_hold_element(self):
+        """ """
         block = create_block("datetime", [0])
 
         # We will check that block._can_hold_element iff arr.__setitem__ works
@@ -1135,6 +1670,21 @@
         ids=lambda x: x.__name__,
     )
     def test_binop_other(self, op, value, dtype):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        value :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         skip = {
             (operator.add, "bool"),
             (operator.sub, "bool"),
@@ -1182,7 +1732,9 @@
 
 
 class TestShouldStore:
+    """ """
     def test_should_store_categorical(self):
+        """ """
         cat = pd.Categorical(["A", "B", "C"])
         df = pd.DataFrame(cat)
         blk = df._mgr.blocks[0]
@@ -1209,11 +1761,25 @@
     ],
 )
 def test_holder(typestr, holder):
+    """
+
+    Parameters
+    ----------
+    typestr :
+        
+    holder :
+        
+
+    Returns
+    -------
+
+    """
     blk = create_block(typestr, [1])
     assert blk._holder is holder
 
 
 def test_validate_ndim():
+    """ """
     values = np.array([1.0, 2.0])
     placement = slice(2)
     msg = r"Wrong number of dimensions. values.ndim != ndim \[1 != 2\]"
@@ -1223,6 +1789,7 @@
 
 
 def test_block_shape():
+    """ """
     idx = pd.Index([0, 1, 2, 3, 4])
     a = pd.Series([1, 2, 3]).reindex(idx)
     b = pd.Series(pd.Categorical([1, 2, 3])).reindex(idx)
@@ -1231,6 +1798,7 @@
 
 
 def test_make_block_no_pandas_array():
+    """ """
     # https://github.com/pandas-dev/pandas/pull/24866
     arr = pd.arrays.PandasArray(np.array([1, 2]))
 
@@ -1251,6 +1819,7 @@
 
 
 def test_dataframe_not_equal():
+    """ """
     # see GH28839
     df1 = pd.DataFrame({"a": [1, 2], "b": ["s", "d"]})
     df2 = pd.DataFrame({"a": ["s", "d"], "b": [1, 2]})
@@ -1258,12 +1827,14 @@
 
 
 def test_missing_unicode_key():
+    """ """
     df = DataFrame({"a": [1]})
     with pytest.raises(KeyError, match="\u05d0"):
         df.loc[:, "\u05d0"]  # should not raise UnicodeEncodeError
 
 
 def test_set_change_dtype_slice():
+    """ """
     # GH#8850
     cols = MultiIndex.from_tuples([("1st", "a"), ("2nd", "b"), ("3rd", "c")])
     df = DataFrame([[1.0, 2, 3], [4.0, 5, 6]], columns=cols)
@@ -1278,6 +1849,7 @@
 
 
 def test_interleave_non_unique_cols():
+    """ """
     df = DataFrame(
         [[pd.Timestamp("20130101"), 3.5], [pd.Timestamp("20130102"), 4.5]],
         columns=["x", "x"],
@@ -1292,6 +1864,7 @@
 
 
 def test_single_block_manager_fastpath_deprecated():
+    """ """
     # GH#33092
     ser = pd.Series(range(3))
     blk = ser._data.blocks[0]
