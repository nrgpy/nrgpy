# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/tseries/frequencies/test_inference.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/tseries/frequencies/test_inference.py
@@ -16,17 +16,21 @@
 
 
 def _check_generated_range(start, periods, freq):
-    """
-    Check the range generated from a given start, frequency, and period count.
-
-    Parameters
-    ----------
-    start : str
-        The start date.
-    periods : int
-        The number of periods.
-    freq : str
-        The frequency of the range.
+    """Check the range generated from a given start, frequency, and period count.
+
+    Parameters
+    ----------
+    start :
+        
+    periods :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    
     """
     freq = freq.upper()
 
@@ -71,30 +75,86 @@
     ]
 )
 def base_delta_code_pair(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=[1, 2, 3, 4])
 def count(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=DAYS)
 def day(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=MONTHS)
 def month(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=[5, 7])
 def periods(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 def test_raise_if_period_index():
+    """ """
     index = period_range(start="1/1/1990", periods=20, freq="M")
     msg = "Check the `freq` attribute instead of using infer_freq"
 
@@ -103,6 +163,7 @@
 
 
 def test_raise_if_too_few():
+    """ """
     index = DatetimeIndex(["12/31/1998", "1/3/1999"])
     msg = "Need at least 3 dates to infer frequency"
 
@@ -111,11 +172,13 @@
 
 
 def test_business_daily():
+    """ """
     index = DatetimeIndex(["01/01/1999", "1/4/1999", "1/5/1999"])
     assert frequencies.infer_freq(index) == "B"
 
 
 def test_business_daily_look_alike():
+    """ """
     # see gh-16624
     #
     # Do not infer "B when "weekend" (2-day gap) in wrong place.
@@ -124,16 +187,19 @@
 
 
 def test_day_corner():
+    """ """
     index = DatetimeIndex(["1/1/2000", "1/2/2000", "1/3/2000"])
     assert frequencies.infer_freq(index) == "D"
 
 
 def test_non_datetime_index():
+    """ """
     dates = to_datetime(["1/1/2000", "1/2/2000", "1/3/2000"])
     assert frequencies.infer_freq(dates) == "D"
 
 
 def test_fifth_week_of_month_infer():
+    """ """
     # see gh-9425
     #
     # Only attempt to infer up to WOM-4.
@@ -142,6 +208,7 @@
 
 
 def test_week_of_month_fake():
+    """ """
     # All of these dates are on same day
     # of week and are 4 or 5 weeks apart.
     index = DatetimeIndex(["2013-08-27", "2013-10-01", "2013-10-29", "2013-11-26"])
@@ -149,6 +216,7 @@
 
 
 def test_fifth_week_of_month():
+    """ """
     # see gh-9425
     #
     # Only supports freq up to WOM-4.
@@ -162,16 +230,31 @@
 
 
 def test_monthly_ambiguous():
+    """ """
     rng = DatetimeIndex(["1/31/2000", "2/29/2000", "3/31/2000"])
     assert rng.inferred_freq == "M"
 
 
 def test_annual_ambiguous():
+    """ """
     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
     assert rng.inferred_freq == "A-JAN"
 
 
 def test_infer_freq_delta(base_delta_code_pair, count):
+    """
+
+    Parameters
+    ----------
+    base_delta_code_pair :
+        
+    count :
+        
+
+    Returns
+    -------
+
+    """
     b = Timestamp(datetime.now())
     base_delta, code = base_delta_code_pair
 
@@ -194,6 +277,19 @@
     ],
 )
 def test_infer_freq_custom(base_delta_code_pair, constructor):
+    """
+
+    Parameters
+    ----------
+    base_delta_code_pair :
+        
+    constructor :
+        
+
+    Returns
+    -------
+
+    """
     b = Timestamp(datetime.now())
     base_delta, _ = base_delta_code_pair
 
@@ -202,24 +298,93 @@
 
 
 def test_weekly_infer(periods, day):
+    """
+
+    Parameters
+    ----------
+    periods :
+        
+    day :
+        
+
+    Returns
+    -------
+
+    """
     _check_generated_range("1/1/2000", periods, f"W-{day}")
 
 
 def test_week_of_month_infer(periods, day, count):
+    """
+
+    Parameters
+    ----------
+    periods :
+        
+    day :
+        
+    count :
+        
+
+    Returns
+    -------
+
+    """
     _check_generated_range("1/1/2000", periods, f"WOM-{count}{day}")
 
 
 @pytest.mark.parametrize("freq", ["M", "BM", "BMS"])
 def test_monthly_infer(periods, freq):
+    """
+
+    Parameters
+    ----------
+    periods :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     _check_generated_range("1/1/2000", periods, "M")
 
 
 def test_quarterly_infer(month, periods):
+    """
+
+    Parameters
+    ----------
+    month :
+        
+    periods :
+        
+
+    Returns
+    -------
+
+    """
     _check_generated_range("1/1/2000", periods, f"Q-{month}")
 
 
 @pytest.mark.parametrize("annual", ["A", "BA"])
 def test_annually_infer(month, periods, annual):
+    """
+
+    Parameters
+    ----------
+    month :
+        
+    periods :
+        
+    annual :
+        
+
+    Returns
+    -------
+
+    """
     _check_generated_range("1/1/2000", periods, f"{annual}-{month}")
 
 
@@ -227,6 +392,19 @@
     "freq,expected", [("Q", "Q-DEC"), ("Q-NOV", "Q-NOV"), ("Q-OCT", "Q-OCT")]
 )
 def test_infer_freq_index(freq, expected):
+    """
+
+    Parameters
+    ----------
+    freq :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     rng = period_range("1959Q2", "2009Q3", freq=freq)
     rng = Index(rng.to_timestamp("D", how="e").astype(object))
 
@@ -252,6 +430,21 @@
     ),
 )
 def test_infer_freq_tz(tz_naive_fixture, expected, dates):
+    """
+
+    Parameters
+    ----------
+    tz_naive_fixture :
+        
+    expected :
+        
+    dates :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-7310
     tz = tz_naive_fixture
     idx = DatetimeIndex(dates, tz=tz)
@@ -270,6 +463,21 @@
     "freq", ["3H", "10T", "3601S", "3600001L", "3600000001U", "3600000000001N"]
 )
 def test_infer_freq_tz_transition(tz_naive_fixture, date_pair, freq):
+    """
+
+    Parameters
+    ----------
+    tz_naive_fixture :
+        
+    date_pair :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-8772
     tz = tz_naive_fixture
     idx = date_range(date_pair[0], date_pair[1], freq=freq, tz=tz)
@@ -277,6 +485,7 @@
 
 
 def test_infer_freq_tz_transition_custom():
+    """ """
     index = date_range("2013-11-03", periods=5, freq="3H").tz_localize(
         "America/Chicago"
     )
@@ -362,12 +571,26 @@
     ],
 )
 def test_infer_freq_business_hour(data, expected):
+    """
+
+    Parameters
+    ----------
+    data :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-7905
     idx = DatetimeIndex(data)
     assert idx.inferred_freq == expected
 
 
 def test_not_monotonic():
+    """ """
     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
     rng = rng[::-1]
 
@@ -375,6 +598,7 @@
 
 
 def test_non_datetime_index2():
+    """ """
     rng = DatetimeIndex(["1/31/2000", "1/31/2001", "1/31/2002"])
     vals = rng.to_pydatetime()
 
@@ -386,6 +610,17 @@
     "idx", [tm.makeIntIndex(10), tm.makeFloatIndex(10), tm.makePeriodIndex(10)]
 )
 def test_invalid_index_types(idx):
+    """
+
+    Parameters
+    ----------
+    idx :
+        
+
+    Returns
+    -------
+
+    """
     msg = (
         "(cannot infer freq from a non-convertible)|"
         "(Check the `freq` attribute instead of using infer_freq)"
@@ -398,6 +633,17 @@
 @pytest.mark.skipif(is_platform_windows(), reason="see gh-10822: Windows issue")
 @pytest.mark.parametrize("idx", [tm.makeStringIndex(10), tm.makeUnicodeIndex(10)])
 def test_invalid_index_types_unicode(idx):
+    """
+
+    Parameters
+    ----------
+    idx :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-10822
     #
     # Odd error message on conversions to datetime for unicode.
@@ -408,6 +654,7 @@
 
 
 def test_string_datetime_like_compat():
+    """ """
     # see gh-6463
     data = ["2004-01", "2004-02", "2004-03", "2004-04"]
 
@@ -418,6 +665,7 @@
 
 
 def test_series():
+    """ """
     # see gh-6407
     s = Series(date_range("20130101", "20130110"))
     inferred = frequencies.infer_freq(s)
@@ -426,6 +674,17 @@
 
 @pytest.mark.parametrize("end", [10, 10.0])
 def test_series_invalid_type(end):
+    """
+
+    Parameters
+    ----------
+    end :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-6407
     msg = "cannot infer freq from a non-convertible dtype on a Series"
     s = Series(np.arange(end))
@@ -435,6 +694,7 @@
 
 
 def test_series_inconvertible_string():
+    """ """
     # see gh-6407
     msg = "Unknown string format"
 
@@ -444,6 +704,17 @@
 
 @pytest.mark.parametrize("freq", [None, "L"])
 def test_series_period_index(freq):
+    """
+
+    Parameters
+    ----------
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-6407
     #
     # Cannot infer on PeriodIndex
@@ -456,6 +727,17 @@
 
 @pytest.mark.parametrize("freq", ["M", "L", "S"])
 def test_series_datetime_index(freq):
+    """
+
+    Parameters
+    ----------
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     s = Series(date_range("20130101", periods=10, freq=freq))
     inferred = frequencies.infer_freq(s)
     assert inferred == freq
@@ -519,11 +801,25 @@
     ],
 )
 def test_legacy_offset_warnings(offset_func, freq):
+    """
+
+    Parameters
+    ----------
+    offset_func :
+        
+    freq :
+        
+
+    Returns
+    -------
+
+    """
     with pytest.raises(ValueError, match=INVALID_FREQ_ERR_MSG):
         offset_func(freq)
 
 
 def test_ms_vs_capital_ms():
+    """ """
     left = frequencies._get_offset("ms")
     right = frequencies._get_offset("MS")
 
