# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/babel/numbers.py
+++ b/..//venv/lib/python3.8/site-packages/babel/numbers.py
@@ -37,8 +37,7 @@
 
 
 class UnknownCurrencyError(Exception):
-    """Exception thrown when a currency is requested for which no data is available.
-    """
+    """ """
 
     def __init__(self, identifier):
         """Create the exception.
@@ -51,14 +50,21 @@
 
 
 def list_currencies(locale=None):
-    """ Return a `set` of normalized currency codes.
-
+    """Return a `set` of normalized currency codes.
+    
     .. versionadded:: 2.5.0
 
-    :param locale: filters returned currency codes by the provided locale.
-                   Expected to be a locale instance or code. If no locale is
-                   provided, returns the list of all currencies from all
-                   locales.
+    Parameters
+    ----------
+    locale :
+        filters returned currency codes by the provided locale.
+        Expected to be a locale instance or code. If no locale is
+        provided, returns the list of all currencies from all
+        locales. (Default value = None)
+
+    Returns
+    -------
+
     """
     # Get locale-scoped currencies.
     if locale:
@@ -69,21 +75,43 @@
 
 
 def validate_currency(currency, locale=None):
-    """ Check the currency code is recognized by Babel.
-
+    """Check the currency code is recognized by Babel.
+    
     Accepts a ``locale`` parameter for fined-grained validation, working as
     the one defined above in ``list_currencies()`` method.
-
+    
     Raises a `UnknownCurrencyError` exception if the currency is unknown to Babel.
+
+    Parameters
+    ----------
+    currency :
+        
+    locale :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if currency not in list_currencies(locale):
         raise UnknownCurrencyError(currency)
 
 
 def is_currency(currency, locale=None):
-    """ Returns `True` only if a currency is recognized by Babel.
-
+    """Returns `True` only if a currency is recognized by Babel.
+    
     This method always return a Boolean and never raise.
+
+    Parameters
+    ----------
+    currency :
+        
+    locale :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if not currency or not isinstance(currency, string_types):
         return False
@@ -96,11 +124,22 @@
 
 def normalize_currency(currency, locale=None):
     """Returns the normalized sting of any currency code.
-
+    
     Accepts a ``locale`` parameter for fined-grained validation, working as
     the one defined above in ``list_currencies()`` method.
-
+    
     Returns None if the currency is unknown to Babel.
+
+    Parameters
+    ----------
+    currency :
+        
+    locale :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     if isinstance(currency, string_types):
         currency = currency.upper()
@@ -111,16 +150,25 @@
 
 def get_currency_name(currency, count=None, locale=LC_NUMERIC):
     """Return the name used by the locale for the specified currency.
+    
+    
+    .. versionadded:: 0.9.4
+
+    Parameters
+    ----------
+    currency :
+        the currency code.
+    count :
+        the optional count.  If provided the currency name
+        will be pluralized to that number if possible. (Default value = None)
+    locale :
+        the `Locale` object or locale identifier. (Default value = LC_NUMERIC)
+
+    Returns
+    -------
 
     >>> get_currency_name('USD', locale='en_US')
     u'US Dollar'
-
-    .. versionadded:: 0.9.4
-
-    :param currency: the currency code.
-    :param count: the optional count.  If provided the currency name
-                  will be pluralized to that number if possible.
-    :param locale: the `Locale` object or locale identifier.
     """
     loc = Locale.parse(locale)
     if count is not None:
@@ -134,46 +182,68 @@
 def get_currency_symbol(currency, locale=LC_NUMERIC):
     """Return the symbol used by the locale for the specified currency.
 
+    Parameters
+    ----------
+    currency :
+        the currency code.
+    locale :
+        the `Locale` object or locale identifier. (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_currency_symbol('USD', locale='en_US')
     u'$'
-
-    :param currency: the currency code.
-    :param locale: the `Locale` object or locale identifier.
     """
     return Locale.parse(locale).currency_symbols.get(currency, currency)
 
 
 def get_currency_precision(currency):
     """Return currency's precision.
-
+    
     Precision is the number of decimals found after the decimal point in the
     currency's format pattern.
-
+    
     .. versionadded:: 2.5.0
 
-    :param currency: the currency code.
+    Parameters
+    ----------
+    currency :
+        the currency code.
+
+    Returns
+    -------
+
     """
     precisions = get_global('currency_fractions')
     return precisions.get(currency, precisions['DEFAULT'])[0]
 
 
 def get_currency_unit_pattern(currency, count=None, locale=LC_NUMERIC):
-    """
-    Return the unit pattern used for long display of a currency value
+    """Return the unit pattern used for long display of a currency value
     for a given locale.
     This is a string containing ``{0}`` where the numeric part
     should be substituted and ``{1}`` where the currency long display
     name should be substituted.
+    
+    
+    .. versionadded:: 2.7.0
+
+    Parameters
+    ----------
+    currency :
+        the currency code.
+    count :
+        the optional count.  If provided the unit
+        pattern for that number will be returned. (Default value = None)
+    locale :
+        the `Locale` object or locale identifier. (Default value = LC_NUMERIC)
+
+    Returns
+    -------
 
     >>> get_currency_unit_pattern('USD', locale='en_US', count=10)
     u'{0} {1}'
-
-    .. versionadded:: 2.7.0
-
-    :param currency: the currency code.
-    :param count: the optional count.  If provided the unit
-                  pattern for that number will be returned.
-    :param locale: the `Locale` object or locale identifier.
     """
     loc = Locale.parse(locale)
     if count is not None:
@@ -194,50 +264,64 @@
     the given date range.  In addition to that the currency database
     distinguishes between tender and non-tender currencies.  By default only
     tender currencies are returned.
-
+    
     The return value is a list of all currencies roughly ordered by the time
     of when the currency became active.  The longer the currency is being in
     use the more to the left of the list it will be.
-
+    
     The start date defaults to today.  If no end date is given it will be the
     same as the start date.  Otherwise a range can be defined.  For instance
     this can be used to find the currencies in use in Austria between 1995 and
     2011:
+    
+    
+    Likewise it's also possible to find all the currencies in use on a
+    single date:
+    
+    
+    By default the return value only includes tender currencies.  This
+    however can be changed:
+    
+    
+    .. versionadded:: 2.0
+
+    Parameters
+    ----------
+    territory :
+        the name of the territory to find the currency for.
+    start_date :
+        the start date.  If not given today is assumed. (Default value = None)
+    end_date :
+        the end date.  If not given the start date is assumed. (Default value = None)
+    tender :
+        controls whether tender currencies should be included. (Default value = True)
+    non_tender :
+        controls whether non-tender currencies should be
+        included. (Default value = False)
+    include_details :
+        if set to `True`, instead of returning currency
+        codes the return value will be dictionaries
+        with detail information.  In that case each
+        dictionary will have the keys ``'currency'``,
+        ``'from'``, ``'to'``, and ``'tender'``. (Default value = False)
+
+    Returns
+    -------
 
     >>> from datetime import date
     >>> get_territory_currencies('AT', date(1995, 1, 1), date(2011, 1, 1))
     ['ATS', 'EUR']
-
-    Likewise it's also possible to find all the currencies in use on a
-    single date:
-
+    
     >>> get_territory_currencies('AT', date(1995, 1, 1))
     ['ATS']
     >>> get_territory_currencies('AT', date(2011, 1, 1))
     ['EUR']
-
-    By default the return value only includes tender currencies.  This
-    however can be changed:
-
+    
     >>> get_territory_currencies('US')
     ['USD']
     >>> get_territory_currencies('US', tender=False, non_tender=True,
     ...                          start_date=date(2014, 1, 1))
     ['USN', 'USS']
-
-    .. versionadded:: 2.0
-
-    :param territory: the name of the territory to find the currency for.
-    :param start_date: the start date.  If not given today is assumed.
-    :param end_date: the end date.  If not given the start date is assumed.
-    :param tender: controls whether tender currencies should be included.
-    :param non_tender: controls whether non-tender currencies should be
-                       included.
-    :param include_details: if set to `True`, instead of returning currency
-                            codes the return value will be dictionaries
-                            with detail information.  In that case each
-                            dictionary will have the keys ``'currency'``,
-                            ``'from'``, ``'to'``, and ``'tender'``.
     """
     currencies = get_global('territory_currencies')
     if start_date is None:
@@ -253,6 +337,19 @@
     # TODO: validate that the territory exists
 
     def _is_active(start, end):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        end :
+            
+
+        Returns
+        -------
+
+        """
         return (start is None or start <= end_date) and \
                (end is None or end >= start_date)
 
@@ -280,10 +377,16 @@
 def get_decimal_symbol(locale=LC_NUMERIC):
     """Return the symbol used by the locale to separate decimal fractions.
 
+    Parameters
+    ----------
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_decimal_symbol('en_US')
     u'.'
-
-    :param locale: the `Locale` object or locale identifier
     """
     return Locale.parse(locale).number_symbols.get('decimal', u'.')
 
@@ -291,10 +394,16 @@
 def get_plus_sign_symbol(locale=LC_NUMERIC):
     """Return the plus sign symbol used by the current locale.
 
+    Parameters
+    ----------
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_plus_sign_symbol('en_US')
     u'+'
-
-    :param locale: the `Locale` object or locale identifier
     """
     return Locale.parse(locale).number_symbols.get('plusSign', u'+')
 
@@ -302,10 +411,16 @@
 def get_minus_sign_symbol(locale=LC_NUMERIC):
     """Return the plus sign symbol used by the current locale.
 
+    Parameters
+    ----------
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_minus_sign_symbol('en_US')
     u'-'
-
-    :param locale: the `Locale` object or locale identifier
     """
     return Locale.parse(locale).number_symbols.get('minusSign', u'-')
 
@@ -313,10 +428,16 @@
 def get_exponential_symbol(locale=LC_NUMERIC):
     """Return the symbol used by the locale to separate mantissa and exponent.
 
+    Parameters
+    ----------
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_exponential_symbol('en_US')
     u'E'
-
-    :param locale: the `Locale` object or locale identifier
     """
     return Locale.parse(locale).number_symbols.get('exponential', u'E')
 
@@ -324,39 +445,59 @@
 def get_group_symbol(locale=LC_NUMERIC):
     """Return the symbol used by the locale to separate groups of thousands.
 
+    Parameters
+    ----------
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
     >>> get_group_symbol('en_US')
     u','
-
-    :param locale: the `Locale` object or locale identifier
     """
     return Locale.parse(locale).number_symbols.get('group', u',')
 
 
 def format_number(number, locale=LC_NUMERIC):
-    u"""Return the given number formatted for a specific locale.
+    """u"""Return the given number formatted for a specific locale.
+    
+    
+    .. deprecated:: 2.6.0
+    
+       Use babel.numbers.format_decimal() instead.
+
+    Parameters
+    ----------
+    number :
+        the number to format
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
 
     >>> format_number(1099, locale='en_US')
     u'1,099'
     >>> format_number(1099, locale='de_DE')
     u'1.099'
-
-    .. deprecated:: 2.6.0
-
-       Use babel.numbers.format_decimal() instead.
-
-    :param number: the number to format
-    :param locale: the `Locale` object or locale identifier
-
-
-    """
     warnings.warn('Use babel.numbers.format_decimal() instead.', DeprecationWarning)
     return format_decimal(number, locale=locale)
 
 
 def get_decimal_precision(number):
-    """Return maximum precision of a decimal instance's fractional part.
-
-    Precision is extracted from the fractional part only.
+    """
+
+    Parameters
+    ----------
+    number :
+        
+
+    Returns
+    -------
+    type
+        Precision is extracted from the fractional part only.
+
     """
     # Copied from: https://github.com/mahmoud/boltons/pull/59
     assert isinstance(number, decimal.Decimal)
@@ -367,14 +508,53 @@
 
 
 def get_decimal_quantum(precision):
-    """Return minimal quantum of a number, as defined by precision."""
+    """
+
+    Parameters
+    ----------
+    precision :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     assert isinstance(precision, (int, long, decimal.Decimal))
     return decimal.Decimal(10) ** (-precision)
 
 
 def format_decimal(
         number, format=None, locale=LC_NUMERIC, decimal_quantization=True, group_separator=True):
-    u"""Return the given decimal number formatted for a specific locale.
+    """u"""Return the given decimal number formatted for a specific locale.
+    
+    
+    The appropriate thousands grouping and the decimal separator are used for
+    each locale:
+    
+    
+    By default the locale is allowed to truncate and round a high-precision
+    number by forcing its format pattern onto the decimal part. You can bypass
+    this behavior with the `decimal_quantization` parameter:
+
+    Parameters
+    ----------
+    number :
+        the number to format
+    format :
+        param locale: the `Locale` object or locale identifier (Default value = None)
+    decimal_quantization :
+        Truncate and round high-precision numbers to
+        the format pattern. Defaults to `True`.
+    group_separator :
+        Boolean to switch group separator on/off in a locale's
+        number format. (Default value = True)
+    locale :
+         (Default value = LC_NUMERIC)
+
+    Returns
+    -------
 
     >>> format_decimal(1.2345, locale='en_US')
     u'1.234'
@@ -386,17 +566,10 @@
     u'1,234'
     >>> format_decimal(1.2345, locale='de')
     u'1,234'
-
-    The appropriate thousands grouping and the decimal separator are used for
-    each locale:
-
+    
     >>> format_decimal(12345.5, locale='en_US')
     u'12,345.5'
-
-    By default the locale is allowed to truncate and round a high-precision
-    number by forcing its format pattern onto the decimal part. You can bypass
-    this behavior with the `decimal_quantization` parameter:
-
+    
     >>> format_decimal(1.2346, locale='en_US')
     u'1.235'
     >>> format_decimal(1.2346, locale='en_US', decimal_quantization=False)
@@ -405,15 +578,6 @@
     u'12345,67'
     >>> format_decimal(12345.67, locale='en_US', group_separator=True)
     u'12,345.67'
-
-    :param number: the number to format
-    :param format:
-    :param locale: the `Locale` object or locale identifier
-    :param decimal_quantization: Truncate and round high-precision numbers to
-                                 the format pattern. Defaults to `True`.
-    :param group_separator: Boolean to switch group separator on/off in a locale's
-                            number format.
-    """
     locale = Locale.parse(locale)
     if not format:
         format = locale.decimal_formats.get(format)
@@ -423,13 +587,71 @@
 
 
 class UnknownCurrencyFormatError(KeyError):
-    """Exception raised when an unknown currency format is requested."""
+    """ """
 
 
 def format_currency(
         number, currency, format=None, locale=LC_NUMERIC, currency_digits=True,
         format_type='standard', decimal_quantization=True, group_separator=True):
-    u"""Return formatted currency value.
+    """u"""Return formatted currency value.
+    
+    
+    The format can also be specified explicitly.  The currency is
+    placed with the '¤' sign.  As the sign gets repeated the format
+    expands (¤ being the symbol, ¤¤ is the currency abbreviation and
+    ¤¤¤ is the full name of the currency):
+    
+    
+    Currencies usually have a specific number of decimal digits. This function
+    favours that information over the given format:
+    
+    
+    However, the number of decimal digits can be overriden from the currency
+    information, by setting the last parameter to ``False``:
+    
+    
+    If a format is not specified the type of currency format to use
+    from the locale can be specified:
+    
+    
+    When the given currency format type is not available, an exception is
+    raised:
+    
+    
+    
+    
+    You can also pass format_type='name' to use long display names. The order of
+    the number and currency name, along with the correct localized plural form
+    of the currency name, is chosen according to locale:
+    
+    
+    By default the locale is allowed to truncate and round a high-precision
+    number by forcing its format pattern onto the decimal part. You can bypass
+    this behavior with the `decimal_quantization` parameter:
+
+    Parameters
+    ----------
+    number :
+        the number to format
+    currency :
+        the currency code
+    format :
+        the format string to use (Default value = None)
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+    currency_digits :
+        use the currency's natural number of decimal digits (Default value = True)
+    format_type :
+        the currency format type to use (Default value = 'standard')
+    decimal_quantization :
+        Truncate and round high-precision numbers to
+        the format pattern. Defaults to `True`.
+    group_separator :
+        Boolean to switch group separator on/off in a locale's
+        number format. (Default value = True)
+
+    Returns
+    -------
 
     >>> format_currency(1099.98, 'USD', locale='en_US')
     u'$1,099.98'
@@ -437,85 +659,47 @@
     u'US$\\xa01.099,98'
     >>> format_currency(1099.98, 'EUR', locale='de_DE')
     u'1.099,98\\xa0\\u20ac'
-
-    The format can also be specified explicitly.  The currency is
-    placed with the '¤' sign.  As the sign gets repeated the format
-    expands (¤ being the symbol, ¤¤ is the currency abbreviation and
-    ¤¤¤ is the full name of the currency):
-
+    
     >>> format_currency(1099.98, 'EUR', u'\xa4\xa4 #,##0.00', locale='en_US')
     u'EUR 1,099.98'
     >>> format_currency(1099.98, 'EUR', u'#,##0.00 \xa4\xa4\xa4', locale='en_US')
     u'1,099.98 euros'
-
-    Currencies usually have a specific number of decimal digits. This function
-    favours that information over the given format:
-
+    
     >>> format_currency(1099.98, 'JPY', locale='en_US')
     u'\\xa51,100'
     >>> format_currency(1099.98, 'COP', u'#,##0.00', locale='es_ES')
     u'1.099,98'
-
-    However, the number of decimal digits can be overriden from the currency
-    information, by setting the last parameter to ``False``:
-
+    
     >>> format_currency(1099.98, 'JPY', locale='en_US', currency_digits=False)
     u'\\xa51,099.98'
     >>> format_currency(1099.98, 'COP', u'#,##0.00', locale='es_ES', currency_digits=False)
     u'1.099,98'
-
-    If a format is not specified the type of currency format to use
-    from the locale can be specified:
-
+    
     >>> format_currency(1099.98, 'EUR', locale='en_US', format_type='standard')
     u'\\u20ac1,099.98'
-
-    When the given currency format type is not available, an exception is
-    raised:
-
+    
     >>> format_currency('1099.98', 'EUR', locale='root', format_type='unknown')
     Traceback (most recent call last):
         ...
     UnknownCurrencyFormatError: "'unknown' is not a known currency format type"
-
+    
     >>> format_currency(101299.98, 'USD', locale='en_US', group_separator=False)
     u'$101299.98'
-
+    
     >>> format_currency(101299.98, 'USD', locale='en_US', group_separator=True)
     u'$101,299.98'
-
-    You can also pass format_type='name' to use long display names. The order of
-    the number and currency name, along with the correct localized plural form
-    of the currency name, is chosen according to locale:
-
+    
     >>> format_currency(1, 'USD', locale='en_US', format_type='name')
     u'1.00 US dollar'
     >>> format_currency(1099.98, 'USD', locale='en_US', format_type='name')
     u'1,099.98 US dollars'
     >>> format_currency(1099.98, 'USD', locale='ee', format_type='name')
     u'us ga dollar 1,099.98'
-
-    By default the locale is allowed to truncate and round a high-precision
-    number by forcing its format pattern onto the decimal part. You can bypass
-    this behavior with the `decimal_quantization` parameter:
-
+    
     >>> format_currency(1099.9876, 'USD', locale='en_US')
     u'$1,099.99'
     >>> format_currency(1099.9876, 'USD', locale='en_US', decimal_quantization=False)
     u'$1,099.9876'
-
-    :param number: the number to format
-    :param currency: the currency code
-    :param format: the format string to use
-    :param locale: the `Locale` object or locale identifier
-    :param currency_digits: use the currency's natural number of decimal digits
-    :param format_type: the currency format type to use
-    :param decimal_quantization: Truncate and round high-precision numbers to
-                                 the format pattern. Defaults to `True`.
-    :param group_separator: Boolean to switch group separator on/off in a locale's
-                            number format.
-
-    """
     if format_type == 'name':
         return _format_currency_long_name(number, currency, format=format,
                                           locale=locale, currency_digits=currency_digits,
@@ -538,6 +722,31 @@
 def _format_currency_long_name(
         number, currency, format=None, locale=LC_NUMERIC, currency_digits=True,
         format_type='standard', decimal_quantization=True, group_separator=True):
+    """
+
+    Parameters
+    ----------
+    number :
+        
+    currency :
+        
+    format :
+         (Default value = None)
+    locale :
+         (Default value = LC_NUMERIC)
+    currency_digits :
+         (Default value = True)
+    format_type :
+         (Default value = 'standard')
+    decimal_quantization :
+         (Default value = True)
+    group_separator :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     # Algorithm described here:
     # https://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
     locale = Locale.parse(locale)
@@ -574,6 +783,32 @@
 def format_percent(
         number, format=None, locale=LC_NUMERIC, decimal_quantization=True, group_separator=True):
     """Return formatted percent value for a specific locale.
+    
+    
+    The format pattern can also be specified explicitly:
+    
+    
+    By default the locale is allowed to truncate and round a high-precision
+    number by forcing its format pattern onto the decimal part. You can bypass
+    this behavior with the `decimal_quantization` parameter:
+
+    Parameters
+    ----------
+    number :
+        the percent number to format
+    format :
+        param locale: the `Locale` object or locale identifier (Default value = None)
+    decimal_quantization :
+        Truncate and round high-precision numbers to
+        the format pattern. Defaults to `True`.
+    group_separator :
+        Boolean to switch group separator on/off in a locale's
+        number format. (Default value = True)
+    locale :
+         (Default value = LC_NUMERIC)
+
+    Returns
+    -------
 
     >>> format_percent(0.34, locale='en_US')
     u'34%'
@@ -581,34 +816,20 @@
     u'2,512%'
     >>> format_percent(25.1234, locale='sv_SE')
     u'2\\xa0512\\xa0%'
-
-    The format pattern can also be specified explicitly:
-
+    
     >>> format_percent(25.1234, u'#,##0\u2030', locale='en_US')
     u'25,123\u2030'
-
-    By default the locale is allowed to truncate and round a high-precision
-    number by forcing its format pattern onto the decimal part. You can bypass
-    this behavior with the `decimal_quantization` parameter:
-
+    
     >>> format_percent(23.9876, locale='en_US')
     u'2,399%'
     >>> format_percent(23.9876, locale='en_US', decimal_quantization=False)
     u'2,398.76%'
-
+    
     >>> format_percent(229291.1234, locale='pt_BR', group_separator=False)
     u'22929112%'
-
+    
     >>> format_percent(229291.1234, locale='pt_BR', group_separator=True)
     u'22.929.112%'
-
-    :param number: the percent number to format
-    :param format:
-    :param locale: the `Locale` object or locale identifier
-    :param decimal_quantization: Truncate and round high-precision numbers to
-                                 the format pattern. Defaults to `True`.
-    :param group_separator: Boolean to switch group separator on/off in a locale's
-                            number format.
     """
     locale = Locale.parse(locale)
     if not format:
@@ -621,29 +842,40 @@
 def format_scientific(
         number, format=None, locale=LC_NUMERIC, decimal_quantization=True):
     """Return value formatted in scientific notation for a specific locale.
-
-    >>> format_scientific(10000, locale='en_US')
-    u'1E4'
-
+    
+    
     The format pattern can also be specified explicitly:
-
-    >>> format_scientific(1234567, u'##0.##E00', locale='en_US')
-    u'1.23E06'
-
+    
+    
     By default the locale is allowed to truncate and round a high-precision
     number by forcing its format pattern onto the decimal part. You can bypass
     this behavior with the `decimal_quantization` parameter:
 
+    Parameters
+    ----------
+    number :
+        the number to format
+    format :
+        param locale: the `Locale` object or locale identifier (Default value = None)
+    decimal_quantization :
+        Truncate and round high-precision numbers to
+        the format pattern. Defaults to `True`.
+    locale :
+         (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+
+    >>> format_scientific(10000, locale='en_US')
+    u'1E4'
+    
+    >>> format_scientific(1234567, u'##0.##E00', locale='en_US')
+    u'1.23E06'
+    
     >>> format_scientific(1234.9876, u'#.##E0', locale='en_US')
     u'1.23E3'
     >>> format_scientific(1234.9876, u'#.##E0', locale='en_US', decimal_quantization=False)
     u'1.2349876E3'
-
-    :param number: the number to format
-    :param format:
-    :param locale: the `Locale` object or locale identifier
-    :param decimal_quantization: Truncate and round high-precision numbers to
-                                 the format pattern. Defaults to `True`.
     """
     locale = Locale.parse(locale)
     if not format:
@@ -654,7 +886,7 @@
 
 
 class NumberFormatError(ValueError):
-    """Exception raised when a string cannot be parsed into a number."""
+    """ """
 
     def __init__(self, message, suggestions=None):
         super(NumberFormatError, self).__init__(message)
@@ -664,23 +896,32 @@
 
 def parse_number(string, locale=LC_NUMERIC):
     """Parse localized number string into an integer.
+    
+    
+    When the given string cannot be parsed, an exception is raised:
+
+    Parameters
+    ----------
+    string :
+        the string to parse
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+
+    Returns
+    -------
+    type
+        the parsed number
+        :raise `NumberFormatError`: if the string can not be converted to a number
 
     >>> parse_number('1,099', locale='en_US')
     1099
     >>> parse_number('1.099', locale='de_DE')
     1099
-
-    When the given string cannot be parsed, an exception is raised:
-
+    
     >>> parse_number('1.099,98', locale='de')
     Traceback (most recent call last):
         ...
     NumberFormatError: '1.099,98' is not a valid number
-
-    :param string: the string to parse
-    :param locale: the `Locale` object or locale identifier
-    :return: the parsed number
-    :raise `NumberFormatError`: if the string can not be converted to a number
     """
     try:
         return int(string.replace(get_group_symbol(locale), ''))
@@ -690,6 +931,28 @@
 
 def parse_decimal(string, locale=LC_NUMERIC, strict=False):
     """Parse localized decimal string into a decimal.
+    
+    
+    When the given string cannot be parsed, an exception is raised:
+    
+    
+    If `strict` is set to `True` and the given string contains a number
+    formatted in an irregular way, an exception is raised:
+
+    Parameters
+    ----------
+    string :
+        the string to parse
+    locale :
+        the `Locale` object or locale identifier (Default value = LC_NUMERIC)
+    strict :
+        controls whether numbers formatted in a weird way are
+        accepted or rejected
+        :raise NumberFormatError: if the string can not be converted to a
+        decimal number (Default value = False)
+
+    Returns
+    -------
 
     >>> parse_decimal('1,099.98', locale='en_US')
     Decimal('1099.98')
@@ -697,33 +960,21 @@
     Decimal('1099.98')
     >>> parse_decimal('12 345,123', locale='ru')
     Decimal('12345.123')
-
-    When the given string cannot be parsed, an exception is raised:
-
+    
     >>> parse_decimal('2,109,998', locale='de')
     Traceback (most recent call last):
         ...
     NumberFormatError: '2,109,998' is not a valid decimal number
-
-    If `strict` is set to `True` and the given string contains a number
-    formatted in an irregular way, an exception is raised:
-
+    
     >>> parse_decimal('30.00', locale='de', strict=True)
     Traceback (most recent call last):
         ...
     NumberFormatError: '30.00' is not a properly formatted decimal number. Did you mean '3.000'? Or maybe '30,00'?
-
+    
     >>> parse_decimal('0.00', locale='de', strict=True)
     Traceback (most recent call last):
         ...
     NumberFormatError: '0.00' is not a properly formatted decimal number. Did you mean '0'?
-
-    :param string: the string to parse
-    :param locale: the `Locale` object or locale identifier
-    :param strict: controls whether numbers formatted in a weird way are
-                   accepted or rejected
-    :raise NumberFormatError: if the string can not be converted to a
-                              decimal number
     """
     locale = Locale.parse(locale)
     group_symbol = get_group_symbol(locale)
@@ -782,6 +1033,14 @@
 def parse_grouping(p):
     """Parse primary and secondary digit grouping
 
+    Parameters
+    ----------
+    p :
+        
+
+    Returns
+    -------
+
     >>> parse_grouping('##')
     (1000, 1000)
     >>> parse_grouping('#,###')
@@ -802,11 +1061,32 @@
 
 
 def parse_pattern(pattern):
-    """Parse number format patterns"""
+    """Parse number format patterns
+
+    Parameters
+    ----------
+    pattern :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(pattern, NumberPattern):
         return pattern
 
     def _match_number(pattern):
+        """
+
+        Parameters
+        ----------
+        pattern :
+            
+
+        Returns
+        -------
+
+        """
         rv = number_re.search(pattern)
         if rv is None:
             raise ValueError('Invalid number pattern %r' % pattern)
@@ -838,7 +1118,17 @@
         fraction = ''
 
     def parse_precision(p):
-        """Calculate the min and max allowed digits"""
+        """Calculate the min and max allowed digits
+
+        Parameters
+        ----------
+        p :
+            
+
+        Returns
+        -------
+
+        """
         min = max = 0
         for c in p:
             if c in '@0':
@@ -869,6 +1159,7 @@
 
 
 class NumberPattern(object):
+    """ """
 
     def __init__(self, pattern, prefix, suffix, grouping,
                  int_prec, frac_prec, exp_prec, exp_plus):
@@ -887,11 +1178,18 @@
         return '<%s %r>' % (type(self).__name__, self.pattern)
 
     def compute_scale(self):
-        """Return the scaling factor to apply to the number before rendering.
-
-        Auto-set to a factor of 2 or 3 if presence of a ``%`` or ``‰`` sign is
-        detected in the prefix or suffix of the pattern. Default is to not mess
-        with the scale at all and keep it to 0.
+        """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            Auto-set to a factor of 2 or 3 if presence of a ``%`` or ``‰`` sign is
+            detected in the prefix or suffix of the pattern. Default is to not mess
+            with the scale at all and keep it to 0.
+
         """
         scale = 0
         if '%' in ''.join(self.prefix + self.suffix):
@@ -901,7 +1199,18 @@
         return scale
 
     def scientific_notation_elements(self, value, locale):
-        """ Returns normalized scientific notation components of a value.
+        """Returns normalized scientific notation components of a value.
+
+        Parameters
+        ----------
+        value :
+            
+        locale :
+            
+
+        Returns
+        -------
+
         """
         # Normalize value to only have one lead digit.
         exp = value.adjusted()
@@ -938,29 +1247,38 @@
         group_separator=True,
     ):
         """Renders into a string a number following the defined pattern.
-
+        
         Forced decimal quantization is active by default so we'll produce a
         number string that is strictly following CLDR pattern definitions.
 
-        :param value: The value to format. If this is not a Decimal object,
-                      it will be cast to one.
-        :type value: decimal.Decimal|float|int
-        :param locale: The locale to use for formatting.
-        :type locale: str|babel.core.Locale
-        :param currency: Which currency, if any, to format as.
-        :type currency: str|None
-        :param currency_digits: Whether or not to use the currency's precision.
-                                If false, the pattern's precision is used.
-        :type currency_digits: bool
-        :param decimal_quantization: Whether decimal numbers should be forcibly
-                                     quantized to produce a formatted output
-                                     strictly matching the CLDR definition for
-                                     the locale.
-        :type decimal_quantization: bool
-        :param force_frac: DEPRECATED - a forced override for `self.frac_prec`
-                           for a single formatting invocation.
-        :return: Formatted decimal string.
-        :rtype: str
+        Parameters
+        ----------
+        value : decimal.Decimal|float|int
+            The value to format. If this is not a Decimal object,
+            it will be cast to one.
+        locale : str|babel.core.Locale
+            The locale to use for formatting.
+        currency : str|None
+            Which currency, if any, to format as. (Default value = None)
+        currency_digits : bool
+            Whether or not to use the currency's precision.
+            If false, the pattern's precision is used. (Default value = True)
+        decimal_quantization : bool
+            Whether decimal numbers should be forcibly
+            quantized to produce a formatted output
+            strictly matching the CLDR definition for
+            the locale. (Default value = True)
+        force_frac :
+            DEPRECATED - a forced override for `self.frac_prec`
+            for a single formatting invocation. (Default value = None)
+        group_separator :
+             (Default value = True)
+
+        Returns
+        -------
+        str
+            Formatted decimal string.
+
         """
         if not isinstance(value, decimal.Decimal):
             value = decimal.Decimal(str(value))
@@ -1052,6 +1370,21 @@
     #     padding with zeroes on either side
     #
     def _format_significant(self, value, minimum, maximum):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        minimum :
+            
+        maximum :
+            
+
+        Returns
+        -------
+
+        """
         exp = value.adjusted()
         scale = maximum - 1 - exp
         digits = str(value.scaleb(scale).quantize(decimal.Decimal(1)))
@@ -1071,6 +1404,23 @@
         return result
 
     def _format_int(self, value, min, max, locale):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        min :
+            
+        max :
+            
+        locale :
+            
+
+        Returns
+        -------
+
+        """
         width = len(value)
         if width < min:
             value = '0' * (min - width) + value
@@ -1084,6 +1434,23 @@
         return value + ret
 
     def _quantize_value(self, value, locale, frac_prec, group_separator):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        locale :
+            
+        frac_prec :
+            
+        group_separator :
+            
+
+        Returns
+        -------
+
+        """
         quantum = get_decimal_quantum(frac_prec[1])
         rounded = value.quantize(quantum)
         a, sep, b = "{:f}".format(rounded).partition(".")
@@ -1094,6 +1461,21 @@
         return number
 
     def _format_frac(self, value, locale, force_frac=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        locale :
+            
+        force_frac :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         min, max = force_frac or self.frac_prec
         if len(value) < min:
             value += ('0' * (min - len(value)))
