# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_overrides.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_overrides.py
@@ -18,25 +18,62 @@
 
 
 def _return_not_implemented(self, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     return NotImplemented
 
 
 # need to define this at the top level to test pickling
 @array_function_dispatch(lambda array: (array,))
 def dispatched_one_arg(array):
-    """Docstring."""
+    """Docstring.
+
+    Parameters
+    ----------
+    array :
+        
+
+    Returns
+    -------
+
+    """
     return 'original'
 
 
 @array_function_dispatch(lambda array1, array2: (array1, array2))
 def dispatched_two_arg(array1, array2):
-    """Docstring."""
+    """Docstring.
+
+    Parameters
+    ----------
+    array1 :
+        
+    array2 :
+        
+
+    Returns
+    -------
+
+    """
     return 'original'
 
 
 class TestGetImplementingArgs:
+    """ """
 
     def test_ndarray(self):
+        """ """
         array = np.array(1)
 
         args = _get_implementing_args([array])
@@ -52,11 +89,14 @@
         assert_equal(list(args), [array])
 
     def test_ndarray_subclasses(self):
+        """ """
 
         class OverrideSub(np.ndarray):
+            """ """
             __array_function__ = _return_not_implemented
 
         class NoOverrideSub(np.ndarray):
+            """ """
             pass
 
         array = np.array(1).view(np.ndarray)
@@ -74,8 +114,10 @@
         assert_equal(list(args), [override_sub, no_override_sub])
 
     def test_ndarray_and_duck_array(self):
+        """ """
 
         class Other:
+            """ """
             __array_function__ = _return_not_implemented
 
         array = np.array(1)
@@ -88,11 +130,14 @@
         assert_equal(list(args), [array, other])
 
     def test_ndarray_subclass_and_duck_array(self):
+        """ """
 
         class OverrideSub(np.ndarray):
+            """ """
             __array_function__ = _return_not_implemented
 
         class Other:
+            """ """
             __array_function__ = _return_not_implemented
 
         array = np.array(1)
@@ -105,17 +150,22 @@
                      [subarray, array, other])
 
     def test_many_duck_arrays(self):
+        """ """
 
         class A:
+            """ """
             __array_function__ = _return_not_implemented
 
         class B(A):
+            """ """
             __array_function__ = _return_not_implemented
 
         class C(A):
+            """ """
             __array_function__ = _return_not_implemented
 
         class D:
+            """ """
             __array_function__ = _return_not_implemented
 
         a = A()
@@ -134,6 +184,7 @@
         assert_equal(_get_implementing_args([a, c, b]), [c, b, a])
 
     def test_too_many_duck_arrays(self):
+        """ """
         namespace = dict(__array_function__=_return_not_implemented)
         types = [type('A' + str(i), (object,), namespace) for i in range(33)]
         relevant_args = [t() for t in types]
@@ -146,17 +197,22 @@
 
 
 class TestNDArrayArrayFunction:
+    """ """
 
     @requires_array_function
     def test_method(self):
+        """ """
 
         class Other:
+            """ """
             __array_function__ = _return_not_implemented
 
         class NoOverrideSub(np.ndarray):
+            """ """
             pass
 
         class OverrideSub(np.ndarray):
+            """ """
             __array_function__ = _return_not_implemented
 
         array = np.array([1])
@@ -196,6 +252,7 @@
         assert_equal(result, expected.view(OverrideSub))
 
     def test_no_wrapper(self):
+        """ """
         # This shouldn't happen unless a user intentionally calls
         # __array_function__ with invalid arguments, but check that we raise
         # an appropriate error all the same.
@@ -208,21 +265,26 @@
 
 @requires_array_function
 class TestArrayFunctionDispatch:
+    """ """
 
     def test_pickle(self):
+        """ """
         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
             roundtripped = pickle.loads(
                     pickle.dumps(dispatched_one_arg, protocol=proto))
             assert_(roundtripped is dispatched_one_arg)
 
     def test_name_and_docstring(self):
+        """ """
         assert_equal(dispatched_one_arg.__name__, 'dispatched_one_arg')
         if sys.flags.optimize < 2:
             assert_equal(dispatched_one_arg.__doc__, 'Docstring.')
 
     def test_interface(self):
+        """ """
 
         class MyArray:
+            """ """
             def __array_function__(self, func, types, args, kwargs):
                 return (self, func, types, args, kwargs)
 
@@ -236,8 +298,10 @@
         assert_equal(kwargs, {})
 
     def test_not_implemented(self):
+        """ """
 
         class MyArray:
+            """ """
             def __array_function__(self, func, types, args, kwargs):
                 return NotImplemented
 
@@ -248,8 +312,10 @@
 
 @requires_array_function
 class TestVerifyMatchingSignatures:
+    """ """
 
     def test_verify_matching_signatures(self):
+        """ """
 
         verify_matching_signatures(lambda x: 0, lambda x: 0)
         verify_matching_signatures(lambda x=None: 0, lambda x=None: 0)
@@ -265,15 +331,38 @@
             verify_matching_signatures(lambda x=1: 0, lambda y=1: 0)
 
     def test_array_function_dispatch(self):
+        """ """
 
         with assert_raises(RuntimeError):
             @array_function_dispatch(lambda x: (x,))
             def f(y):
+                """
+
+                Parameters
+                ----------
+                y :
+                    
+
+                Returns
+                -------
+
+                """
                 pass
 
         # should not raise
         @array_function_dispatch(lambda x: (x,), verify=False)
         def f(y):
+            """
+
+            Parameters
+            ----------
+            y :
+                
+
+            Returns
+            -------
+
+            """
             pass
 
 
@@ -282,6 +371,7 @@
     HANDLED_FUNCTIONS = {}
 
     class MyArray:
+        """ """
         def __array_function__(self, func, types, args, kwargs):
             if func not in HANDLED_FUNCTIONS:
                 return NotImplemented
@@ -290,8 +380,29 @@
             return HANDLED_FUNCTIONS[func](*args, **kwargs)
 
     def implements(numpy_function):
-        """Register an __array_function__ implementations."""
+        """Register an __array_function__ implementations.
+
+        Parameters
+        ----------
+        numpy_function :
+            
+
+        Returns
+        -------
+
+        """
         def decorator(func):
+            """
+
+            Parameters
+            ----------
+            func :
+                
+
+            Returns
+            -------
+
+            """
             HANDLED_FUNCTIONS[numpy_function] = func
             return func
         return decorator
@@ -301,26 +412,66 @@
 
 @requires_array_function
 class TestArrayFunctionImplementation:
+    """ """
 
     def test_one_arg(self):
+        """ """
         MyArray, implements = _new_duck_type_and_implements()
 
         @implements(dispatched_one_arg)
         def _(array):
+            """
+
+            Parameters
+            ----------
+            array :
+                
+
+            Returns
+            -------
+
+            """
             return 'myarray'
 
         assert_equal(dispatched_one_arg(1), 'original')
         assert_equal(dispatched_one_arg(MyArray()), 'myarray')
 
     def test_optional_args(self):
+        """ """
         MyArray, implements = _new_duck_type_and_implements()
 
         @array_function_dispatch(lambda array, option=None: (array,))
         def func_with_option(array, option='default'):
+            """
+
+            Parameters
+            ----------
+            array :
+                
+            option :
+                 (Default value = 'default')
+
+            Returns
+            -------
+
+            """
             return option
 
         @implements(func_with_option)
         def my_array_func_with_option(array, new_option='myarray'):
+            """
+
+            Parameters
+            ----------
+            array :
+                
+            new_option :
+                 (Default value = 'myarray')
+
+            Returns
+            -------
+
+            """
             return new_option
 
         # we don't need to implement every option on __array_function__
@@ -338,10 +489,22 @@
             func_with_option(MyArray(), new_option='no')
 
     def test_not_implemented(self):
+        """ """
         MyArray, implements = _new_duck_type_and_implements()
 
         @array_function_dispatch(lambda array: (array,), module='my')
         def func(array):
+            """
+
+            Parameters
+            ----------
+            array :
+                
+
+            Returns
+            -------
+
+            """
             return array
 
         array = np.array(1)
@@ -354,12 +517,15 @@
 
 
 class TestNDArrayMethods:
+    """ """
 
     def test_repr(self):
+        """ """
         # gh-12162: should still be defined even if __array_function__ doesn't
         # implement np.array_repr()
 
         class MyArray(np.ndarray):
+            """ """
             def __array_function__(*args, **kwargs):
                 return NotImplemented
 
@@ -369,33 +535,50 @@
 
 
 class TestNumPyFunctions:
+    """ """
 
     def test_set_module(self):
+        """ """
         assert_equal(np.sum.__module__, 'numpy')
         assert_equal(np.char.equal.__module__, 'numpy.char')
         assert_equal(np.fft.fft.__module__, 'numpy.fft')
         assert_equal(np.linalg.solve.__module__, 'numpy.linalg')
 
     def test_inspect_sum(self):
+        """ """
         signature = inspect.signature(np.sum)
         assert_('axis' in signature.parameters)
 
     @requires_array_function
     def test_override_sum(self):
+        """ """
         MyArray, implements = _new_duck_type_and_implements()
 
         @implements(np.sum)
         def _(array):
+            """
+
+            Parameters
+            ----------
+            array :
+                
+
+            Returns
+            -------
+
+            """
             return 'yes'
 
         assert_equal(np.sum(MyArray()), 'yes')
 
     @requires_array_function
     def test_sum_on_mock_array(self):
+        """ """
 
         # We need a proxy for mocks because __array_function__ is only looked
         # up in the class dict
         class ArrayProxy:
+            """ """
             def __init__(self, value):
                 self.value = value
             def __array_function__(self, *args, **kwargs):
@@ -413,10 +596,25 @@
 
     @requires_array_function
     def test_sum_forwarding_implementation(self):
+        """ """
 
         class MyArray(np.ndarray):
+            """ """
 
             def sum(self, axis, out):
+                """
+
+                Parameters
+                ----------
+                axis :
+                    
+                out :
+                    
+
+                Returns
+                -------
+
+                """
                 return 'summed'
 
             def __array_function__(self, func, types, args, kwargs):
