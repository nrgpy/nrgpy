# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/indexing.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/indexing.py
@@ -42,44 +42,7 @@
 
 # the public IndexSlicerMaker
 class _IndexSlice:
-    """
-    Create an object to more easily perform multi-index slicing.
-
-    See Also
-    --------
-    MultiIndex.remove_unused_levels : New MultiIndex with no unused levels.
-
-    Notes
-    -----
-    See :ref:`Defined Levels <advanced.shown_levels>`
-    for further info on slicing a MultiIndex.
-
-    Examples
-    --------
-    >>> midx = pd.MultiIndex.from_product([['A0','A1'], ['B0','B1','B2','B3']])
-    >>> columns = ['foo', 'bar']
-    >>> dfmi = pd.DataFrame(np.arange(16).reshape((len(midx), len(columns))),
-                            index=midx, columns=columns)
-
-    Using the default slice command:
-
-    >>> dfmi.loc[(slice(None), slice('B0', 'B1')), :]
-               foo  bar
-        A0 B0    0    1
-           B1    2    3
-        A1 B0    8    9
-           B1   10   11
-
-    Using the IndexSlice class for a more intuitive command:
-
-    >>> idx = pd.IndexSlice
-    >>> dfmi.loc[idx[:, 'B0':'B1'], :]
-               foo  bar
-        A0 B0    0    1
-           B1    2    3
-        A1 B0    8    9
-           B1   10   11
-    """
+    """Create an object to more easily perform multi-index slicing."""
 
     def __getitem__(self, arg):
         return arg
@@ -89,25 +52,23 @@
 
 
 class IndexingError(Exception):
+    """ """
     pass
 
 
 class IndexingMixin:
-    """
-    Mixin for adding .loc/.iloc/.at/.iat to Dataframes and Series.
-    """
+    """Mixin for adding .loc/.iloc/.at/.iat to Dataframes and Series."""
 
     @property
     def iloc(self) -> "_iLocIndexer":
-        """
-        Purely integer-location based indexing for selection by position.
-
+        """Purely integer-location based indexing for selection by position.
+        
         ``.iloc[]`` is primarily integer position based (from ``0`` to
         ``length-1`` of the axis), but may also be used with a boolean
         array.
-
+        
         Allowed inputs are:
-
+        
         - An integer, e.g. ``5``.
         - A list or array of integers, e.g. ``[4, 3, 0]``.
         - A slice object with ints, e.g. ``1:7``.
@@ -116,12 +77,18 @@
           DataFrame) and that returns valid output for indexing (one of the above).
           This is useful in method chains, when you don't have a reference to the
           calling object, but would like to base your selection on some value.
-
+        
         ``.iloc`` will raise ``IndexError`` if a requested indexer is
         out-of-bounds, except *slice* indexers which allow out-of-bounds
         indexing (this conforms with python/numpy *slice* semantics).
-
+        
         See more at :ref:`Selection by Position <indexing.integer>`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         See Also
         --------
@@ -129,9 +96,47 @@
         DataFrame.loc : Purely label-location based indexer for selection by label.
         Series.iloc : Purely integer-location based indexing for
                        selection by position.
-
         Examples
         --------
+        
+        **Indexing just the rows**
+        
+        With a scalar integer.
+        
+        
+        With a list of integers.
+        
+        
+        
+        With a `slice` object.
+        
+        
+        With a boolean mask the same length as the index.
+        
+        
+        With a callable, useful in method chains. The `x` passed
+        to the ``lambda`` is the DataFrame being sliced. This selects
+        the rows whose index label even.
+        
+        
+        **Indexing both axes**
+        
+        You can mix the indexer types for the index and columns. Use ``:`` to
+        select the entire axis.
+        
+        With scalar integers.
+        
+        
+        With lists of integers.
+        
+        
+        With `slice` objects.
+        
+        
+        With a boolean array whose length matches the columns.
+        
+        
+        With a callable function that expects the Series or DataFrame.
         >>> mydict = [{'a': 1, 'b': 2, 'c': 3, 'd': 4},
         ...           {'a': 100, 'b': 200, 'c': 300, 'd': 400},
         ...           {'a': 1000, 'b': 2000, 'c': 3000, 'd': 4000 }]
@@ -141,11 +146,7 @@
         0     1     2     3     4
         1   100   200   300   400
         2  1000  2000  3000  4000
-
-        **Indexing just the rows**
-
-        With a scalar integer.
-
+        
         >>> type(df.iloc[0])
         <class 'pandas.core.series.Series'>
         >>> df.iloc[0]
@@ -154,78 +155,53 @@
         c    3
         d    4
         Name: 0, dtype: int64
-
-        With a list of integers.
-
+        
         >>> df.iloc[[0]]
            a  b  c  d
         0  1  2  3  4
         >>> type(df.iloc[[0]])
         <class 'pandas.core.frame.DataFrame'>
-
+        
         >>> df.iloc[[0, 1]]
              a    b    c    d
         0    1    2    3    4
         1  100  200  300  400
-
-        With a `slice` object.
-
+        
         >>> df.iloc[:3]
               a     b     c     d
         0     1     2     3     4
         1   100   200   300   400
         2  1000  2000  3000  4000
-
-        With a boolean mask the same length as the index.
-
+        
         >>> df.iloc[[True, False, True]]
               a     b     c     d
         0     1     2     3     4
         2  1000  2000  3000  4000
-
-        With a callable, useful in method chains. The `x` passed
-        to the ``lambda`` is the DataFrame being sliced. This selects
-        the rows whose index label even.
-
+        
         >>> df.iloc[lambda x: x.index % 2 == 0]
               a     b     c     d
         0     1     2     3     4
         2  1000  2000  3000  4000
-
-        **Indexing both axes**
-
-        You can mix the indexer types for the index and columns. Use ``:`` to
-        select the entire axis.
-
-        With scalar integers.
-
+        
         >>> df.iloc[0, 1]
         2
-
-        With lists of integers.
-
+        
         >>> df.iloc[[0, 2], [1, 3]]
               b     d
         0     2     4
         2  2000  4000
-
-        With `slice` objects.
-
+        
         >>> df.iloc[1:3, 0:3]
               a     b     c
         1   100   200   300
         2  1000  2000  3000
-
-        With a boolean array whose length matches the columns.
-
+        
         >>> df.iloc[:, [True, False, True, False]]
               a     c
         0     1     3
         1   100   300
         2  1000  3000
-
-        With a callable function that expects the Series or DataFrame.
-
+        
         >>> df.iloc[:, lambda df: [0, 2]]
               a     c
         0     1     3
@@ -236,29 +212,34 @@
 
     @property
     def loc(self) -> "_LocIndexer":
-        """
-        Access a group of rows and columns by label(s) or a boolean array.
-
+        """Access a group of rows and columns by label(s) or a boolean array.
+        
         ``.loc[]`` is primarily label based, but may also be used with a
         boolean array.
-
+        
         Allowed inputs are:
-
+        
         - A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is
           interpreted as a *label* of the index, and **never** as an
           integer position along the index).
         - A list or array of labels, e.g. ``['a', 'b', 'c']``.
         - A slice object with labels, e.g. ``'a':'f'``.
-
+        
           .. warning:: Note that contrary to usual python slices, **both** the
               start and the stop are included
-
+        
         - A boolean array of the same length as the axis being sliced,
           e.g. ``[True, False, True]``.
         - A ``callable`` function with one argument (the calling Series or
           DataFrame) and that returns valid output for indexing (one of the above)
-
+        
         See more at :ref:`Selection by Label <indexing.label>`
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Raises
         ------
@@ -272,11 +253,84 @@
         DataFrame.xs : Returns a cross-section (row(s) or column(s)) from the
             Series/DataFrame.
         Series.loc : Access group of values using labels.
-
         Examples
         --------
         **Getting values**
-
+        
+        
+        Single label. Note this returns the row as a Series.
+        
+        
+        List of labels. Note using ``[[]]`` returns a DataFrame.
+        
+        
+        Single label for row and column
+        
+        
+        Slice with labels for row and single label for column. As mentioned
+        above, note that both the start and stop of the slice are included.
+        
+        
+        Boolean list with the same length as the row axis
+        
+        
+        Conditional that returns a boolean Series
+        
+        
+        Conditional that returns a boolean Series with column labels specified
+        
+        
+        Callable that returns a boolean Series
+        
+        
+        **Setting values**
+        
+        Set value for all items matching the list of labels
+        
+        
+        Set value for an entire row
+        
+        
+        Set value for an entire column
+        
+        
+        Set value for rows matching callable condition
+        
+        
+        **Getting values on a DataFrame with an index that has integer labels**
+        
+        Another example using integers for the index
+        
+        
+        Slice with integer labels for rows. As mentioned above, note that both
+        the start and stop of the slice are included.
+        
+        
+        **Getting values with a MultiIndex**
+        
+        A number of examples using a DataFrame with a MultiIndex
+        
+        
+        Single label. Note this returns a DataFrame with a single index.
+        
+        
+        Single index tuple. Note this returns a Series.
+        
+        
+        Single label for row and column. Similar to passing in a tuple, this
+        returns a Series.
+        
+        
+        Single tuple. Note using ``[[]]`` returns a DataFrame.
+        
+        
+        Single tuple for the index with a single label for the column
+        
+        
+        Slice from index tuple to single label
+        
+        
+        Slice from index tuple to index tuple
         >>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],
         ...      index=['cobra', 'viper', 'sidewinder'],
         ...      columns=['max_speed', 'shield'])
@@ -285,100 +339,69 @@
         cobra               1       2
         viper               4       5
         sidewinder          7       8
-
-        Single label. Note this returns the row as a Series.
-
+        
         >>> df.loc['viper']
         max_speed    4
         shield       5
         Name: viper, dtype: int64
-
-        List of labels. Note using ``[[]]`` returns a DataFrame.
-
+        
         >>> df.loc[['viper', 'sidewinder']]
                     max_speed  shield
         viper               4       5
         sidewinder          7       8
-
-        Single label for row and column
-
+        
         >>> df.loc['cobra', 'shield']
         2
-
-        Slice with labels for row and single label for column. As mentioned
-        above, note that both the start and stop of the slice are included.
-
+        
         >>> df.loc['cobra':'viper', 'max_speed']
         cobra    1
         viper    4
         Name: max_speed, dtype: int64
-
-        Boolean list with the same length as the row axis
-
+        
         >>> df.loc[[False, False, True]]
                     max_speed  shield
         sidewinder          7       8
-
-        Conditional that returns a boolean Series
-
+        
         >>> df.loc[df['shield'] > 6]
                     max_speed  shield
         sidewinder          7       8
-
-        Conditional that returns a boolean Series with column labels specified
-
+        
         >>> df.loc[df['shield'] > 6, ['max_speed']]
                     max_speed
         sidewinder          7
-
-        Callable that returns a boolean Series
-
+        
         >>> df.loc[lambda df: df['shield'] == 8]
                     max_speed  shield
         sidewinder          7       8
-
-        **Setting values**
-
-        Set value for all items matching the list of labels
-
+        
         >>> df.loc[['viper', 'sidewinder'], ['shield']] = 50
         >>> df
                     max_speed  shield
         cobra               1       2
         viper               4      50
         sidewinder          7      50
-
-        Set value for an entire row
-
+        
         >>> df.loc['cobra'] = 10
         >>> df
                     max_speed  shield
         cobra              10      10
         viper               4      50
         sidewinder          7      50
-
-        Set value for an entire column
-
+        
         >>> df.loc[:, 'max_speed'] = 30
         >>> df
                     max_speed  shield
         cobra              30      10
         viper              30      50
         sidewinder         30      50
-
-        Set value for rows matching callable condition
-
+        
         >>> df.loc[df['shield'] > 35] = 0
         >>> df
                     max_speed  shield
         cobra              30      10
         viper               0       0
         sidewinder          0       0
-
-        **Getting values on a DataFrame with an index that has integer labels**
-
-        Another example using integers for the index
-
+        
         >>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],
         ...      index=[7, 8, 9], columns=['max_speed', 'shield'])
         >>> df
@@ -386,20 +409,13 @@
         7          1       2
         8          4       5
         9          7       8
-
-        Slice with integer labels for rows. As mentioned above, note that both
-        the start and stop of the slice are included.
-
+        
         >>> df.loc[7:9]
            max_speed  shield
         7          1       2
         8          4       5
         9          7       8
-
-        **Getting values with a MultiIndex**
-
-        A number of examples using a DataFrame with a MultiIndex
-
+        
         >>> tuples = [
         ...    ('cobra', 'mark i'), ('cobra', 'mark ii'),
         ...    ('sidewinder', 'mark i'), ('sidewinder', 'mark ii'),
@@ -417,42 +433,29 @@
                    mark ii           1       4
         viper      mark ii           7       1
                    mark iii         16      36
-
-        Single label. Note this returns a DataFrame with a single index.
-
+        
         >>> df.loc['cobra']
                  max_speed  shield
         mark i          12       2
         mark ii          0       4
-
-        Single index tuple. Note this returns a Series.
-
+        
         >>> df.loc[('cobra', 'mark ii')]
         max_speed    0
         shield       4
         Name: (cobra, mark ii), dtype: int64
-
-        Single label for row and column. Similar to passing in a tuple, this
-        returns a Series.
-
+        
         >>> df.loc['cobra', 'mark i']
         max_speed    12
         shield        2
         Name: (cobra, mark i), dtype: int64
-
-        Single tuple. Note using ``[[]]`` returns a DataFrame.
-
+        
         >>> df.loc[[('cobra', 'mark ii')]]
                        max_speed  shield
         cobra mark ii          0       4
-
-        Single tuple for the index with a single label for the column
-
+        
         >>> df.loc[('cobra', 'mark i'), 'shield']
         2
-
-        Slice from index tuple to single label
-
+        
         >>> df.loc[('cobra', 'mark i'):'viper']
                              max_speed  shield
         cobra      mark i           12       2
@@ -461,9 +464,7 @@
                    mark ii           1       4
         viper      mark ii           7       1
                    mark iii         16      36
-
-        Slice from index tuple to index tuple
-
+        
         >>> df.loc[('cobra', 'mark i'):('viper', 'mark ii')]
                             max_speed  shield
         cobra      mark i          12       2
@@ -476,12 +477,17 @@
 
     @property
     def at(self) -> "_AtIndexer":
-        """
-        Access a single value for a row/column label pair.
-
+        """Access a single value for a row/column label pair.
+        
         Similar to ``loc``, in that both provide label-based lookups. Use
         ``at`` if you only need to get or set a single value in a DataFrame
         or Series.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Raises
         ------
@@ -494,9 +500,16 @@
             position.
         DataFrame.loc : Access a group of rows and columns by label(s).
         Series.at : Access a single value using a label.
-
         Examples
         --------
+        
+        Get value at specified row/column pair
+        
+        
+        Set value at specified row/column pair
+        
+        
+        Get value within a Series
         >>> df = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]],
         ...                   index=[4, 5, 6], columns=['A', 'B', 'C'])
         >>> df
@@ -504,20 +517,14 @@
         4   0   2   3
         5   0   4   1
         6  10  20  30
-
-        Get value at specified row/column pair
-
+        
         >>> df.at[4, 'B']
         2
-
-        Set value at specified row/column pair
-
+        
         >>> df.at[4, 'B'] = 10
         >>> df.at[4, 'B']
         10
-
-        Get value within a Series
-
+        
         >>> df.loc[5].at['B']
         4
         """
@@ -525,12 +532,17 @@
 
     @property
     def iat(self) -> "_iAtIndexer":
-        """
-        Access a single value for a row/column pair by integer position.
-
+        """Access a single value for a row/column pair by integer position.
+        
         Similar to ``iloc``, in that both provide integer-based lookups. Use
         ``iat`` if you only need to get or set a single value in a DataFrame
         or Series.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Raises
         ------
@@ -542,9 +554,16 @@
         DataFrame.at : Access a single value for a row/column label pair.
         DataFrame.loc : Access a group of rows and columns by label(s).
         DataFrame.iloc : Access a group of rows and columns by integer position(s).
-
         Examples
         --------
+        
+        Get value at specified row/column pair
+        
+        
+        Set value at specified row/column pair
+        
+        
+        Get value within a series
         >>> df = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]],
         ...                   columns=['A', 'B', 'C'])
         >>> df
@@ -552,20 +571,14 @@
         0   0   2   3
         1   0   4   1
         2  10  20  30
-
-        Get value at specified row/column pair
-
+        
         >>> df.iat[1, 2]
         1
-
-        Set value at specified row/column pair
-
+        
         >>> df.iat[1, 2] = 10
         >>> df.iat[1, 2]
         10
-
-        Get value within a series
-
+        
         >>> df.loc[0].iat[1]
         2
         """
@@ -573,6 +586,7 @@
 
 
 class _LocationIndexer(_NDFrameIndexerBase):
+    """ """
     _valid_types: str
     axis = None
 
@@ -586,8 +600,16 @@
         return new_self
 
     def _get_setitem_indexer(self, key):
-        """
-        Convert a potentially-label-based key into a positional indexer.
+        """Convert a potentially-label-based key into a positional indexer.
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
         """
         if self.name == "loc":
             self._ensure_listlike_indexer(key)
@@ -625,15 +647,20 @@
             raise IndexingError(key) from e
 
     def _ensure_listlike_indexer(self, key, axis=None):
-        """
-        Ensure that a list-like of column labels are all present by adding them if
+        """Ensure that a list-like of column labels are all present by adding them if
         they do not already exist.
 
         Parameters
         ----------
-        key : list-like of column labels
-            Target labels.
-        axis : key axis if known
+        key :
+            
+        axis :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         column_axis = 1
 
@@ -670,8 +697,7 @@
         iloc._setitem_with_indexer(indexer, value)
 
     def _validate_key(self, key, axis: int):
-        """
-        Ensure that key is valid for current indexer.
+        """Ensure that key is valid for current indexer.
 
         Parameters
         ----------
@@ -679,21 +705,27 @@
             Key requested.
         axis : int
             Dimension on which the indexing is being made.
-
-        Raises
-        ------
-        TypeError
-            If the key (or some element of it) has wrong type.
-        IndexError
-            If the key (or some element of it) is out of bounds.
-        KeyError
-            If the key was not found.
+        axis: int :
+            
+
+        Returns
+        -------
+
+        
         """
         raise AbstractMethodError(self)
 
     def _has_valid_tuple(self, key: Tuple):
-        """
-        Check the key for valid keys across my indexer.
+        """Check the key for valid keys across my indexer.
+
+        Parameters
+        ----------
+        key: Tuple :
+            
+
+        Returns
+        -------
+
         """
         for i, k in enumerate(key):
             if i >= self.ndim:
@@ -708,15 +740,35 @@
 
     def _is_nested_tuple_indexer(self, tup: Tuple) -> bool:
         """
-        Returns
-        -------
-        bool
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        
         """
         if any(isinstance(ax, ABCMultiIndex) for ax in self.obj.axes):
             return any(is_nested_tuple(tup, ax) for ax in self.obj.axes)
         return False
 
     def _convert_tuple(self, key, is_setter: bool = False):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         keyidx = []
         if self.axis is not None:
             axis = self.obj._get_axis_number(self.axis)
@@ -736,11 +788,19 @@
         return tuple(keyidx)
 
     def _getitem_tuple_same_dim(self, tup: Tuple):
-        """
-        Index with indexers that should return an object of the same dimension
+        """Index with indexers that should return an object of the same dimension
         as self.obj.
-
+        
         This is only called after a failed call to _getitem_lowerdim.
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
         """
         retval = self.obj
         for i, key in enumerate(tup):
@@ -755,6 +815,17 @@
         return retval
 
     def _getitem_lowerdim(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
 
         # we can directly get the axis result since the axis is specified
         if self.axis is not None:
@@ -812,6 +883,17 @@
         raise IndexingError("not applicable")
 
     def _getitem_nested_tuple(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         # we have a nested tuple so have at least 1 multi-index level
         # we should be able to match up the dimensionality here
 
@@ -859,6 +941,21 @@
         return obj
 
     def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         raise AbstractMethodError(self)
 
     def __getitem__(self, key):
@@ -879,18 +976,77 @@
             return self._getitem_axis(maybe_callable, axis=axis)
 
     def _is_scalar_access(self, key: Tuple):
+        """
+
+        Parameters
+        ----------
+        key: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def _getitem_tuple(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         raise AbstractMethodError(self)
 
     def _getitem_axis(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def _has_valid_setitem_indexer(self, indexer) -> bool:
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+
+        Returns
+        -------
+
+        """
         raise AbstractMethodError(self)
 
     def _getbool_axis(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         # caller is responsible for ensuring non-None axis
         labels = self.obj._get_axis(axis)
         key = check_bool_indexer(labels, key)
@@ -900,6 +1056,7 @@
 
 @doc(IndexingMixin.loc)
 class _LocIndexer(_LocationIndexer):
+    """ """
     _takeable: bool = False
     _valid_types = (
         "labels (MUST BE IN THE INDEX), slices of labels (BOTH "
@@ -912,6 +1069,19 @@
 
     @doc(_LocationIndexer._validate_key)
     def _validate_key(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
 
         # valid for a collection of labels (we check their presence later)
         # slice of labels (where start-end in labels)
@@ -920,13 +1090,31 @@
         pass
 
     def _has_valid_setitem_indexer(self, indexer) -> bool:
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+
+        Returns
+        -------
+
+        """
         return True
 
     def _is_scalar_access(self, key: Tuple) -> bool:
         """
-        Returns
-        -------
-        bool
+
+        Parameters
+        ----------
+        key: Tuple :
+            
+
+        Returns
+        -------
+
+        
         """
         # this is a shortcut accessor to both .loc and .iloc
         # that provide the equivalent access of .at and .iat
@@ -957,9 +1145,8 @@
     # MultiIndex Handling
 
     def _multi_take_opportunity(self, tup: Tuple) -> bool:
-        """
-        Check whether there is the possibility to use ``_multi_take``.
-
+        """Check whether there is the possibility to use ``_multi_take``.
+        
         Currently the limit is that all axes being indexed, must be indexed with
         list-likes.
 
@@ -967,12 +1154,13 @@
         ----------
         tup : tuple
             Tuple of indexers, one per axis.
-
-        Returns
-        -------
-        bool
-            Whether the current indexing,
-            can be passed through `_multi_take`.
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        
         """
         if not all(is_list_like_indexer(x) for x in tup):
             return False
@@ -984,8 +1172,7 @@
         return True
 
     def _multi_take(self, tup: Tuple):
-        """
-        Create the indexers for the passed tuple of keys, and
+        """Create the indexers for the passed tuple of keys, and
         executes the take operation. This allows the take operation to be
         executed all at once, rather than once for each dimension.
         Improving efficiency.
@@ -994,10 +1181,13 @@
         ----------
         tup : tuple
             Tuple of indexers, one per axis.
-
-        Returns
-        -------
-        values: same type as the object being indexed
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        
         """
         # GH 836
         d = {
@@ -1009,15 +1199,19 @@
     # -------------------------------------------------------------------
 
     def _getitem_iterable(self, key, axis: int):
-        """
-        Index current object with an an iterable collection of keys.
+        """Index current object with an an iterable collection of keys.
 
         Parameters
         ----------
         key : iterable
             Targeted labels.
-        axis: int
+        axis : int
             Dimension on which the indexing is being made.
+        axis: int :
+            
+
+        Returns
+        -------
 
         Raises
         ------
@@ -1025,9 +1219,7 @@
             If no key was found. Will change in the future to raise if not all
             keys were found.
 
-        Returns
-        -------
-        scalar, DataFrame, or Series: indexed value(s).
+        
         """
         # we assume that not com.is_bool_indexer(key), as that is
         #  handled before we get here.
@@ -1040,6 +1232,17 @@
         )
 
     def _getitem_tuple(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         try:
             return self._getitem_lowerdim(tup)
         except IndexingError:
@@ -1055,10 +1258,34 @@
         return self._getitem_tuple_same_dim(tup)
 
     def _get_label(self, label, axis: int):
+        """
+
+        Parameters
+        ----------
+        label :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         # GH#5667 this will fail if the label is not present in the axis.
         return self.obj.xs(label, axis=axis)
 
     def _handle_lowerdim_multi_index_axis0(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
         # we have an axis0 multi-index, handle or raise
         axis = self.axis or 0
         try:
@@ -1076,6 +1303,19 @@
         raise IndexingError("No label returned")
 
     def _getitem_axis(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         key = item_from_zerodim(key)
         if is_iterator(key):
             key = list(key)
@@ -1110,8 +1350,18 @@
         return self._get_label(key, axis=axis)
 
     def _get_slice_axis(self, slice_obj: slice, axis: int):
-        """
-        This is pretty simple as we just have to deal with labels.
+        """This is pretty simple as we just have to deal with labels.
+
+        Parameters
+        ----------
+        slice_obj: slice :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
         """
         # caller is responsible for ensuring non-None axis
         obj = self.obj
@@ -1131,19 +1381,34 @@
             return self.obj.take(indexer, axis=axis)
 
     def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):
-        """
-        Convert indexing key into something we can use to do actual fancy
+        """Convert indexing key into something we can use to do actual fancy
         indexing on a ndarray.
-
+        
         Examples
         ix[:5] -> slice(0, 5)
         ix[[1,2,3]] -> [1,2,3]
         ix[['foo', 'bar', 'baz']] -> [i, j, k] (indices of foo, bar, baz)
-
+        
         Going by Zen of Python?
         'In the face of ambiguity, refuse the temptation to guess.'
-        raise AmbiguousIndexError with integer labels?
-        - No, prefer label-based indexing
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        Raises
+        ------
+        No
+            prefer label
+
         """
         labels = self.obj._get_axis(axis)
 
@@ -1206,19 +1471,25 @@
                 raise
 
     def _get_listlike_indexer(self, key, axis: int, raise_missing: bool = False):
-        """
-        Transform a list-like of keys into a new index and an indexer.
+        """Transform a list-like of keys into a new index and an indexer.
 
         Parameters
         ----------
         key : list-like
             Targeted labels.
-        axis: int
+        axis : int
             Dimension on which the indexing is being made.
-        raise_missing: bool, default False
+        raise_missing : bool, default False
             Whether to raise a KeyError if some labels were not found.
             Will be removed in the future, and then this method will always behave as
             if ``raise_missing=True``.
+        axis: int :
+            
+        raise_missing: bool :
+             (Default value = False)
+
+        Returns
+        -------
 
         Raises
         ------
@@ -1226,12 +1497,7 @@
             If at least one key was requested but none was found, and
             raise_missing=True.
 
-        Returns
-        -------
-        keyarr: Index
-            New index (coinciding with 'key' if the axis is unique).
-        values : array-like
-            Indexer for the return object, -1 denotes keys not found.
+        
         """
         ax = self.obj._get_axis(axis)
 
@@ -1257,9 +1523,8 @@
     def _validate_read_indexer(
         self, key, indexer, axis: int, raise_missing: bool = False
     ):
-        """
-        Check that indexer can be used to return a result.
-
+        """Check that indexer can be used to return a result.
+        
         e.g. at least one element was found,
         unless the list of keys was actually empty.
 
@@ -1267,21 +1532,24 @@
         ----------
         key : list-like
             Targeted labels (only used to show correct error message).
-        indexer: array-like of booleans
+        indexer : array-like of booleans
             Indices corresponding to the key,
             (with -1 indicating not found).
-        axis: int
+        axis : int
             Dimension on which the indexing is being made.
-        raise_missing: bool
+        raise_missing : bool
             Whether to raise a KeyError if some labels are not found. Will be
             removed in the future, and then this method will always behave as
             if raise_missing=True.
-
-        Raises
-        ------
-        KeyError
-            If at least one key was requested but none was found, and
-            raise_missing=True.
+        axis: int :
+            
+        raise_missing: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         ax = self.obj._get_axis(axis)
 
@@ -1322,6 +1590,7 @@
 
 @doc(IndexingMixin.iloc)
 class _iLocIndexer(_LocationIndexer):
+    """ """
     _valid_types = (
         "integer, integer slice (START point is INCLUDED, END "
         "point is EXCLUDED), listlike of integers, boolean array"
@@ -1332,6 +1601,19 @@
     # Key Checks
 
     def _validate_key(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         if com.is_bool_indexer(key):
             if hasattr(key, "index") and isinstance(key.index, Index):
                 if key.index.inferred_type == "integer":
@@ -1369,13 +1651,18 @@
             raise ValueError(f"Can only index by location with a [{self._valid_types}]")
 
     def _has_valid_setitem_indexer(self, indexer) -> bool:
-        """
-        Validate that a positional indexer cannot enlarge its target
+        """Validate that a positional indexer cannot enlarge its target
         will raise if needed, does not modify the indexer externally.
 
-        Returns
-        -------
-        bool
+        Parameters
+        ----------
+        indexer :
+            
+
+        Returns
+        -------
+
+        
         """
         if isinstance(indexer, dict):
             raise IndexError("iloc cannot enlarge its target object")
@@ -1399,9 +1686,16 @@
 
     def _is_scalar_access(self, key: Tuple) -> bool:
         """
-        Returns
-        -------
-        bool
+
+        Parameters
+        ----------
+        key: Tuple :
+            
+
+        Returns
+        -------
+
+        
         """
         # this is a shortcut accessor to both .loc and .iloc
         # that provide the equivalent access of .at and .iat
@@ -1417,8 +1711,7 @@
         return True
 
     def _validate_integer(self, key: int, axis: int) -> None:
-        """
-        Check that 'key' is a valid position in the desired axis.
+        """Check that 'key' is a valid position in the desired axis.
 
         Parameters
         ----------
@@ -1426,11 +1719,15 @@
             Requested position.
         axis : int
             Desired axis.
-
-        Raises
-        ------
-        IndexError
-            If 'key' is not a valid position in axis 'axis'.
+        key: int :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        
         """
         len_axis = len(self.obj._get_axis(axis))
         if key >= len_axis or key < -len_axis:
@@ -1439,6 +1736,17 @@
     # -------------------------------------------------------------------
 
     def _getitem_tuple(self, tup: Tuple):
+        """
+
+        Parameters
+        ----------
+        tup: Tuple :
+            
+
+        Returns
+        -------
+
+        """
 
         self._has_valid_tuple(tup)
         try:
@@ -1449,17 +1757,21 @@
         return self._getitem_tuple_same_dim(tup)
 
     def _get_list_axis(self, key, axis: int):
-        """
-        Return Series values by list or array of integers.
+        """Return Series values by list or array of integers.
 
         Parameters
         ----------
         key : list-like positional indexer
+            
         axis : int
+            
+        axis: int :
+            
 
         Returns
         -------
         Series object
+            
 
         Notes
         -----
@@ -1472,6 +1784,19 @@
             raise IndexError("positional indexers are out-of-bounds") from err
 
     def _getitem_axis(self, key, axis: int):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(key, slice):
             return self._get_slice_axis(key, axis=axis)
 
@@ -1498,6 +1823,19 @@
             return self.obj._ixs(key, axis=axis)
 
     def _get_slice_axis(self, slice_obj: slice, axis: int):
+        """
+
+        Parameters
+        ----------
+        slice_obj: slice :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         # caller is responsible for ensuring non-None axis
         obj = self.obj
 
@@ -1509,28 +1847,61 @@
         return self.obj._slice(slice_obj, axis=axis)
 
     def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):
-        """
-        Much simpler as we only have to deal with our valid types.
+        """Much simpler as we only have to deal with our valid types.
+
+        Parameters
+        ----------
+        key :
+            
+        axis: int :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         return key
 
     def _get_setitem_indexer(self, key):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+
+        Returns
+        -------
+
+        """
         # GH#32257 Fall through to let numpy do validation
         return key
 
     # -------------------------------------------------------------------
 
     def _setitem_with_indexer(self, indexer, value):
-        """
-        _setitem_with_indexer is for setting values on a Series/DataFrame
+        """_setitem_with_indexer is for setting values on a Series/DataFrame
         using positional indexers.
-
+        
         If the relevant keys are not present, the Series/DataFrame may be
         expanded.
-
+        
         This method is currently broken when dealing with non-unique Indexes,
         since it goes from positional indexers back to labels when calling
         BlockManager methods, see GH#12991, GH#22046, GH#15686.
+
+        Parameters
+        ----------
+        indexer :
+            
+        value :
+            
+
+        Returns
+        -------
+
         """
 
         # also has the side effect of consolidating in-place
@@ -1670,6 +2041,19 @@
                     )
 
             def isetter(loc, v):
+                """
+
+                Parameters
+                ----------
+                loc :
+                    
+                v :
+                    
+
+                Returns
+                -------
+
+                """
                 # positional setting on column loc
                 ser = self.obj._ixs(loc, axis=1)
 
@@ -1801,8 +2185,18 @@
             self.obj._maybe_update_cacher(clear=True)
 
     def _setitem_with_indexer_missing(self, indexer, value):
-        """
-        Insert new row(s) or column(s) into the Series or DataFrame.
+        """Insert new row(s) or column(s) into the Series or DataFrame.
+
+        Parameters
+        ----------
+        indexer :
+            
+        value :
+            
+
+        Returns
+        -------
+
         """
         from pandas import Series
 
@@ -1862,6 +2256,7 @@
 
     def _align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool = False):
         """
+
         Parameters
         ----------
         indexer : tuple, slice, scalar
@@ -1871,11 +2266,15 @@
         multiindex_indexer : boolean, optional
             Defaults to False. Should be set to True if `indexer` was from
             a `pd.MultiIndex`, to avoid unnecessary broadcasting.
-
-        Returns
-        -------
-        `np.array` of `ser` broadcast to the appropriate shape for assignment
-        to the locations selected by `indexer`
+        ser: ABCSeries :
+            
+        multiindex_indexer: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         if isinstance(indexer, (slice, np.ndarray, list, Index)):
             indexer = tuple([indexer])
@@ -1884,6 +2283,17 @@
 
             # flatten np.ndarray indexers
             def ravel(i):
+                """
+
+                Parameters
+                ----------
+                i :
+                    
+
+                Returns
+                -------
+
+                """
                 return i.ravel() if isinstance(i, np.ndarray) else i
 
             indexer = tuple(map(ravel, indexer))
@@ -1952,6 +2362,19 @@
         raise ValueError("Incompatible indexer with Series")
 
     def _align_frame(self, indexer, df: ABCDataFrame):
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+        df: ABCDataFrame :
+            
+
+        Returns
+        -------
+
+        """
         is_frame = self.ndim == 2
 
         if isinstance(indexer, tuple):
@@ -2005,11 +2428,22 @@
 
 
 class _ScalarAccessIndexer(_NDFrameIndexerBase):
-    """
-    Access scalars quickly.
-    """
+    """Access scalars quickly."""
 
     def _convert_key(self, key, is_setter: bool = False):
+        """
+
+        Parameters
+        ----------
+        key :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         raise AbstractMethodError(self)
 
     def __getitem__(self, key):
@@ -2042,12 +2476,23 @@
 
 @doc(IndexingMixin.at)
 class _AtIndexer(_ScalarAccessIndexer):
+    """ """
     _takeable = False
 
     def _convert_key(self, key, is_setter: bool = False):
-        """
-        Require they keys to be the same type as the index. (so we don't
+        """Require they keys to be the same type as the index. (so we don't
         fallback)
+
+        Parameters
+        ----------
+        key :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         # GH 26989
         # For series, unpacking key needs to result in the label.
@@ -2063,6 +2508,7 @@
 
     @property
     def _axes_are_unique(self) -> bool:
+        """ """
         # Only relevant for self.ndim == 2
         assert self.ndim == 2
         return self.obj.index.is_unique and self.obj.columns.is_unique
@@ -2091,11 +2537,22 @@
 
 @doc(IndexingMixin.iat)
 class _iAtIndexer(_ScalarAccessIndexer):
+    """ """
     _takeable = True
 
     def _convert_key(self, key, is_setter: bool = False):
-        """
-        Require integer args. (and convert to label arguments)
+        """Require integer args. (and convert to label arguments)
+
+        Parameters
+        ----------
+        key :
+            
+        is_setter: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         for a, i in zip(self.obj.axes, key):
             if not is_integer(i):
@@ -2104,18 +2561,24 @@
 
 
 def _tuplify(ndim: int, loc: Hashable) -> Tuple[Union[Hashable, slice], ...]:
-    """
-    Given an indexer for the first dimension, create an equivalent tuple
+    """Given an indexer for the first dimension, create an equivalent tuple
     for indexing over all dimensions.
 
     Parameters
     ----------
     ndim : int
+        
     loc : object
+        
+    ndim: int :
+        
+    loc: Hashable :
+        
 
     Returns
     -------
-    tuple
+
+    
     """
     _tup: List[Union[Hashable, slice]]
     _tup = [slice(None, None) for _ in range(ndim)]
@@ -2124,8 +2587,18 @@
 
 
 def convert_to_index_sliceable(obj: "DataFrame", key):
-    """
-    If we are index sliceable, then return my slicer, otherwise return None.
+    """If we are index sliceable, then return my slicer, otherwise return None.
+
+    Parameters
+    ----------
+    obj: "DataFrame" :
+        
+    key :
+        
+
+    Returns
+    -------
+
     """
     idx = obj.index
     if isinstance(key, slice):
@@ -2149,10 +2622,9 @@
 
 
 def check_bool_indexer(index: Index, key) -> np.ndarray:
-    """
-    Check if key is a valid boolean indexer for an object with such index and
+    """Check if key is a valid boolean indexer for an object with such index and
     perform reindexing or conversion if needed.
-
+    
     This function assumes that is_bool_indexer(key) == True.
 
     Parameters
@@ -2161,18 +2633,15 @@
         Index of the object on which the indexing is done.
     key : list-like
         Boolean indexer to check.
+    index: Index :
+        
 
     Returns
     -------
     np.array
         Resulting key.
 
-    Raises
-    ------
-    IndexError
-        If the key does not have the same length as index.
-    IndexingError
-        If the index of the key is unalignable to index.
+    
     """
     result = key
     if isinstance(key, ABCSeries) and not key.index.equals(index):
@@ -2196,9 +2665,18 @@
 
 
 def convert_missing_indexer(indexer):
-    """
-    Reverse convert a missing indexer, which is a dict
-    return the scalar indexer and a boolean indicating if we converted
+    """Reverse convert a missing indexer, which is a dict
+
+    Parameters
+    ----------
+    indexer :
+        
+
+    Returns
+    -------
+    type
+        
+
     """
     if isinstance(indexer, dict):
 
@@ -2213,19 +2691,50 @@
 
 
 def convert_from_missing_indexer_tuple(indexer, axes):
+    """Create a filtered indexer that doesn't have any missing indexers.
+
+    Parameters
+    ----------
+    indexer :
+        
+    axes :
+        
+
+    Returns
+    -------
+
     """
-    Create a filtered indexer that doesn't have any missing indexers.
-    """
 
     def get_indexer(_i, _idx):
+        """
+
+        Parameters
+        ----------
+        _i :
+            
+        _idx :
+            
+
+        Returns
+        -------
+
+        """
         return axes[_i].get_loc(_idx["key"]) if isinstance(_idx, dict) else _idx
 
     return tuple(get_indexer(_i, _idx) for _i, _idx in enumerate(indexer))
 
 
 def maybe_convert_ix(*args):
-    """
-    We likely want to take the cross-product.
+    """We likely want to take the cross-product.
+
+    Parameters
+    ----------
+    *args :
+        
+
+    Returns
+    -------
+
     """
     ixify = True
     for arg in args:
@@ -2240,9 +2749,18 @@
 
 def is_nested_tuple(tup, labels) -> bool:
     """
+
+    Parameters
+    ----------
+    tup :
+        
+    labels :
+        
+
     Returns
     -------
-    bool
+
+    
     """
     # check for a compatible nested tuple and multiindexes among the axes
     if not isinstance(tup, tuple):
@@ -2257,9 +2775,16 @@
 
 def is_label_like(key) -> bool:
     """
+
+    Parameters
+    ----------
+    key :
+        
+
     Returns
     -------
-    bool
+
+    
     """
     # select a label or row
     return not isinstance(key, slice) and not is_list_like_indexer(key)
@@ -2267,9 +2792,16 @@
 
 def need_slice(obj) -> bool:
     """
+
+    Parameters
+    ----------
+    obj :
+        
+
     Returns
     -------
-    bool
+
+    
     """
     return (
         obj.start is not None
@@ -2279,11 +2811,19 @@
 
 
 def _non_reducing_slice(slice_):
-    """
-    Ensure that a slice doesn't reduce to a Series or Scalar.
-
+    """Ensure that a slice doesn't reduce to a Series or Scalar.
+    
     Any user-passed `subset` should have this called on it
     to make sure we're always working with DataFrames.
+
+    Parameters
+    ----------
+    slice_ :
+        
+
+    Returns
+    -------
+
     """
     # default to column slice, like DataFrame
     # ['A', 'B'] -> IndexSlices[:, ['A', 'B']]
@@ -2293,11 +2833,16 @@
 
     def pred(part) -> bool:
         """
-        Returns
-        -------
-        bool
-            True if slice does *not* reduce,
-            False if `part` is a tuple.
+
+        Parameters
+        ----------
+        part :
+            
+
+        Returns
+        -------
+
+        
         """
         # true when slice does *not* reduce, False when part is a tuple,
         # i.e. MultiIndex slice
@@ -2318,9 +2863,21 @@
 
 
 def _maybe_numeric_slice(df, slice_, include_bool=False):
-    """
-    Want nice defaults for background_gradient that don't break
+    """Want nice defaults for background_gradient that don't break
     with non-numeric data. But if slice_ is passed go with that.
+
+    Parameters
+    ----------
+    df :
+        
+    slice_ :
+        
+    include_bool :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     if slice_ is None:
         dtypes = [np.number]
