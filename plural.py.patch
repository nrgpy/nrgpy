# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/babel/plural.py
+++ b/..//venv/lib/python3.8/site-packages/babel/plural.py
@@ -19,9 +19,9 @@
 
 def extract_operands(source):
     """Extract operands from a decimal, a float or an int, according to `CLDR rules`_.
-
+    
     The result is a 6-tuple (n, i, v, w, f, t), where those symbols are as follows:
-
+    
     ====== ===============================================================
     Symbol Value
     ------ ---------------------------------------------------------------
@@ -32,13 +32,19 @@
     f      visible fractional digits in n, with trailing zeros.
     t      visible fractional digits in n, without trailing zeros.
     ====== ===============================================================
-
+    
     .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Operands
 
-    :param source: A real number
-    :type source: int|float|decimal.Decimal
-    :return: A n-i-v-w-f-t tuple
-    :rtype: tuple[decimal.Decimal, int, int, int, int, int]
+    Parameters
+    ----------
+    source : int|float|decimal.Decimal
+        A real number
+
+    Returns
+    -------
+    tuple[decimal.Decimal, int, int, int, int, int]
+        A n-i-v-w-f-t tuple
+
     """
     n = abs(source)
     i = int(n)
@@ -79,19 +85,26 @@
     resulting object is callable and accepts one parameter with a positive or
     negative number (both integer and float) for the number that indicates the
     plural form for a string and returns the tag for the format:
+    
+    
+    Currently the CLDR defines these tags: zero, one, two, few, many and
+    other where other is an implicit default.  Rules should be mutually
+    exclusive; for a given numeric value, only one rule should apply (i.e.
+    the condition should only be true for one of the plural rule elements.
+    
+    .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Language_Plural_Rules
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     >>> rule = PluralRule({'one': 'n is 1'})
     >>> rule(1)
     'one'
     >>> rule(2)
     'other'
-
-    Currently the CLDR defines these tags: zero, one, two, few, many and
-    other where other is an implicit default.  Rules should be mutually
-    exclusive; for a given numeric value, only one rule should apply (i.e.
-    the condition should only be true for one of the plural rule elements.
-
-    .. _`CLDR rules`: https://www.unicode.org/reports/tr35/tr35-33/tr35-numbers.html#Language_Plural_Rules
     """
 
     __slots__ = ('abstract', '_func')
@@ -131,8 +144,15 @@
         """Create a `PluralRule` instance for the given rules.  If the rules
         are a `PluralRule` object, that object is returned.
 
-        :param rules: the rules as list or dict, or a `PluralRule` object
-        :raise RuleError: if the expression is malformed
+        Parameters
+        ----------
+        rules :
+            the rules as list or dict, or a `PluralRule` object
+            :raise RuleError: if the expression is malformed
+
+        Returns
+        -------
+
         """
         if isinstance(rules, cls):
             return rules
@@ -140,12 +160,7 @@
 
     @property
     def rules(self):
-        """The `PluralRule` as a dict of unicode plural rules.
-
-        >>> rule = PluralRule({'one': 'n is 1'})
-        >>> rule.rules
-        {'one': 'n is 1'}
-        """
+        """The `PluralRule` as a dict of unicode plural rules."""
         _compile = _UnicodeCompiler().compile
         return dict([(tag, _compile(ast)) for tag, ast in self.abstract])
 
@@ -169,17 +184,24 @@
 def to_javascript(rule):
     """Convert a list/dict of rules or a `PluralRule` object into a JavaScript
     function.  This function depends on no external library:
-
-    >>> to_javascript({'one': 'n is 1'})
-    "(function(n) { return (n == 1) ? 'one' : 'other'; })"
-
+    
+    
     Implementation detail: The function generated will probably evaluate
     expressions involved into range operations multiple times.  This has the
     advantage that external helper functions are not required and is not a
     big performance hit for these simple calculations.
 
-    :param rule: the rules as list or dict, or a `PluralRule` object
-    :raise RuleError: if the expression is malformed
+    Parameters
+    ----------
+    rule :
+        the rules as list or dict, or a `PluralRule` object
+        :raise RuleError: if the expression is malformed
+
+    Returns
+    -------
+
+    >>> to_javascript({'one': 'n is 1'})
+    "(function(n) { return (n == 1) ? 'one' : 'other'; })"
     """
     to_js = _JavaScriptCompiler().compile
     result = ['(function(n) { return ']
@@ -193,6 +215,15 @@
     """Convert a list/dict of rules or a `PluralRule` object into a regular
     Python function.  This is useful in situations where you need a real
     function and don't are about the actual rule object:
+
+    Parameters
+    ----------
+    rule :
+        the rules as list or dict, or a `PluralRule` object
+        :raise RuleError: if the expression is malformed
+
+    Returns
+    -------
 
     >>> func = to_python({'one': 'n is 1', 'few': 'n in 2..4'})
     >>> func(1)
@@ -204,9 +235,6 @@
     'one'
     >>> func(15)
     'few'
-
-    :param rule: the rules as list or dict, or a `PluralRule` object
-    :raise RuleError: if the expression is malformed
     """
     namespace = {
         'IN': in_range_list,
@@ -233,11 +261,17 @@
     """The plural rule as gettext expression.  The gettext expression is
     technically limited to integers and returns indices rather than tags.
 
+    Parameters
+    ----------
+    rule :
+        the rules as list or dict, or a `PluralRule` object
+        :raise RuleError: if the expression is malformed
+
+    Returns
+    -------
+
     >>> to_gettext({'one': 'n is 1', 'two': 'n is 2'})
     'nplurals=3; plural=((n == 1) ? 0 : (n == 2) ? 1 : 2)'
-
-    :param rule: the rules as list or dict, or a `PluralRule` object
-    :raise RuleError: if the expression is malformed
     """
     rule = PluralRule.parse(rule)
 
@@ -255,6 +289,16 @@
 def in_range_list(num, range_list):
     """Integer range list test.  This is the callback for the "in" operator
     of the UTS #35 pluralization rule language:
+
+    Parameters
+    ----------
+    num :
+        
+    range_list :
+        
+
+    Returns
+    -------
 
     >>> in_range_list(1, [(1, 3)])
     True
@@ -276,6 +320,16 @@
     """Float range test.  This is the callback for the "within" operator
     of the UTS #35 pluralization rule language:
 
+    Parameters
+    ----------
+    num :
+        
+    range_list :
+        
+
+    Returns
+    -------
+
     >>> within_range_list(1, [(1, 3)])
     True
     >>> within_range_list(1.0, [(1, 3)])
@@ -296,6 +350,16 @@
     """Javaish modulo.  This modulo operator returns the value with the sign
     of the dividend rather than the divisor like Python does:
 
+    Parameters
+    ----------
+    a :
+        
+    b :
+        
+
+    Returns
+    -------
+
     >>> cldr_modulo(-3, 5)
     -3
     >>> cldr_modulo(-3, -5)
@@ -316,7 +380,7 @@
 
 
 class RuleError(Exception):
-    """Raised if a rule is malformed."""
+    """ """
 
 _VARS = 'nivwft'
 
@@ -331,6 +395,17 @@
 
 
 def tokenize_rule(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     s = s.split('@')[0]
     result = []
     pos = 0
@@ -350,35 +425,109 @@
 
 
 def test_next_token(tokens, type_, value=None):
+    """
+
+    Parameters
+    ----------
+    tokens :
+        
+    type_ :
+        
+    value :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     return tokens and tokens[-1][0] == type_ and \
         (value is None or tokens[-1][1] == value)
 
 
 def skip_token(tokens, type_, value=None):
+    """
+
+    Parameters
+    ----------
+    tokens :
+        
+    type_ :
+        
+    value :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if test_next_token(tokens, type_, value):
         return tokens.pop()
 
 
 def value_node(value):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+
+    Returns
+    -------
+
+    """
     return 'value', (value, )
 
 
 def ident_node(name):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     return name, ()
 
 
 def range_list_node(range_list):
+    """
+
+    Parameters
+    ----------
+    range_list :
+        
+
+    Returns
+    -------
+
+    """
     return 'range_list', range_list
 
 
 def negate(rv):
+    """
+
+    Parameters
+    ----------
+    rv :
+        
+
+    Returns
+    -------
+
+    """
     return 'not', (rv,)
 
 
 class _Parser(object):
     """Internal parser.  This class can translate a single rule into an abstract
     tree of tuples. It implements the following grammar::
-
+    
         condition     = and_condition ('or' and_condition)*
                         ('@integer' samples)?
                         ('@decimal' samples)?
@@ -396,7 +545,7 @@
         samples       = sampleRange (',' sampleRange)* (',' ('â€¦'|'...'))?
         sampleRange   = decimalValue '~' decimalValue
         decimalValue  = value ('.' value)?
-
+    
     - Whitespace can occur between or around any of the above tokens.
     - Rules should be mutually exclusive; for a given numeric value, only one
       rule should apply (i.e. the condition should only be true for one of
@@ -404,9 +553,16 @@
     - The in and within relations can take comma-separated lists, such as:
       'n in 3,5,7..15'.
     - Samples are ignored.
-
+    
     The translator parses the expression on instanciation into an attribute
     called `ast`.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, string):
@@ -422,6 +578,21 @@
                             self.tokens[-1][1])
 
     def expect(self, type_, value=None, term=None):
+        """
+
+        Parameters
+        ----------
+        type_ :
+            
+        value :
+             (Default value = None)
+        term :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         token = skip_token(self.tokens, type_, value)
         if token is not None:
             return token
@@ -432,18 +603,21 @@
         raise RuleError('expected %s but got %r' % (term, self.tokens[-1][1]))
 
     def condition(self):
+        """ """
         op = self.and_condition()
         while skip_token(self.tokens, 'word', 'or'):
             op = 'or', (op, self.and_condition())
         return op
 
     def and_condition(self):
+        """ """
         op = self.relation()
         while skip_token(self.tokens, 'word', 'and'):
             op = 'and', (op, self.relation())
         return op
 
     def relation(self):
+        """ """
         left = self.expr()
         if skip_token(self.tokens, 'word', 'is'):
             return skip_token(self.tokens, 'word', 'not') and 'isnot' or 'is', \
@@ -461,6 +635,17 @@
         return negate(rv) if negated else rv
 
     def newfangled_relation(self, left):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+
+        Returns
+        -------
+
+        """
         if skip_token(self.tokens, 'symbol', '='):
             negated = False
         elif skip_token(self.tokens, 'symbol', '!='):
@@ -471,6 +656,7 @@
         return negate(rv) if negated else rv
 
     def range_or_value(self):
+        """ """
         left = self.value()
         if skip_token(self.tokens, 'ellipsis'):
             return left, self.value()
@@ -478,12 +664,14 @@
             return left, left
 
     def range_list(self):
+        """ """
         range_list = [self.range_or_value()]
         while skip_token(self.tokens, 'symbol', ','):
             range_list.append(self.range_or_value())
         return range_list_node(range_list)
 
     def expr(self):
+        """ """
         word = skip_token(self.tokens, 'word')
         if word is None or word[1] not in _VARS:
             raise RuleError('Expected identifier variable')
@@ -495,16 +683,37 @@
         return ident_node(name)
 
     def value(self):
+        """ """
         return value_node(int(self.expect('value')[1]))
 
 
 def _binary_compiler(tmpl):
-    """Compiler factory for the `_Compiler`."""
+    """Compiler factory for the `_Compiler`.
+
+    Parameters
+    ----------
+    tmpl :
+        
+
+    Returns
+    -------
+
+    """
     return lambda self, l, r: tmpl % (self.compile(l), self.compile(r))
 
 
 def _unary_compiler(tmpl):
-    """Compiler factory for the `_Compiler`."""
+    """Compiler factory for the `_Compiler`.
+
+    Parameters
+    ----------
+    tmpl :
+        
+
+    Returns
+    -------
+
+    """
     return lambda self, x: tmpl % self.compile(x)
 
 
@@ -514,9 +723,27 @@
 class _Compiler(object):
     """The compilers are able to transform the expressions into multiple
     output formats.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def compile(self, arg):
+        """
+
+        Parameters
+        ----------
+        arg :
+            
+
+        Returns
+        -------
+
+        """
         op, args = arg
         return getattr(self, 'compile_' + op)(*args)
 
@@ -535,6 +762,21 @@
     compile_isnot = _binary_compiler('(%s != %s)')
 
     def compile_relation(self, method, expr, range_list):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        expr :
+            
+        range_list :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
 
@@ -547,6 +789,21 @@
     compile_mod = _binary_compiler('MOD(%s, %s)')
 
     def compile_relation(self, method, expr, range_list):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        expr :
+            
+        range_list :
+            
+
+        Returns
+        -------
+
+        """
         compile_range_list = '[%s]' % ','.join(
             ['(%s, %s)' % tuple(map(self.compile, range_))
              for range_ in range_list[1]])
@@ -564,6 +821,21 @@
     compile_t = compile_zero
 
     def compile_relation(self, method, expr, range_list):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        expr :
+            
+        range_list :
+            
+
+        Returns
+        -------
+
+        """
         rv = []
         expr = self.compile(expr)
         for item in range_list[1]:
@@ -595,6 +867,21 @@
     compile_t = compile_zero
 
     def compile_relation(self, method, expr, range_list):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        expr :
+            
+        range_list :
+            
+
+        Returns
+        -------
+
+        """
         code = _GettextCompiler.compile_relation(
             self, method, expr, range_list)
         if method == 'in':
@@ -617,9 +904,37 @@
     compile_mod = _binary_compiler('%s mod %s')
 
     def compile_not(self, relation):
+        """
+
+        Parameters
+        ----------
+        relation :
+            
+
+        Returns
+        -------
+
+        """
         return self.compile_relation(negated=True, *relation[1])
 
     def compile_relation(self, method, expr, range_list, negated=False):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        expr :
+            
+        range_list :
+            
+        negated :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         ranges = []
         for item in range_list[1]:
             if item[0] == item[1]:
