# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/io/json/test_ujson.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/io/json/test_ujson.py
@@ -22,8 +22,7 @@
 
 
 def _clean_dict(d):
-    """
-    Sanitize dictionary for JSON by converting all keys to strings.
+    """Sanitize dictionary for JSON by converting all keys to strings.
 
     Parameters
     ----------
@@ -32,7 +31,8 @@
 
     Returns
     -------
-    cleaned_dict : dict
+
+    
     """
     return {str(k): v for k, v in d.items()}
 
@@ -41,15 +41,50 @@
     params=[None, "split", "records", "values", "index"]  # Column indexed by default.
 )
 def orient(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=[None, True])
 def numpy(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 def get_int32_compat_dtype(numpy, orient):
+    """
+
+    Parameters
+    ----------
+    numpy :
+        
+    orient :
+        
+
+    Returns
+    -------
+
+    """
     # See GH#32527
     dtype = np.int64
     if not ((numpy is None or orient == "index") or (numpy is True and orient is None)):
@@ -62,10 +97,12 @@
 
 
 class TestUltraJSONTests:
+    """ """
     @pytest.mark.skipif(
         compat.is_platform_32bit(), reason="not compliant on 32-bit, xref #15865"
     )
     def test_encode_decimal(self):
+        """ """
         sut = decimal.Decimal("1337.1337")
         encoded = ujson.encode(sut, double_precision=15)
         decoded = ujson.decode(encoded)
@@ -122,6 +159,17 @@
 
     @pytest.mark.parametrize("ensure_ascii", [True, False])
     def test_encode_string_conversion(self, ensure_ascii):
+        """
+
+        Parameters
+        ----------
+        ensure_ascii :
+            
+
+        Returns
+        -------
+
+        """
         string_input = "A string \\ / \b \f \n \r \t </script> &"
         not_html_encoded = '"A string \\\\ \\/ \\b \\f \\n \\r \\t <\\/script> &"'
         html_encoded = (
@@ -129,6 +177,19 @@
         )
 
         def helper(expected_output, **encode_kwargs):
+            """
+
+            Parameters
+            ----------
+            expected_output :
+                
+            **encode_kwargs :
+                
+
+            Returns
+            -------
+
+            """
             output = ujson.encode(
                 string_input, ensure_ascii=ensure_ascii, **encode_kwargs
             )
@@ -150,6 +211,17 @@
         "long_number", [-4342969734183514, -12345678901234.56789012, -528656961.4399388]
     )
     def test_double_long_numbers(self, long_number):
+        """
+
+        Parameters
+        ----------
+        long_number :
+            
+
+        Returns
+        -------
+
+        """
         sut = {"a": long_number}
         encoded = ujson.encode(sut, double_precision=15)
 
@@ -157,6 +229,7 @@
         assert sut == decoded
 
     def test_encode_non_c_locale(self):
+        """ """
         lc_category = locale.LC_NUMERIC
 
         # We just need one of these locales to work.
@@ -168,12 +241,14 @@
                 break
 
     def test_decimal_decode_test_precise(self):
+        """ """
         sut = {"a": 4.56}
         encoded = ujson.encode(sut)
         decoded = ujson.decode(encoded, precise_float=True)
         assert sut == decoded
 
     def test_encode_double_tiny_exponential(self):
+        """ """
         num = 1e-40
         assert num == ujson.decode(ujson.encode(num))
         num = 1e-100
@@ -185,6 +260,17 @@
 
     @pytest.mark.parametrize("unicode_key", ["key1", "بن"])
     def test_encode_dict_with_unicode_keys(self, unicode_key):
+        """
+
+        Parameters
+        ----------
+        unicode_key :
+            
+
+        Returns
+        -------
+
+        """
         unicode_dict = {unicode_key: "value1"}
         assert unicode_dict == ujson.decode(ujson.encode(unicode_dict))
 
@@ -192,17 +278,30 @@
         "double_input", [math.pi, -math.pi]  # Should work with negatives too.
     )
     def test_encode_double_conversion(self, double_input):
+        """
+
+        Parameters
+        ----------
+        double_input :
+            
+
+        Returns
+        -------
+
+        """
         output = ujson.encode(double_input)
         assert round(double_input, 5) == round(json.loads(output), 5)
         assert round(double_input, 5) == round(ujson.decode(output), 5)
 
     def test_encode_with_decimal(self):
+        """ """
         decimal_input = 1.0
         output = ujson.encode(decimal_input)
 
         assert output == "1.0"
 
     def test_encode_array_of_nested_arrays(self):
+        """ """
         nested_input = [[[[]]]] * 20
         output = ujson.encode(nested_input)
 
@@ -215,6 +314,7 @@
         )
 
     def test_encode_array_of_doubles(self):
+        """ """
         doubles_input = [31337.31337, 31337.31337, 31337.31337, 31337.31337] * 10
         output = ujson.encode(doubles_input)
 
@@ -226,6 +326,7 @@
         )
 
     def test_double_precision(self):
+        """ """
         double_input = 30.012345678901234
         output = ujson.encode(double_input, double_precision=15)
 
@@ -241,6 +342,17 @@
 
     @pytest.mark.parametrize("invalid_val", [20, -1, "9", None])
     def test_invalid_double_precision(self, invalid_val):
+        """
+
+        Parameters
+        ----------
+        invalid_val :
+            
+
+        Returns
+        -------
+
+        """
         double_input = 30.12345678901234567890
         expected_exception = ValueError if isinstance(invalid_val, int) else TypeError
 
@@ -248,6 +360,7 @@
             ujson.encode(double_input, double_precision=invalid_val)
 
     def test_encode_string_conversion2(self):
+        """ """
         string_input = "A string \\ / \b \f \n \r \t"
         output = ujson.encode(string_input)
 
@@ -260,6 +373,17 @@
         ["Räksmörgås اسامة بن محمد بن عوض بن لادن", "\xe6\x97\xa5\xd1\x88"],
     )
     def test_encode_unicode_conversion(self, unicode_input):
+        """
+
+        Parameters
+        ----------
+        unicode_input :
+            
+
+        Returns
+        -------
+
+        """
         enc = ujson.encode(unicode_input)
         dec = ujson.decode(enc)
 
@@ -267,6 +391,7 @@
         assert dec == json.loads(enc)
 
     def test_encode_control_escaping(self):
+        """ """
         escaped_input = "\x19"
         enc = ujson.encode(escaped_input)
         dec = ujson.decode(enc)
@@ -275,6 +400,7 @@
         assert enc == json.dumps(escaped_input)
 
     def test_encode_unicode_surrogate_pair(self):
+        """ """
         surrogate_input = "\xf0\x90\x8d\x86"
         enc = ujson.encode(surrogate_input)
         dec = ujson.decode(enc)
@@ -283,6 +409,7 @@
         assert dec == json.loads(enc)
 
     def test_encode_unicode_4bytes_utf8(self):
+        """ """
         four_bytes_input = "\xf0\x91\x80\xb0TRAILINGNORMAL"
         enc = ujson.encode(four_bytes_input)
         dec = ujson.decode(enc)
@@ -291,6 +418,7 @@
         assert dec == json.loads(enc)
 
     def test_encode_unicode_4bytes_utf8highest(self):
+        """ """
         four_bytes_input = "\xf3\xbf\xbf\xbfTRAILINGNORMAL"
         enc = ujson.encode(four_bytes_input)
 
@@ -300,6 +428,7 @@
         assert dec == json.loads(enc)
 
     def test_encode_array_in_array(self):
+        """ """
         arr_in_arr_input = [[[[]]]]
         output = ujson.encode(arr_in_arr_input)
 
@@ -320,12 +449,24 @@
         ],
     )
     def test_encode_num_conversion(self, num_input):
+        """
+
+        Parameters
+        ----------
+        num_input :
+            
+
+        Returns
+        -------
+
+        """
         output = ujson.encode(num_input)
         assert num_input == json.loads(output)
         assert output == json.dumps(num_input)
         assert num_input == ujson.decode(output)
 
     def test_encode_list_conversion(self):
+        """ """
         list_input = [1, 2, 3, 4]
         output = ujson.encode(list_input)
 
@@ -337,6 +478,7 @@
         )
 
     def test_encode_dict_conversion(self):
+        """ """
         dict_input = {"k1": 1, "k2": 2, "k3": 3, "k4": 4}
         output = ujson.encode(dict_input)
 
@@ -345,12 +487,24 @@
 
     @pytest.mark.parametrize("builtin_value", [None, True, False])
     def test_encode_builtin_values_conversion(self, builtin_value):
+        """
+
+        Parameters
+        ----------
+        builtin_value :
+            
+
+        Returns
+        -------
+
+        """
         output = ujson.encode(builtin_value)
         assert builtin_value == json.loads(output)
         assert output == json.dumps(builtin_value)
         assert builtin_value == ujson.decode(output)
 
     def test_encode_datetime_conversion(self):
+        """ """
         datetime_input = datetime.datetime.fromtimestamp(time.time())
         output = ujson.encode(datetime_input, date_unit="s")
         expected = calendar.timegm(datetime_input.utctimetuple())
@@ -359,6 +513,7 @@
         assert int(expected) == ujson.decode(output)
 
     def test_encode_date_conversion(self):
+        """ """
         date_input = datetime.date.fromtimestamp(time.time())
         output = ujson.encode(date_input, date_unit="s")
 
@@ -373,11 +528,23 @@
         [datetime.time(), datetime.time(1, 2, 3), datetime.time(10, 12, 15, 343243)],
     )
     def test_encode_time_conversion_basic(self, test):
+        """
+
+        Parameters
+        ----------
+        test :
+            
+
+        Returns
+        -------
+
+        """
         output = ujson.encode(test)
         expected = f'"{test.isoformat()}"'
         assert expected == output
 
     def test_encode_time_conversion_pytz(self):
+        """ """
         # see gh-11473: to_json segfaults with timezone-aware datetimes
         test = datetime.time(10, 12, 15, 343243, pytz.utc)
         output = ujson.encode(test)
@@ -385,6 +552,7 @@
         assert expected == output
 
     def test_encode_time_conversion_dateutil(self):
+        """ """
         # see gh-11473: to_json segfaults with timezone-aware datetimes
         test = datetime.time(10, 12, 15, 343243, dateutil.tz.tzutc())
         output = ujson.encode(test)
@@ -395,9 +563,21 @@
         "decoded_input", [NaT, np.datetime64("NaT"), np.nan, np.inf, -np.inf]
     )
     def test_encode_as_null(self, decoded_input):
+        """
+
+        Parameters
+        ----------
+        decoded_input :
+            
+
+        Returns
+        -------
+
+        """
         assert ujson.encode(decoded_input) == "null", "Expected null"
 
     def test_datetime_units(self):
+        """ """
         val = datetime.datetime(2013, 8, 17, 21, 17, 12, 215504)
         stamp = Timestamp(val)
 
@@ -418,6 +598,7 @@
             ujson.encode(val, date_unit="foo")
 
     def test_encode_to_utf8(self):
+        """ """
         unencoded = "\xe6\x97\xa5\xd1\x88"
 
         enc = ujson.encode(unencoded, ensure_ascii=False)
@@ -427,6 +608,7 @@
         assert dec == json.loads(enc)
 
     def test_decode_from_unicode(self):
+        """ """
         unicode_input = '{"obj": 31337}'
 
         dec1 = ujson.decode(unicode_input)
@@ -435,13 +617,16 @@
         assert dec1 == dec2
 
     def test_encode_recursion_max(self):
+        """ """
         # 8 is the max recursion depth
 
         class O2:
+            """ """
             member = 0
             pass
 
         class O1:
+            """ """
             member = 0
             pass
 
@@ -453,6 +638,7 @@
             ujson.encode(decoded_input)
 
     def test_decode_jibberish(self):
+        """ """
         jibberish = "fdsa sda v9sa fdsa"
 
         with pytest.raises(ValueError):
@@ -468,11 +654,33 @@
         ],
     )
     def test_decode_broken_json(self, broken_json):
+        """
+
+        Parameters
+        ----------
+        broken_json :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(broken_json)
 
     @pytest.mark.parametrize("too_big_char", ["[", "{"])
     def test_decode_depth_too_big(self, too_big_char):
+        """
+
+        Parameters
+        ----------
+        too_big_char :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(too_big_char * (1024 * 1024))
 
@@ -487,11 +695,33 @@
         ],
     )
     def test_decode_bad_string(self, bad_string):
+        """
+
+        Parameters
+        ----------
+        bad_string :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(bad_string)
 
     @pytest.mark.parametrize("broken_json", ['{{1337:""}}', '{{"key":"}', "[[[true"])
     def test_decode_broken_json_leak(self, broken_json):
+        """
+
+        Parameters
+        ----------
+        broken_json :
+            
+
+        Returns
+        -------
+
+        """
         for _ in range(1000):
             with pytest.raises(ValueError):
                 ujson.decode(broken_json)
@@ -505,6 +735,17 @@
         ],
     )
     def test_decode_invalid_dict(self, invalid_dict):
+        """
+
+        Parameters
+        ----------
+        invalid_dict :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(invalid_dict)
 
@@ -512,9 +753,21 @@
         "numeric_int_as_str", ["31337", "-31337"]  # Should work with negatives.
     )
     def test_decode_numeric_int(self, numeric_int_as_str):
+        """
+
+        Parameters
+        ----------
+        numeric_int_as_str :
+            
+
+        Returns
+        -------
+
+        """
         assert int(numeric_int_as_str) == ujson.decode(numeric_int_as_str)
 
     def test_encode_null_character(self):
+        """ """
         wrapped_input = "31337 \x00 1337"
         output = ujson.encode(wrapped_input)
 
@@ -531,10 +784,12 @@
         assert '"  \\u0000\\r\\n "' == ujson.dumps("  \u0000\r\n ")
 
     def test_decode_null_character(self):
+        """ """
         wrapped_input = '"31337 \\u0000 31337"'
         assert ujson.decode(wrapped_input) == json.loads(wrapped_input)
 
     def test_encode_list_long_conversion(self):
+        """ """
         long_input = [
             9223372036854775807,
             9223372036854775807,
@@ -553,6 +808,7 @@
         )
 
     def test_encode_long_conversion(self):
+        """ """
         long_input = 9223372036854775807
         output = ujson.encode(long_input)
 
@@ -563,6 +819,17 @@
     @pytest.mark.parametrize("bigNum", [sys.maxsize + 1, -(sys.maxsize + 2)])
     @pytest.mark.xfail(not compat.IS64, reason="GH-35288")
     def test_dumps_ints_larger_than_maxsize(self, bigNum):
+        """
+
+        Parameters
+        ----------
+        bigNum :
+            
+
+        Returns
+        -------
+
+        """
         # GH34395
         bigNum = sys.maxsize + 1
         encoding = ujson.encode(bigNum)
@@ -576,21 +843,45 @@
         "int_exp", ["1337E40", "1.337E40", "1337E+9", "1.337e+40", "1.337E-4"]
     )
     def test_decode_numeric_int_exp(self, int_exp):
+        """
+
+        Parameters
+        ----------
+        int_exp :
+            
+
+        Returns
+        -------
+
+        """
         assert ujson.decode(int_exp) == json.loads(int_exp)
 
     def test_loads_non_str_bytes_raises(self):
+        """ """
         msg = "Expected 'str' or 'bytes'"
         with pytest.raises(TypeError, match=msg):
             ujson.loads(None)
 
     @pytest.mark.parametrize("val", [3590016419, 2 ** 31, 2 ** 32, (2 ** 32) - 1])
     def test_decode_number_with_32bit_sign_bit(self, val):
+        """
+
+        Parameters
+        ----------
+        val :
+            
+
+        Returns
+        -------
+
+        """
         # Test that numbers that fit within 32 bits but would have the
         # sign bit set (2**31 <= x < 2**32) are decoded properly.
         doc = f'{{"id": {val}}}'
         assert ujson.decode(doc)["id"] == val
 
     def test_encode_big_escape(self):
+        """ """
         # Make sure no Exception is raised.
         for _ in range(10):
             base = "\u00e5".encode("utf-8")
@@ -598,6 +889,7 @@
             ujson.encode(escape_input)
 
     def test_decode_big_escape(self):
+        """ """
         # Make sure no Exception is raised.
         for _ in range(10):
             base = "\u00e5".encode("utf-8")
@@ -607,10 +899,13 @@
             ujson.decode(escape_input)
 
     def test_to_dict(self):
+        """ """
         d = {"key": 31337}
 
         class DictTest:
+            """ """
             def toDict(self):
+                """ """
                 return d
 
         o = DictTest()
@@ -620,12 +915,15 @@
         assert dec == d
 
     def test_default_handler(self):
+        """ """
         class _TestObject:
+            """ """
             def __init__(self, val):
                 self.val = val
 
             @property
             def recursive_attr(self):
+                """ """
                 return _TestObject("recursive_attr")
 
             def __str__(self) -> str:
@@ -637,6 +935,17 @@
         assert '"foo"' == ujson.encode(_TestObject("foo"), default_handler=str)
 
         def my_handler(_):
+            """
+
+            Parameters
+            ----------
+            _ :
+                
+
+            Returns
+            -------
+
+            """
             return "foobar"
 
         assert '"foobar"' == ujson.encode(
@@ -644,12 +953,34 @@
         )
 
         def my_handler_raises(_):
+            """
+
+            Parameters
+            ----------
+            _ :
+                
+
+            Returns
+            -------
+
+            """
             raise TypeError("I raise for anything")
 
         with pytest.raises(TypeError, match="I raise for anything"):
             ujson.encode(_TestObject("foo"), default_handler=my_handler_raises)
 
         def my_int_handler(_):
+            """
+
+            Parameters
+            ----------
+            _ :
+                
+
+            Returns
+            -------
+
+            """
             return 42
 
         assert (
@@ -660,6 +991,17 @@
         )
 
         def my_obj_handler(_):
+            """
+
+            Parameters
+            ----------
+            _ :
+                
+
+            Returns
+            -------
+
+            """
             return datetime.datetime(2013, 2, 3)
 
         assert ujson.decode(
@@ -675,12 +1017,25 @@
 
 
 class TestNumpyJSONTests:
+    """ """
     @pytest.mark.parametrize("bool_input", [True, False])
     def test_bool(self, bool_input):
+        """
+
+        Parameters
+        ----------
+        bool_input :
+            
+
+        Returns
+        -------
+
+        """
         b = bool(bool_input)
         assert ujson.decode(ujson.encode(b)) == b
 
     def test_bool_array(self):
+        """ """
         bool_array = np.array(
             [True, False, True, True, False, True, False, False], dtype=bool
         )
@@ -688,12 +1043,34 @@
         tm.assert_numpy_array_equal(bool_array, output)
 
     def test_int(self, any_int_dtype):
+        """
+
+        Parameters
+        ----------
+        any_int_dtype :
+            
+
+        Returns
+        -------
+
+        """
         klass = np.dtype(any_int_dtype).type
         num = klass(1)
 
         assert klass(ujson.decode(ujson.encode(num))) == num
 
     def test_int_array(self, any_int_dtype):
+        """
+
+        Parameters
+        ----------
+        any_int_dtype :
+            
+
+        Returns
+        -------
+
+        """
         arr = np.arange(100, dtype=int)
         arr_input = arr.astype(any_int_dtype)
 
@@ -703,6 +1080,17 @@
         tm.assert_numpy_array_equal(arr_input, arr_output)
 
     def test_int_max(self, any_int_dtype):
+        """
+
+        Parameters
+        ----------
+        any_int_dtype :
+            
+
+        Returns
+        -------
+
+        """
         if any_int_dtype in ("int64", "uint64") and compat.is_platform_32bit():
             pytest.skip("Cannot test 64-bit integer on 32-bit platform")
 
@@ -718,12 +1106,34 @@
         assert klass(ujson.decode(ujson.encode(num))) == num
 
     def test_float(self, float_dtype):
+        """
+
+        Parameters
+        ----------
+        float_dtype :
+            
+
+        Returns
+        -------
+
+        """
         klass = np.dtype(float_dtype).type
         num = klass(256.2013)
 
         assert klass(ujson.decode(ujson.encode(num))) == num
 
     def test_float_array(self, float_dtype):
+        """
+
+        Parameters
+        ----------
+        float_dtype :
+            
+
+        Returns
+        -------
+
+        """
         arr = np.arange(12.5, 185.72, 1.7322, dtype=float)
         float_input = arr.astype(float_dtype)
 
@@ -734,6 +1144,17 @@
         tm.assert_almost_equal(float_input, float_output)
 
     def test_float_max(self, float_dtype):
+        """
+
+        Parameters
+        ----------
+        float_dtype :
+            
+
+        Returns
+        -------
+
+        """
         klass = np.dtype(float_dtype).type
         num = klass(np.finfo(float_dtype).max / 10)
 
@@ -742,6 +1163,7 @@
         )
 
     def test_array_basic(self):
+        """ """
         arr = np.arange(96)
         arr = arr.reshape((2, 2, 2, 2, 3, 2))
 
@@ -750,6 +1172,17 @@
 
     @pytest.mark.parametrize("shape", [(10, 10), (5, 5, 4), (100, 1)])
     def test_array_reshaped(self, shape):
+        """
+
+        Parameters
+        ----------
+        shape :
+            
+
+        Returns
+        -------
+
+        """
         arr = np.arange(100)
         arr = arr.reshape(shape)
 
@@ -757,6 +1190,7 @@
         tm.assert_numpy_array_equal(ujson.decode(ujson.encode(arr), numpy=True), arr)
 
     def test_array_list(self):
+        """ """
         arr_list = [
             "a",
             list(),
@@ -773,6 +1207,7 @@
         tm.assert_numpy_array_equal(result, arr)
 
     def test_array_float(self):
+        """ """
         dtype = np.float32
 
         arr = np.arange(100.202, 200.202, 1, dtype=dtype)
@@ -785,6 +1220,7 @@
         tm.assert_almost_equal(arr, arr_out)
 
     def test_0d_array(self):
+        """ """
         # gh-18878
         msg = re.escape("array(1) (0d array) is not JSON serializable at the moment")
         with pytest.raises(TypeError, match=msg):
@@ -805,10 +1241,26 @@
         ],
     )
     def test_array_numpy_except(self, bad_input, exc_type, kwargs):
+        """
+
+        Parameters
+        ----------
+        bad_input :
+            
+        exc_type :
+            
+        kwargs :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(exc_type):
             ujson.decode(ujson.dumps(bad_input), numpy=True, **kwargs)
 
     def test_array_numpy_labelled(self):
+        """ """
         labelled_input = {"a": []}
         output = ujson.loads(ujson.dumps(labelled_input), numpy=True, labelled=True)
         assert (np.empty((1, 0)) == output[0]).all()
@@ -842,7 +1294,21 @@
 
 
 class TestPandasJSONTests:
+    """ """
     def test_dataframe(self, orient, numpy):
+        """
+
+        Parameters
+        ----------
+        orient :
+            
+        numpy :
+            
+
+        Returns
+        -------
+
+        """
         if orient == "records" and numpy:
             pytest.skip("Not idiomatic pandas")
 
@@ -881,6 +1347,17 @@
         tm.assert_frame_equal(output, df)
 
     def test_dataframe_nested(self, orient):
+        """
+
+        Parameters
+        ----------
+        orient :
+            
+
+        Returns
+        -------
+
+        """
         df = DataFrame(
             [[1, 2, 3], [4, 5, 6]], index=["a", "b"], columns=["x", "y", "z"]
         )
@@ -895,6 +1372,17 @@
         assert ujson.decode(ujson.encode(nested, **kwargs)) == exp
 
     def test_dataframe_numpy_labelled(self, orient):
+        """
+
+        Parameters
+        ----------
+        orient :
+            
+
+        Returns
+        -------
+
+        """
         if orient in ("split", "values"):
             pytest.skip("Incompatible with labelled=True")
 
@@ -918,6 +1406,19 @@
         tm.assert_frame_equal(output, df)
 
     def test_series(self, orient, numpy):
+        """
+
+        Parameters
+        ----------
+        orient :
+            
+        numpy :
+            
+
+        Returns
+        -------
+
+        """
         dtype = get_int32_compat_dtype(numpy, orient)
         s = Series(
             [10, 20, 30, 40, 50, 60],
@@ -951,6 +1452,17 @@
         tm.assert_series_equal(output, s)
 
     def test_series_nested(self, orient):
+        """
+
+        Parameters
+        ----------
+        orient :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(
             [10, 20, 30, 40, 50, 60], name="series", index=[6, 7, 8, 9, 10, 15]
         ).sort_values()
@@ -964,6 +1476,7 @@
         assert ujson.decode(ujson.encode(nested, **kwargs)) == exp
 
     def test_index(self):
+        """ """
         i = Index([23, 45, 18, 98, 43, 11], name="index")
 
         # Column indexed.
@@ -1010,6 +1523,7 @@
         tm.assert_index_equal(i, output)
 
     def test_datetime_index(self):
+        """ """
         date_unit = "ns"
 
         # freq doesnt round-trip
@@ -1036,32 +1550,79 @@
         ],
     )
     def test_decode_invalid_array(self, invalid_arr):
+        """
+
+        Parameters
+        ----------
+        invalid_arr :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(invalid_arr)
 
     @pytest.mark.parametrize("arr", [[], [31337]])
     def test_decode_array(self, arr):
+        """
+
+        Parameters
+        ----------
+        arr :
+            
+
+        Returns
+        -------
+
+        """
         assert arr == ujson.decode(str(arr))
 
     @pytest.mark.parametrize("extreme_num", [9223372036854775807, -9223372036854775808])
     def test_decode_extreme_numbers(self, extreme_num):
+        """
+
+        Parameters
+        ----------
+        extreme_num :
+            
+
+        Returns
+        -------
+
+        """
         assert extreme_num == ujson.decode(str(extreme_num))
 
     @pytest.mark.parametrize(
         "too_extreme_num", ["9223372036854775808", "-90223372036854775809"]
     )
     def test_decode_too_extreme_numbers(self, too_extreme_num):
+        """
+
+        Parameters
+        ----------
+        too_extreme_num :
+            
+
+        Returns
+        -------
+
+        """
         with pytest.raises(ValueError):
             ujson.decode(too_extreme_num)
 
     def test_decode_with_trailing_whitespaces(self):
+        """ """
         assert {} == ujson.decode("{}\n\t ")
 
     def test_decode_with_trailing_non_whitespaces(self):
+        """ """
         with pytest.raises(ValueError):
             ujson.decode("{}\n\t a")
 
     def test_decode_array_with_big_int(self):
+        """ """
         with pytest.raises(ValueError):
             ujson.loads("[18446098363113800555]")
 
@@ -1081,10 +1642,24 @@
     )
     @pytest.mark.parametrize("sign", [-1, 1])
     def test_decode_floating_point(self, sign, float_number):
+        """
+
+        Parameters
+        ----------
+        sign :
+            
+        float_number :
+            
+
+        Returns
+        -------
+
+        """
         float_number *= sign
         tm.assert_almost_equal(float_number, ujson.loads(str(float_number)), rtol=1e-15)
 
     def test_encode_big_set(self):
+        """ """
         s = set()
 
         for x in range(0, 100000):
@@ -1094,9 +1669,11 @@
         ujson.encode(s)
 
     def test_encode_empty_set(self):
+        """ """
         assert "[]" == ujson.encode(set())
 
     def test_encode_set(self):
+        """ """
         s = {1, 2, 3, 4, 5, 6, 7, 8, 9}
         enc = ujson.encode(s)
         dec = ujson.decode(enc)
@@ -1119,6 +1696,17 @@
         ],
     )
     def test_encode_timedelta_iso(self, td):
+        """
+
+        Parameters
+        ----------
+        td :
+            
+
+        Returns
+        -------
+
+        """
         # GH 28256
         result = ujson.encode(td, iso_dates=True)
         expected = f'"{td.isoformat()}"'
