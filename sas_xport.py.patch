# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/io/sas/sas_xport.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/io/sas/sas_xport.py
@@ -134,7 +134,17 @@
 
 
 def _parse_date(datestr: str) -> datetime:
-    """ Given a date in xport format, return Python date. """
+    """Given a date in xport format, return Python date.
+
+    Parameters
+    ----------
+    datestr: str :
+        
+
+    Returns
+    -------
+
+    """
     try:
         # e.g. "16FEB11:10:07:55"
         return datetime.strptime(datestr, "%d%b%y:%H:%M:%S")
@@ -144,16 +154,20 @@
 
 def _split_line(s: str, parts):
     """
+
     Parameters
     ----------
-    s: str
+    s : str
         Fixed-length string to split
-    parts: list of (name, length) pairs
+    parts : list of (name, length) pairs
         Used to break up string, name '_' will be filtered from output.
+    s: str :
+        
 
     Returns
     -------
-    Dict of name:contents of string at given location.
+
+    
     """
     out = {}
     start = 0
@@ -165,6 +179,19 @@
 
 
 def _handle_truncated_float_vec(vec, nbytes):
+    """
+
+    Parameters
+    ----------
+    vec :
+        
+    nbytes :
+        
+
+    Returns
+    -------
+
+    """
     # This feature is not well documented, but some SAS XPORT files
     # have 2-7 byte "truncated" floats.  To read these truncated
     # floats, pad them with zeros on the right to make 8 byte floats.
@@ -184,9 +211,17 @@
 
 
 def _parse_float_vec(vec):
-    """
-    Parse a vector of float values representing IBM 8 byte floats into
+    """Parse a vector of float values representing IBM 8 byte floats into
     native 8 byte floats.
+
+    Parameters
+    ----------
+    vec :
+        
+
+    Returns
+    -------
+
     """
     dtype = np.dtype(">u4,>u4")
     vec1 = vec.view(dtype=dtype)
@@ -241,6 +276,7 @@
 
 
 class XportReader(ReaderBase, abc.Iterator):
+    """ """
     __doc__ = _xport_reader_doc
 
     def __init__(
@@ -270,12 +306,15 @@
         self._read_header()
 
     def close(self):
+        """ """
         self.filepath_or_buffer.close()
 
     def _get_row(self):
+        """ """
         return self.filepath_or_buffer.read(80).decode()
 
     def _read_header(self):
+        """ """
         self.filepath_or_buffer.seek(0)
 
         # read file header
@@ -388,13 +427,19 @@
         return self.read(nrows=self._chunksize or 1)
 
     def _record_count(self) -> int:
-        """
-        Get number of records in file.
-
+        """Get number of records in file.
+        
         This is maybe suboptimal because we have to seek to the end of
         the file.
-
+        
         Side effect: returns file position to record_start.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.filepath_or_buffer.seek(0, 2)
         total_records_length = self.filepath_or_buffer.tell() - self.record_start
@@ -423,23 +468,34 @@
         return (total_records_length - tail_pad) // self.record_length
 
     def get_chunk(self, size=None):
-        """
-        Reads lines from Xport file and returns as dataframe
+        """Reads lines from Xport file and returns as dataframe
 
         Parameters
         ----------
         size : int, defaults to None
-            Number of lines to read.  If None, reads whole file.
+            Number of lines to read.  If None, reads whole file. (Default value = None)
 
         Returns
         -------
-        DataFrame
+
+        
         """
         if size is None:
             size = self._chunksize
         return self.read(nrows=size)
 
     def _missing_double(self, vec):
+        """
+
+        Parameters
+        ----------
+        vec :
+            
+
+        Returns
+        -------
+
+        """
         v = vec.view(dtype="u1,u1,u2,u4")
         miss = (v["f1"] == 0) & (v["f2"] == 0) & (v["f3"] == 0)
         miss1 = (
@@ -452,6 +508,17 @@
 
     @Appender(_read_method_doc)
     def read(self, nrows=None):
+        """
+
+        Parameters
+        ----------
+        nrows :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if nrows is None:
             nrows = self.nobs
