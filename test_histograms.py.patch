# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/tests/test_histograms.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/tests/test_histograms.py
@@ -10,14 +10,18 @@
 
 
 class TestHistogram:
+    """ """
 
     def setup(self):
+        """ """
         pass
 
     def teardown(self):
+        """ """
         pass
 
     def test_simple(self):
+        """ """
         n = 100
         v = np.random.rand(n)
         (a, b) = histogram(v)
@@ -29,6 +33,7 @@
         assert_array_equal(a, 10)
 
     def test_one_bin(self):
+        """ """
         # Ticket 632
         hist, edges = histogram([1, 2, 3, 4], [1, 2])
         assert_array_equal(hist, [2, ])
@@ -39,6 +44,7 @@
         assert_allclose(e, np.array([1., 2.]))
 
     def test_normed(self):
+        """ """
         sup = suppress_warnings()
         with sup:
             rec = sup.record(np.VisibleDeprecationWarning, '.*normed.*')
@@ -63,6 +69,7 @@
             assert_equal(len(rec), 1)
 
     def test_density(self):
+        """ """
         # Check that the integral of the density equals 1.
         n = 100
         v = np.random.rand(n)
@@ -95,6 +102,7 @@
         assert_equal(counts, [.25, 0])
 
     def test_outliers(self):
+        """ """
         # Check that outliers are not tallied
         a = np.arange(10) + .5
 
@@ -119,6 +127,7 @@
         assert_equal(h, w[1:-1])
 
     def test_arr_weights_mismatch(self):
+        """ """
         a = np.arange(10) + .5
         w = np.arange(11) + .5
         with assert_raises_regex(ValueError, "same shape as"):
@@ -126,6 +135,7 @@
 
 
     def test_type(self):
+        """ """
         # Check the type of the returned histogram
         a = np.arange(10) + .5
         h, b = histogram(a)
@@ -141,6 +151,7 @@
         assert_(np.issubdtype(h.dtype, np.floating))
 
     def test_f32_rounding(self):
+        """ """
         # gh-4799, check that the rounding of the edges works with float32
         x = np.array([276.318359, -69.593948, 21.329449], dtype=np.float32)
         y = np.array([5005.689453, 4481.327637, 6010.369629], dtype=np.float32)
@@ -148,6 +159,7 @@
         assert_equal(counts_hist.sum(), 3.)
 
     def test_bool_conversion(self):
+        """ """
         # gh-12107
         # Reference integer histogram
         a = np.array([1, 1, 0], dtype=np.uint8)
@@ -165,6 +177,7 @@
             assert_array_equal(edges, int_edges)
 
     def test_weights(self):
+        """ """
         v = np.random.rand(100)
         w = np.ones(100) * 5
         a, b = histogram(v)
@@ -194,6 +207,7 @@
         assert_almost_equal(a, [.2, .1, .1, .075])
 
     def test_exotic_weights(self):
+        """ """
 
         # Test the use of weights that are not integer or floats, but e.g.
         # complex numbers or object types.
@@ -224,6 +238,7 @@
         assert_array_almost_equal(wa, [Decimal(1), Decimal(5)])
 
     def test_no_side_effects(self):
+        """ """
         # This is a regression test that ensures that values passed to
         # ``histogram`` are unchanged.
         values = np.array([1.3, 2.5, 2.3])
@@ -231,17 +246,20 @@
         assert_array_almost_equal(values, [1.3, 2.5, 2.3])
 
     def test_empty(self):
+        """ """
         a, b = histogram([], bins=([0, 1]))
         assert_array_equal(a, np.array([0]))
         assert_array_equal(b, np.array([0, 1]))
 
     def test_error_binnum_type (self):
+        """ """
         # Tests if right Error is raised if bins argument is float
         vals = np.linspace(0.0, 1.0, num=100)
         histogram(vals, 5)
         assert_raises(TypeError, histogram, vals, 2.4)
 
     def test_finite_range(self):
+        """ """
         # Normal ranges should be fine
         vals = np.linspace(0.0, 1.0, num=100)
         histogram(vals, range=[0.25,0.75])
@@ -249,12 +267,14 @@
         assert_raises(ValueError, histogram, vals, range=[0.25,np.inf])
 
     def test_invalid_range(self):
+        """ """
         # start of range must be < end of range
         vals = np.linspace(0.0, 1.0, num=100)
         with assert_raises_regex(ValueError, "max must be larger than"):
             np.histogram(vals, range=[0.1, 0.01])
 
     def test_bin_edge_cases(self):
+        """ """
         # Ensure that floating-point computations correctly place edge cases.
         arr = np.array([337, 404, 739, 806, 1007, 1811, 2012])
         hist, edges = np.histogram(arr, bins=8296, range=(2, 2280))
@@ -266,11 +286,13 @@
             assert_(x < right)
 
     def test_last_bin_inclusive_range(self):
+        """ """
         arr = np.array([0.,  0.,  0.,  1.,  2.,  3.,  3.,  4.,  5.])
         hist, edges = np.histogram(arr, bins=30, range=(-0.5, 5))
         assert_equal(hist[-1], 1)
 
     def test_bin_array_dims(self):
+        """ """
         # gracefully handle bins object > 1 dimension
         vals = np.linspace(0.0, 1.0, num=100)
         bins = np.array([[0, 0.5], [0.6, 1.0]])
@@ -278,6 +300,7 @@
             np.histogram(vals, bins=bins)
 
     def test_unsigned_monotonicity_check(self):
+        """ """
         # Ensures ValueError is raised if bins not increasing monotonically
         # when bins contain unsigned values (see #9222)
         arr = np.array([2])
@@ -286,6 +309,7 @@
             hist, edges = np.histogram(arr, bins=bins)
 
     def test_object_array_of_0d(self):
+        """ """
         # gh-7864
         assert_raises(ValueError,
             histogram, [np.array(0.4) for i in range(10)] + [-np.inf])
@@ -297,6 +321,7 @@
         np.histogram([np.array(0.5) for i in range(10)] + [.5])
 
     def test_some_nan_values(self):
+        """ """
         # gh-7503
         one_nan = np.array([0, 1, np.nan])
         all_nan = np.array([np.nan, np.nan])
@@ -322,6 +347,7 @@
             assert_equal(h.sum(), 0)  # nan is not counted
 
     def test_datetime(self):
+        """ """
         begin = np.datetime64('2000-01-01', 'D')
         offsets = np.array([0, 0, 1, 1, 2, 3, 5, 10, 20])
         bins = np.array([0, 2, 7, 20])
@@ -347,6 +373,17 @@
         assert_equal(t_edge.dtype, td)
 
     def do_signed_overflow_bounds(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         exponent = 8 * np.dtype(dtype).itemsize - 1
         arr = np.array([-2**exponent + 4, 2**exponent - 4], dtype=dtype)
         hist, e = histogram(arr, bins=2)
@@ -354,6 +391,7 @@
         assert_equal(hist, [1, 1])
 
     def test_signed_overflow_bounds(self):
+        """ """
         self.do_signed_overflow_bounds(np.byte)
         self.do_signed_overflow_bounds(np.short)
         self.do_signed_overflow_bounds(np.intc)
@@ -361,6 +399,19 @@
         self.do_signed_overflow_bounds(np.longlong)
 
     def do_precision_lower_bound(self, float_small, float_large):
+        """
+
+        Parameters
+        ----------
+        float_small :
+            
+        float_large :
+            
+
+        Returns
+        -------
+
+        """
         eps = np.finfo(float_large).eps
 
         arr = np.array([1.0], float_small)
@@ -378,6 +429,19 @@
         assert_equal(x_loc.dtype, float_small)
 
     def do_precision_upper_bound(self, float_small, float_large):
+        """
+
+        Parameters
+        ----------
+        float_small :
+            
+        float_large :
+            
+
+        Returns
+        -------
+
+        """
         eps = np.finfo(float_large).eps
 
         arr = np.array([1.0], float_small)
@@ -395,10 +459,24 @@
         assert_equal(x_loc.dtype, float_small)
 
     def do_precision(self, float_small, float_large):
+        """
+
+        Parameters
+        ----------
+        float_small :
+            
+        float_large :
+            
+
+        Returns
+        -------
+
+        """
         self.do_precision_lower_bound(float_small, float_large)
         self.do_precision_upper_bound(float_small, float_large)
 
     def test_precision(self):
+        """ """
         # not looping results in a useful stack trace upon failure
         self.do_precision(np.half, np.single)
         self.do_precision(np.half, np.double)
@@ -408,6 +486,7 @@
         self.do_precision(np.double, np.longdouble)
 
     def test_histogram_bin_edges(self):
+        """ """
         hist, e = histogram([1, 2, 3, 4], [1, 2])
         edges = histogram_bin_edges([1, 2, 3, 4], [1, 2])
         assert_array_equal(edges, e)
@@ -423,12 +502,19 @@
 
 
 class TestHistogramOptimBinNums:
+    """Provide test coverage when using provided estimators for optimal number of
+    bins
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
-    Provide test coverage when using provided estimators for optimal number of
-    bins
-    """
 
     def test_empty(self):
+        """ """
         estimator_list = ['fd', 'scott', 'rice', 'sturges',
                           'doane', 'sqrt', 'auto', 'stone']
         # check it can deal with empty data
@@ -438,10 +524,16 @@
             assert_array_equal(b, np.array([0, 1]))
 
     def test_simple(self):
-        """
-        Straightforward testing with a mixture of linspace data (for
+        """Straightforward testing with a mixture of linspace data (for
         consistency). All test values have been precomputed and the values
         shouldn't change
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # Some basic sanity checking, with some fixed data.
         # Checking for the correct number of bins
@@ -464,10 +556,16 @@
                              "with datasize of {1}".format(estimator, testlen))
 
     def test_small(self):
-        """
-        Smaller datasets have the potential to cause issues with the data
+        """Smaller datasets have the potential to cause issues with the data
         adaptive methods, especially the FD method. All bin numbers have been
         precalculated.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         small_dat = {1: {'fd': 1, 'scott': 1, 'rice': 1, 'sturges': 1,
                          'doane': 1, 'sqrt': 1, 'stone': 1},
@@ -484,17 +582,21 @@
                              "with datasize of {1}".format(estimator, testlen))
 
     def test_incorrect_methods(self):
-        """
-        Check a Value Error is thrown when an unknown string is passed in
-        """
+        """Check a Value Error is thrown when an unknown string is passed in"""
         check_list = ['mad', 'freeman', 'histograms', 'IQR']
         for estimator in check_list:
             assert_raises(ValueError, histogram, [1, 2, 3], estimator)
 
     def test_novariance(self):
-        """
-        Check that methods handle no variance in data
+        """Check that methods handle no variance in data
         Primarily for Scott and FD as the SD and IQR are both 0 in this case
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         novar_dataset = np.ones(100)
         novar_resultdict = {'fd': 1, 'scott': 1, 'rice': 1, 'sturges': 1,
@@ -506,9 +608,15 @@
                          "No Variance test".format(estimator))
 
     def test_limited_variance(self):
-        """
-        Check when IQR is 0, but variance exists, we return the sturges value
+        """Check when IQR is 0, but variance exists, we return the sturges value
         and not the fd value.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         lim_var_data = np.ones(1000)
         lim_var_data[:3] = 0
@@ -524,15 +632,21 @@
         assert_equal(edges_sturges, np.linspace(0, 100, 12))
 
     def test_outlier(self):
-        """
-        Check the FD, Scott and Doane with outliers.
-
+        """Check the FD, Scott and Doane with outliers.
+        
         The FD estimates a smaller binwidth since it's less affected by
         outliers. Since the range is so (artificially) large, this means more
         bins, most of which will be empty, but the data of interest usually is
         unaffected. The Scott estimator is more affected and returns fewer bins,
         despite most of the variance being in one area of the data. The Doane
         estimator lies somewhere between the other two.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         xcenter = np.linspace(-10, 10, 50)
         outlier_dataset = np.hstack((np.linspace(-110, -100, 5), xcenter))
@@ -547,6 +661,19 @@
         """Verify that Scott's rule and Stone's rule converges for normally distributed data"""
 
         def nbins_ratio(seed, size):
+            """
+
+            Parameters
+            ----------
+            seed :
+                
+            size :
+                
+
+            Returns
+            -------
+
+            """
             rng = np.random.RandomState(seed)
             x = rng.normal(loc=0, scale=2, size=size)
             a, b = len(np.histogram(x, 'stone')[0]), len(np.histogram(x, 'scott')[0])
@@ -560,11 +687,17 @@
         assert_almost_equal(avg, [0.15, 0.09, 0.08, 0.03], decimal=2)
 
     def test_simple_range(self):
-        """
-        Straightforward testing with a mixture of linspace data (for
+        """Straightforward testing with a mixture of linspace data (for
         consistency). Adding in a 3rd mixture that will then be
         completely ignored. All test values have been precomputed and
         the shouldn't change.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # some basic sanity checking, with some fixed data.
         # Checking for the correct number of bins
@@ -593,6 +726,17 @@
     @pytest.mark.parametrize("bins", ['auto', 'fd', 'doane', 'scott',
                                       'stone', 'rice', 'sturges'])
     def test_signed_integer_data(self, bins):
+        """
+
+        Parameters
+        ----------
+        bins :
+            
+
+        Returns
+        -------
+
+        """
         # Regression test for gh-14379.
         a = np.array([-2, 0, 127], dtype=np.int8)
         hist, edges = np.histogram(a, bins=bins)
@@ -601,9 +745,7 @@
         assert_array_equal(edges, edges32)
 
     def test_simple_weighted(self):
-        """
-        Check that weighted data raises a TypeError
-        """
+        """Check that weighted data raises a TypeError"""
         estimator_list = ['fd', 'scott', 'rice', 'sturges', 'auto']
         for estimator in estimator_list:
             assert_raises(TypeError, histogram, [1, 2, 3],
@@ -611,8 +753,10 @@
 
 
 class TestHistogramdd:
+    """ """
 
     def test_simple(self):
+        """ """
         x = np.array([[-.5, .5, 1.5], [-.5, 1.5, 2.5], [-.5, 2.5, .5],
                       [.5,  .5, 1.5], [.5,  1.5, 2.5], [.5,  2.5, 2.5]])
         H, edges = histogramdd(x, (2, 3, 3),
@@ -650,6 +794,7 @@
         assert_array_equal(H, Z)
 
     def test_shape_3d(self):
+        """ """
         # All possible permutations for bins of different lengths in 3D.
         bins = ((5, 4, 6), (6, 4, 5), (5, 6, 4), (4, 6, 5), (6, 5, 4),
                 (4, 5, 6))
@@ -659,6 +804,7 @@
             assert_(H.shape == b)
 
     def test_shape_4d(self):
+        """ """
         # All possible permutations for bins of different lengths in 4D.
         bins = ((7, 4, 5, 6), (4, 5, 7, 6), (5, 6, 4, 7), (7, 6, 5, 4),
                 (5, 7, 6, 4), (4, 6, 7, 5), (6, 5, 7, 4), (7, 5, 4, 6),
@@ -673,6 +819,7 @@
             assert_(H.shape == b)
 
     def test_weights(self):
+        """ """
         v = np.random.rand(100, 2)
         hist, edges = histogramdd(v)
         n_hist, edges = histogramdd(v, density=True)
@@ -684,17 +831,20 @@
         assert_array_equal(w_hist, 2 * hist)
 
     def test_identical_samples(self):
+        """ """
         x = np.zeros((10, 2), int)
         hist, edges = histogramdd(x, bins=2)
         assert_array_equal(edges[0], np.array([-0.5, 0., 0.5]))
 
     def test_empty(self):
+        """ """
         a, b = histogramdd([[], []], bins=([0, 1], [0, 1]))
         assert_array_max_ulp(a, np.array([[0.]]))
         a, b = np.histogramdd([[], [], []], bins=2)
         assert_array_max_ulp(a, np.zeros((2, 2, 2)))
 
     def test_bins_errors(self):
+        """ """
         # There are two ways to specify bins. Check for the right errors
         # when mixing those.
         x = np.arange(8).reshape(2, 4)
@@ -705,6 +855,7 @@
         assert_(np.histogramdd(x, bins=[1, 1, 1, [1, 2, 3, 4]]))
 
     def test_inf_edges(self):
+        """ """
         # Test using +/-inf bin edges works. See #1788.
         with np.errstate(invalid='ignore'):
             x = np.arange(6).reshape(3, 2)
@@ -717,6 +868,7 @@
             assert_allclose(h, expected)
 
     def test_rightmost_binedge(self):
+        """ """
         # Test event very close to rightmost binedge. See Github issue #4266
         x = [0.9999999995]
         bins = [[0., 0.5, 1.0]]
@@ -740,6 +892,7 @@
         assert_(hist[1] == 0.0)
 
     def test_finite_range(self):
+        """ """
         vals = np.random.random((100, 3))
         histogramdd(vals, range=[[0.0, 1.0], [0.25, 0.75], [0.25, 0.5]])
         assert_raises(ValueError, histogramdd, vals,
@@ -748,7 +901,7 @@
                       range=[[0.0, 1.0], [np.nan, 0.75], [0.25, 0.5]])
 
     def test_equal_edges(self):
-        """ Test that adjacent entries in an edge array can be equal """
+        """Test that adjacent entries in an edge array can be equal"""
         x = np.array([0, 1, 2])
         y = np.array([0, 1, 2])
         x_edges = np.array([0, 2, 2])
@@ -762,7 +915,7 @@
         assert_equal(hist, hist_expected)
 
     def test_edge_dtype(self):
-        """ Test that if an edge array is input, its type is preserved """
+        """Test that if an edge array is input, its type is preserved"""
         x = np.array([0, 10, 20])
         y = x / 10
         x_edges = np.array([0, 5, 15, 20])
@@ -773,6 +926,7 @@
         assert_equal(edges[1].dtype, y_edges.dtype)
 
     def test_large_integers(self):
+        """ """
         big = 2**60  # Too large to represent with a full precision float
 
         x = np.array([0], np.int64)
@@ -785,6 +939,7 @@
         assert_equal(hist[0, 0], 1)
 
     def test_density_non_uniform_2d(self):
+        """ """
         # Defines the following grid:
         #
         #    0 2     8
@@ -812,6 +967,7 @@
         assert_equal(hist, 1 / (8*8))
 
     def test_density_non_uniform_1d(self):
+        """ """
         # compare to histogram to show the results are the same
         v = np.arange(10)
         bins = np.array([0, 1, 3, 6, 10])
@@ -821,6 +977,7 @@
         assert_equal(edges, edges_dd[0])
 
     def test_density_via_normed(self):
+        """ """
         # normed should simply alias to density argument
         v = np.arange(10)
         bins = np.array([0, 1, 3, 6, 10])
@@ -830,6 +987,7 @@
         assert_equal(edges, edges_dd[0])
 
     def test_density_normed_redundancy(self):
+        """ """
         v = np.arange(10)
         bins = np.array([0, 1, 3, 6, 10])
         with assert_raises_regex(TypeError, "Cannot specify both"):
