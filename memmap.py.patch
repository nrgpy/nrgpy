# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/memmap.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/memmap.py
@@ -22,23 +22,22 @@
 @set_module('numpy')
 class memmap(ndarray):
     """Create a memory-map to an array stored in a *binary* file on disk.
-
+    
     Memory-mapped files are used for accessing small segments of large files
     on disk, without reading the entire file into memory.  NumPy's
     memmap's are array-like objects.  This differs from Python's ``mmap``
     module, which uses file-like objects.
-
+    
     This subclass of ndarray has some unpleasant interactions with
     some operations, because it doesn't quite fit properly as a subclass.
     An alternative to using this subclass is to create the ``mmap``
     object yourself, then create an ndarray with ndarray.__new__ directly,
     passing the object created in its 'buffer=' parameter.
-
+    
     This class may at some point be turned into a factory function
     which returns a view into an mmap buffer.
-
+    
     Delete the memmap instance to close the memmap file.
-
 
     Parameters
     ----------
@@ -49,7 +48,6 @@
         Default is `uint8`.
     mode : {'r+', 'r', 'w+', 'c'}, optional
         The file is opened in this mode:
-
         +------+-------------------------------------------------------------+
         | 'r'  | Open existing file for reading only.                        |
         +------+-------------------------------------------------------------+
@@ -61,7 +59,6 @@
         |      | changes are not saved to disk.  The file on disk is         |
         |      | read-only.                                                  |
         +------+-------------------------------------------------------------+
-
         Default is 'r+'.
     offset : int, optional
         In the file, array data starts at this offset. Since `offset` is
@@ -83,6 +80,9 @@
         Fortran-style.  This only has an effect if the shape is
         greater than 1-D.  The default order is 'C'.
 
+    Returns
+    -------
+
     Attributes
     ----------
     filename : str or pathlib.Path instance
@@ -91,19 +91,16 @@
         Offset position in the file.
     mode : str
         File mode.
-
     Methods
     -------
     flush
         Flush any changes in memory to file on disk.
         When you delete a memmap object, flush is called first to write
         changes to disk before removing the object.
-
-
+    
     See also
     --------
     lib.format.open_memmap : Create or load a memory-mapped ``.npy`` file.
-
     Notes
     -----
     The memmap object can be used anywhere an ndarray is accepted.
@@ -111,70 +108,83 @@
     ``True``.
     
     Memory-mapped files cannot be larger than 2GB on 32-bit systems.
-
+    
     When a memmap causes a file to be created or extended beyond its
     current size in the filesystem, the contents of the new part are
     unspecified. On systems with POSIX filesystem semantics, the extended
     part will be filled with zero bytes.
-
     Examples
     --------
+    
+    This example uses a temporary file so that doctest doesn't write
+    files to your directory. You would use a 'normal' filename.
+    
+    
+    Create a memmap with dtype and shape that matches our data:
+    
+    
+    Write data to memmap array:
+    
+    
+    
+    Deletion flushes memory changes to disk before removing the object:
+    
+    
+    Load the memmap and verify data was stored:
+    
+    
+    Read-only memmap:
+    
+    
+    Copy-on-write memmap:
+    
+    
+    It's possible to assign to copy-on-write array, but values are only
+    written into the memory copy of the array, and not written to disk:
+    
+    
+    File on disk is unchanged:
+    
+    
+    Offset into a memmap:
     >>> data = np.arange(12, dtype='float32')
     >>> data.resize((3,4))
-
-    This example uses a temporary file so that doctest doesn't write
-    files to your directory. You would use a 'normal' filename.
-
+    
     >>> from tempfile import mkdtemp
     >>> import os.path as path
     >>> filename = path.join(mkdtemp(), 'newfile.dat')
-
-    Create a memmap with dtype and shape that matches our data:
-
+    
     >>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))
     >>> fp
     memmap([[0., 0., 0., 0.],
             [0., 0., 0., 0.],
             [0., 0., 0., 0.]], dtype=float32)
-
-    Write data to memmap array:
-
+    
     >>> fp[:] = data[:]
     >>> fp
     memmap([[  0.,   1.,   2.,   3.],
             [  4.,   5.,   6.,   7.],
             [  8.,   9.,  10.,  11.]], dtype=float32)
-
+    
     >>> fp.filename == path.abspath(filename)
     True
-
-    Deletion flushes memory changes to disk before removing the object:
-
+    
     >>> del fp
-
-    Load the memmap and verify data was stored:
-
+    
     >>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
     >>> newfp
     memmap([[  0.,   1.,   2.,   3.],
             [  4.,   5.,   6.,   7.],
             [  8.,   9.,  10.,  11.]], dtype=float32)
-
-    Read-only memmap:
-
+    
     >>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))
     >>> fpr.flags.writeable
     False
-
-    Copy-on-write memmap:
-
+    
     >>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))
     >>> fpc.flags.writeable
     True
-
-    It's possible to assign to copy-on-write array, but values are only
-    written into the memory copy of the array, and not written to disk:
-
+    
     >>> fpc
     memmap([[  0.,   1.,   2.,   3.],
             [  4.,   5.,   6.,   7.],
@@ -184,20 +194,15 @@
     memmap([[  0.,   0.,   0.,   0.],
             [  4.,   5.,   6.,   7.],
             [  8.,   9.,  10.,  11.]], dtype=float32)
-
-    File on disk is unchanged:
-
+    
     >>> fpr
     memmap([[  0.,   1.,   2.,   3.],
             [  4.,   5.,   6.,   7.],
             [  8.,   9.,  10.,  11.]], dtype=float32)
-
-    Offset into a memmap:
-
+    
     >>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)
     >>> fpo
     memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)
-
     """
 
     __array_priority__ = -100.0
@@ -295,19 +300,21 @@
             self.mode = None
 
     def flush(self):
-        """
-        Write any changes in the array to the file on disk.
-
+        """Write any changes in the array to the file on disk.
+        
         For further information, see `memmap`.
 
         Parameters
         ----------
-        None
+        None :
+            
+
+        Returns
+        -------
 
         See Also
         --------
         memmap
-
         """
         if self.base is not None and hasattr(self.base, 'flush'):
             self.base.flush()
