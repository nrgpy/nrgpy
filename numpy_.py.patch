# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/arrays/numpy_.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/arrays/numpy_.py
@@ -27,11 +27,10 @@
 
 
 class PandasDtype(ExtensionDtype):
-    """
-    A Pandas ExtensionDtype for NumPy dtypes.
-
+    """A Pandas ExtensionDtype for NumPy dtypes.
+    
     .. versionadded:: 0.24.0
-
+    
     This is mostly for internal compatibility, and is not especially
     useful on its own.
 
@@ -40,6 +39,9 @@
     dtype : object
         Object to be converted to a NumPy data type object.
 
+    Returns
+    -------
+
     See Also
     --------
     numpy.dtype
@@ -55,36 +57,43 @@
 
     @property
     def numpy_dtype(self) -> np.dtype:
-        """
-        The NumPy dtype this PandasDtype wraps.
-        """
+        """The NumPy dtype this PandasDtype wraps."""
         return self._dtype
 
     @property
     def name(self) -> str:
-        """
-        A bit-width name for this data-type.
-        """
+        """A bit-width name for this data-type."""
         return self._dtype.name
 
     @property
     def type(self) -> Type[np.generic]:
-        """
-        The type object used to instantiate a scalar of this NumPy data-type.
-        """
+        """The type object used to instantiate a scalar of this NumPy data-type."""
         return self._dtype.type
 
     @property
     def _is_numeric(self) -> bool:
+        """ """
         # exclude object, str, unicode, void.
         return self.kind in set("biufc")
 
     @property
     def _is_boolean(self) -> bool:
+        """ """
         return self.kind == "b"
 
     @classmethod
     def construct_from_string(cls, string: str) -> "PandasDtype":
+        """
+
+        Parameters
+        ----------
+        string: str :
+            
+
+        Returns
+        -------
+
+        """
         try:
             dtype = np.dtype(string)
         except TypeError as err:
@@ -97,38 +106,27 @@
 
     @classmethod
     def construct_array_type(cls) -> Type["PandasArray"]:
-        """
-        Return the array type associated with this dtype.
-
-        Returns
-        -------
-        type
-        """
+        """Return the array type associated with this dtype."""
         return PandasArray
 
     @property
     def kind(self) -> str:
-        """
-        A character code (one of 'biufcmMOSUV') identifying the general kind of data.
-        """
+        """A character code (one of 'biufcmMOSUV') identifying the general kind of data."""
         return self._dtype.kind
 
     @property
     def itemsize(self) -> int:
-        """
-        The element size of this data-type object.
-        """
+        """The element size of this data-type object."""
         return self._dtype.itemsize
 
 
 class PandasArray(
     NDArrayBackedExtensionArray, ExtensionOpsMixin, NDArrayOperatorsMixin
 ):
-    """
-    A pandas ExtensionArray for NumPy data.
-
+    """A pandas ExtensionArray for NumPy data.
+    
     .. versionadded:: 0.24.0
-
+    
     This is mostly for internal compatibility, and is not especially
     useful on its own.
 
@@ -139,10 +137,12 @@
     copy : bool, default False
         Whether to copy `values`.
 
+    Returns
+    -------
+
     Attributes
     ----------
     None
-
     Methods
     -------
     None
@@ -178,6 +178,21 @@
 
     @classmethod
     def _from_sequence(cls, scalars, dtype=None, copy: bool = False) -> "PandasArray":
+        """
+
+        Parameters
+        ----------
+        scalars :
+            
+        dtype :
+             (Default value = None)
+        copy: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         if isinstance(dtype, PandasDtype):
             dtype = dtype._dtype
 
@@ -188,13 +203,48 @@
 
     @classmethod
     def _from_factorized(cls, values, original) -> "PandasArray":
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        original :
+            
+
+        Returns
+        -------
+
+        """
         return cls(values)
 
     @classmethod
     def _concat_same_type(cls, to_concat) -> "PandasArray":
+        """
+
+        Parameters
+        ----------
+        to_concat :
+            
+
+        Returns
+        -------
+
+        """
         return cls(np.concatenate(to_concat))
 
     def _from_backing_data(self, arr: np.ndarray) -> "PandasArray":
+        """
+
+        Parameters
+        ----------
+        arr: np.ndarray :
+            
+
+        Returns
+        -------
+
+        """
         return type(self)(arr)
 
     # ------------------------------------------------------------------------
@@ -202,6 +252,7 @@
 
     @property
     def dtype(self) -> PandasDtype:
+        """ """
         return self._dtype
 
     # ------------------------------------------------------------------------
@@ -278,11 +329,27 @@
         self._ndarray[key] = value
 
     def isna(self) -> np.ndarray:
+        """ """
         return isna(self._ndarray)
 
     def fillna(
         self, value=None, method: Optional[str] = None, limit: Optional[int] = None,
     ) -> "PandasArray":
+        """
+
+        Parameters
+        ----------
+        value :
+             (Default value = None)
+        method: Optional[str] :
+             (Default value = None)
+        limit: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # TODO(_values_for_fillna): remove this
         value, method = validate_fillna_kwargs(value, method)
 
@@ -310,21 +377,49 @@
         return new_values
 
     def _validate_fill_value(self, fill_value):
+        """
+
+        Parameters
+        ----------
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         if fill_value is None:
             # Primarily for subclasses
             fill_value = self.dtype.na_value
         return fill_value
 
     def _values_for_argsort(self) -> np.ndarray:
+        """ """
         return self._ndarray
 
     def _values_for_factorize(self) -> Tuple[np.ndarray, int]:
+        """ """
         return self._ndarray, -1
 
     # ------------------------------------------------------------------------
     # Reductions
 
     def _reduce(self, name, skipna=True, **kwargs):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+        skipna :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         meth = getattr(self, name, None)
         if meth:
             return meth(skipna=skipna, **kwargs)
@@ -333,14 +428,61 @@
             raise TypeError(msg)
 
     def any(self, axis=None, out=None, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        out :
+             (Default value = None)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_any((), dict(out=out, keepdims=keepdims))
         return nanops.nanany(self._ndarray, axis=axis, skipna=skipna)
 
     def all(self, axis=None, out=None, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        out :
+             (Default value = None)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_all((), dict(out=out, keepdims=keepdims))
         return nanops.nanall(self._ndarray, axis=axis, skipna=skipna)
 
     def min(self, skipna: bool = True, **kwargs) -> Scalar:
+        """
+
+        Parameters
+        ----------
+        skipna: bool :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_min((), kwargs)
         result = masked_reductions.min(
             values=self.to_numpy(), mask=self.isna(), skipna=skipna
@@ -348,6 +490,19 @@
         return result
 
     def max(self, skipna: bool = True, **kwargs) -> Scalar:
+        """
+
+        Parameters
+        ----------
+        skipna: bool :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_max((), kwargs)
         result = masked_reductions.max(
             values=self.to_numpy(), mask=self.isna(), skipna=skipna
@@ -355,54 +510,227 @@
         return result
 
     def sum(self, axis=None, skipna=True, min_count=0, **kwargs) -> Scalar:
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        skipna :
+             (Default value = True)
+        min_count :
+             (Default value = 0)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_sum((), kwargs)
         return nanops.nansum(
             self._ndarray, axis=axis, skipna=skipna, min_count=min_count
         )
 
     def prod(self, axis=None, skipna=True, min_count=0, **kwargs) -> Scalar:
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        skipna :
+             (Default value = True)
+        min_count :
+             (Default value = 0)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         nv.validate_prod((), kwargs)
         return nanops.nanprod(
             self._ndarray, axis=axis, skipna=skipna, min_count=min_count
         )
 
     def mean(self, axis=None, dtype=None, out=None, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_mean((), dict(dtype=dtype, out=out, keepdims=keepdims))
         return nanops.nanmean(self._ndarray, axis=axis, skipna=skipna)
 
     def median(
         self, axis=None, out=None, overwrite_input=False, keepdims=False, skipna=True
     ):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        out :
+             (Default value = None)
+        overwrite_input :
+             (Default value = False)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_median(
             (), dict(out=out, overwrite_input=overwrite_input, keepdims=keepdims)
         )
         return nanops.nanmedian(self._ndarray, axis=axis, skipna=skipna)
 
     def std(self, axis=None, dtype=None, out=None, ddof=1, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        ddof :
+             (Default value = 1)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_stat_ddof_func(
             (), dict(dtype=dtype, out=out, keepdims=keepdims), fname="std"
         )
         return nanops.nanstd(self._ndarray, axis=axis, skipna=skipna, ddof=ddof)
 
     def var(self, axis=None, dtype=None, out=None, ddof=1, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        ddof :
+             (Default value = 1)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_stat_ddof_func(
             (), dict(dtype=dtype, out=out, keepdims=keepdims), fname="var"
         )
         return nanops.nanvar(self._ndarray, axis=axis, skipna=skipna, ddof=ddof)
 
     def sem(self, axis=None, dtype=None, out=None, ddof=1, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        ddof :
+             (Default value = 1)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_stat_ddof_func(
             (), dict(dtype=dtype, out=out, keepdims=keepdims), fname="sem"
         )
         return nanops.nansem(self._ndarray, axis=axis, skipna=skipna, ddof=ddof)
 
     def kurt(self, axis=None, dtype=None, out=None, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_stat_ddof_func(
             (), dict(dtype=dtype, out=out, keepdims=keepdims), fname="kurt"
         )
         return nanops.nankurt(self._ndarray, axis=axis, skipna=skipna)
 
     def skew(self, axis=None, dtype=None, out=None, keepdims=False, skipna=True):
+        """
+
+        Parameters
+        ----------
+        axis :
+             (Default value = None)
+        dtype :
+             (Default value = None)
+        out :
+             (Default value = None)
+        keepdims :
+             (Default value = False)
+        skipna :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         nv.validate_stat_ddof_func(
             (), dict(dtype=dtype, out=out, keepdims=keepdims), fname="skew"
         )
@@ -414,6 +742,21 @@
     def to_numpy(
         self, dtype=None, copy: bool = False, na_value=lib.no_default
     ) -> np.ndarray:
+        """
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+        copy: bool :
+             (Default value = False)
+        na_value :
+             (Default value = lib.no_default)
+
+        Returns
+        -------
+
+        """
         result = np.asarray(self._ndarray, dtype=dtype)
 
         if (copy or na_value is not lib.no_default) and result is self._ndarray:
@@ -426,6 +769,21 @@
 
     @doc(ExtensionArray.searchsorted)
     def searchsorted(self, value, side="left", sorter=None):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        side :
+             (Default value = "left")
+        sorter :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return searchsorted(self.to_numpy(), value, side=side, sorter=sorter)
 
     # ------------------------------------------------------------------------
@@ -436,7 +794,29 @@
 
     @classmethod
     def _create_arithmetic_method(cls, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         def arithmetic_method(self, other):
+            """
+
+            Parameters
+            ----------
+            other :
+                
+
+            Returns
+            -------
+
+            """
             if isinstance(other, (ABCIndexClass, ABCSeries)):
                 return NotImplemented
 
