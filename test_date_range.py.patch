# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/datetimes/test_date_range.py
@@ -23,12 +23,14 @@
 
 
 class TestTimestampEquivDateRange:
+    """ """
     # Older tests in TestTimeSeries constructed their `stamp` objects
     # using `date_range` instead of the `Timestamp` constructor.
     # TestTimestampEquivDateRange checks that these are equivalent in the
     # pertinent cases.
 
     def test_date_range_timestamp_equiv(self):
+        """ """
         rng = date_range("20090415", "20090519", tz="US/Eastern")
         stamp = rng[0]
 
@@ -36,6 +38,7 @@
         assert ts == stamp
 
     def test_date_range_timestamp_equiv_dateutil(self):
+        """ """
         rng = date_range("20090415", "20090519", tz="dateutil/US/Eastern")
         stamp = rng[0]
 
@@ -43,6 +46,7 @@
         assert ts == stamp
 
     def test_date_range_timestamp_equiv_explicit_pytz(self):
+        """ """
         rng = date_range("20090415", "20090519", tz=pytz.timezone("US/Eastern"))
         stamp = rng[0]
 
@@ -51,6 +55,7 @@
 
     @td.skip_if_windows_python_3
     def test_date_range_timestamp_equiv_explicit_dateutil(self):
+        """ """
         from pandas._libs.tslibs.timezones import dateutil_gettz as gettz
 
         rng = date_range("20090415", "20090519", tz=gettz("US/Eastern"))
@@ -60,6 +65,7 @@
         assert ts == stamp
 
     def test_date_range_timestamp_equiv_from_datetime_instance(self):
+        """ """
         datetime_instance = datetime(2014, 3, 4)
         # build a timestamp with a frequency, since then it supports
         # addition/subtraction of integers
@@ -69,6 +75,7 @@
         assert ts == timestamp_instance
 
     def test_date_range_timestamp_equiv_preserve_frequency(self):
+        """ """
         timestamp_instance = date_range("2014-03-05", periods=1, freq="D")[0]
         ts = Timestamp("2014-03-05", freq="D")
 
@@ -76,7 +83,9 @@
 
 
 class TestDateRanges:
+    """ """
     def test_date_range_nat(self):
+        """ """
         # GH#11587
         msg = "Neither `start` nor `end` can be NaT"
         with pytest.raises(ValueError, match=msg):
@@ -85,6 +94,7 @@
             date_range(start=pd.NaT, end="2016-01-01", freq="D")
 
     def test_date_range_multiplication_overflow(self):
+        """ """
         # GH#24255
         # check that overflows in calculating `addend = periods * stride`
         #  are caught
@@ -100,6 +110,7 @@
             date_range("1969-05-04", periods=200000000, freq="30000D")
 
     def test_date_range_unsigned_overflow_handling(self):
+        """ """
         # GH#24255
         # case where `addend = periods * stride` overflows int64 bounds
         #  but not uint64 bounds
@@ -112,6 +123,7 @@
         assert dti3.equals(dti)
 
     def test_date_range_int64_overflow_non_recoverable(self):
+        """ """
         # GH#24255
         # case with start later than 1970-01-01, overflow int64 but not uint64
         msg = "Cannot generate range with"
@@ -123,6 +135,7 @@
             date_range(end="1969-11-14", periods=106752 * 24, freq="H")
 
     def test_date_range_int64_overflow_stride_endpoint_different_signs(self):
+        """ """
         # cases where stride * periods overflow int64 and stride/endpoint
         #  have different signs
         start = Timestamp("2262-02-23")
@@ -146,6 +159,7 @@
         tm.assert_index_equal(dti2, expected2)
 
     def test_date_range_out_of_bounds(self):
+        """ """
         # GH#14187
         msg = "Cannot generate range"
         with pytest.raises(OutOfBoundsDatetime, match=msg):
@@ -154,11 +168,23 @@
             date_range(end="1763-10-12", periods=100000, freq="D")
 
     def test_date_range_gen_error(self):
+        """ """
         rng = date_range("1/1/2000 00:00", "1/1/2000 00:18", freq="5min")
         assert len(rng) == 4
 
     @pytest.mark.parametrize("freq", ["AS", "YS"])
     def test_begin_year_alias(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-9313
         rng = date_range("1/1/2013", "7/1/2017", freq=freq)
         exp = pd.DatetimeIndex(
@@ -169,6 +195,17 @@
 
     @pytest.mark.parametrize("freq", ["A", "Y"])
     def test_end_year_alias(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-9313
         rng = date_range("1/1/2013", "7/1/2017", freq=freq)
         exp = pd.DatetimeIndex(
@@ -178,6 +215,17 @@
 
     @pytest.mark.parametrize("freq", ["BA", "BY"])
     def test_business_end_year_alias(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-9313
         rng = date_range("1/1/2013", "7/1/2017", freq=freq)
         exp = pd.DatetimeIndex(
@@ -186,6 +234,7 @@
         tm.assert_index_equal(rng, exp)
 
     def test_date_range_negative_freq(self):
+        """ """
         # GH 11018
         rng = date_range("2011-12-31", freq="-2A", periods=3)
         exp = pd.DatetimeIndex(["2011-12-31", "2009-12-31", "2007-12-31"], freq="-2A")
@@ -198,6 +247,7 @@
         assert rng.freq == "-2M"
 
     def test_date_range_bms_bug(self):
+        """ """
         # #1645
         rng = date_range("1/1/2000", periods=10, freq="BMS")
 
@@ -205,6 +255,7 @@
         assert rng[0] == ex_first
 
     def test_date_range_normalize(self):
+        """ """
         snap = datetime.today()
         n = 50
 
@@ -221,6 +272,7 @@
             assert val.time() == the_time
 
     def test_date_range_fy5252(self):
+        """ """
         dr = date_range(
             start="2013-01-01",
             periods=2,
@@ -230,6 +282,7 @@
         assert dr[1] == Timestamp("2014-01-30")
 
     def test_date_range_ambiguous_arguments(self):
+        """ """
         # #2538
         start = datetime(2011, 1, 1, 5, 3, 40)
         end = datetime(2011, 1, 1, 8, 9, 40)
@@ -242,6 +295,7 @@
             date_range(start, end, periods=10, freq="s")
 
     def test_date_range_convenience_periods(self):
+        """ """
         # GH 20808
         result = date_range("2018-04-24", "2018-04-27", periods=3)
         expected = DatetimeIndex(
@@ -286,12 +340,28 @@
         ],
     )
     def test_date_range_linspacing_tz(self, start, end, result_tz):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        end :
+            
+        result_tz :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20983
         result = date_range(start, end, periods=3, tz=result_tz)
         expected = date_range("20180101", periods=3, freq="D", tz="US/Eastern")
         tm.assert_index_equal(result, expected)
 
     def test_date_range_businesshour(self):
+        """ """
         idx = DatetimeIndex(
             [
                 "2014-07-04 09:00",
@@ -345,6 +415,7 @@
         tm.assert_index_equal(idx, rng)
 
     def test_range_misspecified(self):
+        """ """
         # GH #1095
         msg = (
             "Of the four parameters: start, end, periods, and "
@@ -373,6 +444,7 @@
             date_range()
 
     def test_compat_replace(self):
+        """ """
         # https://github.com/statsmodels/statsmodels/issues/3349
         # replace should take ints/longs for compat
         result = date_range(
@@ -381,6 +453,7 @@
         assert len(result) == 76
 
     def test_catch_infinite_loop(self):
+        """ """
         offset = offsets.DateOffset(minute=5)
         # blow up, don't loop forever
         msg = "Offset <DateOffset: minute=5> did not increment date"
@@ -389,11 +462,23 @@
 
     @pytest.mark.parametrize("periods", (1, 2))
     def test_wom_len(self, periods):
+        """
+
+        Parameters
+        ----------
+        periods :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/20517
         res = date_range(start="20110101", periods=periods, freq="WOM-1MON")
         assert len(res) == periods
 
     def test_construct_over_dst(self):
+        """ """
         # GH 20854
         pre_dst = Timestamp("2010-11-07 01:00:00").tz_localize(
             "US/Pacific", ambiguous=True
@@ -411,6 +496,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_construct_with_different_start_end_string_format(self):
+        """ """
         # GH 12064
         result = date_range(
             "2013-01-01 00:00:00+09:00", "2013/01/01 02:00:00+09:00", freq="H"
@@ -426,11 +512,13 @@
         tm.assert_index_equal(result, expected)
 
     def test_error_with_zero_monthends(self):
+        """ """
         msg = r"Offset <0 \* MonthEnds> did not increment date"
         with pytest.raises(ValueError, match=msg):
             date_range("1/1/2000", "1/1/2001", freq=MonthEnd(0))
 
     def test_range_bug(self):
+        """ """
         # GH #770
         offset = DateOffset(months=3)
         result = date_range("2011-1-1", "2012-1-31", freq=offset)
@@ -440,6 +528,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_range_tz_pytz(self):
+        """ """
         # see gh-2906
         tz = timezone("US/Eastern")
         start = tz.localize(datetime(2011, 1, 1))
@@ -474,6 +563,19 @@
         ],
     )
     def test_range_tz_dst_straddle_pytz(self, start, end):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        end :
+            
+
+        Returns
+        -------
+
+        """
         dr = date_range(start, end, freq="D")
         assert dr[0] == start
         assert dr[-1] == end
@@ -495,6 +597,7 @@
         assert np.all(dr.hour == 0)
 
     def test_range_tz_dateutil(self):
+        """ """
         # see gh-2906
 
         # Use maybe_get_tz to fix filename in tz under dateutil.
@@ -522,6 +625,17 @@
 
     @pytest.mark.parametrize("freq", ["1D", "3D", "2M", "7W", "3H", "A"])
     def test_range_closed(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         begin = datetime(2011, 1, 1)
         end = datetime(2014, 1, 1)
 
@@ -540,6 +654,7 @@
         tm.assert_index_equal(expected_right, right)
 
     def test_range_closed_with_tz_aware_start_end(self):
+        """ """
         # GH12409, GH12684
         begin = Timestamp("2011/1/1", tz="US/Eastern")
         end = Timestamp("2014/1/1", tz="US/Eastern")
@@ -581,6 +696,17 @@
 
     @pytest.mark.parametrize("closed", ["right", "left", None])
     def test_range_closed_boundary(self, closed):
+        """
+
+        Parameters
+        ----------
+        closed :
+            
+
+        Returns
+        -------
+
+        """
         # GH#11804
         right_boundary = date_range(
             "2015-09-12", "2015-12-01", freq="QS-MAR", closed=closed
@@ -606,12 +732,14 @@
         tm.assert_index_equal(both_boundary, expected_both)
 
     def test_years_only(self):
+        """ """
         # GH 6961
         dr = date_range("2014", "2015", freq="M")
         assert dr[0] == datetime(2014, 1, 31)
         assert dr[-1] == datetime(2014, 12, 31)
 
     def test_freq_divides_end_in_nanos(self):
+        """ """
         # GH 10885
         result_1 = date_range("2005-01-12 10:00", "2005-01-12 16:00", freq="345min")
         result_2 = date_range("2005-01-13 10:00", "2005-01-13 16:00", freq="345min")
@@ -631,23 +759,37 @@
         tm.assert_index_equal(result_2, expected_2)
 
     def test_cached_range_bug(self):
+        """ """
         rng = date_range("2010-09-01 05:00:00", periods=50, freq=DateOffset(hours=6))
         assert len(rng) == 50
         assert rng[0] == datetime(2010, 9, 1, 5)
 
     def test_timezone_comparaison_bug(self):
+        """ """
         # smoke test
         start = Timestamp("20130220 10:00", tz="US/Eastern")
         result = date_range(start, periods=2, tz="US/Eastern")
         assert len(result) == 2
 
     def test_timezone_comparaison_assert(self):
+        """ """
         start = Timestamp("20130220 10:00", tz="US/Eastern")
         msg = "Inferred time zone not equal to passed time zone"
         with pytest.raises(AssertionError, match=msg):
             date_range(start, periods=2, tz="Europe/Berlin")
 
     def test_negative_non_tick_frequency_descending_dates(self, tz_aware_fixture):
+        """
+
+        Parameters
+        ----------
+        tz_aware_fixture :
+            
+
+        Returns
+        -------
+
+        """
         # GH 23270
         tz = tz_aware_fixture
         result = pd.date_range(start="2011-06-01", end="2011-01-01", freq="-1MS", tz=tz)
@@ -661,6 +803,7 @@
     """Tests for date_range with timezones"""
 
     def test_hongkong_tz_convert(self):
+        """ """
         # GH#1673 smoke test
         dr = date_range("2012-01-01", "2012-01-10", freq="D", tz="Hongkong")
 
@@ -669,6 +812,17 @@
 
     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
     def test_date_range_span_dst_transition(self, tzstr):
+        """
+
+        Parameters
+        ----------
+        tzstr :
+            
+
+        Returns
+        -------
+
+        """
         # GH#1778
 
         # Standard -> Daylight Savings Time
@@ -683,6 +837,17 @@
 
     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
     def test_date_range_timezone_str_argument(self, tzstr):
+        """
+
+        Parameters
+        ----------
+        tzstr :
+            
+
+        Returns
+        -------
+
+        """
         tz = timezones.maybe_get_tz(tzstr)
         result = date_range("1/1/2000", periods=10, tz=tzstr)
         expected = date_range("1/1/2000", periods=10, tz=tz)
@@ -690,6 +855,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_date_range_with_fixedoffset_noname(self):
+        """ """
         from pandas.tests.indexes.datetimes.test_timezones import fixed_off_no_name
 
         off = fixed_off_no_name
@@ -703,6 +869,17 @@
 
     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
     def test_date_range_with_tz(self, tzstr):
+        """
+
+        Parameters
+        ----------
+        tzstr :
+            
+
+        Returns
+        -------
+
+        """
         stamp = Timestamp("3/11/2012 05:00", tz=tzstr)
         assert stamp.hour == 5
 
@@ -712,32 +889,39 @@
 
 
 class TestGenRangeGeneration:
+    """ """
     def test_generate(self):
+        """ """
         rng1 = list(generate_range(START, END, offset=BDay()))
         rng2 = list(generate_range(START, END, offset="B"))
         assert rng1 == rng2
 
     def test_generate_cday(self):
+        """ """
         rng1 = list(generate_range(START, END, offset=CDay()))
         rng2 = list(generate_range(START, END, offset="C"))
         assert rng1 == rng2
 
     def test_1(self):
+        """ """
         rng = list(generate_range(start=datetime(2009, 3, 25), periods=2))
         expected = [datetime(2009, 3, 25), datetime(2009, 3, 26)]
         assert rng == expected
 
     def test_2(self):
+        """ """
         rng = list(generate_range(start=datetime(2008, 1, 1), end=datetime(2008, 1, 3)))
         expected = [datetime(2008, 1, 1), datetime(2008, 1, 2), datetime(2008, 1, 3)]
         assert rng == expected
 
     def test_3(self):
+        """ """
         rng = list(generate_range(start=datetime(2008, 1, 5), end=datetime(2008, 1, 6)))
         expected = []
         assert rng == expected
 
     def test_precision_finer_than_offset(self):
+        """ """
         # GH#9907
         result1 = pd.date_range(
             start="2015-04-15 00:00:03", end="2016-04-22 00:00:00", freq="Q"
@@ -785,6 +969,19 @@
         ],
     )
     def test_mismatching_tz_raises_err(self, start, end):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        end :
+            
+
+        Returns
+        -------
+
+        """
         # issue 18488
         msg = "Start and end cannot both be tz-aware with different timezones"
         with pytest.raises(TypeError, match=msg):
@@ -794,7 +991,9 @@
 
 
 class TestBusinessDateRange:
+    """ """
     def test_constructor(self):
+        """ """
         bdate_range(START, END, freq=BDay())
         bdate_range(START, periods=20, freq=BDay())
         bdate_range(end=START, periods=20, freq=BDay())
@@ -811,6 +1010,7 @@
             bdate_range(START, END, periods=10, freq=None)
 
     def test_misc(self):
+        """ """
         end = datetime(2009, 5, 13)
         dr = bdate_range(end=end, periods=20)
         firstDate = end - 19 * BDay()
@@ -820,6 +1020,7 @@
         assert dr[-1] == end
 
     def test_date_parse_failure(self):
+        """ """
         badly_formed_date = "2007/100/1"
 
         msg = "could not convert string to Timestamp"
@@ -836,6 +1037,7 @@
             bdate_range(badly_formed_date, badly_formed_date)
 
     def test_daterange_bug_456(self):
+        """ """
         # GH #456
         rng1 = bdate_range("12/5/2011", "12/5/2011")
         rng2 = bdate_range("12/2/2011", "12/5/2011")
@@ -846,6 +1048,17 @@
 
     @pytest.mark.parametrize("closed", ["left", "right"])
     def test_bdays_and_open_boundaries(self, closed):
+        """
+
+        Parameters
+        ----------
+        closed :
+            
+
+        Returns
+        -------
+
+        """
         # GH 6673
         start = "2018-07-21"  # Saturday
         end = "2018-07-29"  # Sunday
@@ -858,6 +1071,7 @@
         # Note: we do _not_ expect the freqs to match here
 
     def test_bday_near_overflow(self):
+        """ """
         # GH#24252 avoid doing unnecessary addition that _would_ overflow
         start = pd.Timestamp.max.floor("D").to_pydatetime()
         rng = pd.date_range(start, end=None, periods=1, freq="B")
@@ -865,6 +1079,7 @@
         tm.assert_index_equal(rng, expected)
 
     def test_bday_overflow_error(self):
+        """ """
         # GH#24252 check that we get OutOfBoundsDatetime and not OverflowError
         msg = "Out of bounds nanosecond timestamp"
         start = pd.Timestamp.max.floor("D").to_pydatetime()
@@ -873,7 +1088,9 @@
 
 
 class TestCustomDateRange:
+    """ """
     def test_constructor(self):
+        """ """
         bdate_range(START, END, freq=CDay())
         bdate_range(START, periods=20, freq=CDay())
         bdate_range(end=START, periods=20, freq=CDay())
@@ -886,6 +1103,7 @@
             bdate_range("2011-1-1", "2012-1-1", "C")
 
     def test_misc(self):
+        """ """
         end = datetime(2009, 5, 13)
         dr = bdate_range(end=end, periods=20, freq="C")
         firstDate = end - 19 * CDay()
@@ -895,6 +1113,7 @@
         assert dr[-1] == end
 
     def test_daterange_bug_456(self):
+        """ """
         # GH #456
         rng1 = bdate_range("12/5/2011", "12/5/2011", freq="C")
         rng2 = bdate_range("12/2/2011", "12/5/2011", freq="C")
@@ -904,12 +1123,14 @@
         assert isinstance(result, DatetimeIndex)
 
     def test_cdaterange(self):
+        """ """
         result = bdate_range("2013-05-01", periods=3, freq="C")
         expected = DatetimeIndex(["2013-05-01", "2013-05-02", "2013-05-03"], freq="C")
         tm.assert_index_equal(result, expected)
         assert result.freq == expected.freq
 
     def test_cdaterange_weekmask(self):
+        """ """
         result = bdate_range(
             "2013-05-01", periods=3, freq="C", weekmask="Sun Mon Tue Wed Thu"
         )
@@ -928,6 +1149,7 @@
             bdate_range("2013-05-01", periods=3, weekmask="Sun Mon Tue Wed Thu")
 
     def test_cdaterange_holidays(self):
+        """ """
         result = bdate_range("2013-05-01", periods=3, freq="C", holidays=["2013-05-01"])
         expected = DatetimeIndex(
             ["2013-05-02", "2013-05-03", "2013-05-06"], freq=result.freq
@@ -944,6 +1166,7 @@
             bdate_range("2013-05-01", periods=3, holidays=["2013-05-01"])
 
     def test_cdaterange_weekmask_and_holidays(self):
+        """ """
         result = bdate_range(
             "2013-05-01",
             periods=3,
@@ -974,6 +1197,17 @@
         "freq", [freq for freq in prefix_mapping if freq.startswith("C")]
     )
     def test_all_custom_freq(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         # should not raise
         bdate_range(
             START, END, freq=freq, weekmask="Mon Wed Fri", holidays=["2009-03-14"]
@@ -993,6 +1227,17 @@
         ],
     )
     def test_range_with_millisecond_resolution(self, start_end):
+        """
+
+        Parameters
+        ----------
+        start_end :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/24110
         start, end = start_end
         result = pd.date_range(start=start, end=end, periods=2, closed="left")
@@ -1001,6 +1246,7 @@
 
 
 def test_date_range_with_custom_holidays():
+    """ """
     # GH 30593
     freq = pd.offsets.CustomBusinessHour(start="15:00", holidays=["2020-11-26"])
     result = pd.date_range(start="2020-11-25 15:00", periods=4, freq=freq)
