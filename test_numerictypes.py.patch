# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_numerictypes.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_numerictypes.py
@@ -68,6 +68,17 @@
 byteorder = {'little':'<', 'big':'>'}[sys.byteorder]
 
 def normalize_descr(descr):
+    """
+
+    Parameters
+    ----------
+    descr :
+        
+
+    Returns
+    -------
+
+    """
     "Normalize a description adding the platform byteorder."
 
     out = []
@@ -205,6 +216,7 @@
     """Check the reading of values in heterogeneous arrays (plain)"""
 
     def test_access_fields(self):
+        """ """
         h = np.array(self._buffer, dtype=self._descr)
         if not self.multiple_rows:
             assert_(h.shape == ())
@@ -329,26 +341,33 @@
     _buffer = NbufferT
 
 class TestEmptyField:
+    """ """
     def test_assign(self):
+        """ """
         a = np.arange(10, dtype=np.float32)
         a.dtype = [("int",   "<0i4"), ("float", "<2f4")]
         assert_(a['int'].shape == (5, 0))
         assert_(a['float'].shape == (5, 2))
 
 class TestCommonType:
+    """ """
     def test_scalar_loses1(self):
+        """ """
         res = np.find_common_type(['f4', 'f4', 'i2'], ['f8'])
         assert_(res == 'f4')
 
     def test_scalar_loses2(self):
+        """ """
         res = np.find_common_type(['f4', 'f4'], ['i8'])
         assert_(res == 'f4')
 
     def test_scalar_wins(self):
+        """ """
         res = np.find_common_type(['f4', 'f4', 'i2'], ['c8'])
         assert_(res == 'c8')
 
     def test_scalar_wins2(self):
+        """ """
         res = np.find_common_type(['u4', 'i4', 'i4'], ['f4'])
         assert_(res == 'f8')
 
@@ -357,34 +376,59 @@
         assert_(res == 'f8')
 
 class TestMultipleFields:
+        """
+
+        Parameters
+        ----------
+        self):  # doesn't go up to 'f16' on purposeres :
+             (Default value = np.find_common_type(['u8')
+        'i8' :
+            
+        'i8'] :
+            
+        ['f8'])assert_(res :
+             (Default value = = 'f8')
+
+        Returns
+        -------
+
+        """
     def setup(self):
+        """ """
         self.ary = np.array([(1, 2, 3, 4), (5, 6, 7, 8)], dtype='i4,f4,i2,c8')
 
     def _bad_call(self):
+        """ """
         return self.ary['f0', 'f1']
 
     def test_no_tuple(self):
+        """ """
         assert_raises(IndexError, self._bad_call)
 
     def test_return(self):
+        """ """
         res = self.ary[['f0', 'f2']].tolist()
         assert_(res == [(1, 3), (5, 7)])
 
 
 class TestIsSubDType:
+    """ """
     # scalar types can be promoted into dtypes
     wrappers = [np.dtype, lambda x: x]
 
     def test_both_abstract(self):
+        """ """
         assert_(np.issubdtype(np.floating, np.inexact))
         assert_(not np.issubdtype(np.inexact, np.floating))
 
     def test_same(self):
+        """ """
         for cls in (np.float32, np.int32):
             for w1, w2 in itertools.product(self.wrappers, repeat=2):
                 assert_(np.issubdtype(w1(cls), w2(cls)))
 
     def test_subclass(self):
+        """ """
         # note we cannot promote floating to a dtype, as it would turn into a
         # concrete type
         for w in self.wrappers:
@@ -392,16 +436,19 @@
             assert_(np.issubdtype(w(np.float64), np.floating))
 
     def test_subclass_backwards(self):
+        """ """
         for w in self.wrappers:
             assert_(not np.issubdtype(np.floating, w(np.float32)))
             assert_(not np.issubdtype(np.floating, w(np.float64)))
 
     def test_sibling_class(self):
+        """ """
         for w1, w2 in itertools.product(self.wrappers, repeat=2):
             assert_(not np.issubdtype(w1(np.float32), w2(np.float64)))
             assert_(not np.issubdtype(w1(np.float64), w2(np.float32)))
 
     def test_nondtype_nonscalartype(self):
+        """ """
         # See gh-14619 and gh-9505 which introduced the deprecation to fix
         # this. These tests are directly taken from gh-9505
         assert not np.issubdtype(np.float32, 'float64')
@@ -432,69 +479,136 @@
 
 
 class TestSctypeDict:
+    """ """
     def test_longdouble(self):
+        """ """
         assert_(np.sctypeDict['f8'] is not np.longdouble)
         assert_(np.sctypeDict['c16'] is not np.clongdouble)
 
 
 class TestBitName:
+    """ """
     def test_abstract(self):
+        """ """
         assert_raises(ValueError, np.core.numerictypes.bitname, np.floating)
 
 
 class TestMaximumSctype:
+    """ """
 
     # note that parametrizing with sctype['int'] and similar would skip types
     # with the same size (gh-11923)
 
     @pytest.mark.parametrize('t', [np.byte, np.short, np.intc, np.int_, np.longlong])
     def test_int(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert_equal(np.maximum_sctype(t), np.sctypes['int'][-1])
 
     @pytest.mark.parametrize('t', [np.ubyte, np.ushort, np.uintc, np.uint, np.ulonglong])
     def test_uint(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert_equal(np.maximum_sctype(t), np.sctypes['uint'][-1])
 
     @pytest.mark.parametrize('t', [np.half, np.single, np.double, np.longdouble])
     def test_float(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert_equal(np.maximum_sctype(t), np.sctypes['float'][-1])
 
     @pytest.mark.parametrize('t', [np.csingle, np.cdouble, np.clongdouble])
     def test_complex(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert_equal(np.maximum_sctype(t), np.sctypes['complex'][-1])
 
     @pytest.mark.parametrize('t', [np.bool_, np.object_, np.unicode_, np.bytes_, np.void])
     def test_other(self, t):
+        """
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert_equal(np.maximum_sctype(t), t)
 
 
 class Test_sctype2char:
+    """ """
     # This function is old enough that we're really just documenting the quirks
     # at this point.
 
     def test_scalar_type(self):
+        """ """
         assert_equal(np.sctype2char(np.double), 'd')
         assert_equal(np.sctype2char(np.int_), 'l')
         assert_equal(np.sctype2char(np.unicode_), 'U')
         assert_equal(np.sctype2char(np.bytes_), 'S')
 
     def test_other_type(self):
+        """ """
         assert_equal(np.sctype2char(float), 'd')
         assert_equal(np.sctype2char(list), 'O')
         assert_equal(np.sctype2char(np.ndarray), 'O')
 
     def test_third_party_scalar_type(self):
+        """ """
         from numpy.core._rational_tests import rational
         assert_raises(KeyError, np.sctype2char, rational)
         assert_raises(KeyError, np.sctype2char, rational(1))
 
     def test_array_instance(self):
+        """ """
         assert_equal(np.sctype2char(np.array([1.0, 2.0])), 'd')
 
     def test_abstract_type(self):
+        """ """
         assert_raises(KeyError, np.sctype2char, np.floating)
 
     def test_non_type(self):
+        """ """
         assert_raises(ValueError, np.sctype2char, 1)
 
 @pytest.mark.parametrize("rep, expected", [
@@ -507,6 +621,19 @@
     (np.dtype([('a', np.int8)]), True),
     ])
 def test_issctype(rep, expected):
+    """
+
+    Parameters
+    ----------
+    rep :
+        
+    expected :
+        
+
+    Returns
+    -------
+
+    """
     # ensure proper identification of scalar
     # data-types by issctype()
     actual = np.issctype(rep)
@@ -518,7 +645,9 @@
 @pytest.mark.xfail(IS_PYPY,
                    reason="PyPy cannot modify tp_doc after PyType_Ready")
 class TestDocStrings:
+    """ """
     def test_platform_dependent_aliases(self):
+        """ """
         if np.int64 is np.int_:
             assert_('int64' in np.int_.__doc__)
         elif np.int64 is np.longlong:
@@ -526,6 +655,7 @@
 
 
 class TestScalarTypeNames:
+    """ """
     # gh-9799
 
     numeric_types = [
@@ -536,6 +666,7 @@
     ]
 
     def test_names_are_unique(self):
+        """ """
         # none of the above may be aliases for each other
         assert len(set(self.numeric_types)) == len(self.numeric_types)
 
@@ -545,10 +676,30 @@
 
     @pytest.mark.parametrize('t', numeric_types)
     def test_names_reflect_attributes(self, t):
-        """ Test that names correspond to where the type is under ``np.`` """
+        """Test that names correspond to where the type is under ``np.``
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert getattr(np, t.__name__) is t
 
     @pytest.mark.parametrize('t', numeric_types)
     def test_names_are_undersood_by_dtype(self, t):
-        """ Test the dtype constructor maps names back to the type """
+        """Test the dtype constructor maps names back to the type
+
+        Parameters
+        ----------
+        t :
+            
+
+        Returns
+        -------
+
+        """
         assert np.dtype(t.__name__).type is t
