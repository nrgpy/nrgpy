# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/context.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/context.py
@@ -14,6 +14,7 @@
 
 
 class AbstractContext(object):
+    """ """
     # Must be defined: inference_state and tree_node and parent_context as an attribute/property
 
     def __init__(self, inference_state):
@@ -22,9 +23,35 @@
 
     @abstractmethod
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     def goto(self, name_or_str, position):
+        """
+
+        Parameters
+        ----------
+        name_or_str :
+            
+        position :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference import finder
         filters = _get_global_filters_for_name(
             self, name_or_str if isinstance(name_or_str, Name) else None, position,
@@ -36,7 +63,21 @@
     def py__getattribute__(self, name_or_str, name_context=None, position=None,
                            analysis_errors=True):
         """
-        :param position: Position of the last statement -> tuple of line, column
+
+        Parameters
+        ----------
+        position :
+            Position of the last statement -> tuple of line, column (Default value = None)
+        name_or_str :
+            
+        name_context :
+             (Default value = None)
+        analysis_errors :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         if name_context is None:
             name_context = self
@@ -86,6 +127,21 @@
         return self._check_for_additional_knowledge(name_or_str, name_context, position)
 
     def _check_for_additional_knowledge(self, name_or_str, name_context, position):
+        """
+
+        Parameters
+        ----------
+        name_or_str :
+            
+        name_context :
+            
+        position :
+            
+
+        Returns
+        -------
+
+        """
         name_context = name_context or self
         # Add isinstance and other if/assert knowledge.
         if isinstance(name_or_str, Name) and not name_context.is_instance():
@@ -106,51 +162,77 @@
         return NO_VALUES
 
     def get_root_context(self):
+        """ """
         parent_context = self.parent_context
         if parent_context is None:
             return self
         return parent_context.get_root_context()
 
     def is_module(self):
+        """ """
         return False
 
     def is_builtins_module(self):
+        """ """
         return False
 
     def is_class(self):
+        """ """
         return False
 
     def is_stub(self):
+        """ """
         return False
 
     def is_instance(self):
+        """ """
         return False
 
     def is_compiled(self):
+        """ """
         return False
 
     def is_bound_method(self):
+        """ """
         return False
 
     @abstractmethod
     def py__name__(self):
+        """ """
         raise NotImplementedError
 
     def get_value(self):
+        """ """
         raise NotImplementedError
 
     @property
     def name(self):
+        """ """
         return None
 
     def get_qualified_names(self):
+        """ """
         return ()
 
     def py__doc__(self):
+        """ """
         return ''
 
     @contextmanager
     def predefine_names(self, flow_scope, dct):
+        """
+
+        Parameters
+        ----------
+        flow_scope :
+            
+        dct :
+            
+
+        Returns
+        -------
+
+        """
         predefined = self.predefined_names
         predefined[flow_scope] = dct
         try:
@@ -160,56 +242,68 @@
 
 
 class ValueContext(AbstractContext):
-    """
-    Should be defined, otherwise the API returns empty types.
-    """
+    """Should be defined, otherwise the API returns empty types."""
     def __init__(self, value):
         super(ValueContext, self).__init__(value.inference_state)
         self._value = value
 
     @property
     def tree_node(self):
+        """ """
         return self._value.tree_node
 
     @property
     def parent_context(self):
+        """ """
         return self._value.parent_context
 
     def is_module(self):
+        """ """
         return self._value.is_module()
 
     def is_builtins_module(self):
+        """ """
         return self._value == self.inference_state.builtins_module
 
     def is_class(self):
+        """ """
         return self._value.is_class()
 
     def is_stub(self):
+        """ """
         return self._value.is_stub()
 
     def is_instance(self):
+        """ """
         return self._value.is_instance()
 
     def is_compiled(self):
+        """ """
         return self._value.is_compiled()
 
     def is_bound_method(self):
+        """ """
         return self._value.is_bound_method()
 
     def py__name__(self):
+        """ """
         return self._value.py__name__()
 
     @property
     def name(self):
+        """ """
         return self._value.name
 
     def get_qualified_names(self):
+        """ """
         return self._value.get_qualified_names()
 
     def py__doc__(self):
+        """ """
         return self._value.py__doc__()
 
     def get_value(self):
+        """ """
         return self._value
 
     def __repr__(self):
@@ -217,11 +311,34 @@
 
 
 class TreeContextMixin(object):
+    """ """
     def infer_node(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.syntax_tree import infer_node
         return infer_node(self, node)
 
     def create_value(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference import value
 
         if node == self.tree_node:
@@ -248,7 +365,31 @@
             raise NotImplementedError("Probably shouldn't happen: %s" % node)
 
     def create_context(self, node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         def from_scope_node(scope_node, is_nested=True):
+            """
+
+            Parameters
+            ----------
+            scope_node :
+                
+            is_nested :
+                 (Default value = True)
+
+            Returns
+            -------
+
+            """
             if scope_node == self.tree_node:
                 return self
 
@@ -263,6 +404,17 @@
             raise Exception("There's a scope that was not managed: %s" % scope_node)
 
         def parent_scope(node):
+            """
+
+            Parameters
+            ----------
+            node :
+                
+
+            Returns
+            -------
+
+            """
             while True:
                 node = node.parent
 
@@ -287,6 +439,17 @@
         return from_scope_node(scope_node, is_nested=True)
 
     def create_name(self, tree_name):
+        """
+
+        Parameters
+        ----------
+        tree_name :
+            
+
+        Returns
+        -------
+
+        """
         definition = tree_name.get_definition()
         if definition and definition.type == 'param' and definition.name == tree_name:
             funcdef = search_ancestor(definition, 'funcdef', 'lambdef')
@@ -298,7 +461,21 @@
 
 
 class FunctionContext(TreeContextMixin, ValueContext):
+    """ """
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield ParserTreeFilter(
             self.inference_state,
             parent_context=self,
@@ -308,10 +485,25 @@
 
 
 class ModuleContext(TreeContextMixin, ValueContext):
+    """ """
     def py__file__(self):
+        """ """
         return self._value.py__file__()
 
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         filters = self._value.get_filters(origin_scope)
         # Skip the first filter and replace it.
         next(filters, None)
@@ -327,45 +519,98 @@
             yield f
 
     def get_global_filter(self):
+        """ """
         return GlobalNameFilter(self, self.tree_node)
 
     @property
     def string_names(self):
+        """ """
         return self._value.string_names
 
     @property
     def code_lines(self):
+        """ """
         return self._value.code_lines
 
     def get_value(self):
-        """
-        This is the only function that converts a context back to a value.
+        """This is the only function that converts a context back to a value.
         This is necessary for stub -> python conversion and vice versa. However
         this method shouldn't be moved to AbstractContext.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return self._value
 
 
 class NamespaceContext(TreeContextMixin, ValueContext):
+    """ """
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self._value.get_filters()
 
     def get_value(self):
+        """ """
         return self._value
 
     @property
     def string_names(self):
+        """ """
         return self._value.string_names
 
     def py__file__(self):
+        """ """
         return self._value.py__file__()
 
 
 class ClassContext(TreeContextMixin, ValueContext):
+    """ """
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield self.get_global_filter(until_position, origin_scope)
 
     def get_global_filter(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return ParserTreeFilter(
             parent_context=self,
             until_position=until_position,
@@ -374,18 +619,34 @@
 
 
 class CompForContext(TreeContextMixin, AbstractContext):
+    """ """
     def __init__(self, parent_context, comp_for):
         super(CompForContext, self).__init__(parent_context.inference_state)
         self.tree_node = comp_for
         self.parent_context = parent_context
 
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         yield ParserTreeFilter(self)
 
     def get_value(self):
+        """ """
         return None
 
     def py__name__(self):
+        """ """
         return '<comprehension context>'
 
     def __repr__(self):
@@ -393,25 +654,58 @@
 
 
 class CompiledContext(ValueContext):
+    """ """
     def get_filters(self, until_position=None, origin_scope=None):
+        """
+
+        Parameters
+        ----------
+        until_position :
+             (Default value = None)
+        origin_scope :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self._value.get_filters()
 
 
 class CompiledModuleContext(CompiledContext):
+    """ """
     code_lines = None
 
     def get_value(self):
+        """ """
         return self._value
 
     @property
     def string_names(self):
+        """ """
         return self._value.string_names
 
     def py__file__(self):
+        """ """
         return self._value.py__file__()
 
 
 def _get_global_filters_for_name(context, name_or_none, position):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    name_or_none :
+        
+    position :
+        
+
+    Returns
+    -------
+
+    """
     # For functions and classes the defaults don't belong to the
     # function and get inferred in the value before the function. So
     # make sure to exclude the function/class name.
@@ -433,11 +727,35 @@
 
 
 def get_global_filters(context, until_position, origin_scope):
-    """
-    Returns all filters in order of priority for name resolution.
-
+    """Returns all filters in order of priority for name resolution.
+    
     For global name lookups. The filters will handle name resolution
     themselves, but here we gather possible filters downwards.
+    
+    
+    First we get the names from the function scope.
+    
+    
+    Then it yields the names from one level "lower". In this example, this is
+    the module scope (including globals).
+    As a side note, you can see, that the position in the filter is None on the
+    globals filter, because there the whole module is searched.
+    
+    
+    Finally, it yields the builtin filter, if `include_builtin` is
+    true (default).
+
+    Parameters
+    ----------
+    context :
+        
+    until_position :
+        
+    origin_scope :
+        
+
+    Returns
+    -------
 
     >>> from jedi._compatibility import u, no_unicode_pprint
     >>> from jedi import Script
@@ -452,9 +770,7 @@
     <Function: func@3-5>
     >>> context = script._get_module_context().create_context(scope)
     >>> filters = list(get_global_filters(context, (4, 0), None))
-
-    First we get the names from the function scope.
-
+    
     >>> no_unicode_pprint(filters[0])  # doctest: +ELLIPSIS
     MergedFilter(<ParserTreeFilter: ...>, <GlobalNameFilter: ...>)
     >>> sorted(str(n) for n in filters[0].values())  # doctest: +NORMALIZE_WHITESPACE
@@ -463,20 +779,12 @@
     >>> filters[0]._filters[0]._until_position
     (4, 0)
     >>> filters[0]._filters[1]._until_position
-
-    Then it yields the names from one level "lower". In this example, this is
-    the module scope (including globals).
-    As a side note, you can see, that the position in the filter is None on the
-    globals filter, because there the whole module is searched.
-
+    
     >>> list(filters[1].values())  # package modules -> Also empty.
     []
     >>> sorted(name.string_name for name in filters[2].values())  # Module attributes
     ['__doc__', '__name__', '__package__']
-
-    Finally, it yields the builtin filter, if `include_builtin` is
-    true (default).
-
+    
     >>> list(filters[3].values())  # doctest: +ELLIPSIS
     [...]
     """
