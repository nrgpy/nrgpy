# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/ptyprocess/ptyprocess.py
+++ b/..//venv/lib/python3.8/site-packages/ptyprocess/ptyprocess.py
@@ -38,9 +38,31 @@
 
 if PY3:
     def _byte(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         return bytes([i])
 else:
     def _byte(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         return chr(i)
     
     class FileNotFoundError(OSError): pass
@@ -49,10 +71,17 @@
 _EOF, _INTR = None, None
 
 def _make_eof_intr():
-    """Set constants _EOF and _INTR.
-    
-    This avoids doing potentially costly operations on module load.
-    """
+        """Set constants _EOF and _INTR.
+        
+            This avoids doing potentially costly operations on module load.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
     global _EOF, _INTR
     if (_EOF is not None) and (_INTR is not None):
         return
@@ -92,6 +121,19 @@
 # to do this from the child before we exec()
     
 def _setecho(fd, state):
+    """
+
+    Parameters
+    ----------
+    fd :
+        
+    state :
+        
+
+    Returns
+    -------
+
+    """
     errmsg = 'setecho() may not be called on this platform (it may still be possible to enable/disable echo when spawning the child process)'
 
     try:
@@ -116,6 +158,21 @@
         raise
 
 def _setwinsize(fd, rows, cols):
+    """
+
+    Parameters
+    ----------
+    fd :
+        
+    rows :
+        
+    cols :
+        
+
+    Returns
+    -------
+
+    """
     # Some very old platforms have a bug that causes the value for
     # termios.TIOCSWINSZ to be truncated. There was a hack here to work
     # around this, but it caused problems with newer platforms so has been
@@ -126,10 +183,17 @@
     fcntl.ioctl(fd, TIOCSWINSZ, s)
 
 class PtyProcess(object):
-    '''This class represents a process running in a pseudoterminal.
+    """This class represents a process running in a pseudoterminal.
     
     The main constructor is the :meth:`spawn` classmethod.
-    '''
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
     string_type = bytes
     if PY3:
         linesep = os.linesep.encode('ascii')
@@ -137,6 +201,17 @@
 
         @staticmethod
         def write_to_stdout(b):
+            """
+
+            Parameters
+            ----------
+            b :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 return sys.stdout.buffer.write(b)
             except AttributeError:
@@ -179,18 +254,39 @@
     def spawn(
             cls, argv, cwd=None, env=None, echo=True, preexec_fn=None,
             dimensions=(24, 80)):
-        '''Start the given command in a child process in a pseudo terminal.
-
+        """Start the given command in a child process in a pseudo terminal.
+        
         This does all the fork/exec type of stuff for a pty, and returns an
         instance of PtyProcess.
-
+        
         If preexec_fn is supplied, it will be called with no arguments in the
         child process before exec-ing the specified command.
         It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.
-
+        
         Dimensions of the psuedoterminal used for the subprocess can be
         specified as a tuple (rows, cols), or the default (24, 80) will be used.
-        '''
+
+        Parameters
+        ----------
+        argv :
+            
+        cwd :
+             (Default value = None)
+        env :
+             (Default value = None)
+        echo :
+             (Default value = True)
+        preexec_fn :
+             (Default value = None)
+        dimensions :
+             (Default value = (24)
+        80) :
+            
+
+        Returns
+        -------
+
+        """
         # Note that it is difficult for this method to fail.
         # You cannot detect if the child process cannot start.
         # So the only way you can tell if the child process started
@@ -353,12 +449,34 @@
 
     @staticmethod
     def _coerce_send_string(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         if not isinstance(s, bytes):
             return s.encode('utf-8')
         return s
 
     @staticmethod
     def _coerce_read_string(s):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
+        """
         return s
 
     def __del__(self):
@@ -380,16 +498,25 @@
 
 
     def fileno(self):
-        '''This returns the file descriptor of the pty for the child.
-        '''
+        """This returns the file descriptor of the pty for the child."""
         return self.fd
 
     def close(self, force=True):
-        '''This closes the connection with the child application. Note that
+        """This closes the connection with the child application. Note that
         calling close() more than once is valid. This emulates standard Python
         behavior with files. Set force to True if you want to make sure that
         the child is terminated (SIGKILL is sent if the child ignores SIGHUP
-        and SIGINT). '''
+        and SIGINT).
+
+        Parameters
+        ----------
+        force :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if not self.closed:
             self.flush()
             self.fileobj.close() # Closes the file descriptor
@@ -403,37 +530,62 @@
             #self.pid = None
 
     def flush(self):
-        '''This does nothing. It is here to support the interface for a
-        File-like object. '''
+        """This does nothing. It is here to support the interface for a
+        File-like object.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         pass
 
     def isatty(self):
-        '''This returns True if the file descriptor is open and connected to a
+        """This returns True if the file descriptor is open and connected to a
         tty(-like) device, else False.
-
+        
         On SVR4-style platforms implementing streams, such as SunOS and HP-UX,
         the child pty may not appear as a terminal device.  This means
         methods such as setecho(), setwinsize(), getwinsize() may raise an
-        IOError. '''
+        IOError.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         return os.isatty(self.fd)
 
     def waitnoecho(self, timeout=None):
-        '''This waits until the terminal ECHO flag is set False. This returns
+        """This waits until the terminal ECHO flag is set False. This returns
         True if the echo mode is off. This returns False if the ECHO flag was
         not set False before the timeout. This can be used to detect when the
         child is waiting for a password. Usually a child application will turn
         off echo mode when it is waiting for the user to enter a password. For
         example, instead of expecting the "password:" prompt you can wait for
         the child to set ECHO off::
-
+        
             p = pexpect.spawn('ssh user@example.com')
             p.waitnoecho()
             p.sendline(mypassword)
-
+        
         If timeout==None then this method to block until ECHO flag is False.
-        '''
+
+        Parameters
+        ----------
+        timeout :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if timeout is not None:
             end_time = time.time() + timeout
@@ -447,11 +599,19 @@
             time.sleep(0.1)
 
     def getecho(self):
-        '''This returns the terminal echo mode. This returns True if echo is
+        """This returns the terminal echo mode. This returns True if echo is
         on or False if echo is off. Child applications that are expecting you
         to enter a password often set ECHO False. See waitnoecho().
-
-        Not supported on platforms where ``isatty()`` returns False.  '''
+        
+        Not supported on platforms where ``isatty()`` returns False.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         try:
             attr = termios.tcgetattr(self.fd)
@@ -465,11 +625,11 @@
         return self.echo
 
     def setecho(self, state):
-        '''This sets the terminal echo mode on or off. Note that anything the
+        """This sets the terminal echo mode on or off. Note that anything the
         child sent before the echo will be lost, so you should be sure that
         your input buffer is empty before you call setecho(). For example, the
         following will work as expected::
-
+        
             p = pexpect.spawn('cat') # Echo is on by default.
             p.sendline('1234') # We expect see this twice from the child...
             p.expect(['1234']) # ... once from the tty echo...
@@ -479,10 +639,10 @@
             p.sendline('wxyz') # We will set this only once (echoed by cat)
             p.expect(['abcd'])
             p.expect(['wxyz'])
-
+        
         The following WILL NOT WORK because the lines sent before the setecho
         will be lost::
-
+        
             p = pexpect.spawn('cat')
             p.sendline('1234')
             p.setecho(False) # Turn off tty echo
@@ -492,17 +652,26 @@
             p.expect(['1234'])
             p.expect(['abcd'])
             p.expect(['wxyz'])
-
-
+        
+        
         Not supported on platforms where ``isatty()`` returns False.
-        '''
+
+        Parameters
+        ----------
+        state :
+            
+
+        Returns
+        -------
+
+        """
         _setecho(self.fd, state)
 
         self.echo = state
 
     def read(self, size=1024):
         """Read and return at most ``size`` bytes from the pty.
-
+        
         Can block if there is nothing to read. Raises :exc:`EOFError` if the
         terminal was closed.
         
@@ -511,6 +680,15 @@
         or older Solaris systems. It handles the errno=EIO pattern used on
         Linux, and the empty-string return used on BSD platforms and (seemingly)
         on recent Solaris.
+
+        Parameters
+        ----------
+        size :
+             (Default value = 1024)
+
+        Returns
+        -------
+
         """
         try:
             s = self.fileobj.read1(size)
@@ -529,9 +707,16 @@
 
     def readline(self):
         """Read one line from the pseudoterminal, and return it as unicode.
-
+        
         Can block if there is nothing to read. Raises :exc:`EOFError` if the
         terminal was closed.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         try:
             s = self.fileobj.readline()
@@ -549,6 +734,19 @@
         return s
 
     def _writeb(self, b, flush=True):
+        """
+
+        Parameters
+        ----------
+        b :
+            
+        flush :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         n = self.fileobj.write(b)
         if flush:
             self.fileobj.flush()
@@ -558,18 +756,38 @@
         """Write bytes to the pseudoterminal.
         
         Returns the number of bytes written.
+
+        Parameters
+        ----------
+        s :
+            
+        flush :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._writeb(s, flush=flush)
 
     def sendcontrol(self, char):
-        '''Helper method that wraps send() with mnemonic access for sending control
+        """Helper method that wraps send() with mnemonic access for sending control
         character to the child (such as Ctrl-C or Ctrl-D).  For example, to send
         Ctrl-G (ASCII 7, bell, '\a')::
-
+        
             child.sendcontrol('g')
-
+        
         See also, sendintr() and sendeof().
-        '''
+
+        Parameters
+        ----------
+        char :
+            
+
+        Returns
+        -------
+
+        """
         char = char.lower()
         a = ord(char)
         if 97 <= a <= 122:
@@ -590,34 +808,59 @@
         return self._writeb(byte), byte
 
     def sendeof(self):
-        '''This sends an EOF to the child. This sends a character which causes
+        """This sends an EOF to the child. This sends a character which causes
         the pending parent output buffer to be sent to the waiting child
         program without waiting for end-of-line. If it is the first character
         of the line, the read() in the user program returns 0, which signifies
         end-of-file. This means to work as expected a sendeof() has to be
         called at the beginning of a line. This method does not send a newline.
         It is the responsibility of the caller to ensure the eof is sent at the
-        beginning of a line. '''
+        beginning of a line.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         return self._writeb(_EOF), _EOF
 
     def sendintr(self):
-        '''This sends a SIGINT to the child. It does not require
-        the SIGINT to be the first character on a line. '''
+        """This sends a SIGINT to the child. It does not require
+        the SIGINT to be the first character on a line.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         return self._writeb(_INTR), _INTR
 
     def eof(self):
-        '''This returns True if the EOF exception was ever raised.
-        '''
+        """This returns True if the EOF exception was ever raised."""
 
         return self.flag_eof
 
     def terminate(self, force=False):
-        '''This forces a child process to terminate. It starts nicely with
+        """This forces a child process to terminate. It starts nicely with
         SIGHUP and SIGINT. If "force" is True then moves onto SIGKILL. This
         returns True if the child was terminated. This returns False if the
-        child could not be terminated. '''
+        child could not be terminated.
+
+        Parameters
+        ----------
+        force :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
 
         if not self.isalive():
             return True
@@ -654,11 +897,19 @@
                 return False
 
     def wait(self):
-        '''This waits until the child exits. This is a blocking call. This will
+        """This waits until the child exits. This is a blocking call. This will
         not read any data from the child, so this will block forever if the
         child has unread output and has terminated. In other words, the child
         may have printed output then called exit(), but, the child is
-        technically still alive until its output is read by the parent. '''
+        technically still alive until its output is read by the parent.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         if self.isalive():
             pid, status = os.waitpid(self.pid, 0)
@@ -683,11 +934,19 @@
         return self.exitstatus
 
     def isalive(self):
-        '''This tests if the child process is running or not. This is
+        """This tests if the child process is running or not. This is
         non-blocking. If the child was terminated then this will read the
         exitstatus or signalstatus of the child. This returns True if the child
         process appears to be running or False if not. It can take literally
-        SECONDS for Solaris to return the right status. '''
+        SECONDS for Solaris to return the right status.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
 
         if self.terminated:
             return False
@@ -761,10 +1020,19 @@
 
     def kill(self, sig):
         """Send the given signal to the child application.
-
+        
         In keeping with UNIX tradition it has a misleading name. It does not
         necessarily kill the child unless you send the right signal. See the
         :mod:`signal` module for constants representing signal numbers.
+
+        Parameters
+        ----------
+        sig :
+            
+
+        Returns
+        -------
+
         """
 
         # Same as os.kill, but the pid is given for you.
@@ -772,8 +1040,7 @@
             os.kill(self.pid, sig)
 
     def getwinsize(self):
-        """Return the window size of the pseudoterminal as a tuple (rows, cols).
-        """
+        """ """
         TIOCGWINSZ = getattr(termios, 'TIOCGWINSZ', 1074295912)
         s = struct.pack('HHHH', 0, 0, 0, 0)
         x = fcntl.ioctl(self.fd, TIOCGWINSZ, s)
@@ -781,20 +1048,38 @@
 
     def setwinsize(self, rows, cols):
         """Set the terminal window size of the child tty.
-
+        
         This will cause a SIGWINCH signal to be sent to the child. This does not
         change the physical window size. It changes the size reported to
         TTY-aware applications like vi or curses -- applications that respond to
         the SIGWINCH signal.
+
+        Parameters
+        ----------
+        rows :
+            
+        cols :
+            
+
+        Returns
+        -------
+
         """
         return _setwinsize(self.fd, rows, cols)
 
 
 class PtyProcessUnicode(PtyProcess):
     """Unicode wrapper around a process running in a pseudoterminal.
-
+    
     This class exposes a similar interface to :class:`PtyProcess`, but its read
     methods return unicode, and its :meth:`write` accepts unicode.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     if PY3:
         string_type = str
@@ -809,28 +1094,53 @@
 
     def read(self, size=1024):
         """Read at most ``size`` bytes from the pty, return them as unicode.
-
+        
         Can block if there is nothing to read. Raises :exc:`EOFError` if the
         terminal was closed.
-
+        
         The size argument still refers to bytes, not unicode code points.
+
+        Parameters
+        ----------
+        size :
+             (Default value = 1024)
+
+        Returns
+        -------
+
         """
         b = super(PtyProcessUnicode, self).read(size)
         return self.decoder.decode(b, final=False)
 
     def readline(self):
         """Read one line from the pseudoterminal, and return it as unicode.
-
+        
         Can block if there is nothing to read. Raises :exc:`EOFError` if the
         terminal was closed.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         b = super(PtyProcessUnicode, self).readline()
         return self.decoder.decode(b, final=False)
 
     def write(self, s):
         """Write the unicode string ``s`` to the pseudoterminal.
-
+        
         Returns the number of bytes written.
+
+        Parameters
+        ----------
+        s :
+            
+
+        Returns
+        -------
+
         """
         b = s.encode(self.encoding)
         return super(PtyProcessUnicode, self).write(b)
