# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pygments/lexers/modula2.py
+++ b/..//venv/lib/python3.8/site-packages/pygments/lexers/modula2.py
@@ -21,20 +21,19 @@
 
 # Multi-Dialect Modula-2 Lexer
 class Modula2Lexer(RegexLexer):
-    """
-    For `Modula-2 <http://www.modula2.org/>`_ source code.
-
+    """For `Modula-2 <http://www.modula2.org/>`_ source code.
+    
     The Modula-2 lexer supports several dialects.  By default, it operates in
     fallback mode, recognising the *combined* literals, punctuation symbols
     and operators of all supported dialects, and the *combined* reserved words
     and builtins of PIM Modula-2, ISO Modula-2 and Modula-2 R10, while not
     differentiating between library defined identifiers.
-
+    
     To select a specific dialect, a dialect option may be passed
     or a dialect tag may be embedded into a source file.
-
+    
     Dialect Options:
-
+    
     `m2pim`
         Select PIM Modula-2 dialect.
     `m2iso`
@@ -43,11 +42,11 @@
         Select Modula-2 R10 dialect.
     `objm2`
         Select Objective Modula-2 dialect.
-
+    
     The PIM and ISO dialect options may be qualified with a language extension.
-
+    
     Language Extensions:
-
+    
     `+aglet`
         Select Aglet Modula-2 extensions, available with m2iso.
     `+gm2`
@@ -56,108 +55,115 @@
         Select p1 Modula-2 extensions, available with m2iso.
     `+xds`
         Select XDS Modula-2 extensions, available with m2iso.
-
-
+    
+    
     Passing a Dialect Option via Unix Commandline Interface
-
+    
     Dialect options may be passed to the lexer using the `dialect` key.
     Only one such option should be passed. If multiple dialect options are
     passed, the first valid option is used, any subsequent options are ignored.
-
+    
     Examples:
-
+    
     `$ pygmentize -O full,dialect=m2iso -f html -o /path/to/output /path/to/input`
         Use ISO dialect to render input to HTML output
     `$ pygmentize -O full,dialect=m2iso+p1 -f rtf -o /path/to/output /path/to/input`
         Use ISO dialect with p1 extensions to render input to RTF output
-
-
+    
+    
     Embedding a Dialect Option within a source file
-
+    
     A dialect option may be embedded in a source file in form of a dialect
     tag, a specially formatted comment that specifies a dialect option.
-
+    
     Dialect Tag EBNF::
-
+    
        dialectTag :
            OpeningCommentDelim Prefix dialectOption ClosingCommentDelim ;
-
+    
        dialectOption :
            'm2pim' | 'm2iso' | 'm2r10' | 'objm2' |
            'm2iso+aglet' | 'm2pim+gm2' | 'm2iso+p1' | 'm2iso+xds' ;
-
+    
        Prefix : '!' ;
-
+    
        OpeningCommentDelim : '(*' ;
-
+    
        ClosingCommentDelim : '*)' ;
-
+    
     No whitespace is permitted between the tokens of a dialect tag.
-
+    
     In the event that a source file contains multiple dialect tags, the first
     tag that contains a valid dialect option will be used and any subsequent
     dialect tags will be ignored.  Ideally, a dialect tag should be placed
     at the beginning of a source file.
-
+    
     An embedded dialect tag overrides a dialect option set via command line.
-
+    
     Examples:
-
+    
     ``(*!m2r10*) DEFINITION MODULE Foobar; ...``
         Use Modula2 R10 dialect to render this source file.
     ``(*!m2pim+gm2*) DEFINITION MODULE Bazbam; ...``
         Use PIM dialect with GNU extensions to render this source file.
-
-
+    
+    
     Algol Publication Mode:
-
+    
     In Algol publication mode, source text is rendered for publication of
     algorithms in scientific papers and academic texts, following the format
     of the Revised Algol-60 Language Report.  It is activated by passing
     one of two corresponding styles as an option:
-
+    
     `algol`
         render reserved words lowercase underline boldface
         and builtins lowercase boldface italic
     `algol_nu`
         render reserved words lowercase boldface (no underlining)
         and builtins lowercase boldface italic
-
+    
     The lexer automatically performs the required lowercase conversion when
     this mode is activated.
-
+    
     Example:
-
+    
     ``$ pygmentize -O full,style=algol -f latex -o /path/to/output /path/to/input``
         Render input file in Algol publication mode to LaTeX output.
-
-
+    
+    
     Rendering Mode of First Class ADT Identifiers:
-
+    
     The rendering of standard library first class ADT identifiers is controlled
     by option flag "treat_stdlib_adts_as_builtins".
-
+    
     When this option is turned on, standard library ADT identifiers are rendered
     as builtins.  When it is turned off, they are rendered as ordinary library
     identifiers.
-
+    
     `treat_stdlib_adts_as_builtins` (default: On)
-
+    
     The option is useful for dialects that support ADTs as first class objects
     and provide ADTs in the standard library that would otherwise be built-in.
-
+    
     At present, only Modula-2 R10 supports library ADTs as first class objects
     and therefore, no ADT identifiers are defined for any other dialects.
-
+    
     Example:
-
+    
     ``$ pygmentize -O full,dialect=m2r10,treat_stdlib_adts_as_builtins=Off ...``
         Render standard library ADTs as ordinary library types.
-
+    
     .. versionadded:: 1.3
-
+    
     .. versionchanged:: 2.1
        Added multi-dialect support.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     name = 'Modula-2'
     aliases = ['modula2', 'm2']
@@ -1301,6 +1307,17 @@
 
     # Set lexer to a specified dialect
     def set_dialect(self, dialect_id):
+        """
+
+        Parameters
+        ----------
+        dialect_id :
+            
+
+        Returns
+        -------
+
+        """
         #
         # if __debug__:
         #    print 'entered set_dialect with arg: ', dialect_id
@@ -1403,6 +1420,17 @@
     # the extracted name against known dialects.  If a match is found,  the
     # matching name is returned, otherwise dialect id 'unknown' is returned
     def get_dialect_from_dialect_tag(self, dialect_tag):
+        """
+
+        Parameters
+        ----------
+        dialect_tag :
+            
+
+        Returns
+        -------
+
+        """
         #
         # if __debug__:
         #    print 'entered get_dialect_from_dialect_tag with arg: ', dialect_tag
@@ -1451,6 +1479,17 @@
 
     # intercept the token stream, modify token attributes and return them
     def get_tokens_unprocessed(self, text):
+        """
+
+        Parameters
+        ----------
+        text :
+            
+
+        Returns
+        -------
+
+        """
         for index, token, value in RegexLexer.get_tokens_unprocessed(self, text):
             #
             # check for dialect tag if dialect has not been set by tag
@@ -1562,7 +1601,17 @@
 
     def analyse_text(text):
         """It's Pascal-like, but does not use FUNCTION -- uses PROCEDURE
-        instead."""
+        instead.
+
+        Parameters
+        ----------
+        text :
+            
+
+        Returns
+        -------
+
+        """
 
         # Check if this looks like Pascal, if not, bail out early
         if not ('(*' in text and '*)' in text and ':=' in text):
