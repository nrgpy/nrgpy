# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/extension/decimal/test_decimal.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/extension/decimal/test_decimal.py
@@ -14,26 +14,31 @@
 
 @pytest.fixture
 def dtype():
+    """ """
     return DecimalDtype()
 
 
 @pytest.fixture
 def data():
+    """ """
     return DecimalArray(make_data())
 
 
 @pytest.fixture
 def data_for_twos():
+    """ """
     return DecimalArray([decimal.Decimal(2) for _ in range(100)])
 
 
 @pytest.fixture
 def data_missing():
+    """ """
     return DecimalArray([decimal.Decimal("NaN"), decimal.Decimal(1)])
 
 
 @pytest.fixture
 def data_for_sorting():
+    """ """
     return DecimalArray(
         [decimal.Decimal("1"), decimal.Decimal("2"), decimal.Decimal("0")]
     )
@@ -41,6 +46,7 @@
 
 @pytest.fixture
 def data_missing_for_sorting():
+    """ """
     return DecimalArray(
         [decimal.Decimal("1"), decimal.Decimal("NaN"), decimal.Decimal("0")]
     )
@@ -48,16 +54,19 @@
 
 @pytest.fixture
 def na_cmp():
+    """ """
     return lambda x, y: x.is_nan() and y.is_nan()
 
 
 @pytest.fixture
 def na_value():
+    """ """
     return decimal.Decimal("NaN")
 
 
 @pytest.fixture
 def data_for_grouping():
+    """ """
     b = decimal.Decimal("1.0")
     a = decimal.Decimal("0.0")
     c = decimal.Decimal("2.0")
@@ -66,9 +75,38 @@
 
 
 class BaseDecimal:
+    """ """
     @classmethod
     def assert_series_equal(cls, left, right, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+        right :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         def convert(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             # need to convert array([Decimal(NaN)], dtype='object') to np.NaN
             # because Series[object].isnan doesn't recognize decimal(NaN) as
             # NA.
@@ -91,6 +129,23 @@
 
     @classmethod
     def assert_frame_equal(cls, left, right, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        left :
+            
+        right :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         # TODO(EA): select_dtypes
         tm.assert_index_equal(
             left.columns,
@@ -113,27 +168,55 @@
 
 
 class TestDtype(BaseDecimal, base.BaseDtypeTests):
+    """ """
     def test_hashable(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
 
 class TestInterface(BaseDecimal, base.BaseInterfaceTests):
+    """ """
     pass
 
 
 class TestConstructors(BaseDecimal, base.BaseConstructorsTests):
+    """ """
     @pytest.mark.skip(reason="not implemented constructor from dtype")
     def test_from_dtype(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # construct from our dtype & string dtype
         pass
 
 
 class TestReshaping(BaseDecimal, base.BaseReshapingTests):
+    """ """
     pass
 
 
 class TestGetitem(BaseDecimal, base.BaseGetitemTests):
+    """ """
     def test_take_na_value_other_decimal(self):
+        """ """
         arr = DecimalArray([decimal.Decimal("1.0"), decimal.Decimal("2.0")])
         result = arr.take([0, -1], allow_fill=True, fill_value=decimal.Decimal("-1.0"))
         expected = DecimalArray([decimal.Decimal("1.0"), decimal.Decimal("-1.0")])
@@ -141,11 +224,28 @@
 
 
 class TestMissing(BaseDecimal, base.BaseMissingTests):
+    """ """
     pass
 
 
 class Reduce:
+    """ """
     def check_reduce(self, s, op_name, skipna):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
 
         if op_name in ["median", "skew", "kurt"]:
             msg = r"decimal does not support the .* operation"
@@ -159,17 +259,33 @@
 
 
 class TestNumericReduce(Reduce, base.BaseNumericReduceTests):
+    """ """
     pass
 
 
 class TestBooleanReduce(Reduce, base.BaseBooleanReduceTests):
+    """ """
     pass
 
 
 class TestMethods(BaseDecimal, base.BaseMethodsTests):
+    """ """
     @pytest.mark.parametrize("dropna", [True, False])
     @pytest.mark.xfail(reason="value_counts not implemented yet.")
     def test_value_counts(self, all_data, dropna):
+        """
+
+        Parameters
+        ----------
+        all_data :
+            
+        dropna :
+            
+
+        Returns
+        -------
+
+        """
         all_data = all_data[:10]
         if dropna:
             other = np.array(all_data[~all_data.isna()])
@@ -183,27 +299,64 @@
 
     @pytest.mark.xfail(reason="value_counts not implemented yet.")
     def test_value_counts_with_normalize(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         return super().test_value_counts_with_normalize(data)
 
 
 class TestCasting(BaseDecimal, base.BaseCastingTests):
+    """ """
     pass
 
 
 class TestGroupby(BaseDecimal, base.BaseGroupbyTests):
+    """ """
     @pytest.mark.xfail(
         reason="needs to correctly define __eq__ to handle nans, xref #27081."
     )
     def test_groupby_apply_identity(self, data_for_grouping):
+        """
+
+        Parameters
+        ----------
+        data_for_grouping :
+            
+
+        Returns
+        -------
+
+        """
         super().test_groupby_apply_identity(data_for_grouping)
 
 
 class TestSetitem(BaseDecimal, base.BaseSetitemTests):
+    """ """
     pass
 
 
 class TestPrinting(BaseDecimal, base.BasePrintingTests):
+    """ """
     def test_series_repr(self, data):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+
+        Returns
+        -------
+
+        """
         # Overriding this base test to explicitly test that
         # the custom _formatter is used
         ser = pd.Series(data)
@@ -218,6 +371,7 @@
     )
 )
 def test_series_constructor_coerce_data_to_extension_dtype_raises():
+    """ """
     xpr = (
         "Cannot cast data to extension dtype 'decimal'. Pass the "
         "extension array directly."
@@ -227,6 +381,7 @@
 
 
 def test_series_constructor_with_dtype():
+    """ """
     arr = DecimalArray([decimal.Decimal("10.0")])
     result = pd.Series(arr, dtype=DecimalDtype())
     expected = pd.Series(arr)
@@ -238,6 +393,7 @@
 
 
 def test_dataframe_constructor_with_dtype():
+    """ """
     arr = DecimalArray([decimal.Decimal("10.0")])
 
     result = pd.DataFrame({"A": arr}, dtype=DecimalDtype())
@@ -252,6 +408,17 @@
 
 @pytest.mark.parametrize("frame", [True, False])
 def test_astype_dispatches(frame):
+    """
+
+    Parameters
+    ----------
+    frame :
+        
+
+    Returns
+    -------
+
+    """
     # This is a dtype-specific test that ensures Series[decimal].astype
     # gets all the way through to ExtensionArray.astype
     # Designing a reliable smoke test that works for arbitrary data types
@@ -272,10 +439,41 @@
 
 
 class TestArithmeticOps(BaseDecimal, base.BaseArithmeticOpsTests):
+    """ """
     def check_opname(self, s, op_name, other, exc=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        other :
+            
+        exc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         super().check_opname(s, op_name, other, exc=None)
 
     def test_arith_series_with_array(self, data, all_arithmetic_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_arithmetic_operators :
+            
+
+        Returns
+        -------
+
+        """
         op_name = all_arithmetic_operators
         s = pd.Series(data)
 
@@ -298,26 +496,105 @@
         context.traps[decimal.InvalidOperation] = invalidoptrap
 
     def _check_divmod_op(self, s, op, other, exc=NotImplementedError):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op :
+            
+        other :
+            
+        exc :
+             (Default value = NotImplementedError)
+
+        Returns
+        -------
+
+        """
         # We implement divmod
         super()._check_divmod_op(s, op, other, exc=None)
 
     def test_error(self):
+        """ """
         pass
 
 
 class TestComparisonOps(BaseDecimal, base.BaseComparisonOpsTests):
+    """ """
     def check_opname(self, s, op_name, other, exc=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        op_name :
+            
+        other :
+            
+        exc :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         super().check_opname(s, op_name, other, exc=None)
 
     def _compare_other(self, s, data, op_name, other):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        data :
+            
+        op_name :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         self.check_opname(s, op_name, other)
 
     def test_compare_scalar(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         op_name = all_compare_operators
         s = pd.Series(data)
         self._compare_other(s, data, op_name, 0.5)
 
     def test_compare_array(self, data, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        data :
+            
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         op_name = all_compare_operators
         s = pd.Series(data)
 
@@ -331,12 +608,39 @@
     """Helper class for testing error handling in _from_sequence."""
 
     def _from_sequence(cls, scalars, dtype=None, copy=False):
+        """
+
+        Parameters
+        ----------
+        scalars :
+            
+        dtype :
+             (Default value = None)
+        copy :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         raise KeyError("For the test")
 
 
 class DecimalArrayWithoutCoercion(DecimalArrayWithoutFromSequence):
+    """ """
     @classmethod
     def _create_arithmetic_method(cls, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         return cls._create_method(op, coerce_to_dtype=False)
 
 
@@ -344,6 +648,7 @@
 
 
 def test_combine_from_sequence_raises():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/22850
     ser = pd.Series(
         DecimalArrayWithoutFromSequence(
@@ -363,6 +668,17 @@
     "class_", [DecimalArrayWithoutFromSequence, DecimalArrayWithoutCoercion]
 )
 def test_scalar_ops_from_sequence_raises(class_):
+    """
+
+    Parameters
+    ----------
+    class_ :
+        
+
+    Returns
+    -------
+
+    """
     # op(EA, EA) should return an EA, or an ndarray if it's not possible
     # to return an EA with the return values.
     arr = class_([decimal.Decimal("1.0"), decimal.Decimal("2.0")])
@@ -378,6 +694,21 @@
     [(False, [0, 1, 1, 2], [1, 0, 1, 0]), (True, [2, 1, 0, 0], [0, 0, 2, 2])],
 )
 def test_divmod_array(reverse, expected_div, expected_mod):
+    """
+
+    Parameters
+    ----------
+    reverse :
+        
+    expected_div :
+        
+    expected_mod :
+        
+
+    Returns
+    -------
+
+    """
     # https://github.com/pandas-dev/pandas/issues/22930
     arr = to_decimal([1, 2, 3, 4])
     if reverse:
@@ -392,6 +723,17 @@
 
 
 def test_ufunc_fallback(data):
+    """
+
+    Parameters
+    ----------
+    data :
+        
+
+    Returns
+    -------
+
+    """
     a = data[:5]
     s = pd.Series(a, index=range(3, 8))
     result = np.abs(s)
@@ -400,6 +742,7 @@
 
 
 def test_array_ufunc():
+    """ """
     a = to_decimal([1, 2, 3])
     result = np.exp(a)
     expected = to_decimal(np.exp(a._data))
@@ -407,6 +750,7 @@
 
 
 def test_array_ufunc_series():
+    """ """
     a = to_decimal([1, 2, 3])
     s = pd.Series(a)
     result = np.exp(s)
@@ -415,6 +759,7 @@
 
 
 def test_array_ufunc_series_scalar_other():
+    """ """
     # check _HANDLED_TYPES
     a = to_decimal([1, 2, 3])
     s = pd.Series(a)
@@ -424,6 +769,7 @@
 
 
 def test_array_ufunc_series_defer():
+    """ """
     a = to_decimal([1, 2, 3])
     s = pd.Series(a)
 
@@ -436,6 +782,7 @@
 
 
 def test_groupby_agg():
+    """ """
     # Ensure that the result of agg is inferred to be decimal dtype
     # https://github.com/pandas-dev/pandas/issues/29141
 
@@ -468,10 +815,22 @@
 
 
 def test_groupby_agg_ea_method(monkeypatch):
+    """
+
+    Parameters
+    ----------
+    monkeypatch :
+        
+
+    Returns
+    -------
+
+    """
     # Ensure that the result of agg is inferred to be decimal dtype
     # https://github.com/pandas-dev/pandas/issues/29141
 
     def DecimalArray__my_sum(self):
+        """ """
         return np.sum(np.array(self))
 
     monkeypatch.setattr(DecimalArray, "my_sum", DecimalArray__my_sum, raising=False)
@@ -488,11 +847,33 @@
 
 
 def test_indexing_no_materialize(monkeypatch):
+    """
+
+    Parameters
+    ----------
+    monkeypatch :
+        
+
+    Returns
+    -------
+
+    """
     # See https://github.com/pandas-dev/pandas/issues/29708
     # Ensure that indexing operations do not materialize (convert to a numpy
     # array) the ExtensionArray unnecessary
 
     def DecimalArray__array__(self, dtype=None):
+        """
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise Exception("tried to convert a DecimalArray to a numpy array")
 
     monkeypatch.setattr(DecimalArray, "__array__", DecimalArray__array__, raising=False)
@@ -509,6 +890,7 @@
 
 
 def test_to_numpy_keyword():
+    """ """
     # test the extra keyword
     values = [decimal.Decimal("1.1111"), decimal.Decimal("2.2222")]
     expected = np.array(
