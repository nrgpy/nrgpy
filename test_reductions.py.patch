# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/reductions/test_reductions.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/reductions/test_reductions.py
@@ -26,6 +26,7 @@
 
 
 def get_objs():
+    """ """
     indexes = [
         tm.makeBoolIndex(10, name="a"),
         tm.makeIntIndex(10, name="a"),
@@ -48,9 +49,23 @@
 
 
 class TestReductions:
+    """ """
     @pytest.mark.parametrize("opname", ["max", "min"])
     @pytest.mark.parametrize("obj", objs)
     def test_ops(self, opname, obj):
+        """
+
+        Parameters
+        ----------
+        opname :
+            
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         result = getattr(obj, opname)()
         if not isinstance(obj, PeriodIndex):
             expected = getattr(obj.values, opname)()
@@ -76,6 +91,23 @@
         ],
     )
     def test_nanminmax(self, opname, dtype, val, index_or_series):
+        """
+
+        Parameters
+        ----------
+        opname :
+            
+        dtype :
+            
+        val :
+            
+        index_or_series :
+            
+
+        Returns
+        -------
+
+        """
         # GH#7261
         klass = index_or_series
 
@@ -83,6 +115,17 @@
             pytest.skip("EAs can't yet be stored in an index")
 
         def check_missing(res):
+            """
+
+            Parameters
+            ----------
+            res :
+                
+
+            Returns
+            -------
+
+            """
             if dtype == "datetime64[ns]":
                 return res is pd.NaT
             elif dtype == "Int64":
@@ -112,6 +155,19 @@
 
     @pytest.mark.parametrize("opname", ["max", "min"])
     def test_nanargminmax(self, opname, index_or_series):
+        """
+
+        Parameters
+        ----------
+        opname :
+            
+        index_or_series :
+            
+
+        Returns
+        -------
+
+        """
         # GH#7261
         klass = index_or_series
         arg_op = "arg" + opname if klass is Index else "idx" + opname
@@ -136,6 +192,21 @@
     @pytest.mark.parametrize("opname", ["max", "min"])
     @pytest.mark.parametrize("dtype", ["M8[ns]", "datetime64[ns, UTC]"])
     def test_nanops_empty_object(self, opname, index_or_series, dtype):
+        """
+
+        Parameters
+        ----------
+        opname :
+            
+        index_or_series :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         klass = index_or_series
         arg_op = "arg" + opname if klass is Index else "idx" + opname
 
@@ -150,6 +221,7 @@
             getattr(obj, arg_op)(skipna=False)
 
     def test_argminmax(self):
+        """ """
         obj = Index(np.arange(5, dtype="int64"))
         assert obj.argmin() == 0
         assert obj.argmax() == 4
@@ -180,6 +252,19 @@
 
     @pytest.mark.parametrize("op, expected_col", [["max", "a"], ["min", "b"]])
     def test_same_tz_min_max_axis_1(self, op, expected_col):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+        expected_col :
+            
+
+        Returns
+        -------
+
+        """
         # GH 10390
         df = DataFrame(
             pd.date_range("2016-01-01 00:00:00", periods=3, tz="UTC"), columns=["a"]
@@ -191,6 +276,19 @@
 
     @pytest.mark.parametrize("func", ["maximum", "minimum"])
     def test_numpy_reduction_with_tz_aware_dtype(self, tz_aware_fixture, func):
+        """
+
+        Parameters
+        ----------
+        tz_aware_fixture :
+            
+        func :
+            
+
+        Returns
+        -------
+
+        """
         # GH 15552
         tz = tz_aware_fixture
         arg = pd.to_datetime(["2019"]).tz_localize(tz)
@@ -200,6 +298,7 @@
 
 
 class TestIndexReductions:
+    """ """
     # Note: the name TestIndexReductions indicates these tests
     #  were moved from a Index-specific test file, _not_ that these tests are
     #  intended long-term to be Index-specific
@@ -215,6 +314,21 @@
         ],
     )
     def test_max_min_range(self, start, stop, step):
+        """
+
+        Parameters
+        ----------
+        start :
+            
+        stop :
+            
+        step :
+            
+
+        Returns
+        -------
+
+        """
         # GH#17607
         idx = RangeIndex(start, stop, step)
         expected = idx._int64index.max()
@@ -239,6 +353,7 @@
         assert isna(idx.min())
 
     def test_minmax_timedelta64(self):
+        """ """
 
         # monotonic
         idx1 = TimedeltaIndex(["1 days", "2 days", "3 days"])
@@ -256,6 +371,17 @@
 
     @pytest.mark.parametrize("op", ["min", "max"])
     def test_minmax_timedelta_empty_or_na(self, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         # Return NaT
         obj = TimedeltaIndex([])
         assert getattr(obj, op)() is pd.NaT
@@ -267,6 +393,7 @@
         assert getattr(obj, op)() is pd.NaT
 
     def test_numpy_minmax_timedelta64(self):
+        """ """
         td = timedelta_range("16815 days", "16820 days", freq="D")
 
         assert np.min(td) == Timedelta("16815 days")
@@ -288,6 +415,7 @@
             np.argmax(td, out=0)
 
     def test_timedelta_ops(self):
+        """ """
         # GH#4984
         # make sure ops return Timedelta
         s = Series(
@@ -342,6 +470,17 @@
 
     @pytest.mark.parametrize("opname", ["skew", "kurt", "sem", "prod", "var"])
     def test_invalid_td64_reductions(self, opname):
+        """
+
+        Parameters
+        ----------
+        opname :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(
             [Timestamp("20130101") + timedelta(seconds=i * i) for i in range(10)]
         )
@@ -361,6 +500,17 @@
             getattr(td.to_frame(), opname)(numeric_only=False)
 
     def test_minmax_tz(self, tz_naive_fixture):
+        """
+
+        Parameters
+        ----------
+        tz_naive_fixture :
+            
+
+        Returns
+        -------
+
+        """
         tz = tz_naive_fixture
         # monotonic
         idx1 = pd.DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"], tz=tz)
@@ -380,6 +530,17 @@
 
     @pytest.mark.parametrize("op", ["min", "max"])
     def test_minmax_nat_datetime64(self, op):
+        """
+
+        Parameters
+        ----------
+        op :
+            
+
+        Returns
+        -------
+
+        """
         # Return NaT
         obj = DatetimeIndex([])
         assert pd.isna(getattr(obj, op)())
@@ -391,6 +552,7 @@
         assert pd.isna(getattr(obj, op)())
 
     def test_numpy_minmax_integer(self):
+        """ """
         # GH#26125
         idx = Index([1, 2, 3])
 
@@ -423,6 +585,7 @@
             np.argmax(idx, out=0)
 
     def test_numpy_minmax_range(self):
+        """ """
         # GH#26125
         idx = RangeIndex(0, 10, 3)
 
@@ -444,6 +607,7 @@
         # is the same as basic integer index
 
     def test_numpy_minmax_datetime64(self):
+        """ """
         dr = pd.date_range(start="2016-01-15", end="2016-01-20")
 
         assert np.min(dr) == Timestamp("2016-01-15 00:00:00", freq="D")
@@ -467,6 +631,7 @@
             np.argmax(dr, out=0)
 
     def test_minmax_period(self):
+        """ """
 
         # monotonic
         idx1 = pd.PeriodIndex([NaT, "2011-01-01", "2011-01-02", "2011-01-03"], freq="D")
@@ -502,6 +667,7 @@
             assert result is NaT
 
     def test_numpy_minmax_period(self):
+        """ """
         pr = pd.period_range(start="2016-01-15", end="2016-01-20")
 
         assert np.min(pr) == Period("2016-01-15", freq="D")
@@ -523,6 +689,7 @@
             np.argmax(pr, out=0)
 
     def test_min_max_categorical(self):
+        """ """
 
         ci = pd.CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
         with pytest.raises(TypeError):
@@ -536,11 +703,13 @@
 
 
 class TestSeriesReductions:
+    """ """
     # Note: the name TestSeriesReductions indicates these tests
     #  were moved from a series-specific test file, _not_ that these tests are
     #  intended long-term to be series-specific
 
     def test_sum_inf(self):
+        """ """
         s = Series(np.random.randn(10))
         s2 = s.copy()
 
@@ -562,6 +731,23 @@
     @pytest.mark.parametrize("use_bottleneck", [True, False])
     @pytest.mark.parametrize("method, unit", [("sum", 0.0), ("prod", 1.0)])
     def test_empty(self, method, unit, use_bottleneck, dtype):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        unit :
+            
+        use_bottleneck :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         with pd.option_context("use_bottleneck", use_bottleneck):
             # GH#9422 / GH#18921
             # Entirely empty
@@ -659,6 +845,19 @@
 
     @pytest.mark.parametrize("method, unit", [("sum", 0.0), ("prod", 1.0)])
     def test_empty_multi(self, method, unit):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+        unit :
+            
+
+        Returns
+        -------
+
+        """
         s = pd.Series(
             [1, np.nan, np.nan, np.nan],
             index=pd.MultiIndex.from_product([("a", "b"), (0, 1)]),
@@ -680,6 +879,17 @@
 
     @pytest.mark.parametrize("method", ["mean", "median", "std", "var"])
     def test_ops_consistency_on_empty(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
 
         # GH#7869
         # consistency on empty
@@ -704,12 +914,24 @@
             assert result is pd.NaT
 
     def test_nansum_buglet(self):
+        """ """
         ser = Series([1.0, np.nan], index=[0, 1])
         result = np.nansum(ser)
         tm.assert_almost_equal(result, 1)
 
     @pytest.mark.parametrize("use_bottleneck", [True, False])
     def test_sum_overflow(self, use_bottleneck):
+        """
+
+        Parameters
+        ----------
+        use_bottleneck :
+            
+
+        Returns
+        -------
+
+        """
 
         with pd.option_context("use_bottleneck", use_bottleneck):
             # GH#6915
@@ -737,6 +959,7 @@
                 assert np.allclose(float(result), v[-1])
 
     def test_empty_timeseries_reductions_return_nat(self):
+        """ """
         # covers GH#11245
         for dtype in ("m8[ns]", "m8[ns]", "M8[ns]", "M8[ns, UTC]"):
             assert Series([], dtype=dtype).min() is pd.NaT
@@ -745,6 +968,7 @@
             assert Series([], dtype=dtype).max(skipna=False) is pd.NaT
 
     def test_numpy_argmin(self):
+        """ """
         # See GH#16830
         data = np.arange(1, 11)
 
@@ -763,6 +987,7 @@
             np.argmin(s, out=data)
 
     def test_numpy_argmax(self):
+        """ """
         # See GH#16830
         data = np.arange(1, 11)
 
@@ -780,6 +1005,7 @@
             np.argmax(s, out=data)
 
     def test_idxmin(self):
+        """ """
         # test idxmin
         # _check_stat_op approach can not be used here because of isna check.
         string_series = tm.makeStringSeries().rename("series")
@@ -810,6 +1036,7 @@
         assert result == 1
 
     def test_idxmax(self):
+        """ """
         # test idxmax
         # _check_stat_op approach can not be used here because of isna check.
         string_series = tm.makeStringSeries().rename("series")
@@ -855,6 +1082,7 @@
         assert result == 1.1
 
     def test_all_any(self):
+        """ """
         ts = tm.makeTimeSeries()
         bool_series = ts > 0
         assert not bool_series.all()
@@ -865,6 +1093,7 @@
         assert "abc" == s.any()  # 'abc' || True => 'abc'
 
     def test_all_any_params(self):
+        """ """
         # Check skipna, with implicit 'object' dtype.
         s1 = Series([np.nan, True])
         s2 = Series([np.nan, False])
@@ -891,6 +1120,7 @@
             s.all(bool_only=True)
 
     def test_all_any_boolean(self):
+        """ """
         # Check skipna, with boolean type
         s1 = Series([pd.NA, True], dtype="boolean")
         s2 = Series([pd.NA, False], dtype="boolean")
@@ -915,6 +1145,7 @@
         tm.assert_series_equal(s.any(level=0), Series([False, True, True]))
 
     def test_timedelta64_analytics(self):
+        """ """
 
         # index min/max
         dti = pd.date_range("2012-1-1", periods=3, freq="D")
@@ -968,8 +1199,18 @@
         ],
     )
     def test_assert_idxminmax_raises(self, test_input, error_type):
-        """
-        Cases where ``Series.argmax`` and related should raise an exception
+        """Cases where ``Series.argmax`` and related should raise an exception
+
+        Parameters
+        ----------
+        test_input :
+            
+        error_type :
+            
+
+        Returns
+        -------
+
         """
         with pytest.raises(error_type):
             test_input.idxmin()
@@ -981,6 +1222,7 @@
             test_input.idxmax(skipna=False)
 
     def test_idxminmax_with_inf(self):
+        """ """
         # For numeric data with NA and Inf (GH #13595)
         s = pd.Series([0, -np.inf, np.inf, np.nan])
 
@@ -1000,6 +1242,7 @@
 
 
 class TestDatetime64SeriesReductions:
+    """ """
     # Note: the name TestDatetime64SeriesReductions indicates these tests
     #  were moved from a series-specific test file, _not_ that these tests are
     #  intended long-term to be series-specific
@@ -1013,6 +1256,17 @@
         ],
     )
     def test_minmax_nat_series(self, nat_ser):
+        """
+
+        Parameters
+        ----------
+        nat_ser :
+            
+
+        Returns
+        -------
+
+        """
         # GH#23282
         assert nat_ser.min() is pd.NaT
         assert nat_ser.max() is pd.NaT
@@ -1028,6 +1282,17 @@
         ],
     )
     def test_minmax_nat_dataframe(self, nat_df):
+        """
+
+        Parameters
+        ----------
+        nat_df :
+            
+
+        Returns
+        -------
+
+        """
         # GH#23282
         assert nat_df.min()[0] is pd.NaT
         assert nat_df.max()[0] is pd.NaT
@@ -1035,6 +1300,7 @@
         assert nat_df.max(skipna=False)[0] is pd.NaT
 
     def test_min_max(self):
+        """ """
         rng = pd.date_range("1/1/2000", "12/31/2000")
         rng2 = rng.take(np.random.permutation(len(rng)))
 
@@ -1049,6 +1315,7 @@
         assert rng.max() == rng[-1]
 
     def test_min_max_series(self):
+        """ """
         rng = pd.date_range("1/1/2000", periods=10, freq="4h")
         lvls = ["A", "A", "A", "B", "B", "B", "C", "C", "C", "C"]
         df = DataFrame({"TS": rng, "V": np.random.randn(len(rng)), "L": lvls})
@@ -1065,12 +1332,24 @@
 
 
 class TestCategoricalSeriesReductions:
+    """ """
     # Note: the name TestCategoricalSeriesReductions indicates these tests
     #  were moved from a series-specific test file, _not_ that these tests are
     #  intended long-term to be series-specific
 
     @pytest.mark.parametrize("function", ["min", "max"])
     def test_min_max_unordered_raises(self, function):
+        """
+
+        Parameters
+        ----------
+        function :
+            
+
+        Returns
+        -------
+
+        """
         # unordered cats have no min/max
         cat = Series(Categorical(["a", "b", "c", "d"], ordered=False))
         msg = f"Categorical is not ordered for operation {function}"
@@ -1089,6 +1368,21 @@
     )
     @pytest.mark.parametrize("function", ["min", "max"])
     def test_min_max_ordered(self, values, categories, function):
+        """
+
+        Parameters
+        ----------
+        values :
+            
+        categories :
+            
+        function :
+            
+
+        Returns
+        -------
+
+        """
         # GH 25303
         cat = Series(Categorical(values, categories=categories, ordered=True))
         result = getattr(cat, function)(skipna=True)
@@ -1098,6 +1392,19 @@
     @pytest.mark.parametrize("function", ["min", "max"])
     @pytest.mark.parametrize("skipna", [True, False])
     def test_min_max_ordered_with_nan_only(self, function, skipna):
+        """
+
+        Parameters
+        ----------
+        function :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/issues/33450
         cat = Series(Categorical([np.nan], categories=[1, 2], ordered=True))
         result = getattr(cat, function)(skipna=skipna)
@@ -1106,6 +1413,19 @@
     @pytest.mark.parametrize("function", ["min", "max"])
     @pytest.mark.parametrize("skipna", [True, False])
     def test_min_max_skipna(self, function, skipna):
+        """
+
+        Parameters
+        ----------
+        function :
+            
+        skipna :
+            
+
+        Returns
+        -------
+
+        """
         cat = Series(
             Categorical(["a", "b", np.nan, "a"], categories=["b", "a"], ordered=True)
         )
@@ -1119,6 +1439,7 @@
 
 
 class TestSeriesMode:
+    """ """
     # Note: the name TestSeriesMode indicates these tests
     #  were moved from a series-specific test file, _not_ that these tests are
     #  intended long-term to be series-specific
@@ -1128,6 +1449,19 @@
         [(True, Series([], dtype=np.float64)), (False, Series([], dtype=np.float64))],
     )
     def test_mode_empty(self, dropna, expected):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         s = Series([], dtype=np.float64)
         result = s.mode(dropna)
         tm.assert_series_equal(result, expected)
@@ -1145,6 +1479,23 @@
         "dt", list(np.typecodes["AllInteger"] + np.typecodes["Float"])
     )
     def test_mode_numerical(self, dropna, data, expected, dt):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        data :
+            
+        expected :
+            
+        dt :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(data, dtype=dt)
         result = s.mode(dropna)
         expected = Series(expected, dtype=dt)
@@ -1152,6 +1503,19 @@
 
     @pytest.mark.parametrize("dropna, expected", [(True, [1.0]), (False, [1, np.nan])])
     def test_mode_numerical_nan(self, dropna, expected):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         s = Series([1, 1, 2, np.nan, np.nan])
         result = s.mode(dropna)
         expected = Series(expected)
@@ -1162,6 +1526,23 @@
         [(True, ["b"], ["bar"], ["nan"]), (False, ["b"], [np.nan], ["nan"])],
     )
     def test_mode_str_obj(self, dropna, expected1, expected2, expected3):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+        expected3 :
+            
+
+        Returns
+        -------
+
+        """
         # Test string and object types.
         data = ["a"] * 2 + ["b"] * 3
 
@@ -1189,6 +1570,21 @@
         [(True, ["foo"], ["foo"]), (False, ["foo"], [np.nan])],
     )
     def test_mode_mixeddtype(self, dropna, expected1, expected2):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+
+        Returns
+        -------
+
+        """
         s = Series([1, "foo", "foo"])
         result = s.mode(dropna)
         expected = Series(expected1)
@@ -1211,6 +1607,21 @@
         ],
     )
     def test_mode_datetime(self, dropna, expected1, expected2):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(
             ["2011-01-03", "2013-01-02", "1900-05-03", "nan", "nan"], dtype="M8[ns]"
         )
@@ -1242,6 +1653,21 @@
         ],
     )
     def test_mode_timedelta(self, dropna, expected1, expected2):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+
+        Returns
+        -------
+
+        """
         # gh-5986: Test timedelta types.
 
         s = Series(
@@ -1286,6 +1712,23 @@
         ],
     )
     def test_mode_category(self, dropna, expected1, expected2, expected3):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+        expected3 :
+            
+
+        Returns
+        -------
+
+        """
         s = Series(Categorical([1, 2, np.nan, np.nan]))
         result = s.mode(dropna)
         expected1 = Series(expected1, dtype="category")
@@ -1310,6 +1753,21 @@
         [(True, [2 ** 63], [1, 2 ** 63]), (False, [2 ** 63], [1, 2 ** 63])],
     )
     def test_mode_intoverflow(self, dropna, expected1, expected2):
+        """
+
+        Parameters
+        ----------
+        dropna :
+            
+        expected1 :
+            
+        expected2 :
+            
+
+        Returns
+        -------
+
+        """
         # Test for uint64 overflow.
         s = Series([1, 2 ** 63, 2 ** 63], dtype=np.uint64)
         result = s.mode(dropna)
@@ -1322,6 +1780,7 @@
         tm.assert_series_equal(result, expected2)
 
     def test_mode_sortwarning(self):
+        """ """
         # Check for the warning that is raised when the mode
         # results cannot be sorted
 
