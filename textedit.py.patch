# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pygments/lexers/textedit.py
+++ b/..//venv/lib/python3.8/site-packages/pygments/lexers/textedit.py
@@ -22,10 +22,16 @@
 
 
 class AwkLexer(RegexLexer):
-    """
-    For Awk scripts.
-
+    """For Awk scripts.
+    
     .. versionadded:: 1.5
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     name = 'Awk'
@@ -76,10 +82,16 @@
 
 
 class VimLexer(RegexLexer):
-    """
-    Lexer for VimL script files.
-
+    """Lexer for VimL script files.
+    
     .. versionadded:: 0.8
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     name = 'VimL'
     aliases = ['vim']
@@ -129,18 +141,27 @@
         RegexLexer.__init__(self, **options)
 
     def is_in(self, w, mapping):
-        r"""
+        """r"""
         It's kind of difficult to decide if something might be a keyword
         in VimL because it allows you to abbreviate them.  In fact,
         'ab[breviate]' is a good example.  :ab, :abbre, or :abbreviate are
         valid ways to call it so rather than making really awful regexps
         like::
-
+        
             \bab(?:b(?:r(?:e(?:v(?:i(?:a(?:t(?:e)?)?)?)?)?)?)?)?\b
-
+        
         we match `\b\w+\b` and then call is_in() on those tokens.  See
         `scripts/get_vimkw.py` for how the lists are extracted.
-        """
+
+        Parameters
+        ----------
+        w :
+            
+        mapping :
+            
+
+        Returns
+        -------
         p = bisect(mapping, (w,))
         if p > 0:
             if mapping[p-1][0] == w[:len(mapping[p-1][0])] and \
@@ -152,6 +173,17 @@
         return False
 
     def get_tokens_unprocessed(self, text):
+        """
+
+        Parameters
+        ----------
+        text :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: builtins are only subsequent tokens on lines
         #       and 'keywords' only happen at the beginning except
         #       for :au ones
