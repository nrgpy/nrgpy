# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jsonschema/tests/test_exceptions.py
+++ b/..//venv/lib/python3.8/site-packages/jsonschema/tests/test_exceptions.py
@@ -6,7 +6,19 @@
 
 
 class TestBestMatch(TestCase):
+    """ """
     def best_match(self, errors):
+        """
+
+        Parameters
+        ----------
+        errors :
+            
+
+        Returns
+        -------
+
+        """
         errors = list(errors)
         best = exceptions.best_match(errors)
         reversed_best = exceptions.best_match(reversed(errors))
@@ -18,6 +30,7 @@
         return best
 
     def test_shallower_errors_are_better_matches(self):
+        """ """
         validator = Draft4Validator(
             {
                 "properties": {
@@ -32,9 +45,15 @@
         self.assertEqual(best.validator, "minProperties")
 
     def test_oneOf_and_anyOf_are_weak_matches(self):
-        """
-        A property you *must* match is probably better than one you have to
+        """A property you *must* match is probably better than one you have to
         match a part of.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         validator = Draft4Validator(
@@ -48,13 +67,19 @@
         self.assertEqual(best.validator, "minProperties")
 
     def test_if_the_most_relevant_error_is_anyOf_it_is_traversed(self):
-        """
-        If the most relevant error is an anyOf, then we traverse its context
+        """If the most relevant error is an anyOf, then we traverse its context
         and select the otherwise *least* relevant error, since in this case
         that means the most specific, deep, error inside the instance.
-
+        
         I.e. since only one of the schemas must match, we look for the most
         relevant one.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         validator = Draft4Validator(
@@ -73,13 +98,19 @@
         self.assertEqual(best.validator_value, "array")
 
     def test_if_the_most_relevant_error_is_oneOf_it_is_traversed(self):
-        """
-        If the most relevant error is an oneOf, then we traverse its context
+        """If the most relevant error is an oneOf, then we traverse its context
         and select the otherwise *least* relevant error, since in this case
         that means the most specific, deep, error inside the instance.
-
+        
         I.e. since only one of the schemas must match, we look for the most
         relevant one.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         validator = Draft4Validator(
@@ -98,9 +129,15 @@
         self.assertEqual(best.validator_value, "array")
 
     def test_if_the_most_relevant_error_is_allOf_it_is_traversed(self):
-        """
-        Now, if the error is allOf, we traverse but select the *most* relevant
+        """Now, if the error is allOf, we traverse but select the *most* relevant
         error from the context, because all schemas here must match anyways.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         validator = Draft4Validator(
@@ -119,6 +156,7 @@
         self.assertEqual(best.validator_value, "string")
 
     def test_nested_context_for_oneOf(self):
+        """ """
         validator = Draft4Validator(
             {
                 "properties": {
@@ -144,6 +182,7 @@
         self.assertEqual(best.validator_value, "array")
 
     def test_one_error(self):
+        """ """
         validator = Draft4Validator({"minProperties": 2})
         error, = validator.iter_errors({})
         self.assertEqual(
@@ -152,12 +191,15 @@
         )
 
     def test_no_errors(self):
+        """ """
         validator = Draft4Validator({})
         self.assertIsNone(exceptions.best_match(validator.iter_errors({})))
 
 
 class TestByRelevance(TestCase):
+    """ """
     def test_short_paths_are_better_matches(self):
+        """ """
         shallow = exceptions.ValidationError("Oh no!", path=["baz"])
         deep = exceptions.ValidationError("Oh yes!", path=["foo", "bar"])
         match = max([shallow, deep], key=exceptions.relevance)
@@ -167,6 +209,7 @@
         self.assertIs(match, shallow)
 
     def test_global_errors_are_even_better_matches(self):
+        """ """
         shallow = exceptions.ValidationError("Oh no!", path=[])
         deep = exceptions.ValidationError("Oh yes!", path=["foo"])
 
@@ -183,6 +226,7 @@
         )
 
     def test_weak_validators_are_lower_priority(self):
+        """ """
         weak = exceptions.ValidationError("Oh no!", path=[], validator="a")
         normal = exceptions.ValidationError("Oh yes!", path=[], validator="b")
 
@@ -195,6 +239,7 @@
         self.assertIs(match, normal)
 
     def test_strong_validators_are_higher_priority(self):
+        """ """
         weak = exceptions.ValidationError("Oh no!", path=[], validator="a")
         normal = exceptions.ValidationError("Oh yes!", path=[], validator="b")
         strong = exceptions.ValidationError("Oh fine!", path=[], validator="c")
@@ -209,7 +254,9 @@
 
 
 class TestErrorTree(TestCase):
+    """ """
     def test_it_knows_how_many_total_errors_it_contains(self):
+        """ """
         # FIXME: https://github.com/Julian/jsonschema/issues/442
         errors = [
             exceptions.ValidationError("Something", validator=i)
@@ -219,21 +266,25 @@
         self.assertEqual(tree.total_errors, 8)
 
     def test_it_contains_an_item_if_the_item_had_an_error(self):
+        """ """
         errors = [exceptions.ValidationError("a message", path=["bar"])]
         tree = exceptions.ErrorTree(errors)
         self.assertIn("bar", tree)
 
     def test_it_does_not_contain_an_item_if_the_item_had_no_error(self):
+        """ """
         errors = [exceptions.ValidationError("a message", path=["bar"])]
         tree = exceptions.ErrorTree(errors)
         self.assertNotIn("foo", tree)
 
     def test_validators_that_failed_appear_in_errors_dict(self):
+        """ """
         error = exceptions.ValidationError("a message", validator="foo")
         tree = exceptions.ErrorTree([error])
         self.assertEqual(tree.errors, {"foo": error})
 
     def test_it_creates_a_child_tree_for_each_nested_path(self):
+        """ """
         errors = [
             exceptions.ValidationError("a bar message", path=["bar"]),
             exceptions.ValidationError("a bar -> 0 message", path=["bar", 0]),
@@ -243,6 +294,7 @@
         self.assertNotIn(1, tree["bar"])
 
     def test_children_have_their_errors_dicts_built(self):
+        """ """
         e1, e2 = (
             exceptions.ValidationError("1", validator="foo", path=["bar", 0]),
             exceptions.ValidationError("2", validator="quux", path=["bar", 0]),
@@ -251,6 +303,7 @@
         self.assertEqual(tree["bar"][0].errors, {"foo": e1, "quux": e2})
 
     def test_multiple_errors_with_instance(self):
+        """ """
         e1, e2 = (
             exceptions.ValidationError(
                 "1",
@@ -266,6 +319,7 @@
         exceptions.ErrorTree([e1, e2])
 
     def test_it_does_not_contain_subtrees_that_are_not_in_the_instance(self):
+        """ """
         error = exceptions.ValidationError("123", validator="foo", instance=[])
         tree = exceptions.ErrorTree([error])
 
@@ -273,10 +327,16 @@
             tree[0]
 
     def test_if_its_in_the_tree_anyhow_it_does_not_raise_an_error(self):
-        """
-        If a validator is dumb (like :validator:`required` in draft 3) and
+        """If a validator is dumb (like :validator:`required` in draft 3) and
         refers to a path that isn't in the instance, the tree still properly
         returns a subtree for that path.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         error = exceptions.ValidationError(
@@ -287,7 +347,19 @@
 
 
 class TestErrorInitReprStr(TestCase):
+    """ """
     def make_error(self, **kwargs):
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         defaults = dict(
             message=u"hello",
             validator=u"type",
@@ -299,6 +371,19 @@
         return exceptions.ValidationError(**defaults)
 
     def assertShows(self, expected, **kwargs):
+        """
+
+        Parameters
+        ----------
+        expected :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if PY3:  # pragma: no cover
             expected = expected.replace("u'", "'")
         expected = textwrap.dedent(expected).rstrip("\n")
@@ -309,16 +394,19 @@
         self.assertEqual(rest, expected)
 
     def test_it_calls_super_and_sets_args(self):
+        """ """
         error = self.make_error()
         self.assertGreater(len(error.args), 1)
 
     def test_repr(self):
+        """ """
         self.assertEqual(
             repr(exceptions.ValidationError(message="Hello!")),
             "<ValidationError: %r>" % "Hello!",
         )
 
     def test_unset_error(self):
+        """ """
         error = exceptions.ValidationError("message")
         self.assertEqual(str(error), "message")
 
@@ -336,6 +424,7 @@
             self.assertEqual(str(error), "message")
 
     def test_empty_paths(self):
+        """ """
         self.assertShows(
             """
             Failed validating u'type' in schema:
@@ -349,6 +438,7 @@
         )
 
     def test_one_item_paths(self):
+        """ """
         self.assertShows(
             """
             Failed validating u'type' in schema:
@@ -362,6 +452,7 @@
         )
 
     def test_multiple_item_paths(self):
+        """ """
         self.assertShows(
             """
             Failed validating u'type' in schema[u'items'][0]:
@@ -375,6 +466,7 @@
         )
 
     def test_uses_pprint(self):
+        """ """
         self.assertShows(
             """
             Failed validating u'maxLength' in schema:
@@ -432,13 +524,20 @@
         )
 
     def test_str_works_with_instances_having_overriden_eq_operator(self):
-        """
-        Check for https://github.com/Julian/jsonschema/issues/164 which
+        """Check for https://github.com/Julian/jsonschema/issues/164 which
         rendered exceptions unusable when a `ValidationError` involved
         instances with an `__eq__` method that returned truthy values.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
 
         class DontEQMeBro(object):
+            """ """
             def __eq__(this, other):  # pragma: no cover
                 self.fail("Don't!")
 
@@ -457,6 +556,8 @@
 
 
 class TestHashable(TestCase):
+    """ """
     def test_hashable(self):
+        """ """
         set([exceptions.ValidationError("")])
         set([exceptions.SchemaError("")])
