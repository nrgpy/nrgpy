# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_nditer.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_nditer.py
@@ -11,6 +11,17 @@
 
 
 def iter_multi_index(i):
+    """
+
+    Parameters
+    ----------
+    i :
+        
+
+    Returns
+    -------
+
+    """
     ret = []
     while not i.finished:
         ret.append(i.multi_index)
@@ -18,6 +29,17 @@
     return ret
 
 def iter_indices(i):
+    """
+
+    Parameters
+    ----------
+    i :
+        
+
+    Returns
+    -------
+
+    """
     ret = []
     while not i.finished:
         ret.append(i.index)
@@ -25,6 +47,17 @@
     return ret
 
 def iter_iterindices(i):
+    """
+
+    Parameters
+    ----------
+    i :
+        
+
+    Returns
+    -------
+
+    """
     ret = []
     while not i.finished:
         ret.append(i.iterindex)
@@ -33,6 +66,7 @@
 
 @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 def test_iter_refcount():
+    """ """
     # Make sure the iterator doesn't leak
 
     # Basic
@@ -75,6 +109,7 @@
     del it2  # avoid pyflakes unused variable warning
 
 def test_iter_best_order():
+    """ """
     # The iterator should always find the iteration order
     # with increasing memory addresses
 
@@ -102,6 +137,7 @@
                 assert_equal([x for x in i], a)
 
 def test_iter_c_order():
+    """ """
     # Test forcing C order
 
     # Test the ordering for 1-D to 5-D shapes
@@ -129,6 +165,7 @@
                                     aview.swapaxes(0, 1).ravel(order='C'))
 
 def test_iter_f_order():
+    """ """
     # Test forcing F order
 
     # Test the ordering for 1-D to 5-D shapes
@@ -156,6 +193,7 @@
                                     aview.swapaxes(0, 1).ravel(order='F'))
 
 def test_iter_c_or_f_order():
+    """ """
     # Test forcing any contiguous (C or F) order
 
     # Test the ordering for 1-D to 5-D shapes
@@ -183,6 +221,7 @@
                                     aview.swapaxes(0, 1).ravel(order='A'))
 
 def test_iter_best_order_multi_index_1d():
+    """ """
     # The multi-indices should be correct with any reordering
 
     a = arange(4)
@@ -194,6 +233,7 @@
     assert_equal(iter_multi_index(i), [(3,), (2,), (1,), (0,)])
 
 def test_iter_best_order_multi_index_2d():
+    """ """
     # The multi-indices should be correct with any reordering
 
     a = arange(6)
@@ -221,6 +261,7 @@
     assert_equal(iter_multi_index(i), [(1, 2), (0, 2), (1, 1), (0, 1), (1, 0), (0, 0)])
 
 def test_iter_best_order_multi_index_3d():
+    """ """
     # The multi-indices should be correct with any reordering
 
     a = arange(12)
@@ -265,6 +306,7 @@
                              (0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 2, 0), (1, 2, 0)])
 
 def test_iter_best_order_c_index_1d():
+    """ """
     # The C index should be correct with any reordering
 
     a = arange(4)
@@ -276,6 +318,7 @@
     assert_equal(iter_indices(i), [3, 2, 1, 0])
 
 def test_iter_best_order_c_index_2d():
+    """ """
     # The C index should be correct with any reordering
 
     a = arange(6)
@@ -305,6 +348,7 @@
     assert_equal(iter_indices(i), [5, 2, 4, 1, 3, 0])
 
 def test_iter_best_order_c_index_3d():
+    """ """
     # The C index should be correct with any reordering
 
     a = arange(12)
@@ -342,6 +386,7 @@
                             [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])
 
 def test_iter_best_order_f_index_1d():
+    """ """
     # The Fortran index should be correct with any reordering
 
     a = arange(4)
@@ -353,6 +398,7 @@
     assert_equal(iter_indices(i), [3, 2, 1, 0])
 
 def test_iter_best_order_f_index_2d():
+    """ """
     # The Fortran index should be correct with any reordering
 
     a = arange(6)
@@ -382,6 +428,7 @@
     assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])
 
 def test_iter_best_order_f_index_3d():
+    """ """
     # The Fortran index should be correct with any reordering
 
     a = arange(12)
@@ -419,6 +466,7 @@
                             [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
 
 def test_iter_no_inner_full_coalesce():
+    """ """
     # Check no_inner iterators which coalesce into a single inner loop
 
     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
@@ -449,6 +497,7 @@
                 assert_equal(i[0].shape, (size,))
 
 def test_iter_no_inner_dim_coalescing():
+    """ """
     # Check no_inner iterators whose dimensions may not coalesce completely
 
     # Skipping the last element in a dimension prevents coalescing
@@ -473,6 +522,7 @@
     assert_equal(i[0].shape, (24,))
 
 def test_iter_dim_coalescing():
+    """ """
     # Check that the correct number of dimensions are coalesced
 
     # Tracking a multi-index disables coalescing
@@ -509,6 +559,7 @@
     assert_equal(i.ndim, 1)
 
 def test_iter_broadcasting():
+    """ """
     # Standard NumPy broadcasting rules
 
     # 1D with scalar
@@ -579,6 +630,7 @@
     assert_equal(i.shape, (4, 2, 3))
 
 def test_iter_itershape():
+    """ """
     # Check that allocated outputs work with a specified shape
     a = np.arange(6, dtype='i2').reshape(2, 3)
     i = nditer([a, None], [], [['readonly'], ['writeonly', 'allocate']],
@@ -610,6 +662,7 @@
     i = np.nditer([np.ones(2), None, None], itershape=(2,))
 
 def test_iter_broadcasting_errors():
+    """ """
     # Check that errors are thrown for bad broadcasting shapes
 
     # 1D with 1D
@@ -685,6 +738,7 @@
                 'Message "%s" doesn\'t contain the broadcast shape (2,1,2)' % msg)
 
 def test_iter_flags_errors():
+    """ """
     # Check that bad combinations of flags produce errors
 
     a = arange(6)
@@ -739,15 +793,59 @@
     # GotoCoords and GotoIndex incompatible with buffering or no_inner
 
     def assign_multi_index(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         i.multi_index = (0,)
 
     def assign_index(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         i.index = 0
 
     def assign_iterindex(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         i.iterindex = 0
 
     def assign_iterrange(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         i.iterrange = (0, 1)
     i = nditer(arange(6), ['external_loop'])
     assert_raises(ValueError, assign_multi_index, i)
@@ -762,6 +860,7 @@
     assert_raises(ValueError, nditer, np.array([]))
 
 def test_iter_slice():
+    """ """
     a, b, c = np.arange(3), np.arange(3), np.arange(3.)
     i = nditer([a, b, c], [], ['readwrite'])
     with i:
@@ -773,6 +872,7 @@
         assert_equal(i[0:2], [3, 12])
 
 def test_iter_assign_mapping():
+    """ """
     a = np.arange(24, dtype='f8').reshape(2, 3, 4).T
     it = np.nditer(a, [], [['readwrite', 'updateifcopy']],
                        casting='same_kind', op_dtypes=[np.dtype('f4')])
@@ -792,6 +892,7 @@
     it = None
 
 def test_iter_nbo_align_contig():
+    """ """
     # Check that byte order, alignment, and contig changes work
 
     # Byte order change by requesting a specific dtype
@@ -854,6 +955,7 @@
     assert_equal(i[0], a[::2])
 
 def test_iter_array_cast():
+    """ """
     # Check that arrays are cast as requested
 
     # No cast 'f4' -> 'f4'
@@ -916,6 +1018,7 @@
     assert_equal(a, [1, 2, 3])
 
 def test_iter_array_cast_errors():
+    """ """
     # Check that invalid casts are caught
 
     # Need to enable copying for casts to occur
@@ -960,6 +1063,7 @@
                 op_dtypes=[np.dtype('f4')])
 
 def test_iter_scalar_cast():
+    """ """
     # Check that scalars are cast as requested
 
     # No cast 'f4' -> 'f4'
@@ -998,6 +1102,7 @@
     assert_equal(i[0], 3.)
 
 def test_iter_scalar_cast_errors():
+    """ """
     # Check that invalid casts are caught
 
     # Need to allow copying/buffering for write casts of scalars to occur
@@ -1017,6 +1122,7 @@
                 op_dtypes=[np.dtype('i4')])
 
 def test_iter_object_arrays_basic():
+    """ """
     # Check that object arrays work
 
     obj = {'a':3,'b':'d'}
@@ -1056,6 +1162,7 @@
     assert_equal(a, np.array([None]*4, dtype='O'))
 
 def test_iter_object_arrays_conversions():
+    """ """
     # Conversions to/from objects
     a = np.arange(6, dtype='O')
     i = nditer(a, ['refs_ok', 'buffered'], ['readwrite'],
@@ -1101,6 +1208,7 @@
     assert_equal(a, np.arange(6)+98172489)
 
 def test_iter_common_dtype():
+    """ """
     # Check that the iterator finds a common data type correctly
 
     i = nditer([array([3], dtype='f4'), array([0], dtype='f8')],
@@ -1165,6 +1273,7 @@
     assert_equal(i.dtypes[2], np.dtype('c16'))
 
 def test_iter_copy_if_overlap():
+    """ """
     # Ensure the iterator makes copies on read/write overlap, if requested
 
     # Copy not needed, 1 op
@@ -1255,6 +1364,7 @@
     assert_(c is c2)
 
 def test_iter_op_axes():
+    """ """
     # Check that custom axes work
 
     # Reverse the axes
@@ -1293,6 +1403,7 @@
     assert_equal(i.shape, (3, 5))
 
 def test_iter_op_axes_errors():
+    """ """
     # Check that custom axes throws errors for bad inputs
 
     # Wrong number of items in op_axes
@@ -1319,6 +1430,7 @@
                                     op_axes=[[0, 1], [1, 0]])
 
 def test_iter_copy():
+    """ """
     # Check that copying the iterator works correctly
     a = arange(24).reshape(2, 3, 4)
 
@@ -1363,6 +1475,7 @@
     assert_equal([x[()] for x in j], a.ravel(order='F'))
 
 def test_iter_allocate_output_simple():
+    """ """
     # Check that the iterator will properly allocate outputs
 
     # Simple case
@@ -1373,6 +1486,7 @@
     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 
 def test_iter_allocate_output_buffered_readwrite():
+    """ """
     # Allocated output with buffering + delay_bufalloc
 
     a = arange(6)
@@ -1386,6 +1500,7 @@
         assert_equal(i.operands[1], a+1)
 
 def test_iter_allocate_output_itorder():
+    """ """
     # The allocated output should match the iteration order
 
     # C-order input, best iteration order
@@ -1413,6 +1528,7 @@
     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 
 def test_iter_allocate_output_opaxes():
+    """ """
     # Specifying op_axes should work
 
     a = arange(24, dtype='i4').reshape(2, 3, 4)
@@ -1424,6 +1540,7 @@
     assert_equal(i.operands[0].dtype, np.dtype('u4'))
 
 def test_iter_allocate_output_types_promotion():
+    """ """
     # Check type promotion of automatic outputs
 
     i = nditer([array([3], dtype='f4'), array([0], dtype='f8'), None], [],
@@ -1443,6 +1560,7 @@
     assert_equal(i.dtypes[2], np.dtype('i8'))
 
 def test_iter_allocate_output_types_byte_order():
+    """ """
     # Verify the rules for byte order changes
 
     # When there's just one input, the output type exactly matches
@@ -1457,6 +1575,7 @@
     assert_equal(i.dtypes[0].newbyteorder('='), i.dtypes[2])
 
 def test_iter_allocate_output_types_scalar():
+    """ """
     # If the inputs are all scalars, the output should be a scalar
 
     i = nditer([None, 1, 2.3, np.float32(12), np.complex128(3)], [],
@@ -1465,8 +1584,10 @@
     assert_equal(i.operands[0].ndim, 0)
 
 def test_iter_allocate_output_subtype():
+    """ """
     # Make sure that the subtype with priority wins
     class MyNDArray(np.ndarray):
+        """ """
         __array_priority__ = 15
 
     # subclass vs ndarray
@@ -1487,6 +1608,7 @@
     assert_equal(i.operands[2].shape, (2, 2))
 
 def test_iter_allocate_output_errors():
+    """ """
     # Check that the iterator will throw errors for bad output allocations
 
     # Need an input if no output data type is specified
@@ -1522,6 +1644,7 @@
                         op_axes=[None, [0, 2, 1, 0]])
 
 def test_iter_remove_axis():
+    """ """
     a = arange(24).reshape(2, 3, 4)
 
     i = nditer(a, ['multi_index'])
@@ -1534,6 +1657,7 @@
     assert_equal([x for x in i], a[0,:,:].ravel())
 
 def test_iter_remove_multi_index_inner_loop():
+    """ """
     # Check that removing multi-index support works
 
     a = arange(24).reshape(2, 3, 4)
@@ -1563,6 +1687,7 @@
     assert_equal(i.value, arange(24))
 
 def test_iter_iterindex():
+    """ """
     # Make sure iterindex works
 
     buffersize = 5
@@ -1597,6 +1722,7 @@
         assert_equal(iter_iterindices(i), list(range(2, 24)))
 
 def test_iter_iterrange():
+    """ """
     # Make sure getting and resetting the iterrange works
 
     buffersize = 5
@@ -1622,6 +1748,17 @@
         assert_equal([x[()] for x in i], a_fort[r[0]:r[1]])
 
     def get_array(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         val = np.array([], dtype='f8')
         for x in i:
             val = np.concatenate((val, x))
@@ -1638,6 +1775,7 @@
         assert_equal(get_array(i), a_fort[r[0]:r[1]])
 
 def test_iter_buffering():
+    """ """
     # Test buffering with several buffer sizes and types
     arrays = []
     # F-order swapped array
@@ -1667,6 +1805,7 @@
             assert_equal(np.concatenate(vals), a.ravel(order='C'))
 
 def test_iter_write_buffering():
+    """ """
     # Test that buffering of writes is working
 
     # F-order swapped array
@@ -1685,6 +1824,7 @@
     assert_equal(a.ravel(order='C'), np.arange(24))
 
 def test_iter_buffering_delayed_alloc():
+    """ """
     # Test that delaying buffer allocation works
 
     a = np.arange(6)
@@ -1699,6 +1839,17 @@
     assert_raises(ValueError, lambda i:i[0:2], i)
 
     def assign_iter(i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         i[0] = 0
     assert_raises(ValueError, assign_iter, i)
 
@@ -1712,6 +1863,7 @@
         assert_equal([[x[0][()], x[1][()]] for x in i], list(zip(range(6), [1]*6)))
 
 def test_iter_buffered_cast_simple():
+    """ """
     # Test that buffering can handle a simple cast
 
     a = np.arange(10, dtype='f4')
@@ -1727,6 +1879,7 @@
     assert_equal(a, 2*np.arange(10, dtype='f4'))
 
 def test_iter_buffered_cast_byteswapped():
+    """ """
     # Test that buffering can handle a cast which requires swap->cast->swap
 
     a = np.arange(10, dtype='f4').newbyteorder().byteswap()
@@ -1757,6 +1910,7 @@
         assert_equal(a, 2*np.arange(10, dtype='f8'))
 
 def test_iter_buffered_cast_byteswapped_complex():
+    """ """
     # Test that buffering can handle a cast which requires swap->cast->copy
 
     a = np.arange(10, dtype='c8').newbyteorder().byteswap()
@@ -1807,6 +1961,7 @@
     assert_equal(a, 2*np.arange(10, dtype=np.longdouble))
 
 def test_iter_buffered_cast_structured_type():
+    """ """
     # Tests buffering of structured types
 
     # simple -> struct type (duplicates the value)
@@ -1892,6 +2047,7 @@
 
 
 def test_iter_buffered_cast_subarray():
+    """ """
     # Tests buffering of subarrays
 
     # one element -> many (copies it to all)
@@ -2059,6 +2215,7 @@
         count += 1
 
 def test_iter_buffering_badwriteback():
+    """ """
     # Writing back from a buffer cannot combine elements
 
     # a needs write buffering, but had a broadcast dimension
@@ -2093,6 +2250,7 @@
                   order='C')
 
 def test_iter_buffering_string():
+    """ """
     # Safe casting disallows shrinking strings
     a = np.array(['abc', 'a', 'abcd'], dtype=np.bytes_)
     assert_equal(a.dtype, np.dtype('S4'))
@@ -2111,6 +2269,7 @@
     assert_equal(i[0].dtype, np.dtype('U6'))
 
 def test_iter_buffering_growinner():
+    """ """
     # Test that the inner loop grows when no buffering is needed
     a = np.arange(30)
     i = nditer(a, ['buffered', 'growinner', 'external_loop'],
@@ -2121,6 +2280,7 @@
 
 @pytest.mark.slow
 def test_iter_buffered_reduce_reuse():
+    """ """
     # large enough array for all views, including negative strides.
     a = np.arange(2*3**5)[3**5:3**5+1]
     flags = ['buffered', 'delay_bufalloc', 'multi_index', 'reduce_ok', 'refs_ok']
@@ -2130,6 +2290,7 @@
     op_dtypes = [float, a.dtype]
 
     def get_params():
+        """ """
         for xs in range(-3**2, 3**2 + 1):
             for ys in range(xs, 3**2 + 1):
                 for op_axes in op_axes_list:
@@ -2172,6 +2333,7 @@
 
 
 def test_iter_no_broadcast():
+    """ """
     # Test that the no_broadcast flag works
     a = np.arange(24).reshape(2, 3, 4)
     b = np.arange(6).reshape(2, 3, 1)
@@ -2187,8 +2349,10 @@
 
 
 class TestIterNested:
+    """ """
 
     def test_basic(self):
+        """ """
         # Test nested iteration basic usage
         a = arange(12).reshape(2, 3, 2)
 
@@ -2205,6 +2369,7 @@
         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 
     def test_reorder(self):
+        """ """
         # Test nested iteration basic usage
         a = arange(12).reshape(2, 3, 2)
 
@@ -2235,6 +2400,7 @@
         assert_equal(vals, [[0, 2, 4], [6, 8, 10], [1, 3, 5], [7, 9, 11]])
 
     def test_flip_axes(self):
+        """ """
         # Test nested iteration with negative axes
         a = arange(12).reshape(2, 3, 2)[::-1, ::-1, ::-1]
 
@@ -2265,6 +2431,7 @@
         assert_equal(vals, [[11, 9, 7], [10, 8, 6], [5, 3, 1], [4, 2, 0]])
 
     def test_broadcast(self):
+        """ """
         # Test nested iteration with broadcasting
         a = arange(2).reshape(2, 1)
         b = arange(3).reshape(1, 3)
@@ -2278,6 +2445,7 @@
         assert_equal(vals, [[[0, 0], [1, 0]], [[0, 1], [1, 1]], [[0, 2], [1, 2]]])
 
     def test_dtype_copy(self):
+        """ """
         # Test nested iteration with a copy to change dtype
 
         # copy
@@ -2320,6 +2488,7 @@
         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 
     def test_dtype_buffered(self):
+        """ """
         # Test nested iteration with buffering to change dtype
 
         a = arange(6, dtype='f4').reshape(2, 3)
@@ -2335,6 +2504,7 @@
         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 
     def test_0d(self):
+        """ """
         a = np.arange(12).reshape(2, 3, 2)
         i, j = np.nested_iters(a, [[], [1, 0, 2]])
         vals = [list(j) for _ in i]
@@ -2352,6 +2522,7 @@
         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 
     def test_iter_nested_iters_dtype_buffered(self):
+        """ """
         # Test nested iteration with buffering to change dtype
 
         a = arange(6, dtype='f4').reshape(2, 3)
@@ -2368,6 +2539,7 @@
         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 
 def test_iter_reduction_error():
+    """ """
 
     a = np.arange(6)
     assert_raises(ValueError, nditer, [a, None], [],
@@ -2380,6 +2552,7 @@
                     op_axes=[[0, 1], [-1, -1]])
 
 def test_iter_reduction():
+    """ """
     # Test doing reductions with the iterator
 
     a = np.arange(6)
@@ -2439,6 +2612,7 @@
         assert_equal(it2.operands[1].sum(), a.size)
 
 def test_iter_buffering_reduction():
+    """ """
     # Test doing buffered reductions with the iterator
 
     a = np.arange(6)
@@ -2503,6 +2677,7 @@
     assert_equal(y_base[::2], 2)
 
 def test_iter_buffering_reduction_reuse_reduce_loops():
+    """ """
     # There was a bug triggering reuse of the reduce loop inappropriately,
     # which caused processing to happen in unnecessarily small chunks
     # and overran the buffer.
@@ -2519,6 +2694,7 @@
     assert_equal(sum(bufsizes), a.size)
 
 def test_iter_writemasked_badinput():
+    """ """
     a = np.zeros((2, 3))
     b = np.zeros((3,))
     m = np.array([[True, True, False], [False, True, False]])
@@ -2585,6 +2761,7 @@
                     casting='same_kind')
 
 def test_iter_writemasked():
+    """ """
     a = np.zeros((3,), dtype='f8')
     msk = np.array([True, True, False])
 
@@ -2626,6 +2803,7 @@
     assert_equal(a, [3, 3, 2.5])
 
 def test_iter_non_writable_attribute_deletion():
+    """ """
     it = np.nditer(np.ones(2))
     attr = ["value", "shape", "operands", "itviews", "has_delayed_bufalloc",
             "iterationneedsapi", "has_multi_index", "has_index", "dtypes",
@@ -2636,6 +2814,7 @@
 
 
 def test_iter_writable_attribute_deletion():
+    """ """
     it = np.nditer(np.ones(2))
     attr = [ "multi_index", "index", "iterrange", "iterindex"]
     for s in attr:
@@ -2643,6 +2822,7 @@
 
 
 def test_iter_element_deletion():
+    """ """
     it = np.nditer(np.ones(3))
     try:
         del it[1]
@@ -2653,6 +2833,7 @@
         raise AssertionError
 
 def test_iter_allocated_array_dtypes():
+    """ """
     # If the dtype of an allocated output has a shape, the shape gets
     # tacked onto the end of the result.
     it = np.nditer(([1, 3, 20], None), op_dtypes=[None, ('i4', (2,))])
@@ -2672,6 +2853,7 @@
 
 
 def test_0d_iter():
+    """ """
     # Basic test for iteration of 0-d arrays:
     i = nditer([2, 3], ['multi_index'], [['readonly']]*2)
     assert_equal(i.ndim, 0)
@@ -2711,6 +2893,7 @@
 
 
 def test_iter_too_large():
+    """ """
     # The total size of the iterator must not exceed the maximum intp due
     # to broadcasting. Dividing by 1024 will keep it small enough to
     # give a legal array.
@@ -2724,6 +2907,7 @@
 
 
 def test_iter_too_large_with_multiindex():
+    """ """
     # When a multi index is being tracked, the error is delayed this
     # checks the delayed error messages and getting below that by
     # removing an axis.
@@ -2758,6 +2942,7 @@
                 _multiarray_tests.test_nditer_too_large(arrays, i*2 + 1, mode)
 
 def test_writebacks():
+    """ """
     a = np.arange(6, dtype='f4')
     au = a.byteswap().newbyteorder()
     assert_(a.dtype.byteorder != au.dtype.byteorder)
@@ -2823,9 +3008,23 @@
     assert_raises(RuntimeError, enter)
 
 def test_close_equivalent():
-    ''' using a context amanger and using nditer.close are equivalent
-    '''
+    """using a context amanger and using nditer.close are equivalent"""
     def add_close(x, y, out=None):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+        y :
+            
+        out :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         addop = np.add
         it = np.nditer([x, y, out], [],
                     [['readonly'], ['readonly'], ['writeonly','allocate']])
@@ -2836,6 +3035,21 @@
         return ret
 
     def add_context(x, y, out=None):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+        y :
+            
+        out :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         addop = np.add
         it = np.nditer([x, y, out], [],
                     [['readonly'], ['readonly'], ['writeonly','allocate']])
@@ -2849,6 +3063,7 @@
     assert_equal(z, range(0, 10, 2))
 
 def test_close_raises():
+    """ """
     it = np.nditer(np.arange(3))
     assert_equal (next(it), 0)
     it.close()
@@ -2857,6 +3072,7 @@
 
 @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 def test_warn_noclose():
+    """ """
     a = np.arange(6, dtype='f4')
     au = a.byteswap().newbyteorder()
     with suppress_warnings() as sup:
