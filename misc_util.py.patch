# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/distutils/misc_util.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/distutils/misc_util.py
@@ -23,6 +23,7 @@
 # store all created temporary directories so they can be deleted on exit
 _tmpdirs = []
 def clean_up_temporary_directory():
+    """ """
     if _tmpdirs is not None:
         for d in _tmpdirs:
             try:
@@ -48,8 +49,7 @@
            'get_num_build_jobs']
 
 class InstallableLib:
-    """
-    Container to hold information on an installable library.
+    """Container to hold information on an installable library.
 
     Parameters
     ----------
@@ -60,14 +60,15 @@
     target_dir : str
         Absolute path specifying where to install the library.
 
+    Returns
+    -------
+
     See Also
     --------
     Configuration.add_installed_library
-
     Notes
     -----
     The three parameters are stored as attributes with the same names.
-
     """
     def __init__(self, name, build_info, target_dir):
         self.name = name
@@ -76,19 +77,20 @@
 
 
 def get_num_build_jobs():
-    """
-    Get number of parallel build jobs set by the --parallel command line
+    """Get number of parallel build jobs set by the --parallel command line
     argument of setup.py
     If the command did not receive a setting the environment variable
     NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of
     processors on the system, with a maximum of 8 (to prevent
     overloading the system if there a lot of CPUs).
 
-    Returns
-    -------
-    out : int
-        number of parallel jobs that can be run
-
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    
     """
     from numpy.distutils.core import get_distribution
     try:
@@ -112,6 +114,17 @@
         return max(x for x in cmdattr if x is not None)
 
 def quote_args(args):
+    """
+
+    Parameters
+    ----------
+    args :
+        
+
+    Returns
+    -------
+
+    """
     # don't used _nt_quote_args as it does not check if
     # args items already have quotes or not.
     args = list(args)
@@ -122,12 +135,37 @@
     return args
 
 def allpath(name):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+
+    Returns
+    -------
+
+    """
     "Convert a /-separated pathname to one using the OS's path separator."
     splitted = name.split('/')
     return os.path.join(*splitted)
 
 def rel_path(path, parent_path):
-    """Return path relative to parent_path."""
+    """
+
+    Parameters
+    ----------
+    path :
+        
+    parent_path :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     # Use realpath to avoid issues with symlinked dirs (see gh-7707)
     pd = os.path.realpath(os.path.abspath(parent_path))
     apath = os.path.realpath(os.path.abspath(path))
@@ -143,8 +181,18 @@
 def get_path_from_frame(frame, parent_path=None):
     """Return path of the module given a frame object from the call stack.
 
-    Returned path is relative to parent_path when given,
-    otherwise it is absolute path.
+    Parameters
+    ----------
+    frame :
+        
+    parent_path :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        otherwise it is absolute path.
+
     """
 
     # First, try to find if the file name is in the frame.
@@ -174,9 +222,18 @@
     """Join two or more pathname components +
     - convert a /-separated pathname to one using the OS's path separator.
     - resolve `..` and `.` from path.
-
+    
     Either passing n arguments as in njoin('a','b'), or a sequence
     of n names as in njoin(['a','b']) is handled, or a mixture of such arguments.
+
+    Parameters
+    ----------
+    *path :
+        
+
+    Returns
+    -------
+
     """
     paths = []
     for p in path:
@@ -198,7 +255,18 @@
     return minrelpath(joined)
 
 def get_mathlibs(path=None):
-    """Return the MATHLIB line from numpyconfig.h
+    """
+
+    Parameters
+    ----------
+    path :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        
+
     """
     if path is not None:
         config_file = os.path.join(path, '_numpyconfig.h')
@@ -226,6 +294,15 @@
 
 def minrelpath(path):
     """Resolve `..` and '.' from path.
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
     """
     if not is_string(path):
         return path
@@ -255,10 +332,35 @@
 
 def sorted_glob(fileglob):
     """sorts output of python glob for https://bugs.python.org/issue30461
-    to allow extensions to have reproducible build results"""
+    to allow extensions to have reproducible build results
+
+    Parameters
+    ----------
+    fileglob :
+        
+
+    Returns
+    -------
+
+    """
     return sorted(glob.glob(fileglob))
 
 def _fix_paths(paths, local_path, include_non_existing):
+    """
+
+    Parameters
+    ----------
+    paths :
+        
+    local_path :
+        
+    include_non_existing :
+        
+
+    Returns
+    -------
+
+    """
     assert is_sequence(paths), repr(type(paths))
     new_paths = []
     assert not is_string(paths), repr(paths)
@@ -297,12 +399,40 @@
 
 def gpaths(paths, local_path='', include_non_existing=True):
     """Apply glob to paths and prepend local_path if needed.
+
+    Parameters
+    ----------
+    paths :
+        
+    local_path :
+         (Default value = '')
+    include_non_existing :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     if is_string(paths):
         paths = (paths,)
     return _fix_paths(paths, local_path, include_non_existing)
 
 def make_temp_file(suffix='', prefix='', text=True):
+    """
+
+    Parameters
+    ----------
+    suffix :
+         (Default value = '')
+    prefix :
+         (Default value = '')
+    text :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     if not hasattr(_tdata, 'tempdir'):
         _tdata.tempdir = tempfile.mkdtemp()
         _tmpdirs.append(_tdata.tempdir)
@@ -316,6 +446,7 @@
 # Hooks for colored terminal output.
 # See also https://web.archive.org/web/20100314204946/http://www.livinglogic.de/Python/ansistyle
 def terminal_has_colors():
+    """ """
     if sys.platform=='cygwin' and 'USE_COLOR' not in os.environ:
         # Avoid importing curses that causes illegal operation
         # with a message:
@@ -346,6 +477,23 @@
     _colour_codes = dict(black=0, red=1, green=2, yellow=3,
                          blue=4, magenta=5, cyan=6, white=7, default=9)
     def colour_text(s, fg=None, bg=None, bold=False):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        fg :
+             (Default value = None)
+        bg :
+             (Default value = None)
+        bold :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         seq = []
         if bold:
             seq.append('1')
@@ -361,31 +509,122 @@
             return s
 else:
     def colour_text(s, fg=None, bg=None):
+        """
+
+        Parameters
+        ----------
+        s :
+            
+        fg :
+             (Default value = None)
+        bg :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return s
 
 def default_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'default')
 def red_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'red')
 def green_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'green')
 def yellow_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'yellow')
 def cyan_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'cyan')
 def blue_text(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return colour_text(s, 'blue')
 
 #########################
 
 def cyg2win32(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     if sys.platform=='cygwin' and path.startswith('/cygdrive'):
         path = path[10] + ':' + os.path.normcase(path[11:])
     return path
 
 def mingw32():
-    """Return true when using mingw32 environment.
-    """
+    """ """
     if sys.platform=='win32':
         if os.environ.get('OSTYPE', '')=='msys':
             return True
@@ -394,6 +633,7 @@
     return False
 
 def msvc_runtime_version():
+    """ """
     "Return version of MSVC runtime library, as defined by __MSC_VER__ macro"
     msc_pos = sys.version.find('MSC v.')
     if msc_pos != -1:
@@ -403,6 +643,7 @@
     return msc_ver
 
 def msvc_runtime_library():
+    """ """
     "Return name of MSVC runtime library if Python was built with MSVC >= 7"
     ver = msvc_runtime_major ()
     if ver:
@@ -414,6 +655,7 @@
         return None
 
 def msvc_runtime_major():
+    """ """
     "Return major version of MSVC runtime coded like get_build_msvc_version"
     major = {1300:  70,  # MSVC 7.0
              1310:  71,  # MSVC 7.1
@@ -432,8 +674,18 @@
 f90_ext_match = re.compile(r'.*[.](f90|f95)\Z', re.I).match
 f90_module_name_match = re.compile(r'\s*module\s*(?P<name>[\w_]+)', re.I).match
 def _get_f90_modules(source):
-    """Return a list of Fortran f90 module names that
-    given source file defines.
+    """
+
+    Parameters
+    ----------
+    source :
+        
+
+    Returns
+    -------
+    type
+        given source file defines.
+
     """
     if not f90_ext_match(source):
         return []
@@ -448,16 +700,50 @@
     return modules
 
 def is_string(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return isinstance(s, str)
 
 def all_strings(lst):
-    """Return True if all items in lst are string objects. """
+    """
+
+    Parameters
+    ----------
+    lst :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     for item in lst:
         if not is_string(item):
             return False
     return True
 
 def is_sequence(seq):
+    """
+
+    Parameters
+    ----------
+    seq :
+        
+
+    Returns
+    -------
+
+    """
     if is_string(seq):
         return False
     try:
@@ -467,15 +753,48 @@
     return True
 
 def is_glob_pattern(s):
+    """
+
+    Parameters
+    ----------
+    s :
+        
+
+    Returns
+    -------
+
+    """
     return is_string(s) and ('*' in s or '?' in s)
 
 def as_list(seq):
+    """
+
+    Parameters
+    ----------
+    seq :
+        
+
+    Returns
+    -------
+
+    """
     if is_sequence(seq):
         return list(seq)
     else:
         return [seq]
 
 def get_language(sources):
+    """
+
+    Parameters
+    ----------
+    sources :
+        
+
+    Returns
+    -------
+
+    """
     # not used in numpy/scipy packages, use build_ext.detect_language instead
     """Determine language value (c,f77,f90) from sources """
     language = None
@@ -489,23 +808,57 @@
     return language
 
 def has_f_sources(sources):
-    """Return True if sources contains Fortran files """
+    """
+
+    Parameters
+    ----------
+    sources :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     for source in sources:
         if fortran_ext_match(source):
             return True
     return False
 
 def has_cxx_sources(sources):
-    """Return True if sources contains C++ files """
+    """
+
+    Parameters
+    ----------
+    sources :
+        
+
+    Returns
+    -------
+    type
+        
+
+    """
     for source in sources:
         if cxx_ext_match(source):
             return True
     return False
 
 def filter_sources(sources):
-    """Return four lists of filenames containing
-    C, C++, Fortran, and Fortran 90 module sources,
-    respectively.
+    """
+
+    Parameters
+    ----------
+    sources :
+        
+
+    Returns
+    -------
+    type
+        C, C++, Fortran, and Fortran 90 module sources,
+        respectively.
+
     """
     c_sources = []
     cxx_sources = []
@@ -526,6 +879,17 @@
 
 
 def _get_headers(directory_list):
+    """
+
+    Parameters
+    ----------
+    directory_list :
+        
+
+    Returns
+    -------
+
+    """
     # get *.h files from list of directories
     headers = []
     for d in directory_list:
@@ -534,6 +898,17 @@
     return headers
 
 def _get_directories(list_of_sources):
+    """
+
+    Parameters
+    ----------
+    list_of_sources :
+        
+
+    Returns
+    -------
+
+    """
     # get unique directories from list of sources.
     direcs = []
     for f in list_of_sources:
@@ -544,8 +919,21 @@
 
 def _commandline_dep_string(cc_args, extra_postargs, pp_opts):
     """
-    Return commandline representation used to determine if a file needs
-    to be recompiled
+
+    Parameters
+    ----------
+    cc_args :
+        
+    extra_postargs :
+        
+    pp_opts :
+        
+
+    Returns
+    -------
+    type
+        to be recompiled
+
     """
     cmdline = 'commandline: '
     cmdline += ' '.join(cc_args)
@@ -555,11 +943,33 @@
 
 
 def get_dependencies(sources):
+    """
+
+    Parameters
+    ----------
+    sources :
+        
+
+    Returns
+    -------
+
+    """
     #XXX scan sources for include statements
     return _get_headers(_get_directories(sources))
 
 def is_local_src_dir(directory):
-    """Return true if directory is local directory.
+    """
+
+    Parameters
+    ----------
+    directory :
+        
+
+    Returns
+    -------
+    type
+        
+
     """
     if not is_string(directory):
         return False
@@ -574,6 +984,17 @@
     return os.path.isdir(new_dir)
 
 def general_source_files(top_path):
+    """
+
+    Parameters
+    ----------
+    top_path :
+        
+
+    Returns
+    -------
+
+    """
     pruned_directories = {'CVS':1, '.svn':1, 'build':1}
     prune_file_pat = re.compile(r'(?:[~#]|\.py[co]|\.o)$')
     for dirpath, dirnames, filenames in os.walk(top_path, topdown=True):
@@ -584,8 +1005,18 @@
                 yield os.path.join(dirpath, f)
 
 def general_source_directories_files(top_path):
-    """Return a directory name relative to top_path and
-    files contained.
+    """
+
+    Parameters
+    ----------
+    top_path :
+        
+
+    Returns
+    -------
+    type
+        files contained.
+
     """
     pruned_directories = ['CVS', '.svn', 'build']
     prune_file_pat = re.compile(r'(?:[~#]|\.py[co]|\.o)$')
@@ -610,6 +1041,17 @@
 
 
 def get_ext_source_files(ext):
+    """
+
+    Parameters
+    ----------
+    ext :
+        
+
+    Returns
+    -------
+
+    """
     # Get sources and any include files in the same directory.
     filenames = []
     sources = [_m for _m in ext.sources if is_string(_m)]
@@ -623,10 +1065,32 @@
     return filenames
 
 def get_script_files(scripts):
+    """
+
+    Parameters
+    ----------
+    scripts :
+        
+
+    Returns
+    -------
+
+    """
     scripts = [_m for _m in scripts if is_string(_m)]
     return scripts
 
 def get_lib_source_files(lib):
+    """
+
+    Parameters
+    ----------
+    lib :
+        
+
+    Returns
+    -------
+
+    """
     filenames = []
     sources = lib[1].get('sources', [])
     sources = [_m for _m in sources if is_string(_m)]
@@ -659,7 +1123,6 @@
     and '.pyd' on Windows.  For Python >= 3.2 `so_ext` has a tag prepended on
     POSIX systems according to PEP 3149.  For Python 3.2 this is implemented on
     Linux, but not on OS X.
-
     """
     confvars = distutils.sysconfig.get_config_vars()
     # SO is deprecated in 3.3.1, use EXT_SUFFIX instead
@@ -688,6 +1151,17 @@
     return so_ext
 
 def get_data_files(data):
+    """
+
+    Parameters
+    ----------
+    data :
+        
+
+    Returns
+    -------
+
+    """
     if is_string(data):
         return [data]
     sources = data[1]
@@ -707,10 +1181,32 @@
     return filenames
 
 def dot_join(*args):
+    """
+
+    Parameters
+    ----------
+    *args :
+        
+
+    Returns
+    -------
+
+    """
     return '.'.join([a for a in args if a])
 
 def get_frame(level=0):
-    """Return frame object from call stack with given level.
+    """
+
+    Parameters
+    ----------
+    level :
+         (Default value = 0)
+
+    Returns
+    -------
+    type
+        
+
     """
     try:
         return sys._getframe(level+1)
@@ -724,6 +1220,7 @@
 ######################
 
 class Configuration:
+    """ """
 
     _list_keys = ['packages', 'ext_modules', 'data_files', 'include_dirs',
                   'libraries', 'headers', 'scripts', 'py_modules',
@@ -831,9 +1328,14 @@
         self.setup_name = setup_name
 
     def todict(self):
-        """
-        Return a dictionary compatible with the keyword arguments of distutils
+        """Return a dictionary compatible with the keyword arguments of distutils
         setup function.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Examples
         --------
@@ -850,22 +1352,51 @@
         return d
 
     def info(self, message):
+        """
+
+        Parameters
+        ----------
+        message :
+            
+
+        Returns
+        -------
+
+        """
         if not self.options['quiet']:
             print(message)
 
     def warn(self, message):
+        """
+
+        Parameters
+        ----------
+        message :
+            
+
+        Returns
+        -------
+
+        """
         sys.stderr.write('Warning: %s\n' % (message,))
 
     def set_options(self, **options):
-        """
-        Configure Configuration instance.
-
+        """Configure Configuration instance.
+        
         The following options are available:
          - ignore_setup_xxx_py
          - assume_default_configuration
          - delegate_options_to_subpackages
          - quiet
 
+        Parameters
+        ----------
+        **options :
+            
+
+        Returns
+        -------
+
         """
         for key, value in options.items():
             if key in self.options:
@@ -874,13 +1405,28 @@
                 raise ValueError('Unknown option: '+key)
 
     def get_distribution(self):
-        """Return the distutils distribution object for self."""
+        """ """
         from numpy.distutils.core import get_distribution
         return get_distribution()
 
     def _wildcard_get_subpackage(self, subpackage_name,
                                  parent_name,
                                  caller_level = 1):
+        """
+
+        Parameters
+        ----------
+        subpackage_name :
+            
+        parent_name :
+            
+        caller_level :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         l = subpackage_name.split('.')
         subpackage_path = njoin([self.local_path]+l)
         dirs = [_m for _m in sorted_glob(subpackage_path) if os.path.isdir(_m)]
@@ -902,6 +1448,25 @@
                                          subpackage_path,
                                          parent_name,
                                          caller_level = 1):
+        """
+
+        Parameters
+        ----------
+        setup_py :
+            
+        subpackage_name :
+            
+        subpackage_path :
+            
+        parent_name :
+            
+        caller_level :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         # In case setup_py imports local modules:
         sys.path.insert(0, os.path.dirname(setup_py))
         try:
@@ -939,15 +1504,19 @@
 
         Parameters
         ----------
-        subpackage_name : str or None
-            Name of the subpackage to get the configuration. '*' in
-            subpackage_name is handled as a wildcard.
-        subpackage_path : str
-            If None, then the path is assumed to be the local path plus the
-            subpackage_name. If a setup.py file is not found in the
-            subpackage_path, then a default configuration is used.
-        parent_name : str
-            Parent name.
+        subpackage_name :
+            
+        subpackage_path :
+             (Default value = None)
+        parent_name :
+             (Default value = None)
+        caller_level :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        
         """
         if subpackage_name is None:
             if subpackage_path is None:
@@ -996,19 +1565,23 @@
                        subpackage_path=None,
                        standalone = False):
         """Add a sub-package to the current Configuration instance.
-
+        
         This is useful in a setup.py script for adding sub-packages to a
         package.
 
         Parameters
         ----------
-        subpackage_name : str
-            name of the subpackage
-        subpackage_path : str
-            if given, the subpackage path such as the subpackage is in
-            subpackage_path / subpackage_name. If None,the subpackage is
-            assumed to be located in the local path / subpackage_name.
-        standalone : bool
+        subpackage_name :
+            
+        subpackage_path :
+             (Default value = None)
+        standalone :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
 
         if standalone:
@@ -1037,7 +1610,7 @@
 
     def add_data_dir(self, data_path):
         """Recursively add files under data_path to data_files list.
-
+        
         Recursively add files under data_path to the list of data_files to be
         installed (and distributed). The data_path can be either a relative
         path-name, or an absolute path-name, or a 2-tuple where the first
@@ -1048,15 +1621,17 @@
         ----------
         data_path : seq or str
             Argument can be either
-
-                * 2-sequence (<datadir suffix>, <path to data directory>)
-                * path to data directory where python datadir suffix defaults
-                  to package dir.
+            * 2-sequence (<datadir suffix>, <path to data directory>)
+            * path to data directory where python datadir suffix defaults
+            to package dir.
+
+        Returns
+        -------
 
         Notes
         -----
         Rules for installation paths::
-
+        
             foo/bar -> (foo/bar, foo/bar) -> parent/foo/bar
             (gun, foo/bar) -> parent/gun
             foo/* -> (foo/a, foo/a), (foo/b, foo/b) -> parent/foo/a, parent/foo/b
@@ -1065,18 +1640,14 @@
             /foo/bar -> (bar, /foo/bar) -> parent/bar
             (gun, /foo/bar) -> parent/gun
             (fun/*/gun/*, sun/foo/bar) -> parent/fun/foo/gun/bar
-
         Examples
         --------
         For example suppose the source directory contains fun/foo.dat and
         fun/bar/car.dat:
-
-        >>> self.add_data_dir('fun')                       #doctest: +SKIP
-        >>> self.add_data_dir(('sun', 'fun'))              #doctest: +SKIP
-        >>> self.add_data_dir(('gun', '/full/path/to/fun'))#doctest: +SKIP
-
+        
+        
         Will install data-files to the locations::
-
+        
             <package install directory>/
               fun/
                 foo.dat
@@ -1089,7 +1660,9 @@
               gun/
                 foo.dat
                 car.dat
-
+        >>> self.add_data_dir('fun')                       #doctest: +SKIP
+        >>> self.add_data_dir(('sun', 'fun'))              #doctest: +SKIP
+        >>> self.add_data_dir(('gun', '/full/path/to/fun'))#doctest: +SKIP
         """
         if is_sequence(data_path):
             d, data_path = data_path
@@ -1157,6 +1730,7 @@
                 data_files.append((target_path, f))
 
     def _optimize_data_files(self):
+        """ """
         data_dict = {}
         for p, files in self.data_files:
             if p not in data_dict:
@@ -1172,10 +1746,14 @@
         ----------
         files : sequence
             Argument(s) can be either
-
-                * 2-sequence (<datadir prefix>,<path to data file(s)>)
-                * paths to data files where python datadir prefix defaults
-                  to package dir.
+            * 2-sequence (<datadir prefix>,<path to data file(s)>)
+            * paths to data files where python datadir prefix defaults
+            to package dir.
+        *files :
+            
+
+        Returns
+        -------
 
         Notes
         -----
@@ -1190,7 +1768,7 @@
         Finally, the file can be an absolute path name in which case the file
         will be found at the absolute path name but installed to the package
         path.
-
+        
         This basic behavior can be augmented by passing a 2-tuple in as the
         file argument. The first element of the tuple should specify the
         relative path (under the package install directory) where the
@@ -1203,9 +1781,9 @@
         Filenames and relative path names will be installed in the package
         install directory under the path name given as the first element of
         the tuple.
-
+        
         Rules for installation paths:
-
+        
           #. file.txt -> (., file.txt)-> parent/file.txt
           #. foo/file.txt -> (foo, foo/file.txt) -> parent/foo/file.txt
           #. /foo/bar/file.txt -> (., /foo/bar/file.txt) -> parent/file.txt
@@ -1218,23 +1796,18 @@
           #. (sun, ``*``.txt) -> parent/sun/a.txt, parent/sun/b.txt
           #. (sun, bar/``*``.txt) -> parent/sun/a.txt, parent/sun/b.txt
           #. (sun/``*``, ``*``/``*``.txt) -> parent/sun/c/a.txt, parent/d/b.txt
-
+        
         An additional feature is that the path to a data-file can actually be
         a function that takes no arguments and returns the actual path(s) to
         the data-files. This is useful when the data files are generated while
         building the package.
-
         Examples
         --------
         Add files to the list of data_files to be included with the package.
-
-            >>> self.add_data_files('foo.dat',
-            ...     ('fun', ['gun.dat', 'nun/pun.dat', '/tmp/sun.dat']),
-            ...     'bar/cat.dat',
-            ...     '/full/path/to/can.dat')                   #doctest: +SKIP
-
+        
+        
         will install these data files to::
-
+        
             <package install directory>/
              foo.dat
              fun/
@@ -1245,12 +1818,16 @@
              bar/
                car.dat
              can.dat
-
+        
         where <package install directory> is the package (or sub-package)
         directory such as '/usr/lib/python2.4/site-packages/mypackage' ('C:
         \\Python2.4 \\Lib \\site-packages \\mypackage') or
         '/usr/lib/python2.4/site- packages/mypackage/mysubpackage' ('C:
         \\Python2.4 \\Lib \\site-packages \\mypackage \\mysubpackage').
+        >>> self.add_data_files('foo.dat',
+            ...     ('fun', ['gun.dat', 'nun/pun.dat', '/tmp/sun.dat']),
+            ...     'bar/cat.dat',
+            ...     '/full/path/to/can.dat')                   #doctest: +SKIP
         """
 
         if len(files)>1:
@@ -1320,10 +1897,19 @@
 
     def add_define_macros(self, macros):
         """Add define macros to configuration
-
+        
         Add the given sequence of macro name and value duples to the beginning
         of the define_macros list This list will be visible to all extension
         modules of the current package.
+
+        Parameters
+        ----------
+        macros :
+            
+
+        Returns
+        -------
+
         """
         dist = self.get_distribution()
         if dist is not None:
@@ -1336,10 +1922,19 @@
 
     def add_include_dirs(self,*paths):
         """Add paths to configuration include directories.
-
+        
         Add the given sequence of paths to the beginning of the include_dirs
         list. This list will be visible to all extension modules of the
         current package.
+
+        Parameters
+        ----------
+        *paths :
+            
+
+        Returns
+        -------
+
         """
         include_dirs = self.paths(paths)
         dist = self.get_distribution()
@@ -1352,7 +1947,7 @@
 
     def add_headers(self,*files):
         """Add installable headers to configuration.
-
+        
         Add the given sequence of files to the beginning of the headers list.
         By default, headers will be installed under <python-
         include>/<self.name.replace('.','/')>/ directory. If an item of files
@@ -1361,12 +1956,13 @@
 
         Parameters
         ----------
-        files : str or seq
-            Argument(s) can be either:
-
-                * 2-sequence (<includedir suffix>,<path to header file(s)>)
-                * path(s) to header file(s) where python includedir suffix will
-                  default to package name.
+        *files :
+            
+
+        Returns
+        -------
+
+        
         """
         headers = []
         for path in files:
@@ -1386,13 +1982,23 @@
 
     def paths(self,*paths,**kws):
         """Apply glob to paths and prepend local_path if needed.
-
+        
         Applies glob.glob(...) to each path in the sequence (if needed) and
         pre-pends the local_path if needed. Because this is called on all
         source lists, this allows wildcard characters to be specified in lists
         of sources for extension modules and libraries and scripts and allows
         path-names be relative to the source directory.
 
+        Parameters
+        ----------
+        *paths :
+            
+        **kws :
+            
+
+        Returns
+        -------
+
         """
         include_non_existing = kws.get('include_non_existing', True)
         return gpaths(paths,
@@ -1400,6 +2006,17 @@
                       include_non_existing=include_non_existing)
 
     def _fix_paths_dict(self, kw):
+        """
+
+        Parameters
+        ----------
+        kw :
+            
+
+        Returns
+        -------
+
+        """
         for k in kw.keys():
             v = kw[k]
             if k in ['sources', 'depends', 'include_dirs', 'library_dirs',
@@ -1409,7 +2026,7 @@
 
     def add_extension(self,name,sources,**kw):
         """Add extension to configuration.
-
+        
         Create and add an Extension instance to the ext_modules list. This
         method also takes the following optional keyword arguments that are
         passed on to the Extension constructor.
@@ -1427,28 +2044,49 @@
             processing all source generators, then no extension module is
             built.
         include_dirs :
+            
         define_macros :
+            
         undef_macros :
+            
         library_dirs :
+            
         libraries :
+            
         runtime_library_dirs :
+            
         extra_objects :
+            
         extra_compile_args :
+            
         extra_link_args :
+            
         extra_f77_compile_args :
+            
         extra_f90_compile_args :
+            
         export_symbols :
+            
         swig_opts :
+            
         depends :
             The depends list contains paths to files or directories that the
             sources of the extension module depend on. If any path in the
             depends list is newer than the extension module, then the module
             will be rebuilt.
         language :
+            
         f2py_options :
+            
         module_dirs :
+            
         extra_info : dict or list
             dict or list of dict of keywords to be appended to keywords.
+        **kw :
+            
+
+        Returns
+        -------
 
         Notes
         -----
@@ -1511,33 +2149,21 @@
         return ext
 
     def add_library(self,name,sources,**build_info):
-        """
-        Add library to configuration.
-
-        Parameters
-        ----------
-        name : str
-            Name of the extension.
-        sources : sequence
-            List of the sources. The list of sources may contain functions
-            (called source generators) which must take an extension instance
-            and a build directory as inputs and return a source file or list of
-            source files or None. If None is returned then no sources are
-            generated. If the Extension instance has no sources after
-            processing all source generators, then no extension module is
-            built.
-        build_info : dict, optional
-            The following keys are allowed:
-
-                * depends
-                * macros
-                * include_dirs
-                * extra_compiler_args
-                * extra_f77_compile_args
-                * extra_f90_compile_args
-                * f2py_options
-                * language
-
+        """Add library to configuration.
+
+        Parameters
+        ----------
+        name :
+            
+        sources :
+            
+        **build_info :
+            
+
+        Returns
+        -------
+
+        
         """
         self._add_library(name, sources, None, build_info)
 
@@ -1548,7 +2174,23 @@
 
     def _add_library(self, name, sources, install_dir, build_info):
         """Common implementation for add_library and add_installed_library. Do
-        not use directly"""
+        not use directly
+
+        Parameters
+        ----------
+        name :
+            
+        sources :
+            
+        install_dir :
+            
+        build_info :
+            
+
+        Returns
+        -------
+
+        """
         build_info = copy.copy(build_info)
         build_info['sources'] = sources
 
@@ -1563,9 +2205,8 @@
         self.libraries.append((name, build_info))
 
     def add_installed_library(self, name, sources, install_dir, build_info=None):
-        """
-        Similar to add_library, but the specified library is installed.
-
+        """Similar to add_library, but the specified library is installed.
+        
         Most C libraries used with `distutils` are only used to build python
         extensions, but libraries built through this method will be installed
         so that they can be reused by third-party packages.
@@ -1580,31 +2221,29 @@
             Path to install the library, relative to the current sub-package.
         build_info : dict, optional
             The following keys are allowed:
-
-                * depends
-                * macros
-                * include_dirs
-                * extra_compiler_args
-                * extra_f77_compile_args
-                * extra_f90_compile_args
-                * f2py_options
-                * language
+            * depends
+            * macros
+            * include_dirs
+            * extra_compiler_args
+            * extra_f77_compile_args
+            * extra_f90_compile_args
+            * f2py_options
+            * language (Default value = None)
 
         Returns
         -------
         None
+            
 
         See Also
         --------
         add_library, add_npy_pkg_config, get_info
-
         Notes
         -----
         The best way to encode the options required to link against the specified
         C libraries is to use a "libname.ini" file, and use `get_info` to
         retrieve the required options (see `add_npy_pkg_config` for more
         information).
-
         """
         if not build_info:
             build_info = {}
@@ -1614,9 +2253,8 @@
         self.installed_libraries.append(InstallableLib(name, build_info, install_dir))
 
     def add_npy_pkg_config(self, template, install_dir, subst_dict=None):
-        """
-        Generate and install a npy-pkg config file from a template.
-
+        """Generate and install a npy-pkg config file from a template.
+        
         The config file generated from `template` is installed in the
         given install directory, using `subst_dict` for variable substitution.
 
@@ -1631,82 +2269,82 @@
             If given, any string of the form ``@key@`` will be replaced by
             ``subst_dict[key]`` in the template file when installed. The install
             prefix is always available through the variable ``@prefix@``, since the
-            install prefix is not easy to get reliably from setup.py.
+            install prefix is not easy to get reliably from setup.py. (Default value = None)
+
+        Returns
+        -------
 
         See also
         --------
         add_installed_library, get_info
-
         Notes
         -----
         This works for both standard installs and in-place builds, i.e. the
         ``@prefix@`` refer to the source directory for in-place builds.
-
         Examples
         --------
         ::
-
+        
             config.add_npy_pkg_config('foo.ini.in', 'lib', {'foo': bar})
-
+        
         Assuming the foo.ini.in file has the following content::
-
+        
             [meta]
             Name=@foo@
             Version=1.0
             Description=dummy description
-
+        
             [default]
             Cflags=-I@prefix@/include
             Libs=
-
+        
         The generated file will have the following content::
-
+        
             [meta]
             Name=bar
             Version=1.0
             Description=dummy description
-
+        
             [default]
             Cflags=-Iprefix_dir/include
             Libs=
-
+        
         and will be installed as foo.ini in the 'lib' subpath.
-
+        
         When cross-compiling with numpy distutils, it might be necessary to
         use modified npy-pkg-config files.  Using the default/generated files
         will link with the host libraries (i.e. libnpymath.a).  For
         cross-compilation you of-course need to link with target libraries,
         while using the host Python installation.
-
+        
         You can copy out the numpy/core/lib/npy-pkg-config directory, add a
         pkgdir value to the .ini files and set NPY_PKG_CONFIG_PATH environment
         variable to point to the directory with the modified npy-pkg-config
         files.
-
+        
         Example npymath.ini modified for cross-compilation::
-
+        
             [meta]
             Name=npymath
             Description=Portable, core math library implementing C99 standard
             Version=0.1
-
+        
             [variables]
             pkgname=numpy.core
             pkgdir=/build/arm-linux-gnueabi/sysroot/usr/lib/python3.7/site-packages/numpy/core
             prefix=${pkgdir}
             libdir=${prefix}/lib
             includedir=${prefix}/include
-
+        
             [default]
             Libs=-L${libdir} -lnpymath
             Cflags=-I${includedir}
             Requires=mlib
-
+        
             [msvc]
             Libs=/LIBPATH:${libdir} npymath.lib
             Cflags=/INCLUDE:${includedir}
             Requires=mlib
-
         """
         if subst_dict is None:
             subst_dict = {}
@@ -1722,9 +2360,17 @@
 
     def add_scripts(self,*files):
         """Add scripts to configuration.
-
+        
         Add the sequence of files to the beginning of the scripts list.
         Scripts will be installed under the <prefix>/bin/ directory.
+
+        Parameters
+        ----------
+        *files :
+            
+
+        Returns
+        -------
 
         """
         scripts = self.paths(files)
@@ -1737,6 +2383,17 @@
             self.scripts.extend(scripts)
 
     def dict_append(self,**dict):
+        """
+
+        Parameters
+        ----------
+        **dict :
+            
+
+        Returns
+        -------
+
+        """
         for key in self.list_keys:
             a = getattr(self, key)
             a.extend(dict.get(key, []))
@@ -1775,9 +2432,7 @@
         return s
 
     def get_config_cmd(self):
-        """
-        Returns the numpy.distutils config command instance.
-        """
+        """Returns the numpy.distutils config command instance."""
         cmd = get_cmd('config')
         cmd.ensure_finalized()
         cmd.dump_source = 0
@@ -1790,8 +2445,15 @@
 
     def get_build_temp_dir(self):
         """
-        Return a path to a temporary directory where temporary files should be
-        placed.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            placed.
+
         """
         cmd = get_cmd('build')
         cmd.ensure_finalized()
@@ -1799,9 +2461,15 @@
 
     def have_f77c(self):
         """Check for availability of Fortran 77 compiler.
-
+        
         Use it inside source generating function to ensure that
         setup distribution instance has been initialized.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Notes
         -----
@@ -1818,9 +2486,15 @@
 
     def have_f90c(self):
         """Check for availability of Fortran 90 compiler.
-
+        
         Use it inside source generating function to ensure that
         setup distribution instance has been initialized.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         Notes
         -----
@@ -1837,6 +2511,15 @@
 
     def append_to(self, extlib):
         """Append libraries, include_dirs to extension or library item.
+
+        Parameters
+        ----------
+        extlib :
+            
+
+        Returns
+        -------
+
         """
         if is_sequence(extlib):
             lib_name, build_info = extlib
@@ -1850,7 +2533,18 @@
             extlib.include_dirs.extend(self.include_dirs)
 
     def _get_svn_revision(self, path):
-        """Return path's SVN revision number.
+        """
+
+        Parameters
+        ----------
+        path :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         try:
             output = subprocess.check_output(['svnversion'], cwd=path)
@@ -1879,7 +2573,18 @@
         return None
 
     def _get_hg_revision(self, path):
-        """Return path's Mercurial revision number.
+        """
+
+        Parameters
+        ----------
+        path :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         try:
             output = subprocess.check_output(
@@ -1917,9 +2622,19 @@
 
     def get_version(self, version_file=None, version_variable=None):
         """Try to get version string of a package.
-
+        
         Return a version string of the current package or None if the version
         information could not be detected.
+
+        Parameters
+        ----------
+        version_file :
+             (Default value = None)
+        version_variable :
+             (Default value = None)
+
+        Returns
+        -------
 
         Notes
         -----
@@ -1987,15 +2702,23 @@
     def make_svn_version_py(self, delete=True):
         """Appends a data function to the data_files list that will generate
         __svn_version__.py file to the current package directory.
-
+        
         Generate package __svn_version__.py file from SVN revision number,
         it will be removed after python exits but will be available
         when sdist, etc commands are executed.
 
+        Parameters
+        ----------
+        delete :
+             (Default value = True)
+
+        Returns
+        -------
+
         Notes
         -----
         If __svn_version__.py existed before, nothing is done.
-
+        
         This is
         intended for working with source directories that are in an SVN
         repository.
@@ -2006,6 +2729,7 @@
             return
         else:
             def generate_svn_version_py():
+                """ """
                 if not os.path.isfile(target):
                     version = str(revision)
                     self.info('Creating %s (version=%r)' % (target, version))
@@ -2013,6 +2737,19 @@
                         f.write('version = %r\n' % (version))
 
                 def rm_file(f=target,p=self.info):
+                    """
+
+                    Parameters
+                    ----------
+                    f :
+                         (Default value = target)
+                    p :
+                         (Default value = self.info)
+
+                    Returns
+                    -------
+
+                    """
                     if delete:
                         try: os.remove(f); p('removed '+f)
                         except OSError: pass
@@ -2028,15 +2765,23 @@
     def make_hg_version_py(self, delete=True):
         """Appends a data function to the data_files list that will generate
         __hg_version__.py file to the current package directory.
-
+        
         Generate package __hg_version__.py file from Mercurial revision,
         it will be removed after python exits but will be available
         when sdist, etc commands are executed.
 
+        Parameters
+        ----------
+        delete :
+             (Default value = True)
+
+        Returns
+        -------
+
         Notes
         -----
         If __hg_version__.py existed before, nothing is done.
-
+        
         This is intended for working with source directories that are
         in an Mercurial repository.
         """
@@ -2046,6 +2791,7 @@
             return
         else:
             def generate_hg_version_py():
+                """ """
                 if not os.path.isfile(target):
                     version = str(revision)
                     self.info('Creating %s (version=%r)' % (target, version))
@@ -2053,6 +2799,19 @@
                         f.write('version = %r\n' % (version))
 
                 def rm_file(f=target,p=self.info):
+                    """
+
+                    Parameters
+                    ----------
+                    f :
+                         (Default value = target)
+                    p :
+                         (Default value = self.info)
+
+                    Returns
+                    -------
+
+                    """
                     if delete:
                         try: os.remove(f); p('removed '+f)
                         except OSError: pass
@@ -2068,18 +2827,34 @@
     def make_config_py(self,name='__config__'):
         """Generate package __config__.py file containing system_info
         information used during building the package.
-
+        
         This file is installed to the
         package installation directory.
 
+        Parameters
+        ----------
+        name :
+             (Default value = '__config__')
+
+        Returns
+        -------
+
         """
         self.py_modules.append((self.name, name, generate_config_py))
 
     def get_info(self,*names):
         """Get resources information.
 
-        Return information (from system_info.get_info) for all of the names in
-        the argument list in a single dictionary.
+        Parameters
+        ----------
+        *names :
+            
+
+        Returns
+        -------
+        type
+            the argument list in a single dictionary.
+
         """
         from .system_info import get_info, dict_append
         info_dict = {}
@@ -2089,6 +2864,19 @@
 
 
 def get_cmd(cmdname, _cache={}):
+    """
+
+    Parameters
+    ----------
+    cmdname :
+        
+    _cache :
+         (Default value = {})
+
+    Returns
+    -------
+
+    """
     if cmdname not in _cache:
         import distutils.core
         dist = distutils.core._setup_distribution
@@ -2101,6 +2889,7 @@
     return _cache[cmdname]
 
 def get_numpy_include_dirs():
+    """ """
     # numpy_include_dirs are set by numpy/core/setup.py, otherwise []
     include_dirs = Configuration.numpy_include_dirs[:]
     if not include_dirs:
@@ -2111,14 +2900,19 @@
 
 def get_npy_pkg_dir():
     """Return the path where to find the npy-pkg-config directory.
-
+    
     If the NPY_PKG_CONFIG_PATH environment variable is set, the value of that
     is returned.  Otherwise, a path inside the location of the numpy module is
-    returned.
-
-    The NPY_PKG_CONFIG_PATH can be useful when cross-compiling, maintaining
-    customized npy-pkg-config .ini files for the cross-compilation
-    environment, and using them when cross-compiling.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        The NPY_PKG_CONFIG_PATH can be useful when cross-compiling, maintaining
+        customized npy-pkg-config .ini files for the cross-compilation
+        environment, and using them when cross-compiling.
 
     """
     # XXX: import here for bootstrapping reasons
@@ -2131,8 +2925,7 @@
     return d
 
 def get_pkg_info(pkgname, dirs=None):
-    """
-    Return library info for the given package.
+    """Return library info for the given package.
 
     Parameters
     ----------
@@ -2142,7 +2935,7 @@
     dirs : sequence, optional
         If given, should be a sequence of additional directories where to look
         for npy-pkg-config files. Those directories are searched prior to the
-        NumPy directory.
+        NumPy directory. (Default value = None)
 
     Returns
     -------
@@ -2158,7 +2951,6 @@
     --------
     Configuration.add_npy_pkg_config, Configuration.add_installed_library,
     get_info
-
     """
     from numpy.distutils.npy_pkg_config import read_config
 
@@ -2169,9 +2961,8 @@
     return read_config(pkgname, dirs)
 
 def get_info(pkgname, dirs=None):
-    """
-    Return an info dict for a given C library.
-
+    """Return an info dict for a given C library.
+    
     The info dict contains the necessary options to use the C library.
 
     Parameters
@@ -2182,7 +2973,7 @@
     dirs : sequence, optional
         If given, should be a sequence of additional directories where to look
         for npy-pkg-config files. Those directories are searched prior to the
-        NumPy directory.
+        NumPy directory. (Default value = None)
 
     Returns
     -------
@@ -2198,20 +2989,18 @@
     --------
     Configuration.add_npy_pkg_config, Configuration.add_installed_library,
     get_pkg_info
-
     Examples
     --------
     To get the necessary information for the npymath library from NumPy:
-
+    
+    
+    This info dict can then be used as input to a `Configuration` instance::
+    
+      config.add_extension('foo', sources=['foo.c'], extra_info=npymath_info)
     >>> npymath_info = np.distutils.misc_util.get_info('npymath')
     >>> npymath_info                                    #doctest: +SKIP
     {'define_macros': [], 'libraries': ['npymath'], 'library_dirs':
     ['.../numpy/core/lib'], 'include_dirs': ['.../numpy/core/include']}
-
-    This info dict can then be used as input to a `Configuration` instance::
-
-      config.add_extension('foo', sources=['foo.c'], extra_info=npymath_info)
-
     """
     from numpy.distutils.npy_pkg_config import parse_flags
     pkg_info = get_pkg_info(pkgname, dirs)
@@ -2229,6 +3018,7 @@
     return info
 
 def is_bootstrapping():
+    """ """
     import builtins
 
     try:
@@ -2241,8 +3031,22 @@
 #########################
 
 def default_config_dict(name = None, parent_name = None, local_path=None):
-    """Return a configuration dictionary for usage in
-    configuration() function defined in file setup_<name>.py.
+    """
+
+    Parameters
+    ----------
+    name :
+         (Default value = None)
+    parent_name :
+         (Default value = None)
+    local_path :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        configuration() function defined in file setup_<name>.py.
+
     """
     import warnings
     warnings.warn('Use Configuration(%r,%r,top_path=%r) instead of '\
@@ -2255,6 +3059,19 @@
 
 
 def dict_append(d, **kws):
+    """
+
+    Parameters
+    ----------
+    d :
+        
+    **kws :
+        
+
+    Returns
+    -------
+
+    """
     for k, v in kws.items():
         if k in d:
             ov = d[k]
@@ -2266,6 +3083,19 @@
             d[k] = v
 
 def appendpath(prefix, path):
+    """
+
+    Parameters
+    ----------
+    prefix :
+        
+    path :
+        
+
+    Returns
+    -------
+
+    """
     if os.path.sep != '/':
         prefix = prefix.replace('/', os.path.sep)
         path = path.replace('/', os.path.sep)
@@ -2289,9 +3119,18 @@
 def generate_config_py(target):
     """Generate config.py file containing system_info information
     used during building the package.
-
+    
     Usage:
         config['py_modules'].append((packagename, '__config__',generate_config_py))
+
+    Parameters
+    ----------
+    target :
+        
+
+    Returns
+    -------
+
     """
     from numpy.distutils.system_info import system_info
     from distutils.dir_util import mkpath
@@ -2321,29 +3160,44 @@
             f.write('%s=%r\n' % (k, i))
         f.write(textwrap.dedent(r'''
             def get_info(name):
+                """
+
+                Parameters
+                ----------
+                name :
+                    
+
+                Returns
+                -------
+
+                """
                 g = globals()
                 return g.get(name, g.get(name + "_info", {}))
 
             def show():
-                """
-                Show libraries in the system on which NumPy was built.
-
+                """Show libraries in the system on which NumPy was built.
+                
                 Print information about various resources (libraries, library
                 directories, include directories, etc.) in the system on which
                 NumPy was built.
+
+                Parameters
+                ----------
+
+                Returns
+                -------
 
                 See Also
                 --------
                 get_include : Returns the directory containing NumPy C
                               header files.
-
                 Notes
                 -----
                 Classes specifying the information to be printed are defined
                 in the `numpy.distutils.system_info` module.
-
+                
                 Information may include:
-
+                
                 * ``language``: language used to write the libraries (mostly
                   C or f77)
                 * ``libraries``: names of libraries found in the system
@@ -2352,7 +3206,6 @@
                 * ``src_dirs``: directories containing library source files
                 * ``define_macros``: preprocessor macros used by
                   ``distutils.setup``
-
                 Examples
                 --------
                 >>> np.show_config()
@@ -2377,14 +3230,26 @@
     return target
 
 def msvc_version(compiler):
-    """Return version major and minor of compiler instance if it is
-    MSVC, raise an exception otherwise."""
+    """
+
+    Parameters
+    ----------
+    compiler :
+        
+
+    Returns
+    -------
+    type
+        MSVC, raise an exception otherwise.
+
+    """
     if not compiler.compiler_type == "msvc":
         raise ValueError("Compiler instance is not msvc (%s)"\
                          % compiler.compiler_type)
     return compiler._MSVCCompiler__version
 
 def get_build_architecture():
+    """ """
     # Importing distutils.msvccompiler triggers a warning on non-Windows
     # systems, so delay the import to here.
     from distutils.msvccompiler import get_build_architecture
