# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/util/test_hashing.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/util/test_hashing.py
@@ -21,24 +21,50 @@
     ]
 )
 def series(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 @pytest.fixture(params=[True, False])
 def index(request):
+    """
+
+    Parameters
+    ----------
+    request :
+        
+
+    Returns
+    -------
+
+    """
     return request.param
 
 
 def _check_equal(obj, **kwargs):
-    """
-    Check that hashing an objects produces the same value each time.
-
-    Parameters
-    ----------
-    obj : object
-        The object to hash.
-    kwargs : kwargs
-        Keyword arguments to pass to the hashing function.
+    """Check that hashing an objects produces the same value each time.
+
+    Parameters
+    ----------
+    obj :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    
     """
     a = hash_pandas_object(obj, **kwargs)
     b = hash_pandas_object(obj, **kwargs)
@@ -46,13 +72,17 @@
 
 
 def _check_not_equal_with_index(obj):
-    """
-    Check the hash of an object with and without its index is not the same.
-
-    Parameters
-    ----------
-    obj : object
-        The object to hash.
+    """Check the hash of an object with and without its index is not the same.
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    
     """
     if not isinstance(obj, Index):
         a = hash_pandas_object(obj, index=True)
@@ -63,6 +93,7 @@
 
 
 def test_consistency():
+    """ """
     # Check that our hash doesn't change because of a mistake
     # in the actual code; this is the ground truth.
     result = hash_pandas_object(Index(["foo", "bar", "baz"]))
@@ -77,6 +108,17 @@
 
 
 def test_hash_array(series):
+    """
+
+    Parameters
+    ----------
+    series :
+        
+
+    Returns
+    -------
+
+    """
     arr = series.values
     tm.assert_numpy_array_equal(hash_array(arr), hash_array(arr))
 
@@ -85,6 +127,17 @@
     "arr2", [np.array([3, 4, "All"]), np.array([3, 4, "All"], dtype=object)]
 )
 def test_hash_array_mixed(arr2):
+    """
+
+    Parameters
+    ----------
+    arr2 :
+        
+
+    Returns
+    -------
+
+    """
     result1 = hash_array(np.array(["3", "4", "All"]))
     result2 = hash_array(arr2)
 
@@ -93,12 +146,24 @@
 
 @pytest.mark.parametrize("val", [5, "foo", pd.Timestamp("20130101")])
 def test_hash_array_errors(val):
+    """
+
+    Parameters
+    ----------
+    val :
+        
+
+    Returns
+    -------
+
+    """
     msg = "must pass a ndarray-like"
     with pytest.raises(TypeError, match=msg):
         hash_array(val)
 
 
 def test_hash_tuples():
+    """ """
     tuples = [(1, "one"), (1, "two"), (2, "one")]
     result = hash_tuples(tuples)
 
@@ -111,12 +176,24 @@
 
 @pytest.mark.parametrize("val", [5, "foo", pd.Timestamp("20130101")])
 def test_hash_tuples_err(val):
+    """
+
+    Parameters
+    ----------
+    val :
+        
+
+    Returns
+    -------
+
+    """
     msg = "must be convertible to a list-of-tuples"
     with pytest.raises(TypeError, match=msg):
         hash_tuples(val)
 
 
 def test_multiindex_unique():
+    """ """
     mi = MultiIndex.from_tuples([(118, 472), (236, 118), (51, 204), (102, 51)])
     assert mi.is_unique is True
 
@@ -125,6 +202,7 @@
 
 
 def test_multiindex_objects():
+    """ """
     mi = MultiIndex(
         levels=[["b", "d", "a"], [1, 2, 3]],
         codes=[[0, 1, 0, 2], [2, 0, 0, 1]],
@@ -168,11 +246,37 @@
     ],
 )
 def test_hash_pandas_object(obj, index):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    index :
+        
+
+    Returns
+    -------
+
+    """
     _check_equal(obj, index=index)
     _check_not_equal_with_index(obj)
 
 
 def test_hash_pandas_object2(series, index):
+    """
+
+    Parameters
+    ----------
+    series :
+        
+    index :
+        
+
+    Returns
+    -------
+
+    """
     _check_equal(series, index=index)
     _check_not_equal_with_index(series)
 
@@ -181,6 +285,19 @@
     "obj", [Series([], dtype="float64"), Series([], dtype="object"), Index([])]
 )
 def test_hash_pandas_empty_object(obj, index):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+    index :
+        
+
+    Returns
+    -------
+
+    """
     # These are by-definition the same with
     # or without the index as the data is empty.
     _check_equal(obj, index=index)
@@ -196,6 +313,19 @@
 )
 @pytest.mark.parametrize("categorize", [True, False])
 def test_categorical_consistency(s1, categorize):
+    """
+
+    Parameters
+    ----------
+    s1 :
+        
+    categorize :
+        
+
+    Returns
+    -------
+
+    """
     # see gh-15143
     #
     # Check that categoricals hash consistent with their values,
@@ -213,6 +343,7 @@
 
 
 def test_categorical_with_nan_consistency():
+    """ """
     c = pd.Categorical.from_codes(
         [-1, 0, 1, 2, 3, 4], categories=pd.date_range("2012-01-01", periods=5, name="B")
     )
@@ -227,12 +358,24 @@
 
 @pytest.mark.parametrize("obj", [pd.Timestamp("20130101")])
 def test_pandas_errors(obj):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    """
     msg = "Unexpected type for hashing"
     with pytest.raises(TypeError, match=msg):
         hash_pandas_object(obj)
 
 
 def test_hash_keys():
+    """ """
     # Using different hash keys, should have
     # different hashes for the same data.
     #
@@ -246,6 +389,7 @@
 
 
 def test_invalid_key():
+    """ """
     # This only matters for object dtypes.
     msg = "key should be a 16-byte string encoded"
 
@@ -254,12 +398,34 @@
 
 
 def test_already_encoded(index):
+    """
+
+    Parameters
+    ----------
+    index :
+        
+
+    Returns
+    -------
+
+    """
     # If already encoded, then ok.
     obj = Series(list("abc")).str.encode("utf8")
     _check_equal(obj, index=index)
 
 
 def test_alternate_encoding(index):
+    """
+
+    Parameters
+    ----------
+    index :
+        
+
+    Returns
+    -------
+
+    """
     obj = Series(list("abc"))
     _check_equal(obj, index=index, encoding="ascii")
 
@@ -267,6 +433,19 @@
 @pytest.mark.parametrize("l_exp", range(8))
 @pytest.mark.parametrize("l_add", [0, 1])
 def test_same_len_hash_collisions(l_exp, l_add):
+    """
+
+    Parameters
+    ----------
+    l_exp :
+        
+    l_add :
+        
+
+    Returns
+    -------
+
+    """
     length = 2 ** (l_exp + 8) + l_add
     s = tm.rands_array(length, 2)
 
@@ -275,6 +454,7 @@
 
 
 def test_hash_collisions():
+    """ """
     # Hash collisions are bad.
     #
     # https://github.com/pandas-dev/pandas/issues/14711#issuecomment-264885726
@@ -297,6 +477,7 @@
 
 
 def test_hash_with_tuple():
+    """ """
     # GH#28969 array containing a tuple raises on call to arr.astype(str)
     #  apparently a numpy bug github.com/numpy/numpy/issues/9441
 
@@ -318,6 +499,7 @@
 
 
 def test_hash_object_none_key():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/30887
     result = pd.util.hash_pandas_object(pd.Series(["a", "b"]), hash_key=None)
     expected = pd.Series([4578374827886788867, 17338122309987883691], dtype="uint64")
