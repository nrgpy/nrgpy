# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/testing_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/testing_test.py
@@ -15,6 +15,19 @@
 
 @contextlib.contextmanager
 def set_environ(name, value):
+    """
+
+    Parameters
+    ----------
+    name :
+        
+    value :
+        
+
+    Returns
+    -------
+
+    """
     old_value = os.environ.get(name)
     os.environ[name] = value
 
@@ -28,7 +41,9 @@
 
 
 class AsyncTestCaseTest(AsyncTestCase):
+    """ """
     def test_wait_timeout(self):
+        """ """
         time = self.io_loop.time
 
         # Accept default 5-second timeout, no error
@@ -47,9 +62,15 @@
                 self.wait()
 
     def test_subsequent_wait_calls(self):
-        """
-        This test makes sure that a second call to wait()
+        """This test makes sure that a second call to wait()
         clears the first timeout.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # The first wait ends with time left on the clock
         self.io_loop.add_timeout(self.io_loop.time() + 0.00, self.stop)
@@ -61,12 +82,15 @@
 
 
 class LeakTest(AsyncTestCase):
+    """ """
     def tearDown(self):
+        """ """
         super().tearDown()
         # Trigger a gc to make warnings more deterministic.
         gc.collect()
 
     def test_leaked_coroutine(self):
+        """ """
         # This test verifies that "leaked" coroutines are shut down
         # without triggering warnings like "task was destroyed but it
         # is pending". If this test were to fail, it would fail
@@ -85,7 +109,9 @@
 
 
 class AsyncHTTPTestCaseTest(AsyncHTTPTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         # Bind a second port.
         sock, port = bind_unused_port()
@@ -96,14 +122,17 @@
         self.second_server = server
 
     def get_app(self):
+        """ """
         return Application()
 
     def test_fetch_segment(self):
+        """ """
         path = "/path"
         response = self.fetch(path)
         self.assertEqual(response.request.url, self.get_url(path))
 
     def test_fetch_full_http_url(self):
+        """ """
         # Ensure that self.fetch() recognizes absolute urls and does
         # not transform them into references to our main test server.
         path = "http://localhost:%d/path" % self.second_port
@@ -112,14 +141,19 @@
         self.assertEqual(response.request.url, path)
 
     def tearDown(self):
+        """ """
         self.second_server.stop()
         super().tearDown()
 
 
 class AsyncTestCaseWrapperTest(unittest.TestCase):
+    """ """
     def test_undecorated_generator(self):
+        """ """
         class Test(AsyncTestCase):
+            """ """
             def test_gen(self):
+                """ """
                 yield
 
         test = Test("test_gen")
@@ -133,7 +167,9 @@
         "pypy destructor warnings cannot be silenced",
     )
     def test_undecorated_coroutine(self):
+        """ """
         class Test(AsyncTestCase):
+            """ """
             async def test_coro(self):
                 pass
 
@@ -149,9 +185,12 @@
         self.assertIn("should be decorated", result.errors[0][1])
 
     def test_undecorated_generator_with_skip(self):
+        """ """
         class Test(AsyncTestCase):
+            """ """
             @unittest.skip("don't run this")
             def test_gen(self):
+                """ """
                 yield
 
         test = Test("test_gen")
@@ -161,8 +200,11 @@
         self.assertEqual(len(result.skipped), 1)
 
     def test_other_return(self):
+        """ """
         class Test(AsyncTestCase):
+            """ """
             def test_other_return(self):
+                """ """
                 return 42
 
         test = Test("test_other_return")
@@ -173,27 +215,39 @@
 
 
 class SetUpTearDownTest(unittest.TestCase):
+    """ """
     def test_set_up_tear_down(self):
-        """
-        This test makes sure that AsyncTestCase calls super methods for
+        """This test makes sure that AsyncTestCase calls super methods for
         setUp and tearDown.
-
+        
         InheritBoth is a subclass of both AsyncTestCase and
         SetUpTearDown, with the ordering so that the super of
         AsyncTestCase will be SetUpTearDown.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         events = []
         result = unittest.TestResult()
 
         class SetUpTearDown(unittest.TestCase):
+            """ """
             def setUp(self):
+                """ """
                 events.append("setUp")
 
             def tearDown(self):
+                """ """
                 events.append("tearDown")
 
         class InheritBoth(AsyncTestCase, SetUpTearDown):
+            """ """
             def test(self):
+                """ """
                 events.append("test")
 
         InheritBoth("test").run(result)
@@ -202,14 +256,19 @@
 
 
 class AsyncHTTPTestCaseSetUpTearDownTest(unittest.TestCase):
+    """ """
     def test_tear_down_releases_app_and_http_server(self):
+        """ """
         result = unittest.TestResult()
 
         class SetUpTearDown(AsyncHTTPTestCase):
+            """ """
             def get_app(self):
+                """ """
                 return Application()
 
             def test(self):
+                """ """
                 self.assertTrue(hasattr(self, "_app"))
                 self.assertTrue(hasattr(self, "http_server"))
 
@@ -220,27 +279,34 @@
 
 
 class GenTest(AsyncTestCase):
+    """ """
     def setUp(self):
+        """ """
         super().setUp()
         self.finished = False
 
     def tearDown(self):
+        """ """
         self.assertTrue(self.finished)
         super().tearDown()
 
     @gen_test
     def test_sync(self):
+        """ """
         self.finished = True
 
     @gen_test
     def test_async(self):
+        """ """
         yield gen.moment
         self.finished = True
 
     def test_timeout(self):
+        """ """
         # Set a short timeout and exceed it.
         @gen_test(timeout=0.1)
         def test(self):
+            """ """
             yield gen.sleep(1)
 
         # This can't use assertRaises because we need to inspect the
@@ -256,17 +322,21 @@
         self.finished = True
 
     def test_no_timeout(self):
+        """ """
         # A test that does not exceed its timeout should succeed.
         @gen_test(timeout=1)
         def test(self):
+            """ """
             yield gen.sleep(0.1)
 
         test(self)
         self.finished = True
 
     def test_timeout_environment_variable(self):
+        """ """
         @gen_test(timeout=0.5)
         def test_long_timeout(self):
+            """ """
             yield gen.sleep(0.25)
 
         # Uses provided timeout of 0.5 seconds, doesn't time out.
@@ -276,8 +346,10 @@
         self.finished = True
 
     def test_no_timeout_environment_variable(self):
+        """ """
         @gen_test(timeout=0.01)
         def test_short_timeout(self):
+            """ """
             yield gen.sleep(1)
 
         # Uses environment-variable timeout of 0.1, times out.
@@ -288,8 +360,20 @@
         self.finished = True
 
     def test_with_method_args(self):
+        """ """
         @gen_test
         def test_with_args(self, *args):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+
+            Returns
+            -------
+
+            """
             self.assertEqual(args, ("test",))
             yield gen.moment
 
@@ -297,8 +381,20 @@
         self.finished = True
 
     def test_with_method_kwargs(self):
+        """ """
         @gen_test
         def test_with_kwargs(self, **kwargs):
+            """
+
+            Parameters
+            ----------
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             self.assertDictEqual(kwargs, {"test": "test"})
             yield gen.moment
 
@@ -306,6 +402,7 @@
         self.finished = True
 
     def test_native_coroutine(self):
+        """ """
         @gen_test
         async def test(self):
             self.finished = True
@@ -313,6 +410,7 @@
         test(self)
 
     def test_native_coroutine_timeout(self):
+        """ """
         # Set a short timeout and exceed it.
         @gen_test(timeout=0.1)
         async def test(self):
@@ -326,11 +424,14 @@
 
 
 class GetNewIOLoopTest(AsyncTestCase):
+    """ """
     def get_new_ioloop(self):
+        """ """
         # Use the current loop instead of creating a new one here.
         return ioloop.IOLoop.current()
 
     def setUp(self):
+        """ """
         # This simulates the effect of an asyncio test harness like
         # pytest-asyncio.
         self.orig_loop = asyncio.get_event_loop()
@@ -339,6 +440,7 @@
         super().setUp()
 
     def tearDown(self):
+        """ """
         super().tearDown()
         # AsyncTestCase must not affect the existing asyncio loop.
         self.assertFalse(asyncio.get_event_loop().is_closed())
@@ -346,6 +448,7 @@
         self.new_loop.close()
 
     def test_loop(self):
+        """ """
         self.assertIs(self.io_loop.asyncio_loop, self.new_loop)  # type: ignore
 
 
