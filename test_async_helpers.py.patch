# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/core/tests/test_async_helpers.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/core/tests/test_async_helpers.py
@@ -16,7 +16,9 @@
 from IPython.core.async_helpers import _should_be_async
 
 class AsyncTest(TestCase):
+    """ """
     def test_should_be_async(self):
+        """ """
         nt.assert_false(_should_be_async("False"))
         nt.assert_true(_should_be_async("await bar()"))
         nt.assert_true(_should_be_async("x = await bar()"))
@@ -32,6 +34,7 @@
         )
 
     def _get_top_level_cases(self):
+        """ """
         # These are test cases that should be valid in a function
         # but invalid outside of a function.
         test_cases = []
@@ -113,6 +116,7 @@
         return test_cases
 
     def _get_ry_syntax_errors(self):
+        """ """
         # This is a mix of tests that should be a syntax error if
         # return or yield whether or not they are in a function
 
@@ -120,12 +124,15 @@
 
         test_cases.append(('class', dedent("""
         class V:
+            """ """
             {val}
         """)))
 
         test_cases.append(('nested-class', dedent("""
         class V:
+            """ """
             class C:
+                """ """
                 {val}
         """)))
 
@@ -133,12 +140,14 @@
 
 
     def test_top_level_return_error(self):
+        """ """
         tl_err_test_cases = self._get_top_level_cases()
         tl_err_test_cases.extend(self._get_ry_syntax_errors())
 
         vals = ('return', 'yield', 'yield from (_ for _ in range(3))',
                 dedent('''
                     def f():
+                        """ """
                         pass
                     return
                     '''),
@@ -157,6 +166,7 @@
                         iprc(test_case.format(val=val))
 
     def test_in_func_no_error(self):
+        """ """
         # Test that the implementation of top-level return/yield
         # detection isn't *too* aggressive, and works inside a function
         func_contexts = []
@@ -167,83 +177,108 @@
         func_contexts.append(('method', False, dedent("""
         class MyClass:
             def __init__(self):
-        """)))
-
-        func_contexts.append(('async-func', True,  dedent("""
+            """)))
+            
+                    func_contexts.append(('async-func', True,  dedent(
+
+            Parameters
+            ----------
+            ):""")) :
+                
+
+            Returns
+            -------
         async def f():""")))
 
         func_contexts.append(('async-method', True,  dedent("""
         class MyClass:
-            async def f(self):""")))
-
-        func_contexts.append(('closure', False, dedent("""
+            """async def f(self):""")))
+            
+                    func_contexts.append(('closure', False, dedent(
+
+            Parameters
+            ----------
+
+            Returns
+            -------
         def f():
+            """ """
             def g():
-        """)))
-
-        def nest_case(context, case):
-            # Detect indentation
-            lines = context.strip().splitlines()
-            prefix_len = 0
-            for c in lines[-1]:
+                """)))
+                
+                        def nest_case(context, case):
+                            # Detect indentation
+                            lines = context.strip().splitlines()
+                            prefix_len = 0
+                            for c in lines[-1]:
                 if c != ' ':
                     break
                 prefix_len += 1
-
-            indented_case = indent(case, ' ' * (prefix_len + 4))
-            return context + '\n' + indented_case
-
-        # Gather and run the tests
-
-        # yield is allowed in async functions, starting in Python 3.6,
-        # and yield from is not allowed in any version
-        vals = ('return', 'yield', 'yield from (_ for _ in range(3))')
-        async_safe = (True,
-                        True,
-                        False)
-        vals = tuple(zip(vals, async_safe))
-
-        success_tests = zip(self._get_top_level_cases(), repeat(False))
-        failure_tests = zip(self._get_ry_syntax_errors(), repeat(True))
-
-        tests = chain(success_tests, failure_tests)
-
-        for context_name, async_func, context in func_contexts:
-            for (test_name, test_case), should_fail in tests:
-                nested_case = nest_case(context, test_case)
-
-                for val, async_safe in vals:
+                
+                            indented_case = indent(case, ' ' * (prefix_len + 4))
+
+                Parameters
+                ----------
+
+                Returns
+                -------
+                type
+                    # Gather and run the tests
+                    
+                    # yield is allowed in async functions, starting in Python 3.6,
+                    # and yield from is not allowed in any version
+                    vals = ('return', 'yield', 'yield from (_ for _ in range(3))')
+                    async_safe = (True,
+                    True,
+                    False)
+                    vals = tuple(zip(vals, async_safe))
+                    
+                    success_tests = zip(self._get_top_level_cases(), repeat(False))
+                    failure_tests = zip(self._get_ry_syntax_errors(), repeat(True))
+                    
+                    tests = chain(success_tests, failure_tests)
+                    
+                    for context_name, async_func, context in func_contexts:
+                    for (test_name, test_case), should_fail in tests:
+                    nested_case = nest_case(context, test_case)
+                    
+                    for val, async_safe in vals:
                     val_should_fail = (should_fail or
-                                        (async_func and not async_safe))
-
+                    (async_func and not async_safe))
+                    
                     test_id = (context_name, test_name, val)
                     cell = nested_case.format(val=val)
-
+                    
                     with self.subTest(test_id):
-                        if val_should_fail:
-                            msg = ("SyntaxError not raised for %s" %
-                                    str(test_id))
-                            with self.assertRaises(SyntaxError, msg=msg):
-                                iprc(cell)
-
-                                print(cell)
-                        else:
-                            iprc(cell)
-
-    def test_nonlocal(self):
-        # fails if outer scope is not a function scope or if var not defined
-        with self.assertRaises(SyntaxError):
-            iprc("nonlocal x")
-            iprc("""
+                    if val_should_fail:
+                    msg = ("SyntaxError not raised for %s" %
+                    str(test_id))
+                    with self.assertRaises(SyntaxError, msg=msg):
+                    iprc(cell)
+                    
+                    print(cell)
+                    else:
+                    iprc(cell)
+                    
+                    def test_nonlocal(self):
+                    # fails if outer scope is not a function scope or if var not defined
+                    with self.assertRaises(SyntaxError):
+                    iprc("nonlocal x")
+                    iprc(
+
+                """
             x = 1
             def f():
+                """ """
                 nonlocal x
                 x = 10000
                 yield x
             """)
             iprc("""
             def f():
+                """ """
                 def g():
+                    """ """
                     nonlocal x
                     x = 10000
                     yield x
@@ -252,8 +287,10 @@
         # works if outer scope is a function scope and var exists
         iprc("""
         def f():
+            """ """
             x = 20
             def g():
+                """ """
                 nonlocal x
                 x = 10000
                 yield x
@@ -261,13 +298,19 @@
 
 
     def test_execute(self):
-        iprc("""
+        """iprc("""
         import asyncio
         await asyncio.sleep(0.001)
-        """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
         )
 
     def test_autoawait(self):
+        """ """
         iprc("%autoawait False")
         iprc("%autoawait True")
         iprc("""
@@ -280,19 +323,23 @@
         # new pgen parser in 3.9 does not raise MemoryError on too many nested
         # parens anymore
         def test_memory_error(self):
+            """ """
             with self.assertRaises(MemoryError):
                 iprc("(" * 200 + ")" * 200)
 
     @skip_without('curio')
     def test_autoawait_curio(self):
+        """ """
         iprc("%autoawait curio")
 
     @skip_without('trio')
     def test_autoawait_trio(self):
+        """ """
         iprc("%autoawait trio")
 
     @skip_without('trio')
     def test_autoawait_trio_wrong_sleep(self):
+        """ """
         iprc("%autoawait trio")
         res = iprc_nr("""
         import asyncio
@@ -303,6 +350,7 @@
 
     @skip_without('trio')
     def test_autoawait_asyncio_wrong_sleep(self):
+        """ """
         iprc("%autoawait asyncio")
         res = iprc_nr("""
         import trio
@@ -313,4 +361,5 @@
 
 
     def tearDown(self):
+        """ """
         ip.loop_runner = "asyncio"
