# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/arguments.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/arguments.py
@@ -15,7 +15,19 @@
 
 
 def try_iter_content(types, depth=0):
-    """Helper method for static analysis."""
+    """Helper method for static analysis.
+
+    Parameters
+    ----------
+    types :
+        
+    depth :
+         (Default value = 0)
+
+    Returns
+    -------
+
+    """
     if depth > 10:
         # It's possible that a loop has references on itself (especially with
         # CompiledValue). Therefore don't loop infinitely.
@@ -32,22 +44,55 @@
 
 
 class ParamIssue(Exception):
+    """ """
     pass
 
 
 def repack_with_argument_clinic(clinic_string):
-    """
-    Transforms a function or method with arguments to the signature that is
+    """Transforms a function or method with arguments to the signature that is
     given as an argument clinic notation.
-
+    
     Argument clinic is part of CPython and used for all the functions that are
     implemented in C (Python 3.7):
-
+    
         str.split.__text_signature__
         # Results in: '($self, /, sep=None, maxsplit=-1)'
+
+    Parameters
+    ----------
+    clinic_string :
+        
+
+    Returns
+    -------
+
     """
     def decorator(func):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         def wrapper(value, arguments):
+            """
+
+            Parameters
+            ----------
+            value :
+                
+            arguments :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 args = tuple(iterate_argument_clinic(
                     value.inference_state,
@@ -64,7 +109,21 @@
 
 
 def iterate_argument_clinic(inference_state, arguments, clinic_string):
-    """Uses a list with argument clinic information (see PEP 436)."""
+    """Uses a list with argument clinic information (see PEP 436).
+
+    Parameters
+    ----------
+    inference_state :
+        
+    arguments :
+        
+    clinic_string :
+        
+
+    Returns
+    -------
+
+    """
     clinic_args = list(_parse_argument_clinic(clinic_string))
 
     iterator = PushBackIterator(arguments.unpack())
@@ -103,6 +162,17 @@
 
 
 def _parse_argument_clinic(string):
+    """
+
+    Parameters
+    ----------
+    string :
+        
+
+    Returns
+    -------
+
+    """
     allow_kwargs = False
     optional = False
     while string:
@@ -125,20 +195,45 @@
 
 
 class _AbstractArgumentsMixin(object):
+    """ """
     def unpack(self, funcdef=None):
+        """
+
+        Parameters
+        ----------
+        funcdef :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     def get_calling_nodes(self):
+        """ """
         return []
 
 
 class AbstractArguments(_AbstractArgumentsMixin):
+    """ """
     context = None
     argument_node = None
     trailer = None
 
 
 def unpack_arglist(arglist):
+    """
+
+    Parameters
+    ----------
+    arglist :
+        
+
+    Returns
+    -------
+
+    """
     if arglist is None:
         return
 
@@ -168,9 +263,17 @@
 
 class TreeArguments(AbstractArguments):
     def __init__(self, inference_state, context, argument_node, trailer=None):
-        """
-        :param argument_node: May be an argument_node or a list of nodes.
-        """
+    """
+
+    Parameters
+    ----------
+    argument_node :
+        May be an argument_node or a list of nodes.
+
+    Returns
+    -------
+
+    """
         self.argument_node = argument_node
         self.context = context
         self._inference_state = inference_state
@@ -179,9 +282,33 @@
     @classmethod
     @inference_state_as_method_param_cache()
     def create_cached(cls, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return cls(*args, **kwargs)
 
     def unpack(self, funcdef=None):
+        """
+
+        Parameters
+        ----------
+        funcdef :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         named_args = []
         for star_count, el in unpack_arglist(self.argument_node):
             if star_count == 1:
@@ -225,6 +352,7 @@
             yield named_arg
 
     def _as_tree_tuple_objects(self):
+        """ """
         for star_count, argument in unpack_arglist(self.argument_node):
             default = None
             if argument.type == 'argument':
@@ -233,6 +361,7 @@
             yield argument, default, star_count
 
     def iter_calling_names_with_star(self):
+        """ """
         for name, default, star_count in self._as_tree_tuple_objects():
             # TODO this function is a bit strange. probably refactor?
             if not star_count or not isinstance(name, tree.Name):
@@ -244,6 +373,7 @@
         return '<%s: %s>' % (self.__class__.__name__, self.argument_node)
 
     def get_calling_nodes(self):
+        """ """
         old_arguments_list = []
         arguments = self
 
@@ -274,10 +404,22 @@
 
 
 class ValuesArguments(AbstractArguments):
+    """ """
     def __init__(self, values_list):
         self._values_list = values_list
 
     def unpack(self, funcdef=None):
+        """
+
+        Parameters
+        ----------
+        funcdef :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         for values in self._values_list:
             yield None, LazyKnownValues(values)
 
@@ -286,25 +428,41 @@
 
 
 class TreeArgumentsWrapper(_AbstractArgumentsMixin):
+    """ """
     def __init__(self, arguments):
         self._wrapped_arguments = arguments
 
     @property
     def context(self):
+        """ """
         return self._wrapped_arguments.context
 
     @property
     def argument_node(self):
+        """ """
         return self._wrapped_arguments.argument_node
 
     @property
     def trailer(self):
+        """ """
         return self._wrapped_arguments.trailer
 
     def unpack(self, func=None):
+        """
+
+        Parameters
+        ----------
+        func :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError
 
     def get_calling_nodes(self):
+        """ """
         return self._wrapped_arguments.get_calling_nodes()
 
     def __repr__(self):
@@ -312,6 +470,23 @@
 
 
 def _iterate_star_args(context, array, input_node, funcdef=None):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    array :
+        
+    input_node :
+        
+    funcdef :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if not array.py__getattribute__('__iter__'):
         if funcdef is not None:
             # TODO this funcdef should not be needed.
@@ -328,6 +503,23 @@
 
 
 def _star_star_dict(context, array, input_node, funcdef):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    array :
+        
+    input_node :
+        
+    funcdef :
+        
+
+    Returns
+    -------
+
+    """
     from jedi.inference.value.instance import CompiledInstance
     if isinstance(array, CompiledInstance) and array.name.string_name == 'dict':
         # For now ignore this case. In the future add proper iterators and just
