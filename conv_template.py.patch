# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/distutils/conv_template.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/distutils/conv_template.py
@@ -101,9 +101,18 @@
 """
 # Parse string for repeat loops
 def parse_structure(astr, level):
-    """
-    The returned line number is from the beginning of the string, starting
+    """The returned line number is from the beginning of the string, starting
     at zero. Returns an empty list if no loops found.
+
+    Parameters
+    ----------
+    astr :
+        
+    level :
+        
+
+    Returns
+    -------
 
     """
     if level == 0 :
@@ -133,6 +142,17 @@
 
 
 def paren_repl(obj):
+    """
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    """
     torep = obj.group(1)
     numrep = obj.group(2)
     return ','.join([torep]*int(numrep))
@@ -140,6 +160,17 @@
 parenrep = re.compile(r"[(]([^)]*)[)]\*(\d+)")
 plainrep = re.compile(r"([^*]+)\*(\d+)")
 def parse_values(astr):
+    """
+
+    Parameters
+    ----------
+    astr :
+        
+
+    Returns
+    -------
+
+    """
     # replaces all occurrences of '(a,b,c)*4' in astr
     # with 'a,b,c,a,b,c,a,b,c,a,b,c'. Empty braces generate
     # empty values, i.e., ()*4 yields ',,,'. The result is
@@ -157,14 +188,22 @@
 exclude_re = re.compile(":exclude:")
 def parse_loop_header(loophead) :
     """Find all named replacements in the header
-
+    
     Returns a list of dictionaries, one for each loop iteration,
     where each key is a name to be substituted and the corresponding
     value is the replacement string.
-
+    
     Also return a list of exclusions.  The exclusions are dictionaries
      of key value pairs. There can be more than one exclusion.
      [{'var1':'value1', 'var2', 'value2'[,...]}, ...]
+
+    Parameters
+    ----------
+    loophead :
+        
+
+    Returns
+    -------
 
     """
     # Strip out '\n' and leading '*', if any, in continuation lines.
@@ -209,10 +248,38 @@
 
 replace_re = re.compile(r"@([\w]+)@")
 def parse_string(astr, env, level, line) :
+    """
+
+    Parameters
+    ----------
+    astr :
+        
+    env :
+        
+    level :
+        
+    line :
+        
+
+    Returns
+    -------
+
+    """
     lineno = "#line %d\n" % line
 
     # local function for string replacement, uses env
     def replace(match):
+        """
+
+        Parameters
+        ----------
+        match :
+            
+
+        Returns
+        -------
+
+        """
         name = match.group(1)
         try :
             val = env[name]
@@ -252,6 +319,17 @@
     return ''.join(code)
 
 def process_str(astr):
+    """
+
+    Parameters
+    ----------
+    astr :
+        
+
+    Returns
+    -------
+
+    """
     code = [header]
     code.extend(parse_string(astr, global_names, 0, 1))
     return ''.join(code)
@@ -261,6 +339,17 @@
                             r"(?P<name>[\w\d./\\]+[.]src)['\"]", re.I)
 
 def resolve_includes(source):
+    """
+
+    Parameters
+    ----------
+    source :
+        
+
+    Returns
+    -------
+
+    """
     d = os.path.dirname(source)
     with open(source) as fid:
         lines = []
@@ -280,6 +369,17 @@
     return lines
 
 def process_file(source):
+    """
+
+    Parameters
+    ----------
+    source :
+        
+
+    Returns
+    -------
+
+    """
     lines = resolve_includes(source)
     sourcefile = os.path.normcase(source).replace("\\", "\\\\")
     try:
@@ -290,6 +390,17 @@
 
 
 def unique_key(adict):
+    """
+
+    Parameters
+    ----------
+    adict :
+        
+
+    Returns
+    -------
+
+    """
     # this obtains a unique key given a dictionary
     # currently it works by appending together n of the letters of the
     #   current keys and increasing n until a unique key is found
@@ -307,6 +418,7 @@
 
 
 def main():
+    """ """
     try:
         file = sys.argv[1]
     except IndexError:
