# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/arrays/test_datetimes.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/arrays/test_datetimes.py
@@ -15,12 +15,15 @@
 
 
 class TestDatetimeArrayConstructor:
+    """ """
     def test_from_sequence_invalid_type(self):
+        """ """
         mi = pd.MultiIndex.from_product([np.arange(5), np.arange(5)])
         with pytest.raises(TypeError, match="Cannot create a DatetimeArray"):
             DatetimeArray._from_sequence(mi)
 
     def test_only_1dim_accepted(self):
+        """ """
         arr = np.array([0, 1, 2, 3], dtype="M8[h]").astype("M8[ns]")
 
         with pytest.raises(ValueError, match="Only 1-dimensional"):
@@ -32,6 +35,7 @@
             DatetimeArray(arr[[0]].squeeze())
 
     def test_freq_validation(self):
+        """ """
         # GH#24623 check that invalid instances cannot be created with the
         #  public constructor
         arr = np.arange(5, dtype=np.int64) * 3600 * 10 ** 9
@@ -53,6 +57,17 @@
         ],
     )
     def test_mixing_naive_tzaware_raises(self, meth):
+        """
+
+        Parameters
+        ----------
+        meth :
+            
+
+        Returns
+        -------
+
+        """
         # GH#24569
         arr = np.array([pd.Timestamp("2000"), pd.Timestamp("2000", tz="CET")])
 
@@ -69,6 +84,7 @@
                 meth(obj)
 
     def test_from_pandas_array(self):
+        """ """
         arr = pd.array(np.arange(5, dtype=np.int64)) * 3600 * 10 ** 9
 
         result = DatetimeArray._from_sequence(arr, freq="infer")
@@ -77,6 +93,7 @@
         tm.assert_datetime_array_equal(result, expected)
 
     def test_mismatched_timezone_raises(self):
+        """ """
         arr = DatetimeArray(
             np.array(["2000-01-01T06:00:00"], dtype="M8[ns]"),
             dtype=DatetimeTZDtype(tz="US/Central"),
@@ -86,10 +103,12 @@
             DatetimeArray(arr, dtype=dtype)
 
     def test_non_array_raises(self):
+        """ """
         with pytest.raises(ValueError, match="list"):
             DatetimeArray([1, 2, 3])
 
     def test_bool_dtype_raises(self):
+        """ """
         arr = np.array([1, 2, 3], dtype="bool")
 
         with pytest.raises(
@@ -111,14 +130,17 @@
             pd.to_datetime(arr)
 
     def test_incorrect_dtype_raises(self):
+        """ """
         with pytest.raises(ValueError, match="Unexpected value for 'dtype'."):
             DatetimeArray(np.array([1, 2, 3], dtype="i8"), dtype="category")
 
     def test_freq_infer_raises(self):
+        """ """
         with pytest.raises(ValueError, match="Frequency inference"):
             DatetimeArray(np.array([1, 2, 3], dtype="i8"), freq="infer")
 
     def test_copy(self):
+        """ """
         data = np.array([1, 2, 3], dtype="M8[ns]")
         arr = DatetimeArray(data, copy=False)
         assert arr._data is data
@@ -128,10 +150,22 @@
 
 
 class TestDatetimeArrayComparisons:
+    """ """
     # TODO: merge this into tests/arithmetic/test_datetime64 once it is
     #  sufficiently robust
 
     def test_cmp_dt64_arraylike_tznaive(self, all_compare_operators):
+        """
+
+        Parameters
+        ----------
+        all_compare_operators :
+            
+
+        Returns
+        -------
+
+        """
         # arbitrary tz-naive DatetimeIndex
         opname = all_compare_operators.strip("_")
         op = getattr(operator, opname)
@@ -161,7 +195,9 @@
 
 
 class TestDatetimeArray:
+    """ """
     def test_astype_to_same(self):
+        """ """
         arr = DatetimeArray._from_sequence(["2000"], tz="US/Central")
         result = arr.astype(DatetimeTZDtype(tz="US/Central"), copy=False)
         assert result is arr
@@ -171,6 +207,19 @@
         "other", ["datetime64[ns]", "datetime64[ns, UTC]", "datetime64[ns, CET]"]
     )
     def test_astype_copies(self, dtype, other):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        other :
+            
+
+        Returns
+        -------
+
+        """
         # https://github.com/pandas-dev/pandas/pull/32490
         s = pd.Series([1, 2], dtype=dtype)
         orig = s.copy()
@@ -180,6 +229,17 @@
 
     @pytest.mark.parametrize("dtype", [int, np.int32, np.int64, "uint32", "uint64"])
     def test_astype_int(self, dtype):
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         arr = DatetimeArray._from_sequence([pd.Timestamp("2000"), pd.Timestamp("2001")])
         result = arr.astype(dtype)
 
@@ -193,11 +253,13 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_tz_setter_raises(self):
+        """ """
         arr = DatetimeArray._from_sequence(["2000"], tz="US/Central")
         with pytest.raises(AttributeError, match="tz_localize"):
             arr.tz = "UTC"
 
     def test_setitem_different_tz_raises(self):
+        """ """
         data = np.array([1, 2, 3], dtype="M8[ns]")
         arr = DatetimeArray(data, copy=False, dtype=DatetimeTZDtype(tz="US/Central"))
         with pytest.raises(TypeError, match="Cannot compare tz-naive and tz-aware"):
@@ -207,6 +269,7 @@
             arr[0] = pd.Timestamp("2000", tz="US/Eastern")
 
     def test_setitem_clears_freq(self):
+        """ """
         a = DatetimeArray(pd.date_range("2000", periods=2, freq="D", tz="US/Central"))
         a[0] = pd.Timestamp("2000", tz="US/Central")
         assert a.freq is None
@@ -220,6 +283,17 @@
         ],
     )
     def test_setitem_objects(self, obj):
+        """
+
+        Parameters
+        ----------
+        obj :
+            
+
+        Returns
+        -------
+
+        """
         # make sure we accept datetime64 and datetime in addition to Timestamp
         dti = pd.date_range("2000", periods=2, freq="D")
         arr = dti._data
@@ -228,6 +302,7 @@
         assert arr[0] == obj
 
     def test_repeat_preserves_tz(self):
+        """ """
         dti = pd.date_range("2000", periods=2, freq="D", tz="US/Central")
         arr = DatetimeArray(dti)
 
@@ -238,6 +313,7 @@
         tm.assert_equal(repeated, expected)
 
     def test_value_counts_preserves_tz(self):
+        """ """
         dti = pd.date_range("2000", periods=2, freq="D", tz="US/Central")
         arr = DatetimeArray(dti).repeat([4, 3])
 
@@ -253,6 +329,17 @@
 
     @pytest.mark.parametrize("method", ["pad", "backfill"])
     def test_fillna_preserves_tz(self, method):
+        """
+
+        Parameters
+        ----------
+        method :
+            
+
+        Returns
+        -------
+
+        """
         dti = pd.date_range("2000-01-01", periods=5, freq="D", tz="US/Central")
         arr = DatetimeArray(dti, copy=True)
         arr[2] = pd.NaT
@@ -270,6 +357,7 @@
         assert dti[2] == pd.Timestamp("2000-01-03", tz="US/Central")
 
     def test_array_interface_tz(self):
+        """ """
         tz = "US/Central"
         data = DatetimeArray(pd.date_range("2017", periods=2, tz=tz))
         result = np.asarray(data)
@@ -294,6 +382,7 @@
         tm.assert_numpy_array_equal(result, expected)
 
     def test_array_interface(self):
+        """ """
         data = DatetimeArray(pd.date_range("2017", periods=2))
         expected = np.array(
             ["2017-01-01T00:00:00", "2017-01-02T00:00:00"], dtype="datetime64[ns]"
@@ -311,6 +400,17 @@
 
     @pytest.mark.parametrize("index", [True, False])
     def test_searchsorted_different_tz(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
         arr = DatetimeArray(data, freq="D").tz_localize("Asia/Tokyo")
         if index:
@@ -326,6 +426,17 @@
 
     @pytest.mark.parametrize("index", [True, False])
     def test_searchsorted_tzawareness_compat(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
         arr = DatetimeArray(data, freq="D")
         if index:
@@ -360,6 +471,19 @@
     )
     @pytest.mark.parametrize("index", [True, False])
     def test_searchsorted_invalid_types(self, other, index):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        index :
+            
+
+        Returns
+        -------
+
+        """
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
         arr = DatetimeArray(data, freq="D")
         if index:
@@ -375,6 +499,7 @@
             arr.searchsorted(other)
 
     def test_shift_fill_value(self):
+        """ """
         dti = pd.date_range("2016-01-01", periods=3)
 
         dta = dti._data
@@ -393,6 +518,7 @@
             tm.assert_datetime_array_equal(result, expected)
 
     def test_shift_value_tzawareness_mismatch(self):
+        """ """
         dti = pd.date_range("2016-01-01", periods=3)
 
         dta = dti._data
@@ -410,20 +536,35 @@
 
 
 class TestSequenceToDT64NS:
+    """ """
     def test_tz_dtype_mismatch_raises(self):
+        """ """
         arr = DatetimeArray._from_sequence(["2000"], tz="US/Central")
         with pytest.raises(TypeError, match="data is already tz-aware"):
             sequence_to_dt64ns(arr, dtype=DatetimeTZDtype(tz="UTC"))
 
     def test_tz_dtype_matches(self):
+        """ """
         arr = DatetimeArray._from_sequence(["2000"], tz="US/Central")
         result, _, _ = sequence_to_dt64ns(arr, dtype=DatetimeTZDtype(tz="US/Central"))
         tm.assert_numpy_array_equal(arr._data, result)
 
 
 class TestReductions:
+    """ """
     @pytest.mark.parametrize("tz", [None, "US/Central"])
     def test_min_max(self, tz):
+        """
+
+        Parameters
+        ----------
+        tz :
+            
+
+        Returns
+        -------
+
+        """
         arr = DatetimeArray._from_sequence(
             [
                 "2000-01-03",
@@ -453,6 +594,19 @@
     @pytest.mark.parametrize("tz", [None, "US/Central"])
     @pytest.mark.parametrize("skipna", [True, False])
     def test_min_max_empty(self, skipna, tz):
+        """
+
+        Parameters
+        ----------
+        skipna :
+            
+        tz :
+            
+
+        Returns
+        -------
+
+        """
         arr = DatetimeArray._from_sequence([], tz=tz)
         result = arr.min(skipna=skipna)
         assert result is pd.NaT
