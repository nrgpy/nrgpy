# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_scalarprint.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/core/tests/test_scalarprint.py
@@ -12,7 +12,9 @@
 from numpy.testing import assert_, assert_equal
 
 class TestRealScalars:
+    """ """
     def test_str(self):
+        """ """
         svals = [0.0, -0.0, 1, -1, np.inf, -np.inf, np.nan]
         styps = [np.float16, np.float32, np.float64, np.longdouble]
         wanted = [
@@ -30,9 +32,21 @@
                 assert_equal(str(styp(val)), want, err_msg=msg)
 
     def test_scalar_cutoffs(self):
+        """ """
         # test that both the str and repr of np.float64 behaves
         # like python floats in python3.
         def check(v):
+            """
+
+            Parameters
+            ----------
+            v :
+                
+
+            Returns
+            -------
+
+            """
             assert_equal(str(np.float64(v)), str(v))
             assert_equal(str(np.float64(v)), repr(v))
             assert_equal(repr(np.float64(v)), repr(v))
@@ -49,6 +63,7 @@
         check(1e16)
 
     def test_py2_float_print(self):
+        """ """
         # gh-10753
         # In python2, the python float type implements an obsolete method
         # tp_print, which overrides tp_repr and tp_str when using "print" to
@@ -74,6 +89,7 @@
 
         # dummy user-input which enters one line and then ctrl-Ds.
         def userinput():
+            """ """
             yield 'np.sqrt(2)'
             raise EOFError
         gen = userinput()
@@ -93,6 +109,7 @@
         assert_equal(capture, repr(np.sqrt(2)))
 
     def test_dragon4(self):
+        """ """
         # these tests are adapted from Ryan Juckett's dragon4 implementation,
         # see dragon4.c for details.
 
@@ -203,6 +220,7 @@
         assert_equal(fpos64('324', unique=False, precision=5, fractional=False), "324.00")
 
     def test_dragon4_interface(self):
+        """ """
         tps = [np.float16, np.float32, np.float64]
         if hasattr(np, 'float128'):
             tps.append(np.float128)
@@ -251,6 +269,7 @@
     @pytest.mark.skipif(not platform.machine().startswith("ppc64"),
                         reason="only applies to ppc float128 values")
     def test_ppc64_ibm_double_double128(self):
+        """ """
         # check that the precision decreases once we get into the subnormal
         # range. Unlike float64, this starts around 1e-292 instead of 1e-308,
         # which happens when the first double is normal and the second is
@@ -309,6 +328,7 @@
         assert_(a != b)
 
     def float32_roundtrip(self):
+        """ """
         # gh-9360
         x = np.float32(1024 - 2**-14)
         y = np.float32(1024 - 2**-13)
@@ -317,6 +337,7 @@
         assert_equal(np.float32(repr(y)), y)
 
     def float64_vs_python(self):
+        """ """
         # gh-2643, gh-6136, gh-6908
         assert_equal(repr(np.float64(0.1)), repr(0.1))
         assert_(repr(np.float64(0.20000000000000004)) != repr(0.2))
