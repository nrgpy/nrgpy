# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/period/test_period.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/period/test_period.py
@@ -23,6 +23,7 @@
 
 
 class TestPeriodIndex(DatetimeLike):
+    """ """
     _holder = PeriodIndex
 
     @pytest.fixture(
@@ -33,21 +34,46 @@
         ids=["index_inc", "index_dec"],
     )
     def index(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         return request.param
 
     def create_index(self) -> PeriodIndex:
+        """ """
         return period_range("20130101", periods=5, freq="D")
 
     def test_pickle_compat_construction(self):
+        """ """
         pass
 
     @pytest.mark.parametrize("freq", ["D", "M", "A"])
     def test_pickle_round_trip(self, freq):
+        """
+
+        Parameters
+        ----------
+        freq :
+            
+
+        Returns
+        -------
+
+        """
         idx = PeriodIndex(["2016-05-16", "NaT", NaT, np.NaN], freq=freq)
         result = tm.round_trip_pickle(idx)
         tm.assert_index_equal(result, idx)
 
     def test_where(self):
+        """ """
         # This is handled in test_indexing
         pass
 
@@ -61,6 +87,19 @@
         ],
     )
     def test_repeat_freqstr(self, index, use_numpy):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+        use_numpy :
+            
+
+        Returns
+        -------
+
+        """
         # GH10183
         expected = PeriodIndex([p for p in index for _ in range(3)])
         result = np.repeat(index, 3) if use_numpy else index.repeat(3)
@@ -68,6 +107,7 @@
         assert result.freqstr == index.freqstr
 
     def test_no_millisecond_field(self):
+        """ """
         msg = "type object 'DatetimeIndex' has no attribute 'millisecond'"
         with pytest.raises(AttributeError, match=msg):
             DatetimeIndex.millisecond
@@ -77,11 +117,13 @@
             DatetimeIndex([]).millisecond
 
     def test_make_time_series(self):
+        """ """
         index = period_range(freq="A", start="1/1/2001", end="12/1/2009")
         series = Series(1, index=index)
         assert isinstance(series, Series)
 
     def test_shallow_copy_empty(self):
+        """ """
         # GH13067
         idx = PeriodIndex([], freq="M")
         result = idx._shallow_copy()
@@ -90,17 +132,20 @@
         tm.assert_index_equal(result, expected)
 
     def test_shallow_copy_disallow_i8(self):
+        """ """
         # GH-24391
         pi = period_range("2018-01-01", periods=3, freq="2D")
         with pytest.raises(AssertionError, match="ndarray"):
             pi._shallow_copy(pi.asi8)
 
     def test_shallow_copy_requires_disallow_period_index(self):
+        """ """
         pi = period_range("2018-01-01", periods=3, freq="2D")
         with pytest.raises(AssertionError, match="PeriodIndex"):
             pi._shallow_copy(pi)
 
     def test_view_asi8(self):
+        """ """
         idx = PeriodIndex([], freq="M")
 
         exp = np.array([], dtype=np.int64)
@@ -119,6 +164,7 @@
         tm.assert_numpy_array_equal(idx.asi8, exp)
 
     def test_values(self):
+        """ """
         idx = PeriodIndex([], freq="M")
 
         exp = np.array([], dtype=object)
@@ -145,6 +191,7 @@
         tm.assert_numpy_array_equal(idx.asi8, exp)
 
     def test_period_index_length(self):
+        """ """
         pi = period_range(freq="A", start="1/1/2001", end="12/1/2009")
         assert len(pi) == 9
 
@@ -205,6 +252,7 @@
             PeriodIndex(vals)
 
     def test_fields(self):
+        """ """
         # year, month, day, hour, minute
         # second, weekofyear, week, dayofweek, weekday, dayofyear, quarter
         # qyear
@@ -239,6 +287,17 @@
         self._check_all_fields(i1)
 
     def _check_all_fields(self, periodindex):
+        """
+
+        Parameters
+        ----------
+        periodindex :
+            
+
+        Returns
+        -------
+
+        """
         fields = [
             "year",
             "month",
@@ -273,6 +332,7 @@
                 assert getattr(x, field) == val
 
     def test_period_set_index_reindex(self):
+        """ """
         # GH 6631
         df = DataFrame(np.random.random(6))
         idx1 = period_range("2011/01/01", periods=6, freq="M")
@@ -303,6 +363,23 @@
     def test_period_reindex_with_object(
         self, p_values, o_values, values, expected_values
     ):
+        """
+
+        Parameters
+        ----------
+        p_values :
+            
+        o_values :
+            
+        values :
+            
+        expected_values :
+            
+
+        Returns
+        -------
+
+        """
         # GH 28337
         period_index = PeriodIndex(p_values)
         object_index = Index(o_values)
@@ -313,6 +390,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_is_(self):
+        """ """
         create_index = lambda: period_range(freq="A", start="1/1/2001", end="12/1/2009")
         index = create_index()
         assert index.is_(index)
@@ -331,6 +409,7 @@
         assert not index.is_(index - 0)
 
     def test_periods_number_check(self):
+        """ """
         msg = (
             "Of the three parameters: start, end, and periods, exactly two "
             "must be specified"
@@ -339,6 +418,7 @@
             period_range("2011-1-1", "2012-1-1", "B")
 
     def test_index_duplicate_periods(self):
+        """ """
         # monotonic
         idx = PeriodIndex([2000, 2007, 2007, 2009, 2009], freq="A-JUN")
         ts = Series(np.random.randn(len(idx)), index=idx)
@@ -358,6 +438,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_index_unique(self):
+        """ """
         idx = PeriodIndex([2000, 2007, 2007, 2009, 2009], freq="A-JUN")
         expected = PeriodIndex([2000, 2007, 2009], freq="A-JUN")
         tm.assert_index_equal(idx.unique(), expected)
@@ -369,14 +450,17 @@
         assert idx.nunique() == 3
 
     def test_shift(self):
+        """ """
         # This is tested in test_arithmetic
         pass
 
     @td.skip_if_32bit
     def test_ndarray_compat_properties(self):
+        """ """
         super().test_ndarray_compat_properties()
 
     def test_negative_ordinals(self):
+        """ """
         Period(ordinal=-1000, freq="A")
         Period(ordinal=0, freq="A")
 
@@ -385,6 +469,7 @@
         tm.assert_index_equal(idx1, idx2)
 
     def test_pindex_fieldaccessor_nat(self):
+        """ """
         idx = PeriodIndex(
             ["2011-01", "2011-02", "NaT", "2012-03", "2012-04"], freq="D", name="name"
         )
@@ -395,12 +480,14 @@
         tm.assert_index_equal(idx.month, exp)
 
     def test_pindex_qaccess(self):
+        """ """
         pi = PeriodIndex(["2Q05", "3Q05", "4Q05", "1Q06", "2Q06"], freq="Q")
         s = Series(np.random.rand(len(pi)), index=pi).cumsum()
         # Todo: fix these accessors!
         assert s["05Q4"] == s[2]
 
     def test_pindex_multiples(self):
+        """ """
         expected = PeriodIndex(
             ["2011-01", "2011-03", "2011-05", "2011-07", "2011-09", "2011-11"],
             freq="2M",
@@ -417,6 +504,7 @@
         assert pi.freqstr == "2M"
 
     def test_iteration(self):
+        """ """
         index = period_range(start="1/1/10", periods=4, freq="B")
 
         result = list(index)
@@ -424,6 +512,7 @@
         assert result[0].freq == index.freq
 
     def test_is_full(self):
+        """ """
         index = PeriodIndex([2005, 2007, 2009], freq="A")
         assert not index.is_full
 
@@ -443,6 +532,7 @@
         assert index[:0].is_full
 
     def test_with_multi_index(self):
+        """ """
         # #1705
         index = date_range("1/1/2012", periods=4, freq="12H")
         index_as_arrays = [index.to_period(freq="D"), index.hour]
@@ -454,6 +544,7 @@
         assert isinstance(s.index.values[0][0], Period)
 
     def test_convert_array_of_periods(self):
+        """ """
         rng = period_range("1/1/2000", periods=20, freq="D")
         periods = list(rng)
 
@@ -461,6 +552,7 @@
         assert isinstance(result, PeriodIndex)
 
     def test_append_concat(self):
+        """ """
         # #1815
         d1 = date_range("12/31/1990", "12/31/1999", freq="A-DEC")
         d2 = date_range("12/31/2000", "12/31/2009", freq="A-DEC")
@@ -477,6 +569,7 @@
         assert result.index[0] == s1.index[0]
 
     def test_pickle_freq(self):
+        """ """
         # GH2891
         prng = period_range("1/1/2011", "1/1/2012", freq="M")
         new_prng = tm.round_trip_pickle(prng)
@@ -484,6 +577,7 @@
         assert new_prng.freqstr == "M"
 
     def test_map(self):
+        """ """
         # test_map_dictlike generally tests
 
         index = PeriodIndex([2005, 2007, 2009], freq="A")
@@ -492,6 +586,7 @@
         tm.assert_index_equal(result, exp)
 
     def test_insert(self):
+        """ """
         # GH 18295 (test missing)
         expected = PeriodIndex(["2017Q1", NaT, "2017Q2", "2017Q3", "2017Q4"], freq="Q")
         for na in (np.nan, NaT, None):
@@ -517,6 +612,19 @@
         ],
     )
     def test_contains_raise_error_if_period_index_is_in_multi_index(self, msg, key):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+        key :
+            
+
+        Returns
+        -------
+
+        """
         # issue 20684
         """
         parse_time_string return parameter if type not matched.
@@ -537,6 +645,7 @@
             df.loc[key]
 
     def test_format_empty(self):
+        """ """
         # GH35712
         empty_idx = self._holder([], freq="A")
         assert empty_idx.format() == []
@@ -544,6 +653,7 @@
 
 
 def test_maybe_convert_timedelta():
+    """ """
     pi = PeriodIndex(["2000", "2001"], freq="D")
     offset = offsets.Day(2)
     assert pi._maybe_convert_timedelta(offset) == 2
@@ -556,6 +666,7 @@
 
 
 def test_is_monotonic_with_nat():
+    """ """
     # GH#31437
     # PeriodIndex.is_monotonic should behave analogously to DatetimeIndex,
     #  in particular never be monotonic when we have NaT
@@ -598,6 +709,17 @@
 
 @pytest.mark.parametrize("array", [True, False])
 def test_dunder_array(array):
+    """
+
+    Parameters
+    ----------
+    array :
+        
+
+    Returns
+    -------
+
+    """
     obj = PeriodIndex(["2000-01-01", "2001-01-01"], freq="D")
     if array:
         obj = obj._data
