# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/value/klass.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/value/klass.py
@@ -55,6 +55,7 @@
 
 
 class ClassName(TreeNameDefinition):
+    """ """
     def __init__(self, class_value, tree_name, name_context, apply_decorators):
         super(ClassName, self).__init__(name_context, tree_name)
         self._apply_decorators = apply_decorators
@@ -62,6 +63,7 @@
 
     @iterator_to_value_set
     def infer(self):
+        """ """
         # We're using a different value to infer, so we cannot call super().
         from jedi.inference.syntax_tree import tree_name_to_values
         inferred = tree_name_to_values(
@@ -76,6 +78,7 @@
 
 
 class ClassFilter(ParserTreeFilter):
+    """ """
     def __init__(self, class_value, node_context=None, until_position=None,
                  origin_scope=None, is_instance=False):
         super(ClassFilter, self).__init__(
@@ -87,6 +90,17 @@
         self._is_instance = is_instance
 
     def _convert_names(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         return [
             ClassName(
                 class_value=self._class_value,
@@ -97,6 +111,7 @@
         ]
 
     def _equals_origin_scope(self):
+        """ """
         node = self._origin_scope
         while node is not None:
             if node == self._parser_scope or node == self.parent_context:
@@ -105,6 +120,17 @@
         return False
 
     def _access_possible(self, name):
+        """
+
+        Parameters
+        ----------
+        name :
+            
+
+        Returns
+        -------
+
+        """
         # Filter for ClassVar variables
         # TODO this is not properly done, yet. It just checks for the string
         # ClassVar in the annotation, which can be quite imprecise. If we
@@ -125,18 +151,43 @@
             or self._equals_origin_scope()
 
     def _filter(self, names):
+        """
+
+        Parameters
+        ----------
+        names :
+            
+
+        Returns
+        -------
+
+        """
         names = super(ClassFilter, self)._filter(names)
         return [name for name in names if self._access_possible(name)]
 
 
 class ClassMixin(object):
+    """ """
     def is_class(self):
+        """ """
         return True
 
     def is_class_mixin(self):
+        """ """
         return True
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.value import TreeInstance
 
         from jedi.inference.gradual.typing import TypedDict
@@ -145,17 +196,21 @@
         return ValueSet([TreeInstance(self.inference_state, self.parent_context, self, arguments)])
 
     def py__class__(self):
+        """ """
         return compiled.builtin_from_name(self.inference_state, u'type')
 
     @property
     def name(self):
+        """ """
         return ValueName(self, self.tree_node.name)
 
     def py__name__(self):
+        """ """
         return self.name.string_name
 
     @inference_state_method_generator_cache()
     def py__mro__(self):
+        """ """
         mro = [self]
         yield self
         # TODO Do a proper mro resolution. Currently we are just listing
@@ -189,6 +244,23 @@
 
     def get_filters(self, origin_scope=None, is_instance=False,
                     include_metaclasses=True, include_type_when_class=True):
+        """
+
+        Parameters
+        ----------
+        origin_scope :
+             (Default value = None)
+        is_instance :
+             (Default value = False)
+        include_metaclasses :
+             (Default value = True)
+        include_type_when_class :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if include_metaclasses:
             metaclasses = self.get_metaclasses()
             if metaclasses:
@@ -224,6 +296,7 @@
                     yield x
 
     def get_signatures(self):
+        """ """
         # Since calling staticmethod without a function is illegal, the Jedi
         # plugin doesn't return anything. Therefore call directly and get what
         # we want: An instance of staticmethod.
@@ -237,15 +310,28 @@
         return [sig.bind(self) for sig in init_funcs.get_signatures()]
 
     def _as_context(self):
+        """ """
         return ClassContext(self)
 
     def get_type_hint(self, add_class_info=True):
+        """
+
+        Parameters
+        ----------
+        add_class_info :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if add_class_info:
             return 'Type[%s]' % self.py__name__()
         return self.py__name__()
 
     @inference_state_method_cache(default=False)
     def is_typeddict(self):
+        """ """
         # TODO Do a proper mro resolution. Currently we are just listing
         # classes. However, it's a complicated algorithm.
         from jedi.inference.gradual.typing import TypedDictClass
@@ -275,6 +361,19 @@
         return False
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.gradual.base import GenericClass
         if not index_value_set:
             debug.warning('Class indexes inferred to nothing. Returning class instead')
@@ -291,6 +390,17 @@
         )
 
     def with_generics(self, generics_tuple):
+        """
+
+        Parameters
+        ----------
+        generics_tuple :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.gradual.base import GenericClass
         return GenericClass(
             self,
@@ -298,17 +408,34 @@
         )
 
     def define_generics(self, type_var_dict):
+        """
+
+        Parameters
+        ----------
+        type_var_dict :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.gradual.base import GenericClass
 
         def remap_type_vars():
-            """
-            The TypeVars in the resulting classes have sometimes different names
+            """The TypeVars in the resulting classes have sometimes different names
             and we need to check for that, e.g. a signature can be:
-
+            
             def iter(iterable: Iterable[_T]) -> Iterator[_T]: ...
-
+            
             However, the iterator is defined as Iterator[_T_co], which means it has
             a different type var name.
+
+            Parameters
+            ----------
+
+            Returns
+            -------
+
             """
             for type_var in self.list_type_vars():
                 yield type_var_dict.get(type_var.py__name__(), NO_VALUES)
@@ -322,10 +449,12 @@
 
 
 class ClassValue(use_metaclass(CachedMetaClass, ClassMixin, FunctionAndClassBase)):
+    """ """
     api_type = u'class'
 
     @inference_state_method_cache()
     def list_type_vars(self):
+        """ """
         found = []
         arglist = self.tree_node.get_super_arglist()
         if arglist is None:
@@ -343,6 +472,7 @@
         return found
 
     def _get_bases_arguments(self):
+        """ """
         arglist = self.tree_node.get_super_arglist()
         if arglist:
             from jedi.inference import arguments
@@ -351,6 +481,7 @@
 
     @inference_state_method_cache(default=())
     def py__bases__(self):
+        """ """
         args = self._get_bases_arguments()
         if args is not None:
             lst = [value for key, value in args.unpack() if key is None]
@@ -366,11 +497,25 @@
 
     @plugin_manager.decorate()
     def get_metaclass_filters(self, metaclasses, is_instance):
+        """
+
+        Parameters
+        ----------
+        metaclasses :
+            
+        is_instance :
+            
+
+        Returns
+        -------
+
+        """
         debug.warning('Unprocessed metaclass %s', metaclasses)
         return []
 
     @inference_state_method_cache(default=NO_VALUES)
     def get_metaclasses(self):
+        """ """
         args = self._get_bases_arguments()
         if args is not None:
             m = [value for key, value in args.unpack() if key == 'metaclass']
@@ -389,4 +534,15 @@
 
     @plugin_manager.decorate()
     def get_metaclass_signatures(self, metaclasses):
+        """
+
+        Parameters
+        ----------
+        metaclasses :
+            
+
+        Returns
+        -------
+
+        """
         return []
