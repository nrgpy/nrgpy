# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/polynomial/polyutils.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/polynomial/polyutils.py
@@ -67,9 +67,15 @@
 
 class PolyDomainError(PolyError):
     """Issued by the generic Poly class when two domains don't match.
-
+    
     This is raised when an binary operation is passed Poly objects with
     different domains.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
     pass
@@ -79,13 +85,18 @@
 #
 
 class PolyBase:
-    """
-    Base class for all polynomial types.
-
+    """Base class for all polynomial types.
+    
     Deprecated in numpy 1.9.0, use the abstract
     ABCPolyBase class instead. Note that the latter
     requires a number of virtual functions to be
     implemented.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
     pass
@@ -112,7 +123,6 @@
     Notes
     -----
     Do not lose the type info if the sequence contains unknown objects.
-
     """
     if len(seq) == 0:
         return seq
@@ -124,9 +134,8 @@
 
 
 def as_series(alist, trim=True):
-    """
-    Return argument as a list of 1-d arrays.
-
+    """Return argument as a list of 1-d arrays.
+    
     The returned list contains array(s) of dtype double, complex double, or
     object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of
     size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays
@@ -140,7 +149,7 @@
         A 1- or 2-d array_like
     trim : boolean, optional
         When True, trailing zeros are removed from the inputs.
-        When False, the inputs are passed through intact.
+        When False, the inputs are passed through intact. (Default value = True)
 
     Returns
     -------
@@ -162,16 +171,15 @@
     >>> b = np.arange(6).reshape((2,3))
     >>> pu.as_series(b)
     [array([0., 1., 2.]), array([3., 4., 5.])]
-
+    
     >>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))
     [array([1.]), array([0., 1., 2.]), array([0., 1.])]
-
+    
     >>> pu.as_series([2, [1.1, 0.]])
     [array([2.]), array([1.1])]
-
+    
     >>> pu.as_series([2, [1.1, 0.]], trim=False)
     [array([2.]), array([1.1, 0. ])]
-
     """
     arrays = [np.array(a, ndmin=1, copy=False) for a in alist]
     if min([a.size for a in arrays]) == 0:
@@ -200,9 +208,8 @@
 
 
 def trimcoef(c, tol=0):
-    """
-    Remove "small" "trailing" coefficients from a polynomial.
-
+    """Remove "small" "trailing" coefficients from a polynomial.
+    
     "Small" means "small in absolute value" and is controlled by the
     parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
     ``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
@@ -230,7 +237,6 @@
     See Also
     --------
     trimseq
-
     Examples
     --------
     >>> from numpy.polynomial import polyutils as pu
@@ -241,7 +247,6 @@
     >>> i = complex(0,1) # works for complex
     >>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
     array([0.0003+0.j   , 0.001 -0.001j])
-
     """
     if tol < 0:
         raise ValueError("tol must be non-negative")
@@ -254,9 +259,8 @@
         return c[:ind[-1] + 1].copy()
 
 def getdomain(x):
-    """
-    Return a domain suitable for given abscissae.
-
+    """Return a domain suitable for given abscissae.
+    
     Find a domain suitable for a polynomial or Chebyshev series
     defined at the values supplied.
 
@@ -278,7 +282,6 @@
     See Also
     --------
     mapparms, mapdomain
-
     Examples
     --------
     >>> from numpy.polynomial import polyutils as pu
@@ -289,7 +292,6 @@
     >>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle
     >>> pu.getdomain(c)
     array([-1.-1.j,  1.+1.j])
-
     """
     [x] = as_series([x], trim=False)
     if x.dtype.char in np.typecodes['Complex']:
@@ -300,9 +302,8 @@
         return np.array((x.min(), x.max()))
 
 def mapparms(old, new):
-    """
-    Linear map parameters between domains.
-
+    """Linear map parameters between domains.
+    
     Return the parameters of the linear map ``offset + scale*x`` that maps
     `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.
 
@@ -311,6 +312,10 @@
     old, new : array_like
         Domains. Each domain must (successfully) convert to a 1-d array
         containing precisely two values.
+    old :
+        
+    new :
+        
 
     Returns
     -------
@@ -321,13 +326,11 @@
     See Also
     --------
     getdomain, mapdomain
-
     Notes
     -----
     Also works for complex numbers, and thus can be used to calculate the
     parameters required to map any line in the complex plane to any other
     line therein.
-
     Examples
     --------
     >>> from numpy.polynomial import polyutils as pu
@@ -338,7 +341,6 @@
     >>> i = complex(0,1)
     >>> pu.mapparms((-i,-1),(1,i))
     ((1+1j), (1-0j))
-
     """
     oldlen = old[1] - old[0]
     newlen = new[1] - new[0]
@@ -347,9 +349,8 @@
     return off, scl
 
 def mapdomain(x, old, new):
-    """
-    Apply linear map to input points.
-
+    """Apply linear map to input points.
+    
     The linear map ``offset + scale*x`` that maps the domain `old` to
     the domain `new` is applied to the points `x`.
 
@@ -361,6 +362,10 @@
     old, new : array_like
         The two domains that determine the map.  Each must (successfully)
         convert to 1-d arrays containing precisely two values.
+    old :
+        
+    new :
+        
 
     Returns
     -------
@@ -371,21 +376,22 @@
     See Also
     --------
     getdomain, mapparms
-
     Notes
     -----
     Effectively, this implements:
-
+    
     .. math ::
         x\\_out = new[0] + m(x - old[0])
-
+    
     where
-
+    
     .. math ::
         m = \\frac{new[1]-new[0]}{old[1]-old[0]}
-
     Examples
     --------
+    
+    Also works for complex numbers (and thus can be used to map any line in
+    the complex plane to any other line therein).
     >>> from numpy.polynomial import polyutils as pu
     >>> old_domain = (-1,1)
     >>> new_domain = (0,2*np.pi)
@@ -396,10 +402,7 @@
             6.28318531])
     >>> x - pu.mapdomain(x_out, new_domain, old_domain)
     array([0., 0., 0., 0., 0., 0.])
-
-    Also works for complex numbers (and thus can be used to map any line in
-    the complex plane to any other line therein).
-
+    
     >>> i = complex(0,1)
     >>> old = (-1 - i, 1 + i)
     >>> new = (-1 + i, 1 - i)
@@ -407,7 +410,6 @@
     array([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])
     >>> new_z = pu.mapdomain(z, old, new); new_z
     array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary
-
     """
     x = np.asanyarray(x)
     off, scl = mapparms(old, new)
@@ -415,34 +417,47 @@
 
 
 def _nth_slice(i, ndim):
+    """
+
+    Parameters
+    ----------
+    i :
+        
+    ndim :
+        
+
+    Returns
+    -------
+
+    """
     sl = [np.newaxis] * ndim
     sl[i] = slice(None)
     return tuple(sl)
 
 
 def _vander_nd(vander_fs, points, degrees):
-    r"""
+    """r"""
     A generalization of the Vandermonde matrix for N dimensions
-
+    
     The result is built by combining the results of 1d Vandermonde matrices,
-
+    
     .. math::
         W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{V_k(x_k)[i_0, \ldots, i_M, j_k]}
-
+    
     where
-
+    
     .. math::
         N &= \texttt{len(points)} = \texttt{len(degrees)} = \texttt{len(vander\_fs)} \\
         M &= \texttt{points[k].ndim} \\
         V_k &= \texttt{vander\_fs[k]} \\
         x_k &= \texttt{points[k]} \\
         0 \le j_k &\le \texttt{degrees[k]}
-
+    
     Expanding the one-dimensional :math:`V_k` functions gives:
-
+    
     .. math::
         W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{B_{k, j_k}(x_k[i_0, \ldots, i_M])}
-
+    
     where :math:`B_{k,m}` is the m'th basis of the polynomial construction used along
     dimension :math:`k`. For a regular polynomial, :math:`B_{k, m}(x) = P_m(x) = x^m`.
 
@@ -462,9 +477,6 @@
 
     Returns
     -------
-    vander_nd : ndarray
-        An array of shape ``points[0].shape + tuple(d + 1 for d in degrees)``.
-    """
     n_dims = len(vander_fs)
     if n_dims != len(points):
         raise ValueError(
@@ -490,27 +502,43 @@
 
 
 def _vander_nd_flat(vander_fs, points, degrees):
-    """
-    Like `_vander_nd`, but flattens the last ``len(degrees)`` axes into a single axis
-
+    """Like `_vander_nd`, but flattens the last ``len(degrees)`` axes into a single axis
+    
     Used to implement the public ``<type>vander<n>d`` functions.
+
+    Parameters
+    ----------
+    vander_fs :
+        
+    points :
+        
+    degrees :
+        
+
+    Returns
+    -------
+
     """
     v = _vander_nd(vander_fs, points, degrees)
     return v.reshape(v.shape[:-len(degrees)] + (-1,))
 
 
 def _fromroots(line_f, mul_f, roots):
-    """
-    Helper function used to implement the ``<type>fromroots`` functions.
-
-    Parameters
-    ----------
-    line_f : function(float, float) -> ndarray
-        The ``<type>line`` function, such as ``polyline``
-    mul_f : function(array_like, array_like) -> ndarray
-        The ``<type>mul`` function, such as ``polymul``
+    """Helper function used to implement the ``<type>fromroots`` functions.
+
+    Parameters
+    ----------
+    line_f :
+        
+    mul_f :
+        
     roots :
-        See the ``<type>fromroots`` functions for more detail
+        
+
+    Returns
+    -------
+
+    
     """
     if len(roots) == 0:
         return np.ones(1)
@@ -530,15 +558,21 @@
 
 
 def _valnd(val_f, c, *args):
-    """
-    Helper function used to implement the ``<type>val<n>d`` functions.
-
-    Parameters
-    ----------
-    val_f : function(array_like, array_like, tensor: bool) -> array_like
-        The ``<type>val`` function, such as ``polyval``
-    c, args :
-        See the ``<type>val<n>d`` functions for more detail
+    """Helper function used to implement the ``<type>val<n>d`` functions.
+
+    Parameters
+    ----------
+    val_f :
+        
+    c :
+        
+    *args :
+        
+
+    Returns
+    -------
+
+    
     """
     args = [np.asanyarray(a) for a in args]
     shape0 = args[0].shape
@@ -560,15 +594,21 @@
 
 
 def _gridnd(val_f, c, *args):
-    """
-    Helper function used to implement the ``<type>grid<n>d`` functions.
-
-    Parameters
-    ----------
-    val_f : function(array_like, array_like, tensor: bool) -> array_like
-        The ``<type>val`` function, such as ``polyval``
-    c, args :
-        See the ``<type>grid<n>d`` functions for more detail
+    """Helper function used to implement the ``<type>grid<n>d`` functions.
+
+    Parameters
+    ----------
+    val_f :
+        
+    c :
+        
+    *args :
+        
+
+    Returns
+    -------
+
+    
     """
     for xi in args:
         c = val_f(xi, c)
@@ -576,18 +616,24 @@
 
 
 def _div(mul_f, c1, c2):
-    """
-    Helper function used to implement the ``<type>div`` functions.
-
+    """Helper function used to implement the ``<type>div`` functions.
+    
     Implementation uses repeated subtraction of c2 multiplied by the nth basis.
     For some polynomial types, a more efficient approach may be possible.
 
     Parameters
     ----------
-    mul_f : function(array_like, array_like) -> array_like
-        The ``<type>mul`` function, such as ``polymul``
-    c1, c2 :
-        See the ``<type>div`` functions for more detail
+    mul_f :
+        
+    c1 :
+        
+    c2 :
+        
+
+    Returns
+    -------
+
+    
     """
     # c1, c2 are trimmed copies
     [c1, c2] = as_series([c1, c2])
@@ -612,7 +658,19 @@
 
 
 def _add(c1, c2):
-    """ Helper function used to implement the ``<type>add`` functions. """
+    """Helper function used to implement the ``<type>add`` functions.
+
+    Parameters
+    ----------
+    c1 :
+        
+    c2 :
+        
+
+    Returns
+    -------
+
+    """
     # c1, c2 are trimmed copies
     [c1, c2] = as_series([c1, c2])
     if len(c1) > len(c2):
@@ -625,7 +683,19 @@
 
 
 def _sub(c1, c2):
-    """ Helper function used to implement the ``<type>sub`` functions. """
+    """Helper function used to implement the ``<type>sub`` functions.
+
+    Parameters
+    ----------
+    c1 :
+        
+    c2 :
+        
+
+    Returns
+    -------
+
+    """
     # c1, c2 are trimmed copies
     [c1, c2] = as_series([c1, c2])
     if len(c1) > len(c2):
@@ -639,15 +709,29 @@
 
 
 def _fit(vander_f, x, y, deg, rcond=None, full=False, w=None):
-    """
-    Helper function used to implement the ``<type>fit`` functions.
-
-    Parameters
-    ----------
-    vander_f : function(array_like, int) -> ndarray
-        The 1d vander function, such as ``polyvander``
-    c1, c2 :
-        See the ``<type>fit`` functions for more detail
+    """Helper function used to implement the ``<type>fit`` functions.
+
+    Parameters
+    ----------
+    vander_f :
+        
+    x :
+        
+    y :
+        
+    deg :
+        
+    rcond :
+         (Default value = None)
+    full :
+         (Default value = False)
+    w :
+         (Default value = None)
+
+    Returns
+    -------
+
+    
     """
     x = np.asarray(x) + 0.0
     y = np.asarray(y) + 0.0
@@ -727,17 +811,23 @@
 
 
 def _pow(mul_f, c, pow, maxpower):
-    """
-    Helper function used to implement the ``<type>pow`` functions.
-
-    Parameters
-    ----------
-    vander_f : function(array_like, int) -> ndarray
-        The 1d vander function, such as ``polyvander``
-    pow, maxpower :
-        See the ``<type>pow`` functions for more detail
-    mul_f : function(array_like, array_like) -> ndarray
-        The ``<type>mul`` function, such as ``polymul``
+    """Helper function used to implement the ``<type>pow`` functions.
+
+    Parameters
+    ----------
+    mul_f :
+        
+    c :
+        
+    pow :
+        
+    maxpower :
+        
+
+    Returns
+    -------
+
+    
     """
     # c is a trimmed copy
     [c] = as_series([c])
@@ -760,8 +850,7 @@
 
 
 def _deprecate_as_int(x, desc):
-    """
-    Like `operator.index`, but emits a deprecation warning when passed a float
+    """Like `operator.index`, but emits a deprecation warning when passed a float
 
     Parameters
     ----------
@@ -770,10 +859,10 @@
     desc : str
         description to include in any error message
 
-    Raises
-    ------
-    TypeError : if x is a non-integral float or non-numeric
-    DeprecationWarning : if x is an integral float
+    Returns
+    -------
+
+    
     """
     try:
         return operator.index(x)
