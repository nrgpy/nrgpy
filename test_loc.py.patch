# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexing/test_loc.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexing/test_loc.py
@@ -15,17 +15,21 @@
 
 
 class TestLoc(Base):
+    """ """
     def test_loc_getitem_int(self):
+        """ """
 
         # int label
         self.check_result("loc", 2, typs=["labels"], fails=KeyError)
 
     def test_loc_getitem_label(self):
+        """ """
 
         # label
         self.check_result("loc", "c", typs=["empty"], fails=KeyError)
 
     def test_loc_getitem_label_out_of_range(self):
+        """ """
 
         # out of range label
         self.check_result(
@@ -41,11 +45,13 @@
         self.check_result("loc", 20, typs=["floats"], axes=0, fails=KeyError)
 
     def test_loc_getitem_label_list(self):
+        """ """
         # TODO: test something here?
         # list of labels
         pass
 
     def test_loc_getitem_label_list_with_missing(self):
+        """ """
         self.check_result(
             "loc", [0, 1, 2], typs=["empty"], fails=KeyError,
         )
@@ -63,23 +69,27 @@
         )
 
     def test_loc_getitem_label_list_fails(self):
+        """ """
         # fails
         self.check_result(
             "loc", [20, 30, 40], typs=["ints", "uints"], axes=1, fails=KeyError,
         )
 
     def test_loc_getitem_label_array_like(self):
+        """ """
         # TODO: test something?
         # array like
         pass
 
     def test_loc_getitem_bool(self):
+        """ """
         # boolean indexers
         b = [True, False, True, False]
 
         self.check_result("loc", b, typs=["empty"], fails=IndexError)
 
     def test_loc_getitem_label_slice(self):
+        """ """
 
         # label slices (with ints)
 
@@ -110,6 +120,7 @@
         )
 
     def test_setitem_from_duplicate_axis(self):
+        """ """
         # GH#34034
         df = DataFrame(
             [[20, "a"], [200, "a"], [200, "a"]],
@@ -124,9 +135,11 @@
 
 
 class TestLoc2:
+    """ """
     # TODO: better name, just separating out things that rely on base class
 
     def test_loc_getitem_dups(self):
+        """ """
         # GH 5678
         # repeated getitems on a dup index returning a ndarray
         df = DataFrame(
@@ -137,6 +150,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_loc_getitem_dups2(self):
+        """ """
 
         # GH4726
         # dup indexing with iloc/loc
@@ -158,6 +172,7 @@
         tm.assert_series_equal(result, expected)
 
     def test_loc_setitem_dups(self):
+        """ """
 
         # GH 6541
         df_orig = DataFrame(
@@ -185,6 +200,7 @@
         tm.assert_frame_equal(df.loc[indexer], 2.0 * df_orig.loc[indexer])
 
     def test_loc_setitem_slice(self):
+        """ """
         # GH10503
 
         # assigning the same type should not change the type
@@ -206,6 +222,7 @@
         tm.assert_frame_equal(df2, expected)
 
     def test_loc_setitem_dtype(self):
+        """ """
         # GH31340
         df = DataFrame({"id": ["A"], "a": [1.2], "b": [0.0], "c": [-2.5]})
         cols = ["a", "b", "c"]
@@ -218,6 +235,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_getitem_label_list_with_missing(self):
+        """ """
         s = Series(range(3), index=["a", "b", "c"])
 
         # consistency
@@ -230,6 +248,17 @@
 
     @pytest.mark.parametrize("index", [[True, False], [True, False, True, False]])
     def test_loc_getitem_bool_diff_len(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         # GH26658
         s = Series([1, 2, 3])
         msg = f"Boolean index has wrong length: {len(index)} instead of {len(s)}"
@@ -237,10 +266,12 @@
             _ = s.loc[index]
 
     def test_loc_getitem_int_slice(self):
+        """ """
         # TODO: test something here?
         pass
 
     def test_loc_to_fail(self):
+        """ """
 
         # GH3449
         df = DataFrame(
@@ -308,6 +339,7 @@
             df.loc[[3]]
 
     def test_loc_getitem_list_with_fail(self):
+        """ """
         # 15747
         # should KeyError if *any* missing labels
 
@@ -328,6 +360,7 @@
             s.loc[[2, 3]]
 
     def test_loc_index(self):
+        """ """
         # gh-17131
         # a boolean index should index like a boolean numpy array
 
@@ -349,6 +382,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_loc_general(self):
+        """ """
 
         df = DataFrame(
             np.random.rand(4, 4),
@@ -368,6 +402,7 @@
         assert result.dtype == object
 
     def test_loc_setitem_consistency(self):
+        """ """
         # GH 6149
         # coerce similarly for setitem and loc when rows have a null-slice
         expected = DataFrame(
@@ -442,6 +477,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_loc_setitem_consistency_empty(self):
+        """ """
         # empty (essentially noops)
         expected = DataFrame(columns=["x", "y"])
         expected["x"] = expected["x"].astype(np.int64)
@@ -454,6 +490,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_loc_setitem_consistency_slice_column_len(self):
+        """ """
         # .loc[:,column] setting with slice == len of the column
         # GH10408
         data = """Level_0,,,Respondent,Respondent,Respondent,OtherCat,OtherCat
@@ -486,6 +523,17 @@
 
     @pytest.mark.parametrize("unit", ["Y", "M", "D", "h", "m", "s", "ms", "us"])
     def test_loc_assign_non_ns_datetime(self, unit):
+        """
+
+        Parameters
+        ----------
+        unit :
+            
+
+        Returns
+        -------
+
+        """
         # GH 27395, non-ns dtype assignment via .loc should work
         # and return the same result when using simple assignment
         df = DataFrame(
@@ -503,6 +551,7 @@
         tm.assert_series_equal(df.loc[:, unit], expected)
 
     def test_loc_modify_datetime(self):
+        """ """
         # see gh-28837
         df = DataFrame.from_dict(
             {"date": [1485264372711, 1485265925110, 1540215845888, 1540282121025]}
@@ -529,6 +578,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_loc_setitem_frame(self):
+        """ """
         df = DataFrame(np.random.randn(4, 4), index=list("abcd"), columns=list("ABCD"))
 
         result = df.iloc[0, 0]
@@ -595,6 +645,7 @@
         tm.assert_frame_equal(df, expected)
 
     def test_loc_setitem_frame_multiples(self):
+        """ """
         # multiple setting
         df = DataFrame(
             {"A": ["foo", "bar", "baz"], "B": Series(range(3), dtype=np.int64)}
@@ -636,6 +687,19 @@
     )
     @pytest.mark.parametrize("value", [["Z"], np.array(["Z"])])
     def test_loc_setitem_with_scalar_index(self, indexer, value):
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+        value :
+            
+
+        Returns
+        -------
+
+        """
         # GH #19474
         # assigning like "df.loc[0, ['A']] = ['Z']" should be evaluated
         # elementwisely, not using "setter('A', ['Z'])".
@@ -699,12 +763,28 @@
         ],
     )
     def test_loc_setitem_missing_columns(self, index, box, expected):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+        box :
+            
+        expected :
+            
+
+        Returns
+        -------
+
+        """
         # GH 29334
         df = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=["A", "B"])
         df.loc[index] = box
         tm.assert_frame_equal(df, expected)
 
     def test_loc_coercion(self):
+        """ """
 
         # 12411
         df = DataFrame({"date": [Timestamp("20130101").tz_localize("UTC"), pd.NaT]})
@@ -741,6 +821,7 @@
         tm.assert_series_equal(result.dtypes, expected)
 
     def test_setitem_new_key_tz(self):
+        """ """
         # GH#12862 should not raise on assigning the second value
         vals = [
             pd.to_datetime(42).tz_localize("UTC"),
@@ -761,6 +842,7 @@
         tm.assert_series_equal(ser, expected)
 
     def test_loc_non_unique(self):
+        """ """
         # GH3659
         # non-unique indexer with loc slice
         # https://groups.google.com/forum/?fromgroups#!topic/pydata/zTm2No0crYs
@@ -795,6 +877,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_loc_non_unique_memory_error(self):
+        """ """
 
         # GH 4280
         # non_unique index with a large selection triggers a memory error
@@ -802,6 +885,19 @@
         columns = list("ABCDEFG")
 
         def gen_test(l, l2):
+            """
+
+            Parameters
+            ----------
+            l :
+                
+            l2 :
+                
+
+            Returns
+            -------
+
+            """
             return pd.concat(
                 [
                     DataFrame(
@@ -816,6 +912,19 @@
             )
 
         def gen_expected(df, mask):
+            """
+
+            Parameters
+            ----------
+            df :
+                
+            mask :
+                
+
+            Returns
+            -------
+
+            """
             len_mask = len(mask)
             return pd.concat(
                 [
@@ -846,6 +955,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_loc_name(self):
+        """ """
         # GH 3880
         df = DataFrame([[1, 1], [1, 1]])
         df.index.name = "index_name"
@@ -856,6 +966,7 @@
         assert result == "index_name"
 
     def test_loc_empty_list_indexer_is_ok(self):
+        """ """
 
         df = tm.makeCustomDataframe(5, 2)
         # vertical empty
@@ -872,6 +983,7 @@
         )
 
     def test_identity_slice_returns_new_object(self):
+        """ """
         # GH13873
         original_df = DataFrame({"a": [1, 2, 3]})
         sliced_df = original_df.loc[:]
@@ -898,6 +1010,7 @@
 
     @pytest.mark.xfail(reason="accidental fix reverted - GH37497")
     def test_loc_copy_vs_view(self):
+        """ """
         # GH 15631
         x = DataFrame(zip(range(3), range(3)), columns=["a", "b"])
 
@@ -914,6 +1027,7 @@
         tm.assert_frame_equal(x, z)
 
     def test_loc_uint64(self):
+        """ """
         # GH20722
         # Test whether loc accept uint64 max value as index.
         s = pd.Series(
@@ -932,6 +1046,7 @@
         tm.assert_series_equal(result, s)
 
     def test_loc_setitem_empty_append(self):
+        """ """
         # GH6173, various appends to an empty dataframe
 
         data = [1, 2, 3]
@@ -950,6 +1065,7 @@
 
     @pytest.mark.xfail(_is_numpy_dev, reason="gh-35481")
     def test_loc_setitem_empty_append_raises(self):
+        """ """
         # GH6173, various appends to an empty dataframe
 
         data = [1, 2]
@@ -967,6 +1083,7 @@
             df.loc[0:2, "x"] = data
 
     def test_indexing_zerodim_np_array(self):
+        """ """
         # GH24924
         df = DataFrame([[1, 2], [3, 4]])
         result = df.loc[np.array(0)]
@@ -974,12 +1091,14 @@
         tm.assert_series_equal(result, s)
 
     def test_series_indexing_zerodim_np_array(self):
+        """ """
         # GH24924
         s = Series([1, 2])
         result = s.loc[np.array(0)]
         assert result == 1
 
     def test_loc_reverse_assignment(self):
+        """ """
         # GH26939
         data = [1, 2, 3, 4, 5, 6] + [None] * 4
         expected = Series(data, index=range(2010, 2020))
@@ -991,6 +1110,7 @@
 
 
 def test_series_loc_getitem_label_list_missing_values():
+    """ """
     # gh-11428
     key = np.array(
         ["2001-01-04", "2001-01-02", "2001-01-04", "2001-01-14"], dtype="datetime64"
@@ -1011,6 +1131,23 @@
 def test_loc_getitem_label_list_integer_labels(
     columns, column_key, expected_columns, check_column_type
 ):
+    """
+
+    Parameters
+    ----------
+    columns :
+        
+    column_key :
+        
+    expected_columns :
+        
+    check_column_type :
+        
+
+    Returns
+    -------
+
+    """
     # gh-14836
     df = DataFrame(np.random.rand(3, 3), columns=columns, index=list("ABC"))
     expected = df.iloc[:, expected_columns]
@@ -1019,6 +1156,7 @@
 
 
 def test_loc_setitem_float_intindex():
+    """ """
     # GH 8720
     rand_data = np.random.randn(8, 4)
     result = pd.DataFrame(rand_data)
@@ -1033,6 +1171,7 @@
 
 
 def test_loc_axis_1_slice():
+    """ """
     # GH 10586
     cols = [(yr, m) for yr in [2014, 2015] for m in [7, 8, 9, 10]]
     df = pd.DataFrame(
@@ -1052,6 +1191,7 @@
 
 
 def test_loc_set_dataframe_multiindex():
+    """ """
     # GH 14592
     expected = pd.DataFrame(
         "a", index=range(2), columns=pd.MultiIndex.from_product([range(2), range(2)])
@@ -1062,6 +1202,7 @@
 
 
 def test_loc_mixed_int_float():
+    """ """
     # GH#19456
     ser = pd.Series(range(2), pd.Index([1, 2.0], dtype=object))
 
@@ -1070,6 +1211,7 @@
 
 
 def test_loc_with_positional_slice_deprecation():
+    """ """
     # GH#31840
     ser = pd.Series(range(4), index=["A", "B", "C", "D"])
 
@@ -1081,6 +1223,7 @@
 
 
 def test_loc_slice_disallows_positional():
+    """ """
     # GH#16121, GH#24612, GH#31810
     dti = pd.date_range("2016-01-01", periods=3)
     df = pd.DataFrame(np.random.random((3, 2)), index=dti)
@@ -1109,6 +1252,7 @@
 
 
 def test_loc_datetimelike_mismatched_dtypes():
+    """ """
     # GH#32650 dont mix and match datetime/timedelta/period dtypes
 
     df = pd.DataFrame(
@@ -1131,6 +1275,7 @@
 
 
 def test_loc_with_period_index_indexer():
+    """ """
     # GH#4125
     idx = pd.period_range("2002-01", "2003-12", freq="M")
     df = pd.DataFrame(np.random.randn(24, 10), index=idx)
