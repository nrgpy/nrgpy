# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/api/refactoring/extract.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/api/refactoring/extract.py
@@ -16,6 +16,27 @@
 
 
 def extract_variable(inference_state, path, module_node, name, pos, until_pos):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    path :
+        
+    module_node :
+        
+    name :
+        
+    pos :
+        
+    until_pos :
+        
+
+    Returns
+    -------
+
+    """
     nodes = _find_nodes(module_node, pos, until_pos)
     debug.dbg('Extracting nodes: %s', nodes)
 
@@ -29,8 +50,16 @@
 
 
 def _is_expression_with_error(nodes):
-    """
-    Returns a tuple (is_expression, error_string).
+    """Returns a tuple (is_expression, error_string).
+
+    Parameters
+    ----------
+    nodes :
+        
+
+    Returns
+    -------
+
     """
     if any(node.type == 'name' and node.is_definition() for node in nodes):
         return False, 'Cannot extract a name that defines something'
@@ -41,9 +70,21 @@
 
 
 def _find_nodes(module_node, pos, until_pos):
-    """
-    Looks up a module and tries to find the appropriate amount of nodes that
+    """Looks up a module and tries to find the appropriate amount of nodes that
     are in there.
+
+    Parameters
+    ----------
+    module_node :
+        
+    pos :
+        
+    until_pos :
+        
+
+    Returns
+    -------
+
     """
     start_node = module_node.get_leaf_for_position(pos, include_prefixes=True)
 
@@ -96,6 +137,27 @@
 
 def _replace(nodes, expression_replacement, extracted, pos,
              insert_before_leaf=None, remaining_prefix=None):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+    expression_replacement :
+        
+    extracted :
+        
+    pos :
+        
+    insert_before_leaf :
+         (Default value = None)
+    remaining_prefix :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     # Now try to replace the nodes found with a variable and move the code
     # before the current statement.
     definition = _get_parent_definition(nodes[0])
@@ -128,10 +190,34 @@
 
 
 def _expression_nodes_to_string(nodes):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+
+    Returns
+    -------
+
+    """
     return ''.join(n.get_code(include_prefix=i != 0) for i, n in enumerate(nodes))
 
 
 def _suite_nodes_to_string(nodes, pos):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+    pos :
+        
+
+    Returns
+    -------
+
+    """
     n = nodes[0]
     prefix, part_of_code = _split_prefix_at(n.get_first_leaf(), pos[0] - 1)
     code = part_of_code + n.get_code(include_prefix=False) \
@@ -140,9 +226,19 @@
 
 
 def _split_prefix_at(leaf, until_line):
-    """
-    Returns a tuple of the leaf's prefix, split at the until_line
+    """Returns a tuple of the leaf's prefix, split at the until_line
     position.
+
+    Parameters
+    ----------
+    leaf :
+        
+    until_line :
+        
+
+    Returns
+    -------
+
     """
     # second means the second returned part
     second_line_count = leaf.start_pos[0] - until_line
@@ -151,12 +247,31 @@
 
 
 def _get_indentation(node):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
+    """
     return split_lines(node.get_first_leaf().prefix)[-1]
 
 
 def _get_parent_definition(node):
-    """
-    Returns the statement where a node is defined.
+    """Returns the statement where a node is defined.
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
     """
     while node is not None:
         if node.parent.type in _DEFINITION_SCOPES:
@@ -166,9 +281,21 @@
 
 
 def _remove_unwanted_expression_nodes(parent_node, pos, until_pos):
-    """
-    This function makes it so for `1 * 2 + 3` you can extract `2 + 3`, even
+    """This function makes it so for `1 * 2 + 3` you can extract `2 + 3`, even
     though it is not part of the expression.
+
+    Parameters
+    ----------
+    parent_node :
+        
+    pos :
+        
+    until_pos :
+        
+
+    Returns
+    -------
+
     """
     typ = parent_node.type
     is_suite_part = typ in ('suite', 'file_input')
@@ -202,11 +329,43 @@
 
 
 def _is_not_extractable_syntax(node):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
+    """
     return node.type == 'operator' \
         or node.type == 'keyword' and node.value not in ('None', 'True', 'False')
 
 
 def extract_function(inference_state, path, module_context, name, pos, until_pos):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    path :
+        
+    module_context :
+        
+    name :
+        
+    pos :
+        
+    until_pos :
+        
+
+    Returns
+    -------
+
+    """
     nodes = _find_nodes(module_context.tree_node, pos, until_pos)
     assert len(nodes)
 
@@ -294,6 +453,17 @@
 
 
 def _check_for_non_extractables(nodes):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+
+    Returns
+    -------
+
+    """
     for n in nodes:
         try:
             children = n.children
@@ -308,6 +478,23 @@
 
 
 def _is_name_input(module_context, names, first, last):
+    """
+
+    Parameters
+    ----------
+    module_context :
+        
+    names :
+        
+    first :
+        
+    last :
+        
+
+    Returns
+    -------
+
+    """
     for name in names:
         if name.api_type == 'param' or not name.parent_context.is_module():
             if name.get_root_context() is not module_context:
@@ -318,6 +505,21 @@
 
 
 def _find_inputs_and_outputs(module_context, context, nodes):
+    """
+
+    Parameters
+    ----------
+    module_context :
+        
+    context :
+        
+    nodes :
+        
+
+    Returns
+    -------
+
+    """
     first = nodes[0].start_pos
     last = nodes[-1].end_pos
 
@@ -339,6 +541,17 @@
 
 
 def _find_non_global_names(nodes):
+    """
+
+    Parameters
+    ----------
+    nodes :
+        
+
+    Returns
+    -------
+
+    """
     for node in nodes:
         try:
             children = node.children
@@ -355,6 +568,19 @@
 
 
 def _get_code_insertion_node(node, is_bound_method):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+    is_bound_method :
+        
+
+    Returns
+    -------
+
+    """
     if not is_bound_method or function_is_staticmethod(node):
         while node.parent.type != 'file_input':
             node = node.parent
@@ -365,9 +591,24 @@
 
 
 def _find_needed_output_variables(context, search_node, at_least_pos, return_variables):
-    """
-    Searches everything after at_least_pos in a node and checks if any of the
-    return_variables are used in there and returns those.
+    """Searches everything after at_least_pos in a node and checks if any of the
+
+    Parameters
+    ----------
+    context :
+        
+    search_node :
+        
+    at_least_pos :
+        
+    return_variables :
+        
+
+    Returns
+    -------
+    type
+        
+
     """
     for node in search_node.children:
         if node.start_pos < at_least_pos:
@@ -381,6 +622,17 @@
 
 
 def _is_node_ending_return_stmt(node):
+    """
+
+    Parameters
+    ----------
+    node :
+        
+
+    Returns
+    -------
+
+    """
     t = node.type
     if t == 'simple_stmt':
         return _is_node_ending_return_stmt(node.children[0])
