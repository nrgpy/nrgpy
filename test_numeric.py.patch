# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/test_numeric.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/indexes/test_numeric.py
@@ -12,16 +12,20 @@
 
 
 class Numeric(Base):
+    """ """
     def test_where(self):
+        """ """
         # Tested in numeric.test_indexing
         pass
 
     def test_can_hold_identifiers(self):
+        """ """
         idx = self.create_index()
         key = idx[0]
         assert idx._can_hold_identifiers_and_holds_name(key) is False
 
     def test_format(self):
+        """ """
         # GH35439
         idx = self.create_index()
         max_width = max(len(str(x)) for x in idx)
@@ -29,9 +33,11 @@
         assert idx.format() == expected
 
     def test_numeric_compat(self):
+        """ """
         pass  # override Base method
 
     def test_explicit_conversions(self):
+        """ """
 
         # GH 8608
         # add/sub are overridden explicitly for Float/Int Index
@@ -57,6 +63,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_index_groupby(self):
+        """ """
         int_idx = Index(range(6))
         float_idx = Index(np.arange(0, 0.6, 0.1))
         obj_idx = Index("A B C D E F".split())
@@ -85,6 +92,17 @@
             tm.assert_dict_equal(idx.groupby(to_groupby), expected)
 
     def test_insert(self, nulls_fixture):
+        """
+
+        Parameters
+        ----------
+        nulls_fixture :
+            
+
+        Returns
+        -------
+
+        """
         # GH 18295 (test missing)
         index = self.create_index()
         expected = Float64Index([index[0], np.nan] + list(index[1:]))
@@ -93,6 +111,7 @@
 
 
 class TestFloat64Index(Numeric):
+    """ """
     _holder = Float64Index
 
     @pytest.fixture(
@@ -105,27 +124,78 @@
         ids=["mixed", "float", "mixed_dec", "float_dec"],
     )
     def index(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         return Float64Index(request.param)
 
     @pytest.fixture
     def mixed_index(self):
+        """ """
         return Float64Index([1.5, 2, 3, 4, 5])
 
     @pytest.fixture
     def float_index(self):
+        """ """
         return Float64Index([0.0, 2.5, 5.0, 7.5, 10.0])
 
     def create_index(self) -> Float64Index:
+        """ """
         return Float64Index(np.arange(5, dtype="float64"))
 
     def test_repr_roundtrip(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         tm.assert_index_equal(eval(repr(index)), index)
 
     def check_is_index(self, i):
+        """
+
+        Parameters
+        ----------
+        i :
+            
+
+        Returns
+        -------
+
+        """
         assert isinstance(i, Index)
         assert not isinstance(i, Float64Index)
 
     def check_coerce(self, a, b, is_float_index=True):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+        is_float_index :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         assert a.equals(b)
         tm.assert_index_equal(a, b, exact=False)
         if is_float_index:
@@ -134,6 +204,7 @@
             self.check_is_index(b)
 
     def test_constructor(self):
+        """ """
 
         # explicit construction
         index = Float64Index([1, 2, 3, 4, 5])
@@ -174,6 +245,19 @@
         ],
     )
     def test_invalid_dtype(self, index, dtype):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+        dtype :
+            
+
+        Returns
+        -------
+
+        """
         # GH 29539
         with pytest.raises(
             ValueError,
@@ -182,6 +266,7 @@
             index([1, 2, 3], dtype=dtype)
 
     def test_constructor_invalid(self):
+        """ """
 
         # invalid
         msg = (
@@ -201,6 +286,19 @@
             Float64Index([Timestamp("20130101")])
 
     def test_constructor_coerce(self, mixed_index, float_index):
+        """
+
+        Parameters
+        ----------
+        mixed_index :
+            
+        float_index :
+            
+
+        Returns
+        -------
+
+        """
 
         self.check_coerce(mixed_index, Index([1.5, 2, 3, 4, 5]))
         self.check_coerce(float_index, Index(np.arange(5) * 2.5))
@@ -209,6 +307,19 @@
         )
 
     def test_constructor_explicit(self, mixed_index, float_index):
+        """
+
+        Parameters
+        ----------
+        mixed_index :
+            
+        float_index :
+            
+
+        Returns
+        -------
+
+        """
 
         # these don't auto convert
         self.check_coerce(
@@ -219,18 +330,41 @@
         )
 
     def test_type_coercion_fail(self, any_int_dtype):
+        """
+
+        Parameters
+        ----------
+        any_int_dtype :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-15832
         msg = "Trying to coerce float values to integers"
         with pytest.raises(ValueError, match=msg):
             Index([1, 2, 3.5], dtype=any_int_dtype)
 
     def test_type_coercion_valid(self, float_dtype):
+        """
+
+        Parameters
+        ----------
+        float_dtype :
+            
+
+        Returns
+        -------
+
+        """
         # There is no Float32Index, so we always
         # generate Float64Index.
         i = Index([1, 2, 3.5], dtype=float_dtype)
         tm.assert_index_equal(i, Index([1, 2, 3.5]))
 
     def test_equals_numeric(self):
+        """ """
 
         i = Float64Index([1.0, 2.0])
         assert i.equals(i)
@@ -255,6 +389,17 @@
         ),
     )
     def test_equals_numeric_other_index_type(self, other):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+
+        Returns
+        -------
+
+        """
         i = Float64Index([1.0, 2.0])
         assert i.equals(other)
         assert other.equals(i)
@@ -267,6 +412,17 @@
         ],
     )
     def test_lookups_datetimelike_values(self, vals):
+        """
+
+        Parameters
+        ----------
+        vals :
+            
+
+        Returns
+        -------
+
+        """
         # If we have datetime64 or timedelta64 values, make sure they are
         #  wrappped correctly  GH#31163
         ser = pd.Series(vals, index=range(3, 6))
@@ -304,12 +460,14 @@
         assert isinstance(result, type(expected)) and result == expected
 
     def test_doesnt_contain_all_the_things(self):
+        """ """
         i = Float64Index([np.nan])
         assert not i.isin([0]).item()
         assert not i.isin([1]).item()
         assert i.isin([np.nan]).item()
 
     def test_nan_multiple_containment(self):
+        """ """
         i = Float64Index([1.0, np.nan])
         tm.assert_numpy_array_equal(i.isin([1.0]), np.array([True, False]))
         tm.assert_numpy_array_equal(i.isin([2.0, np.pi]), np.array([False, False]))
@@ -319,6 +477,7 @@
         tm.assert_numpy_array_equal(i.isin([np.nan]), np.array([False, False]))
 
     def test_fillna_float64(self):
+        """ """
         # GH 11343
         idx = Index([1.0, np.nan, 3.0], dtype=float, name="x")
         # can't downcast
@@ -335,7 +494,9 @@
 
 
 class NumericInt(Numeric):
+    """ """
     def test_view(self):
+        """ """
         i = self._holder([], name="Foo")
         i_view = i.view()
         assert i_view.name == "Foo"
@@ -347,6 +508,7 @@
         tm.assert_index_equal(i, self._holder(i_view, name="Foo"))
 
     def test_is_monotonic(self):
+        """ """
         index = self._holder([1, 2, 3, 4])
         assert index.is_monotonic is True
         assert index.is_monotonic_increasing is True
@@ -367,6 +529,7 @@
         assert index._is_strictly_monotonic_decreasing is True
 
     def test_is_strictly_monotonic(self):
+        """ """
         index = self._holder([1, 1, 2, 3])
         assert index.is_monotonic_increasing is True
         assert index._is_strictly_monotonic_increasing is False
@@ -382,11 +545,13 @@
         assert not index._is_strictly_monotonic_decreasing
 
     def test_logical_compat(self):
+        """ """
         idx = self.create_index()
         assert idx.all() == idx.values.all()
         assert idx.any() == idx.values.any()
 
     def test_identical(self):
+        """ """
         index = self.create_index()
         i = Index(index.copy())
         assert i.identical(index)
@@ -405,6 +570,7 @@
         assert not index.copy(dtype=object).identical(index.copy(dtype=self._dtype))
 
     def test_union_noncomparable(self):
+        """ """
         # corner case, non-Int64Index
         index = self.create_index()
         other = Index([datetime.now() + timedelta(i) for i in range(4)], dtype=object)
@@ -417,6 +583,7 @@
         tm.assert_index_equal(result, expected)
 
     def test_cant_or_shouldnt_cast(self):
+        """ """
         msg = (
             "String dtype not supported, "
             "you may need to explicitly cast to a numeric type"
@@ -432,16 +599,19 @@
             self._holder(data)
 
     def test_view_index(self):
+        """ """
         index = self.create_index()
         index.view(Index)
 
     def test_prevent_casting(self):
+        """ """
         index = self.create_index()
         result = index.astype("O")
         assert result.dtype == np.object_
 
 
 class TestInt64Index(NumericInt):
+    """ """
     _dtype = "int64"
     _holder = Int64Index
 
@@ -449,13 +619,26 @@
         params=[range(0, 20, 2), range(19, -1, -1)], ids=["index_inc", "index_dec"]
     )
     def index(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         return Int64Index(request.param)
 
     def create_index(self) -> Int64Index:
+        """ """
         # return Int64Index(np.arange(5, dtype="int64"))
         return Int64Index(range(0, 20, 2))
 
     def test_constructor(self):
+        """ """
         # pass list, coerce fine
         index = Int64Index([-5, 0, 1, 2])
         expected = Index([-5, 0, 1, 2], dtype=np.int64)
@@ -494,6 +677,7 @@
                 tm.assert_index_equal(idx, expected)
 
     def test_constructor_corner(self):
+        """ """
         arr = np.array([1, 2, 3, 4], dtype=object)
         index = Int64Index(arr)
         assert index.values.dtype == np.int64
@@ -509,6 +693,17 @@
             Int64Index(arr_with_floats)
 
     def test_constructor_coercion_signed_to_unsigned(self, uint_dtype):
+        """
+
+        Parameters
+        ----------
+        uint_dtype :
+            
+
+        Returns
+        -------
+
+        """
 
         # see gh-15832
         msg = "Trying to coerce negative values to unsigned integers"
@@ -517,12 +712,14 @@
             Index([-1], dtype=uint_dtype)
 
     def test_constructor_unwraps_index(self):
+        """ """
         idx = pd.Index([1, 2])
         result = pd.Int64Index(idx)
         expected = np.array([1, 2], dtype="int64")
         tm.assert_numpy_array_equal(result._data, expected)
 
     def test_coerce_list(self):
+        """ """
         # coerce things
         arr = Index([1, 2, 3, 4])
         assert isinstance(arr, Int64Index)
@@ -532,6 +729,7 @@
         assert isinstance(arr, Index)
 
     def test_intersection(self):
+        """ """
         index = self.create_index()
         other = Index([1, 2, 3, 4, 5])
         result = index.intersection(other)
@@ -546,6 +744,7 @@
 
 
 class TestUInt64Index(NumericInt):
+    """ """
 
     _dtype = "uint64"
     _holder = UInt64Index
@@ -558,19 +757,33 @@
         ids=["index_inc", "index_dec"],
     )
     def index(self, request):
+        """
+
+        Parameters
+        ----------
+        request :
+            
+
+        Returns
+        -------
+
+        """
         return UInt64Index(request.param)
 
     @pytest.fixture
     def index_large(self):
+        """ """
         # large values used in TestUInt64Index where no compat needed with Int64/Float64
         large = [2 ** 63, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20, 2 ** 63 + 25]
         return UInt64Index(large)
 
     def create_index(self) -> UInt64Index:
+        """ """
         # compat with shared Int64/Float64 tests; use index_large for UInt64 only tests
         return UInt64Index(np.arange(5, dtype="uint64"))
 
     def test_constructor(self):
+        """ """
         idx = UInt64Index([1, 2, 3])
         res = Index([1, 2, 3], dtype=np.uint64)
         tm.assert_index_equal(res, idx)
@@ -593,6 +806,17 @@
         tm.assert_index_equal(res, idx)
 
     def test_intersection(self, index_large):
+        """
+
+        Parameters
+        ----------
+        index_large :
+            
+
+        Returns
+        -------
+
+        """
         other = Index([2 ** 63, 2 ** 63 + 5, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20])
         result = index_large.intersection(other)
         expected = Index(np.sort(np.intersect1d(index_large.values, other.values)))
@@ -607,6 +831,17 @@
 
 @pytest.mark.parametrize("dtype", ["int64", "uint64"])
 def test_int_float_union_dtype(dtype):
+    """
+
+    Parameters
+    ----------
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
     # https://github.com/pandas-dev/pandas/issues/26778
     # [u]int | float -> float
     index = pd.Index([0, 2, 3], dtype=dtype)
@@ -620,6 +855,7 @@
 
 
 def test_range_float_union_dtype():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/26778
     index = pd.RangeIndex(start=0, stop=3)
     other = pd.Float64Index([0.5, 1.5])
@@ -632,6 +868,7 @@
 
 
 def test_uint_index_does_not_convert_to_float64():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/28279
     # https://github.com/pandas-dev/pandas/issues/28023
     series = pd.Series(
@@ -658,6 +895,7 @@
 
 
 def test_float64_index_equals():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/35217
     float_index = pd.Index([1.0, 2, 3])
     string_index = pd.Index(["1", "2", "3"])
@@ -670,6 +908,7 @@
 
 
 def test_float64_index_difference():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/35217
     float_index = pd.Index([1.0, 2, 3])
     string_index = pd.Index(["1", "2", "3"])
