# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jupyter_client/session.py
+++ b/..//venv/lib/python3.8/site-packages/jupyter_client/session.py
@@ -54,7 +54,17 @@
 #-----------------------------------------------------------------------------
 
 def squash_unicode(obj):
-    """coerce unicode back to bytestrings."""
+    """coerce unicode back to bytestrings.
+
+    Parameters
+    ----------
+    obj :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(obj,dict):
         for key in obj.keys():
             obj[key] = squash_unicode(obj[key])
@@ -99,13 +109,16 @@
 
 def new_id():
     """Generate a new random id.
-
+    
     Avoids problematic runtime import in stdlib uuid on Python 2.
+
+    Parameters
+    ----------
 
     Returns
     -------
 
-    id string (16 random bytes as hex-encoded text, chunks separated by '-')
+    
     """
     buf = os.urandom(16)
     return '-'.join(b2a_hex(x).decode('ascii') for x in (
@@ -113,7 +126,7 @@
     ))
 
 def new_id_bytes():
-    """Return new_id as ascii bytes"""
+    """ """
     return new_id().encode('ascii')
 
 session_aliases = dict(
@@ -134,9 +147,18 @@
 
 def default_secure(cfg):
     """Set the default behavior for a config environment to be secure.
-
+    
     If Session.key/keyfile have not been set, set Session.key to
     a new random UUID.
+
+    Parameters
+    ----------
+    cfg :
+        
+
+    Returns
+    -------
+
     """
     warnings.warn("default_secure is deprecated", DeprecationWarning)
     if 'Session' in cfg:
@@ -146,7 +168,7 @@
     cfg.Session.key = new_id_bytes()
 
 def utcnow():
-    """Return timezone-aware UTC timestamp"""
+    """ """
     return datetime.utcnow().replace(tzinfo=utc)
 
 #-----------------------------------------------------------------------------
@@ -156,17 +178,36 @@
 class SessionFactory(LoggingConfigurable):
     """The Base class for configurables that have a Session, Context, logger,
     and IOLoop.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     logname = Unicode('')
 
     @observe('logname')
     def _logname_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         self.log = logging.getLogger(change['new'])
 
     # not configurable:
     context = Instance('zmq.Context')
     def _context_default(self):
+        """ """
         return zmq.Context()
 
     session = Instance('jupyter_client.session.Session',
@@ -174,6 +215,7 @@
 
     loop = Instance('tornado.ioloop.IOLoop')
     def _loop_default(self):
+        """ """
         return IOLoop.current()
 
     def __init__(self, **kwargs):
@@ -186,9 +228,17 @@
 
 class Message(object):
     """A simple message object that maps dict keys to attributes.
-
+    
     A Message can be created from a dict and a dict from a Message instance
-    simply by calling dict(msg_obj)."""
+    simply by calling dict(msg_obj).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
 
     def __init__(self, msg_dict):
         dct = self.__dict__
@@ -215,13 +265,39 @@
 
 
 def msg_header(msg_id, msg_type, username, session):
-    """Create a new message header"""
+    """Create a new message header
+
+    Parameters
+    ----------
+    msg_id :
+        
+    msg_type :
+        
+    username :
+        
+    session :
+        
+
+    Returns
+    -------
+
+    """
     date = utcnow()
     version = protocol_version
     return locals()
 
 def extract_header(msg_or_header):
-    """Given a message or header, return the header."""
+    """Given a message or header, return the header.
+
+    Parameters
+    ----------
+    msg_or_header :
+        
+
+    Returns
+    -------
+
+    """
     if not msg_or_header:
         return {}
     try:
@@ -241,43 +317,23 @@
 
 class Session(Configurable):
     """Object for handling serialization and sending of messages.
-
+    
     The Session object handles building messages and sending them
     with ZMQ sockets or ZMQStream objects.  Objects can communicate with each
     other over the network via Session objects, and only need to work with the
     dict-based IPython message spec. The Session will handle
     serialization/deserialization, security, and metadata.
-
+    
     Sessions support configurable serialization via packer/unpacker traits,
     and signing with HMAC digests via the key/keyfile traits.
 
     Parameters
     ----------
 
-    debug : bool
-        whether to trigger extra debugging statements
-    packer/unpacker : str : 'json', 'pickle' or import_string
-        importstrings for methods to serialize message parts.  If just
-        'json' or 'pickle', predefined JSON and pickle packers will be used.
-        Otherwise, the entire importstring must be used.
-
-        The functions must accept at least valid JSON input, and output *bytes*.
-
-        For example, to use msgpack:
-        packer = 'msgpack.packb', unpacker='msgpack.unpackb'
-    pack/unpack : callables
-        You can also set the pack/unpack callables for serialization directly.
-    session : bytes
-        the ID of this Session object.  The default is to generate a new UUID.
-    username : unicode
-        username added to message headers.  The default is to ask the OS.
-    key : bytes
-        The key used to initialize an HMAC signature.  If unset, messages
-        will not be signed or checked.
-    keyfile : filepath
-        The file containing a key.  If this is set, `key` will be initialized
-        to the contents of the file.
-
+    Returns
+    -------
+
+    
     """
 
     debug = Bool(False, config=True, help="""Debug output in the Session""")
@@ -295,6 +351,17 @@
 
     @observe('packer')
     def _packer_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         new = change['new']
         if new.lower() == 'json':
             self.pack = json_packer
@@ -313,6 +380,17 @@
 
     @observe('unpacker')
     def _unpacker_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         new = change['new']
         if new.lower() == 'json':
             self.pack = json_packer
@@ -328,12 +406,24 @@
     session = CUnicode('', config=True,
         help="""The UUID identifying this session.""")
     def _session_default(self):
+        """ """
         u = new_id()
         self.bsession = u.encode('ascii')
         return u
 
     @observe('session')
     def _session_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         self.bsession = self.session.encode('ascii')
 
     # bsession is the session as bytes
@@ -354,10 +444,22 @@
     key = CBytes(config=True,
         help="""execution key, for signing messages.""")
     def _key_default(self):
+        """ """
         return new_id_bytes()
 
     @observe('key')
     def _key_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         self._new_auth()
 
     signature_scheme = Unicode('hmac-sha256', config=True,
@@ -366,6 +468,17 @@
 
     @observe('signature_scheme')
     def _signature_scheme_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         new = change['new']
         if not new.startswith('hmac-'):
             raise TraitError("signature_scheme must start with 'hmac-', got %r" % new)
@@ -379,11 +492,13 @@
 
     digest_mod = Any()
     def _digest_mod_default(self):
+        """ """
         return hashlib.sha256
 
     auth = Instance(hmac.HMAC, allow_none=True)
 
     def _new_auth(self):
+        """ """
         if self.key:
             self.auth = hmac.HMAC(self.key, digestmod=self.digest_mod)
         else:
@@ -402,6 +517,17 @@
 
     @observe('keyfile')
     def _keyfile_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         with open(change['new'], 'rb') as f:
             self.key = f.read().strip()
 
@@ -414,6 +540,17 @@
 
     @observe('pack')
     def _pack_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         new = change['new']
         if not callable(new):
             raise TypeError("packer must be callable, not %s"%type(new))
@@ -422,6 +559,17 @@
 
     @observe('unpack')
     def _unpack_changed(self, change):
+        """
+
+        Parameters
+        ----------
+        change :
+            
+
+        Returns
+        -------
+
+        """
         # unpacker is not checked - it is assumed to be
         new = change['new']
         if not callable(new):
@@ -491,12 +639,19 @@
 
     def clone(self):
         """Create a copy of this Session
-
+        
         Useful when connecting multiple times to a given kernel.
         This prevents a shared digest_history warning about duplicate digests
         due to multiple connections to IOPub in the same process.
-
+        
         .. versionadded:: 5.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # make a copy
         new_session = type(self)()
@@ -510,6 +665,7 @@
     message_count = 0
     @property
     def msg_id(self):
+        """ """
         message_number = self.message_count
         self.message_count += 1
         return '{}_{}'.format(self.session, message_number)
@@ -562,14 +718,42 @@
             self.unpack = lambda s: unpack(s)
 
     def msg_header(self, msg_type):
+        """
+
+        Parameters
+        ----------
+        msg_type :
+            
+
+        Returns
+        -------
+
+        """
         return msg_header(self.msg_id, msg_type, self.username, self.session)
 
     def msg(self, msg_type, content=None, parent=None, header=None, metadata=None):
-        """Return the nested message dict.
-
-        This format is different from what is sent over the wire. The
-        serialize/deserialize methods converts this nested message dict to the wire
-        format, which is a list of message parts.
+        """
+
+        Parameters
+        ----------
+        msg_type :
+            
+        content :
+             (Default value = None)
+        parent :
+             (Default value = None)
+        header :
+             (Default value = None)
+        metadata :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            This format is different from what is sent over the wire. The
+            serialize/deserialize methods converts this nested message dict to the wire
+            format, which is a list of message parts.
+
         """
         msg = {}
         header = self.msg_header(msg_type) if header is None else header
@@ -588,8 +772,13 @@
 
         Parameters
         ----------
-        msg_list : list
-            The [p_header,p_parent,p_content] part of the message list.
+        msg_list :
+            
+
+        Returns
+        -------
+
+        
         """
         if self.auth is None:
             return b''
@@ -600,7 +789,7 @@
 
     def serialize(self, msg, ident=None):
         """Serialize the message components to bytes.
-
+        
         This is roughly the inverse of deserialize. The serialize/deserialize
         methods work with full message lists, whereas pack/unpack work with
         the individual message parts in the message list.
@@ -609,17 +798,13 @@
         ----------
         msg : dict or Message
             The next message dict as returned by the self.msg method.
-
-        Returns
-        -------
-        msg_list : list
-            The list of bytes objects to be sent with the format::
-
-                [ident1, ident2, ..., DELIM, HMAC, p_header, p_parent,
-                 p_metadata, p_content, buffer1, buffer2, ...]
-
-            In this list, the ``p_*`` entities are the packed or serialized
-            versions, so if JSON is used, these are utf8 encoded JSON strings.
+        ident :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         content = msg.get('content', {})
         if content is None:
@@ -660,47 +845,44 @@
     def send(self, stream, msg_or_type, content=None, parent=None, ident=None,
              buffers=None, track=False, header=None, metadata=None):
         """Build and send a message via stream or socket.
-
+        
         The message format used by this function internally is as follows:
-
+        
         [ident1,ident2,...,DELIM,HMAC,p_header,p_parent,p_content,
          buffer1,buffer2,...]
-
+        
         The serialize/deserialize methods convert the nested message dict into this
         format.
 
         Parameters
         ----------
-
         stream : zmq.Socket or ZMQStream
             The socket-like object used to send the data.
         msg_or_type : str or Message/dict
             Normally, msg_or_type will be a msg_type unless a message is being
             sent more than once. If a header is supplied, this can be set to
             None and the msg_type will be pulled from the header.
-
         content : dict or None
-            The content of the message (ignored if msg_or_type is a message).
+            The content of the message (ignored if msg_or_type is a message). (Default value = None)
         header : dict or None
-            The header dict for the message (ignored if msg_to_type is a message).
+            The header dict for the message (ignored if msg_to_type is a message). (Default value = None)
         parent : Message or dict or None
             The parent or parent header describing the parent of this message
-            (ignored if msg_or_type is a message).
+            (ignored if msg_or_type is a message). (Default value = None)
         ident : bytes or list of bytes
-            The zmq.IDENTITY routing path.
+            The zmq.IDENTITY routing path. (Default value = None)
         metadata : dict or None
-            The metadata describing the message
+            The metadata describing the message (Default value = None)
         buffers : list or None
-            The already-serialized buffers to be appended to the message.
+            The already-serialized buffers to be appended to the message. (Default value = None)
         track : bool
             Whether to track.  Only for use with Sockets, because ZMQStream
-            objects cannot track messages.
-
-
-        Returns
-        -------
-        msg : dict
-            The constructed message.
+            objects cannot track messages. (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         if not isinstance(stream, zmq.Socket):
             # ZMQStreams and dummy sockets do not support tracking.
@@ -761,19 +943,26 @@
 
     def send_raw(self, stream, msg_list, flags=0, copy=True, ident=None):
         """Send a raw message via ident path.
-
+        
         This method is used to send a already serialized message.
 
         Parameters
         ----------
-        stream : ZMQStream or Socket
-            The ZMQ stream or socket to use for sending the message.
-        msg_list : list
-            The serialized list of messages to send. This only includes the
-            [p_header,p_parent,p_metadata,p_content,buffer1,buffer2,...] portion of
-            the message.
-        ident : ident or list
-            A single ident or a list of idents to use in sending.
+        stream :
+            
+        msg_list :
+            
+        flags :
+             (Default value = 0)
+        copy :
+             (Default value = True)
+        ident :
+             (Default value = None)
+
+        Returns
+        -------
+
+        
         """
         to_send = []
         if isinstance(ident, bytes):
@@ -794,12 +983,17 @@
         ----------
         socket : ZMQStream or Socket
             The socket or stream to use in receiving.
-
-        Returns
-        -------
-        [idents], msg
-            [idents] is a list of idents and msg is a nested message dict of
-            same format as self.msg returns.
+        mode :
+             (Default value = zmq.NOBLOCK)
+        content :
+             (Default value = True)
+        copy :
+             (Default value = True)
+
+        Returns
+        -------
+
+        
         """
         if isinstance(socket, ZMQStream):
             socket = socket.socket
@@ -823,7 +1017,7 @@
 
     def feed_identities(self, msg_list, copy=True):
         """Split the identities from the rest of the message.
-
+        
         Feed until DELIM is reached, then return the prefix as idents and
         remainder as msg_list. This is easily broken by setting an IDENT to DELIM,
         but that would be silly.
@@ -833,16 +1027,12 @@
         msg_list : a list of Message or bytes objects
             The message to be split.
         copy : bool
-            flag determining whether the arguments are bytes or Messages
-
-        Returns
-        -------
-        (idents, msg_list) : two lists
-            idents will always be a list of bytes, each of which is a ZMQ
-            identity. msg_list will be a list of bytes or zmq.Messages of the
-            form [HMAC,p_header,p_parent,p_content,buffer1,buffer2,...] and
-            should be unpackable/unserializable via self.deserialize at this
-            point.
+            flag determining whether the arguments are bytes or Messages (Default value = True)
+
+        Returns
+        -------
+
+        
         """
         if copy:
             idx = msg_list.index(DELIM)
@@ -859,7 +1049,17 @@
             return [m.bytes for m in idents], msg_list
 
     def _add_digest(self, signature):
-        """add a digest to history to protect against replay attacks"""
+        """add a digest to history to protect against replay attacks
+
+        Parameters
+        ----------
+        signature :
+            
+
+        Returns
+        -------
+
+        """
         if self.digest_history_size == 0:
             # no history, never add digests
             return
@@ -871,8 +1071,15 @@
 
     def _cull_digest_history(self):
         """cull the digest history
-
+        
         Removes a randomly selected 10% of the digest history
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         current = len(self.digest_history)
         n_to_cull = max(int(current // 10), current - self.digest_history_size)
@@ -884,7 +1091,7 @@
 
     def deserialize(self, msg_list, content=True, copy=True):
         """Unserialize a msg_list to a nested message dict.
-
+        
         This is roughly the inverse of serialize. The serialize/deserialize
         methods work with full message lists, whereas pack/unpack work with
         the individual message parts in the message list.
@@ -896,16 +1103,15 @@
             p_metadata,p_content,buffer1,buffer2,...].
         content : bool (True)
             Whether to unpack the content dict (True), or leave it packed
-            (False).
+            (False). (Default value = True)
         copy : bool (True)
             Whether msg_list contains bytes (True) or the non-copying Message
-            objects in each place (False).
-
-        Returns
-        -------
-        msg : dict
-            The nested message dict with top-level keys [header, parent_header,
-            content, buffers].  The buffers are returned as memoryviews.
+            objects in each place (False). (Default value = True)
+
+        Returns
+        -------
+
+        
         """
         minlen = 5
         message = {}
@@ -948,6 +1154,19 @@
         return adapt(message)
 
     def unserialize(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         warnings.warn(
             "Session.unserialize is deprecated. Use Session.deserialize.",
             DeprecationWarning,
@@ -956,6 +1175,7 @@
 
 
 def test_msg2obj():
+    """ """
     am = dict(x=1)
     ao = Message(am)
     assert ao.x == am['x']
