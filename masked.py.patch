# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/arrays/masked.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/arrays/masked.py
@@ -30,33 +30,32 @@
 
 
 class BaseMaskedDtype(ExtensionDtype):
-    """
-    Base class for dtypes for BasedMaskedArray subclasses.
-    """
+    """Base class for dtypes for BasedMaskedArray subclasses."""
 
     na_value = libmissing.NA
 
     @property
     def numpy_dtype(self) -> np.dtype:
+        """ """
         raise AbstractMethodError
 
     @classmethod
     def construct_array_type(cls) -> Type["BaseMaskedArray"]:
-        """
-        Return the array type associated with this dtype.
-
-        Returns
-        -------
-        type
-        """
+        """Return the array type associated with this dtype."""
         raise NotImplementedError
 
 
 class BaseMaskedArray(ExtensionArray, ExtensionOpsMixin):
-    """
-    Base class for masked arrays (which use _data and _mask to store the data).
-
+    """Base class for masked arrays (which use _data and _mask to store the data).
+    
     numpy based
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # The value used to fill '_data' to avoid upcasting
@@ -83,6 +82,7 @@
 
     @property
     def dtype(self) -> BaseMaskedDtype:
+        """ """
         raise AbstractMethodError(self)
 
     def __getitem__(self, item):
@@ -96,6 +96,17 @@
         return type(self)(self._data[item], self._mask[item])
 
     def _coerce_to_array(self, values) -> Tuple[np.ndarray, np.ndarray]:
+        """
+
+        Parameters
+        ----------
+        values :
+            
+
+        Returns
+        -------
+
+        """
         raise AbstractMethodError(self)
 
     def __setitem__(self, key, value) -> None:
@@ -128,16 +139,15 @@
     def to_numpy(
         self, dtype=None, copy: bool = False, na_value: Scalar = lib.no_default,
     ) -> np.ndarray:
-        """
-        Convert to a NumPy Array.
-
+        """Convert to a NumPy Array.
+        
         By default converts to an object-dtype NumPy array. Specify the `dtype` and
         `na_value` keywords to customize the conversion.
 
         Parameters
         ----------
         dtype : dtype, default object
-            The numpy dtype to convert to.
+            The numpy dtype to convert to. (Default value = None)
         copy : bool, default False
             Whether to ensure that the returned value is a not a view on
             the array. Note that ``copy=False`` does not *ensure* that
@@ -146,45 +156,53 @@
             only possible when no missing values are present and `dtype`
             is the equivalent numpy dtype.
         na_value : scalar, optional
-             Scalar missing value indicator to use in numpy array. Defaults
-             to the native missing value indicator of this array (pd.NA).
+            Scalar missing value indicator to use in numpy array. Defaults
+            to the native missing value indicator of this array (pd.NA).
+        copy: bool :
+             (Default value = False)
+        na_value: Scalar :
+             (Default value = lib.no_default)
 
         Returns
         -------
         numpy.ndarray
+            
 
         Examples
         --------
         An object-dtype is the default result
-
+        
+        
+        When no missing values are present, an equivalent dtype can be used.
+        
+        
+        However, requesting such dtype will raise a ValueError if
+        missing values are present and the default missing value :attr:`NA`
+        is used.
+        
+        
+        
+        Specify a valid `na_value` instead
         >>> a = pd.array([True, False, pd.NA], dtype="boolean")
         >>> a.to_numpy()
         array([True, False, <NA>], dtype=object)
-
-        When no missing values are present, an equivalent dtype can be used.
-
+        
         >>> pd.array([True, False], dtype="boolean").to_numpy(dtype="bool")
         array([ True, False])
         >>> pd.array([1, 2], dtype="Int64").to_numpy("int64")
         array([1, 2])
-
-        However, requesting such dtype will raise a ValueError if
-        missing values are present and the default missing value :attr:`NA`
-        is used.
-
+        
         >>> a = pd.array([True, False, pd.NA], dtype="boolean")
         >>> a
         <BooleanArray>
         [True, False, <NA>]
         Length: 3, dtype: boolean
-
+        
         >>> a.to_numpy(dtype="bool")
         Traceback (most recent call last):
         ...
         ValueError: cannot convert to bool numpy array in presence of missing values
-
-        Specify a valid `na_value` instead
-
+        
         >>> a.to_numpy(dtype="bool", na_value=False)
         array([ True, False, False])
         """
@@ -228,24 +246,41 @@
 
     @property
     def _hasna(self) -> bool:
+        """ """
         # Note: this is expensive right now! The hope is that we can
         # make this faster by having an optional mask, but not have to change
         # source code using it..
         return self._mask.any()
 
     def isna(self) -> np.ndarray:
+        """ """
         return self._mask
 
     @property
     def _na_value(self):
+        """ """
         return self.dtype.na_value
 
     @property
     def nbytes(self) -> int:
+        """ """
         return self._data.nbytes + self._mask.nbytes
 
     @classmethod
     def _concat_same_type(cls: Type[BaseMaskedArrayT], to_concat) -> BaseMaskedArrayT:
+        """
+
+        Parameters
+        ----------
+        cls: Type[BaseMaskedArrayT] :
+            
+        to_concat :
+            
+
+        Returns
+        -------
+
+        """
         data = np.concatenate([x._data for x in to_concat])
         mask = np.concatenate([x._mask for x in to_concat])
         return cls(data, mask)
@@ -256,6 +291,23 @@
         allow_fill: bool = False,
         fill_value: Optional[Scalar] = None,
     ) -> BaseMaskedArrayT:
+        """
+
+        Parameters
+        ----------
+        self: BaseMaskedArrayT :
+            
+        indexer :
+            
+        allow_fill: bool :
+             (Default value = False)
+        fill_value: Optional[Scalar] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         # we always fill with 1 internally
         # to avoid upcasting
         data_fill_value = self._internal_fill_value if isna(fill_value) else fill_value
@@ -277,6 +329,17 @@
         return type(self)(result, mask, copy=False)
 
     def copy(self: BaseMaskedArrayT) -> BaseMaskedArrayT:
+        """
+
+        Parameters
+        ----------
+        self: BaseMaskedArrayT :
+            
+
+        Returns
+        -------
+
+        """
         data, mask = self._data, self._mask
         data = data.copy()
         mask = mask.copy()
@@ -284,6 +347,17 @@
 
     @doc(ExtensionArray.factorize)
     def factorize(self, na_sentinel: int = -1) -> Tuple[np.ndarray, ExtensionArray]:
+        """
+
+        Parameters
+        ----------
+        na_sentinel: int :
+             (Default value = -1)
+
+        Returns
+        -------
+
+        """
         arr = self._data
         mask = self._mask
 
@@ -295,17 +369,19 @@
         return codes, uniques
 
     def value_counts(self, dropna: bool = True) -> "Series":
-        """
-        Returns a Series containing counts of each unique value.
+        """Returns a Series containing counts of each unique value.
 
         Parameters
         ----------
         dropna : bool, default True
             Don't include counts of missing values.
+        dropna: bool :
+             (Default value = True)
 
         Returns
         -------
         counts : Series
+            
 
         See Also
         --------
@@ -342,6 +418,21 @@
         return Series(counts, index=index)
 
     def _reduce(self, name: str, skipna: bool = True, **kwargs):
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        skipna: bool :
+             (Default value = True)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         data = self._data
         mask = self._mask
 
