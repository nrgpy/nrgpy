# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/asyncio_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/asyncio_test.py
@@ -25,17 +25,21 @@
 
 
 class AsyncIOLoopTest(AsyncTestCase):
+    """ """
     def get_new_ioloop(self):
+        """ """
         io_loop = AsyncIOLoop()
         return io_loop
 
     def test_asyncio_callback(self):
+        """ """
         # Basic test that the asyncio loop is set up correctly.
         asyncio.get_event_loop().call_soon(self.stop)
         self.wait()
 
     @gen_test
     def test_asyncio_future(self):
+        """ """
         # Test that we can yield an asyncio future from a tornado coroutine.
         # Without 'yield from', we must wrap coroutines in ensure_future,
         # which was introduced during Python 3.4, deprecating the prior "async".
@@ -52,8 +56,10 @@
 
     @gen_test
     def test_asyncio_yield_from(self):
+        """ """
         @gen.coroutine
         def f():
+            """ """
             event_loop = asyncio.get_event_loop()
             x = yield from event_loop.run_in_executor(None, lambda: 42)
             return x
@@ -62,12 +68,14 @@
         self.assertEqual(result, 42)
 
     def test_asyncio_adapter(self):
+        """ """
         # This test demonstrates that when using the asyncio coroutine
         # runner (i.e. run_until_complete), the to_asyncio_future
         # adapter is needed. No adapter is needed in the other direction,
         # as demonstrated by other tests in the package.
         @gen.coroutine
         def tornado_coroutine():
+            """ """
             yield gen.moment
             raise gen.Return(42)
 
@@ -109,7 +117,9 @@
 
 
 class LeakTest(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         # Trigger a cleanup of the mapping so we start with a clean slate.
         AsyncIOLoop().close()
         # If we don't clean up after ourselves other tests may fail on
@@ -118,10 +128,12 @@
         asyncio.set_event_loop_policy(asyncio.DefaultEventLoopPolicy())
 
     def tearDown(self):
+        """ """
         asyncio.get_event_loop().close()
         asyncio.set_event_loop_policy(self.orig_policy)
 
     def test_ioloop_close_leak(self):
+        """ """
         orig_count = len(IOLoop._ioloop_for_asyncio)
         for i in range(10):
             # Create and close an AsyncIOLoop using Tornado interfaces.
@@ -131,6 +143,7 @@
         self.assertEqual(new_count, 0)
 
     def test_asyncio_close_leak(self):
+        """ """
         orig_count = len(IOLoop._ioloop_for_asyncio)
         for i in range(10):
             # Create and close an AsyncIOMainLoop using asyncio interfaces.
@@ -146,22 +159,33 @@
 
 
 class AnyThreadEventLoopPolicyTest(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         self.orig_policy = asyncio.get_event_loop_policy()
         self.executor = ThreadPoolExecutor(1)
 
     def tearDown(self):
+        """ """
         asyncio.set_event_loop_policy(self.orig_policy)
         self.executor.shutdown()
 
     def get_event_loop_on_thread(self):
+        """ """
         def get_and_close_event_loop():
             """Get the event loop. Close it if one is returned.
-
+            
             Returns the (closed) event loop. This is a silly thing
             to do and leaves the thread in a broken state, but it's
             enough for this test. Closing the loop avoids resource
             leak warnings.
+
+            Parameters
+            ----------
+
+            Returns
+            -------
+
             """
             loop = asyncio.get_event_loop()
             loop.close()
@@ -171,6 +195,19 @@
         return future.result()
 
     def run_policy_test(self, accessor, expected_type):
+        """
+
+        Parameters
+        ----------
+        accessor :
+            
+        expected_type :
+            
+
+        Returns
+        -------
+
+        """
         # With the default policy, non-main threads don't get an event
         # loop.
         self.assertRaises(
@@ -184,7 +221,9 @@
         self.executor.submit(lambda: asyncio.get_event_loop().close()).result()  # type: ignore
 
     def test_asyncio_accessor(self):
+        """ """
         self.run_policy_test(asyncio.get_event_loop, asyncio.AbstractEventLoop)
 
     def test_tornado_accessor(self):
+        """ """
         self.run_policy_test(IOLoop.current, IOLoop)
