# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/annotation.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/gradual/annotation.py
@@ -23,13 +23,23 @@
 
 
 def infer_annotation(context, annotation):
-    """
-    Inferes an annotation node. This means that it inferes the part of
+    """Inferes an annotation node. This means that it inferes the part of
     `int` here:
-
+    
         foo: int = 3
-
+    
     Also checks for forward references (strings)
+
+    Parameters
+    ----------
+    context :
+        
+    annotation :
+        
+
+    Returns
+    -------
+
     """
     value_set = context.infer_node(annotation)
     if len(value_set) != 1:
@@ -46,6 +56,21 @@
 
 
 def _infer_annotation_string(context, string, index=None):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    string :
+        
+    index :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     node = _get_forward_reference_node(context, string)
     if node is None:
         return NO_VALUES
@@ -60,6 +85,19 @@
 
 
 def _get_forward_reference_node(context, string):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    string :
+        
+
+    Returns
+    -------
+
+    """
     try:
         new_node = context.inference_state.grammar.parse(
             force_unicode(string),
@@ -77,12 +115,19 @@
 
 
 def _split_comment_param_declaration(decl_text):
-    """
-    Split decl_text on commas, but group generic expressions
+    """Split decl_text on commas, but group generic expressions
     together.
-
+    
     For example, given "foo, Bar[baz, biz]" we return
     ['foo', 'Bar[baz, biz]'].
+
+    Parameters
+    ----------
+    decl_text :
+        
+
+    Returns
+    -------
 
     """
     try:
@@ -109,6 +154,21 @@
 
 @inference_state_method_cache()
 def infer_param(function_value, param, ignore_stars=False):
+    """
+
+    Parameters
+    ----------
+    function_value :
+        
+    param :
+        
+    ignore_stars :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     values = _infer_param(function_value, param)
     if ignore_stars or not values:
         return values
@@ -133,8 +193,18 @@
 
 
 def _infer_param(function_value, param):
-    """
-    Infers the type of a function parameter, using type annotations.
+    """Infers the type of a function parameter, using type annotations.
+
+    Parameters
+    ----------
+    function_value :
+        
+    param :
+        
+
+    Returns
+    -------
+
     """
     annotation = param.annotation
     if annotation is None:
@@ -183,6 +253,17 @@
 
 
 def py__annotations__(funcdef):
+    """
+
+    Parameters
+    ----------
+    funcdef :
+        
+
+    Returns
+    -------
+
+    """
     dct = {}
     for function_param in funcdef.get_params():
         param_annotation = function_param.annotation
@@ -197,9 +278,19 @@
 
 @inference_state_method_cache()
 def infer_return_types(function, arguments):
-    """
-    Infers the type of a function's return value,
+    """Infers the type of a function's return value,
     according to type annotations.
+
+    Parameters
+    ----------
+    function :
+        
+    arguments :
+        
+
+    Returns
+    -------
+
     """
     all_annotations = py__annotations__(function.tree_node)
     annotation = all_annotations.get("return", None)
@@ -235,14 +326,26 @@
 
 
 def infer_type_vars_for_execution(function, arguments, annotation_dict):
-    """
-    Some functions use type vars that are not defined by the class, but rather
+    """Some functions use type vars that are not defined by the class, but rather
     only defined in the function. See for example `iter`. In those cases we
     want to:
-
+    
     1. Search for undefined type vars.
     2. Infer type vars with the execution state we have.
     3. Return the union of all type vars that have been found.
+
+    Parameters
+    ----------
+    function :
+        
+    arguments :
+        
+    annotation_dict :
+        
+
+    Returns
+    -------
+
     """
     context = function.get_default_param_context()
 
@@ -273,6 +376,21 @@
 
 
 def infer_return_for_callable(arguments, param_values, result_values):
+    """
+
+    Parameters
+    ----------
+    arguments :
+        
+    param_values :
+        
+    result_values :
+        
+
+    Returns
+    -------
+
+    """
     all_type_vars = {}
     for pv in param_values:
         if pv.array_type == 'list':
@@ -288,10 +406,20 @@
 
 
 def _infer_type_vars_for_callable(arguments, lazy_params):
-    """
-    Infers type vars for the Calllable class:
-
+    """Infers type vars for the Calllable class:
+    
         def x() -> Callable[[Callable[..., _T]], _T]: ...
+
+    Parameters
+    ----------
+    arguments :
+        
+    lazy_params :
+        
+
+    Returns
+    -------
+
     """
     annotation_variable_results = {}
     for (_, lazy_value), lazy_callable_param in zip(arguments.unpack(), lazy_params):
@@ -306,6 +434,19 @@
 
 
 def merge_type_var_dicts(base_dict, new_dict):
+    """
+
+    Parameters
+    ----------
+    base_dict :
+        
+    new_dict :
+        
+
+    Returns
+    -------
+
+    """
     for type_var_name, values in new_dict.items():
         if values:
             try:
@@ -315,25 +456,24 @@
 
 
 def merge_pairwise_generics(annotation_value, annotated_argument_class):
-    """
-    Match up the generic parameters from the given argument class to the
+    """Match up the generic parameters from the given argument class to the
     target annotation.
-
+    
     This walks the generic parameters immediately within the annotation and
     argument's type, in order to determine the concrete values of the
     annotation's parameters for the current case.
-
+    
     For example, given the following code:
-
+    
         def values(mapping: Mapping[K, V]) -> List[V]: ...
-
+    
         for val in values({1: 'a'}):
             val
-
+    
     Then this function should be given representations of `Mapping[K, V]`
     and `Mapping[int, str]`, so that it can determine that `K` is `int and
     `V` is `str`.
-
+    
     Note that it is responsibility of the caller to traverse the MRO of the
     argument type as needed in order to find the type matching the
     annotation (in this case finding `Mapping[int, str]` as a parent of
@@ -341,12 +481,15 @@
 
     Parameters
     ----------
-
-    `annotation_value`: represents the annotation to infer the concrete
-        parameter types of.
-
-    `annotated_argument_class`: represents the annotated class of the
-        argument being passed to the object annotated by `annotation_value`.
+    annotation_value :
+        
+    annotated_argument_class :
+        
+
+    Returns
+    -------
+
+    
     """
 
     type_var_dict = {}
@@ -367,10 +510,40 @@
 
 
 def find_type_from_comment_hint_for(context, node, name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     return _find_type_from_comment_hint(context, node, node.children[1], name)
 
 
 def find_type_from_comment_hint_with(context, node, name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     assert len(node.children[1].children) == 3, \
         "Can only be here when children[1] is 'foo() as f'"
     varlist = node.children[1].children[2]
@@ -378,10 +551,42 @@
 
 
 def find_type_from_comment_hint_assign(context, node, name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     return _find_type_from_comment_hint(context, node, node.children[0], name)
 
 
 def _find_type_from_comment_hint(context, node, varlist, name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+    varlist :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     index = None
     if varlist.type in ("testlist_star_expr", "exprlist", "testlist"):
         # something like "a, b = 1, 2"
@@ -407,7 +612,31 @@
 
 
 def find_unknown_type_vars(context, node):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    node :
+        
+
+    Returns
+    -------
+
+    """
     def check_node(node):
+        """
+
+        Parameters
+        ----------
+        node :
+            
+
+        Returns
+        -------
+
+        """
         if node.type in ('atom_expr', 'power'):
             trailer = node.children[-1]
             if trailer.type == 'trailer' and trailer.children[0] == '[':
@@ -422,6 +651,19 @@
 
 
 def _filter_type_vars(value_set, found=()):
+    """
+
+    Parameters
+    ----------
+    value_set :
+        
+    found :
+         (Default value = ())
+
+    Returns
+    -------
+
+    """
     new_found = list(found)
     for type_var in value_set:
         if isinstance(type_var, TypeVar) and type_var not in found:
@@ -430,6 +672,17 @@
 
 
 def _unpack_subscriptlist(subscriptlist):
+    """
+
+    Parameters
+    ----------
+    subscriptlist :
+        
+
+    Returns
+    -------
+
+    """
     if subscriptlist.type == 'subscriptlist':
         for subscript in subscriptlist.children[::2]:
             if subscript.type != 'subscript':
