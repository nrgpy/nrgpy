# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/simple_httpclient.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/simple_httpclient.py
@@ -43,11 +43,18 @@
 
 class HTTPTimeoutError(HTTPError):
     """Error raised by SimpleAsyncHTTPClient on timeout.
-
+    
     For historical reasons, this is a subclass of `.HTTPClientError`
     which simulates a response code of 599.
-
+    
     .. versionadded:: 5.1
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, message: str) -> None:
@@ -59,14 +66,21 @@
 
 class HTTPStreamClosedError(HTTPError):
     """Error raised by SimpleAsyncHTTPClient when the underlying stream is closed.
-
+    
     When a more specific exception is available (such as `ConnectionResetError`),
     it may be raised instead of this one.
-
+    
     For historical reasons, this is a subclass of `.HTTPClientError`
     which simulates a response code of 599.
-
+    
     .. versionadded:: 5.1
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, message: str) -> None:
@@ -78,12 +92,19 @@
 
 class SimpleAsyncHTTPClient(AsyncHTTPClient):
     """Non-blocking HTTP client with no external dependencies.
-
+    
     This class implements an HTTP 1.1 client on top of Tornado's IOStreams.
     Some features found in the curl-based AsyncHTTPClient are not yet
     supported.  In particular, proxies are not supported, connections
     are not reused, and callers cannot select the network interface to be
     used.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(  # type: ignore
@@ -97,26 +118,26 @@
         max_body_size: Optional[int] = None,
     ) -> None:
         """Creates a AsyncHTTPClient.
-
+        
         Only a single AsyncHTTPClient instance exists per IOLoop
         in order to provide limitations on the number of pending connections.
         ``force_instance=True`` may be used to suppress this behavior.
-
+        
         Note that because of this implicit reuse, unless ``force_instance``
         is used, only the first call to the constructor actually uses
         its arguments. It is recommended to use the ``configure`` method
         instead of the constructor to ensure that arguments take effect.
-
+        
         ``max_clients`` is the number of concurrent requests that can be
         in progress; when this limit is reached additional requests will be
         queued. Note that time spent waiting in this queue still counts
         against the ``request_timeout``.
-
+        
         ``hostname_mapping`` is a dictionary mapping hostnames to IP addresses.
         It can be used to make local DNS changes when modifying system-wide
         settings like ``/etc/hosts`` is not possible or desirable (e.g. in
         unittests).
-
+        
         ``max_buffer_size`` (default 100MB) is the number of bytes
         that can be read into memory at once. ``max_body_size``
         (defaults to ``max_buffer_size``) is the largest response body
@@ -124,9 +145,36 @@
         ``streaming_callback``, the smaller of these two limits
         applies; with a ``streaming_callback`` only ``max_body_size``
         does.
-
+        
         .. versionchanged:: 4.2
            Added the ``max_body_size`` argument.
+
+        Parameters
+        ----------
+        # type: ignoreself :
+            
+        max_clients: int :
+             (Default value = 10)
+        hostname_mapping: Optional[Dict[str :
+            
+        str]] :
+             (Default value = None)
+        max_buffer_size: int :
+             (Default value = 104857600)
+        resolver: Optional[Resolver] :
+             (Default value = None)
+        defaults: Optional[Dict[str :
+            
+        Any]] :
+             (Default value = None)
+        max_header_size: Optional[int] :
+             (Default value = None)
+        max_body_size: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         super().initialize(defaults=defaults)
         self.max_clients = max_clients
@@ -157,6 +205,7 @@
         self.tcp_client = TCPClient(resolver=self.resolver)
 
     def close(self) -> None:
+        """ """
         super().close()
         if self.own_resolver:
             self.resolver.close()
@@ -165,6 +214,21 @@
     def fetch_impl(
         self, request: HTTPRequest, callback: Callable[[HTTPResponse], None]
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        request: HTTPRequest :
+            
+        callback: Callable[[HTTPResponse] :
+            
+        None] :
+            
+
+        Returns
+        -------
+
+        """
         key = object()
         self.queue.append((key, request, callback))
         assert request.connect_timeout is not None
@@ -190,6 +254,7 @@
             )
 
     def _process_queue(self) -> None:
+        """ """
         while self.queue and len(self.active) < self.max_clients:
             key, request, callback = self.queue.popleft()
             if key not in self.waiting:
@@ -200,6 +265,7 @@
             self._handle_request(request, release_callback, callback)
 
     def _connection_class(self) -> type:
+        """ """
         return _HTTPConnection
 
     def _handle_request(
@@ -208,6 +274,23 @@
         release_callback: Callable[[], None],
         final_callback: Callable[[HTTPResponse], None],
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        request: HTTPRequest :
+            
+        release_callback: Callable[[] :
+            
+        None] :
+            
+        final_callback: Callable[[HTTPResponse] :
+            
+
+        Returns
+        -------
+
+        """
         self._connection_class()(
             self,
             request,
@@ -220,10 +303,32 @@
         )
 
     def _release_fetch(self, key: object) -> None:
+        """
+
+        Parameters
+        ----------
+        key: object :
+            
+
+        Returns
+        -------
+
+        """
         del self.active[key]
         self._process_queue()
 
     def _remove_timeout(self, key: object) -> None:
+        """
+
+        Parameters
+        ----------
+        key: object :
+            
+
+        Returns
+        -------
+
+        """
         if key in self.waiting:
             request, callback, timeout_handle = self.waiting[key]
             if timeout_handle is not None:
@@ -232,11 +337,22 @@
 
     def _on_timeout(self, key: object, info: Optional[str] = None) -> None:
         """Timeout callback of request.
-
+        
         Construct a timeout HTTPResponse when a timeout occurs.
-
+        
         :arg object key: A simple object to mark the request.
         :info string key: More detailed timeout information.
+
+        Parameters
+        ----------
+        key: object :
+            
+        info: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         request, callback, timeout_handle = self.waiting[key]
         self.queue.remove((key, request, callback))
@@ -253,6 +369,7 @@
 
 
 class _HTTPConnection(httputil.HTTPMessageDelegate):
+    """ """
     _SUPPORTED_METHODS = set(
         ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]
     )
@@ -449,6 +566,17 @@
     def _get_ssl_options(
         self, scheme: str
     ) -> Union[None, Dict[str, Any], ssl.SSLContext]:
+        """
+
+        Parameters
+        ----------
+        scheme: str :
+            
+
+        Returns
+        -------
+
+        """
         if scheme == "https":
             if self.request.ssl_options is not None:
                 return self.request.ssl_options
@@ -480,9 +608,19 @@
     def _on_timeout(self, info: Optional[str] = None) -> None:
         """Timeout callback of _HTTPConnection instance.
 
-        Raise a `HTTPTimeoutError` when a timeout occurs.
-
-        :info string key: More detailed timeout information.
+        Parameters
+        ----------
+        info: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        Raises
+        ------
+        info
+            string key
+
         """
         self._timeout = None
         error_message = "Timeout {0}".format(info) if info else "Timeout"
@@ -492,11 +630,23 @@
             )
 
     def _remove_timeout(self) -> None:
+        """ """
         if self._timeout is not None:
             self.io_loop.remove_timeout(self._timeout)
             self._timeout = None
 
     def _create_connection(self, stream: IOStream) -> HTTP1Connection:
+        """
+
+        Parameters
+        ----------
+        stream: IOStream :
+            
+
+        Returns
+        -------
+
+        """
         stream.set_nodelay(True)
         connection = HTTP1Connection(
             stream,
@@ -527,12 +677,24 @@
                     raise
 
     def _release(self) -> None:
+        """ """
         if self.release_callback is not None:
             release_callback = self.release_callback
             self.release_callback = None  # type: ignore
             release_callback()
 
     def _run_callback(self, response: HTTPResponse) -> None:
+        """
+
+        Parameters
+        ----------
+        response: HTTPResponse :
+            
+
+        Returns
+        -------
+
+        """
         self._release()
         if self.final_callback is not None:
             final_callback = self.final_callback
@@ -545,6 +707,21 @@
         value: Optional[BaseException],
         tb: Optional[TracebackType],
     ) -> bool:
+        """
+
+        Parameters
+        ----------
+        typ: "Optional[Type[BaseException]]" :
+            
+        value: Optional[BaseException] :
+            
+        tb: Optional[TracebackType] :
+            
+
+        Returns
+        -------
+
+        """
         if self.final_callback:
             self._remove_timeout()
             if isinstance(value, StreamClosedError):
@@ -576,6 +753,7 @@
             return isinstance(value, StreamClosedError)
 
     def on_connection_close(self) -> None:
+        """ """
         if self.final_callback is not None:
             message = "Connection closed"
             if self.stream.error:
@@ -609,6 +787,7 @@
             self.request.header_callback("\r\n")
 
     def _should_follow_redirect(self) -> bool:
+        """ """
         if self.request.follow_redirects:
             assert self.request.max_redirects is not None
             return (
@@ -620,6 +799,7 @@
         return False
 
     def finish(self) -> None:
+        """ """
         assert self.code is not None
         data = b"".join(self.chunks)
         self._remove_timeout()
@@ -682,9 +862,21 @@
         self._on_end_request()
 
     def _on_end_request(self) -> None:
+        """ """
         self.stream.close()
 
     def data_received(self, chunk: bytes) -> None:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
+        """
         if self._should_follow_redirect():
             # We're going to follow a redirect so just discard the body.
             return
