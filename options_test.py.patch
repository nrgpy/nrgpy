# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/options_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/options_test.py
@@ -16,6 +16,7 @@
 
 
 class Email(object):
+    """ """
     def __init__(self, value):
         if isinstance(value, str) and "@" in value:
             self._value = value
@@ -24,17 +25,21 @@
 
     @property
     def value(self):
+        """ """
         return self._value
 
 
 class OptionsTest(unittest.TestCase):
+    """ """
     def test_parse_command_line(self):
+        """ """
         options = OptionParser()
         options.define("port", default=80)
         options.parse_command_line(["main.py", "--port=443"])
         self.assertEqual(options.port, 443)
 
     def test_parse_config_file(self):
+        """ """
         options = OptionParser()
         options.define("port", default=80)
         options.define("username", default="foo")
@@ -48,10 +53,12 @@
         self.assertEqual(options.my_path, config_path)
 
     def test_parse_callbacks(self):
+        """ """
         options = OptionParser()
         self.called = False
 
         def callback():
+            """ """
             self.called = True
 
         options.add_parse_callback(callback)
@@ -71,6 +78,7 @@
         self.assertTrue(self.called)
 
     def test_help(self):
+        """ """
         options = OptionParser()
         try:
             orig_stderr = sys.stderr
@@ -83,6 +91,7 @@
         self.assertIn("Usage:", usage)
 
     def test_subcommand(self):
+        """ """
         base_options = OptionParser()
         base_options.define("verbose", default=False)
         sub_options = OptionParser()
@@ -106,12 +115,14 @@
             sys.stderr = orig_stderr
 
     def test_setattr(self):
+        """ """
         options = OptionParser()
         options.define("foo", default=1, type=int)
         options.foo = 2
         self.assertEqual(options.foo, 2)
 
     def test_setattr_type_check(self):
+        """ """
         # setattr requires that options be the right type and doesn't
         # parse from string formats.
         options = OptionParser()
@@ -120,6 +131,7 @@
             options.foo = "2"
 
     def test_setattr_with_callback(self):
+        """ """
         values = []  # type: List[int]
         options = OptionParser()
         options.define("foo", default=1, type=int, callback=values.append)
@@ -127,27 +139,32 @@
         self.assertEqual(values, [2])
 
     def _sample_options(self):
+        """ """
         options = OptionParser()
         options.define("a", default=1)
         options.define("b", default=2)
         return options
 
     def test_iter(self):
+        """ """
         options = self._sample_options()
         # OptionParsers always define 'help'.
         self.assertEqual(set(["a", "b", "help"]), set(iter(options)))
 
     def test_getitem(self):
+        """ """
         options = self._sample_options()
         self.assertEqual(1, options["a"])
 
     def test_setitem(self):
+        """ """
         options = OptionParser()
         options.define("foo", default=1, type=int)
         options["foo"] = 2
         self.assertEqual(options["foo"], 2)
 
     def test_items(self):
+        """ """
         options = self._sample_options()
         # OptionParsers always define 'help'.
         expected = [("a", 1), ("b", 2), ("help", options.help)]
@@ -155,11 +172,13 @@
         self.assertEqual(expected, actual)
 
     def test_as_dict(self):
+        """ """
         options = self._sample_options()
         expected = {"a": 1, "b": 2, "help": options.help}
         self.assertEqual(expected, options.as_dict())
 
     def test_group_dict(self):
+        """ """
         options = OptionParser()
         options.define("a", default=1)
         options.define("b", group="b_group", default=2)
@@ -174,6 +193,7 @@
         self.assertEqual({}, options.group_dict("nonexistent"))
 
     def test_mock_patch(self):
+        """ """
         # ensure that our setattr hooks don't interfere with mock.patch
         options = OptionParser()
         options.define("foo", default=1)
@@ -195,6 +215,7 @@
         self.assertEqual(options.foo, 2)
 
     def _define_options(self):
+        """ """
         options = OptionParser()
         options.define("str", type=str)
         options.define("basestring", type=basestring_type)
@@ -207,6 +228,17 @@
         return options
 
     def _check_options_values(self, options):
+        """
+
+        Parameters
+        ----------
+        options :
+            
+
+        Returns
+        -------
+
+        """
         self.assertEqual(options.str, "asdf")
         self.assertEqual(options.basestring, "qwer")
         self.assertEqual(options.int, 42)
@@ -218,6 +250,7 @@
         self.assertEqual(options.list_of_int, [1, 2, 3])
 
     def test_types(self):
+        """ """
         options = self._define_options()
         options.parse_command_line(
             [
@@ -235,6 +268,7 @@
         self._check_options_values(options)
 
     def test_types_with_conf_file(self):
+        """ """
         for config_file_name in (
             "options_test_types.cfg",
             "options_test_types_str.cfg",
@@ -246,18 +280,21 @@
             self._check_options_values(options)
 
     def test_multiple_string(self):
+        """ """
         options = OptionParser()
         options.define("foo", type=str, multiple=True)
         options.parse_command_line(["main.py", "--foo=a,b,c"])
         self.assertEqual(options.foo, ["a", "b", "c"])
 
     def test_multiple_int(self):
+        """ """
         options = OptionParser()
         options.define("foo", type=int, multiple=True)
         options.parse_command_line(["main.py", "--foo=1,3,5:7"])
         self.assertEqual(options.foo, [1, 3, 5, 6, 7])
 
     def test_error_redefine(self):
+        """ """
         options = OptionParser()
         options.define("foo")
         with self.assertRaises(Error) as cm:
@@ -265,6 +302,7 @@
         self.assertRegexpMatches(str(cm.exception), "Option.*foo.*already defined")
 
     def test_error_redefine_underscore(self):
+        """ """
         # Ensure that the dash/underscore normalization doesn't
         # interfere with the redefinition error.
         tests = [
@@ -284,6 +322,7 @@
                 )
 
     def test_dash_underscore_cli(self):
+        """ """
         # Dashes and underscores should be interchangeable.
         for defined_name in ["foo-bar", "foo_bar"]:
             for flag in ["--foo-bar=a", "--foo_bar=a"]:
@@ -297,6 +336,7 @@
                 self.assertEqual(options["foo_bar"], "a")
 
     def test_dash_underscore_file(self):
+        """ """
         # No matter how an option was defined, it can be set with underscores
         # in a config file.
         for defined_name in ["foo-bar", "foo_bar"]:
@@ -308,6 +348,7 @@
             self.assertEqual(options.foo_bar, "a")
 
     def test_dash_underscore_introspection(self):
+        """ """
         # Original names are preserved in introspection APIs.
         options = OptionParser()
         options.define("with-dash", group="g")
