# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/core/internals/managers.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/core/internals/managers.py
@@ -67,12 +67,23 @@
 
 
 class BlockManager(PandasObject):
-    """
-    Core internal data structure to implement DataFrame, Series, etc.
-
+    """Core internal data structure to implement DataFrame, Series, etc.
+    
     Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a
     lightweight blocked set of labeled data to be manipulated by the DataFrame
     public API class
+
+    Parameters
+    ----------
+    blocks : Sequence of Block
+        
+    axes : Sequence of Index
+        
+    do_integrity_check : bool, default True
+        
+
+    Returns
+    -------
 
     Attributes
     ----------
@@ -81,37 +92,29 @@
     axes
     values
     items
-
     Methods
     -------
     set_axis(axis, new_labels)
     copy(deep=True)
-
+    
     get_dtypes
-
+    
     apply(func, axes, block_filter_fn)
-
+    
     get_bool_data
     get_numeric_data
-
+    
     get_slice(slice_like, axis)
     get(label)
     iget(loc)
-
+    
     take(indexer, axis)
     reindex_axis(new_labels, axis)
     reindex_indexer(new_labels, indexer, axis)
-
+    
     delete(label)
     insert(loc, label, value)
     set(label, value)
-
-    Parameters
-    ----------
-    blocks: Sequence of Block
-    axes: Sequence of Index
-    do_integrity_check: bool, default True
-
     Notes
     -----
     This is *not* a public API class
@@ -155,20 +158,36 @@
 
     @classmethod
     def from_blocks(cls, blocks: List[Block], axes: List[Index]):
-        """
-        Constructor for BlockManager and SingleBlockManager with same signature.
+        """Constructor for BlockManager and SingleBlockManager with same signature.
+
+        Parameters
+        ----------
+        blocks: List[Block] :
+            
+        axes: List[Index] :
+            
+
+        Returns
+        -------
+
         """
         return cls(blocks, axes, do_integrity_check=False)
 
     @property
     def blknos(self):
-        """
-        Suppose we want to find the array corresponding to our i'th column.
-
+        """Suppose we want to find the array corresponding to our i'th column.
+        
         blknos[i] identifies the block from self.blocks that contains this column.
-
+        
         blklocs[i] identifies the column of interest within
         self.blocks[self.blknos[i]]
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if self._blknos is None:
             # Note: these can be altered by other BlockManager methods.
@@ -178,9 +197,7 @@
 
     @property
     def blklocs(self):
-        """
-        See blknos.__doc__
-        """
+        """See blknos.__doc__"""
         if self._blklocs is None:
             # Note: these can be altered by other BlockManager methods.
             self._rebuild_blknos_and_blklocs()
@@ -188,7 +205,21 @@
         return self._blklocs
 
     def make_empty(self: T, axes=None) -> T:
-        """ return an empty BlockManager with the items axis of len 0 """
+        """
+
+        Parameters
+        ----------
+        self: T :
+            
+        axes :
+             (Default value = None)
+
+        Returns
+        -------
+        type
+            
+
+        """
         if axes is None:
             axes = [Index([])] + self.axes[1:]
 
@@ -211,13 +242,28 @@
 
     @property
     def shape(self) -> Tuple[int, ...]:
+        """ """
         return tuple(len(ax) for ax in self.axes)
 
     @property
     def ndim(self) -> int:
+        """ """
         return len(self.axes)
 
     def set_axis(self, axis: int, new_labels: Index) -> None:
+        """
+
+        Parameters
+        ----------
+        axis: int :
+            
+        new_labels: Index :
+            
+
+        Returns
+        -------
+
+        """
         # Caller is responsible for ensuring we have an Index object.
         old_len = len(self.axes[axis])
         new_len = len(new_labels)
@@ -232,13 +278,12 @@
 
     @property
     def _is_single_block(self) -> bool:
+        """ """
         # Assumes we are 2D; overriden by SingleBlockManager
         return len(self.blocks) == 1
 
     def _rebuild_blknos_and_blklocs(self) -> None:
-        """
-        Update mgr._blknos / mgr._blklocs.
-        """
+        """Update mgr._blknos / mgr._blklocs."""
         new_blknos = np.empty(self.shape[0], dtype=np.intp)
         new_blklocs = np.empty(self.shape[0], dtype=np.intp)
         new_blknos.fill(-1)
@@ -258,9 +303,11 @@
 
     @property
     def items(self) -> Index:
+        """ """
         return self.axes[0]
 
     def get_dtypes(self):
+        """ """
         dtypes = np.array([blk.dtype for blk in self.blocks])
         return algos.take_1d(dtypes, self.blknos, allow_fill=False)
 
@@ -285,6 +332,19 @@
 
     def __setstate__(self, state):
         def unpickle_block(values, mgr_locs):
+            """
+
+            Parameters
+            ----------
+            values :
+                
+            mgr_locs :
+                
+
+            Returns
+            -------
+
+            """
             return make_block(values, placement=mgr_locs)
 
         if isinstance(state, tuple) and len(state) >= 4 and "0.14.1" in state[3]:
@@ -299,6 +359,7 @@
         self._post_setstate()
 
     def _post_setstate(self) -> None:
+        """ """
         self._is_consolidated = False
         self._known_consolidated = False
         self._rebuild_blknos_and_blklocs()
@@ -319,6 +380,7 @@
         return output
 
     def _verify_integrity(self) -> None:
+        """ """
         mgr_shape = self.shape
         tot_items = sum(len(x.mgr_locs) for x in self.blocks)
         for block in self.blocks:
@@ -332,6 +394,17 @@
             )
 
     def reduce(self, func):
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         # If 2D, we assume that we're operating column-wise
         if self.ndim == 1:
             # we'll be returning a scalar
@@ -358,23 +431,39 @@
         return res
 
     def operate_blockwise(self, other: "BlockManager", array_op) -> "BlockManager":
-        """
-        Apply array_op blockwise with another (aligned) BlockManager.
+        """Apply array_op blockwise with another (aligned) BlockManager.
+
+        Parameters
+        ----------
+        other: "BlockManager" :
+            
+        array_op :
+            
+
+        Returns
+        -------
+
         """
         return operate_blockwise(self, other, array_op)
 
     def apply(self: T, f, align_keys=None, **kwargs) -> T:
-        """
-        Iterate over the blocks, collect and create a new BlockManager.
+        """Iterate over the blocks, collect and create a new BlockManager.
 
         Parameters
         ----------
         f : str or callable
             Name of the Block method to apply.
-
-        Returns
-        -------
-        BlockManager
+        self: T :
+            
+        align_keys :
+             (Default value = None)
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        
         """
         assert "filter" not in kwargs
 
@@ -419,29 +508,52 @@
         qs=None,
         numeric_only=None,
     ) -> "BlockManager":
-        """
-        Iterate over blocks applying quantile reduction.
+        """Iterate over blocks applying quantile reduction.
         This routine is intended for reduction type operations and
         will do inference on the generated blocks.
 
         Parameters
         ----------
-        axis: reduction axis, default 0
-        transposed: bool, default False
+        axis : reduction axis, default 0
+            
+        transposed : bool, default False
             we are holding transposed data
         interpolation : type of interpolation, default 'linear'
+             (Default value = "linear")
         qs : a scalar or list of the quantiles to be computed
+             (Default value = None)
         numeric_only : ignored
-
-        Returns
-        -------
-        BlockManager
+             (Default value = None)
+        axis: int :
+             (Default value = 0)
+        transposed: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         # Series dispatches to DataFrame for quantile, which allows us to
         #  simplify some of the code here and in the blocks
         assert self.ndim >= 2
 
         def get_axe(block, qs, axes):
+            """
+
+            Parameters
+            ----------
+            block :
+                
+            qs :
+                
+            axes :
+                
+
+            Returns
+            -------
+
+            """
             # Because Series dispatches to DataFrame, we will always have
             #  block.ndim == 2
             from pandas import Float64Index
@@ -509,11 +621,43 @@
         )
 
     def isna(self, func) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        func :
+            
+
+        Returns
+        -------
+
+        """
         return self.apply("apply", func=func)
 
     def where(
         self, other, cond, align: bool, errors: str, try_cast: bool, axis: int
     ) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        cond :
+            
+        align: bool :
+            
+        errors: str :
+            
+        try_cast: bool :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         if align:
             align_keys = ["other", "cond"]
         else:
@@ -531,11 +675,41 @@
         )
 
     def setitem(self, indexer, value) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        indexer :
+            
+        value :
+            
+
+        Returns
+        -------
+
+        """
         return self.apply("setitem", indexer=indexer, value=value)
 
     def putmask(
         self, mask, new, align: bool = True, axis: int = 0,
     ):
+        """
+
+        Parameters
+        ----------
+        mask :
+            
+        new :
+            
+        align: bool :
+             (Default value = True)
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         transpose = self.ndim == 2
 
         if align:
@@ -555,12 +729,51 @@
         )
 
     def diff(self, n: int, axis: int) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        n: int :
+            
+        axis: int :
+            
+
+        Returns
+        -------
+
+        """
         return self.apply("diff", n=n, axis=axis)
 
     def interpolate(self, **kwargs) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.apply("interpolate", **kwargs)
 
     def shift(self, periods: int, axis: int, fill_value) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        periods: int :
+            
+        axis: int :
+            
+        fill_value :
+            
+
+        Returns
+        -------
+
+        """
         if axis == 0 and self.ndim == 2 and self.nblocks > 1:
             # GH#35488 we need to watch out for multi-block cases
             ncols = self.shape[0]
@@ -582,16 +795,49 @@
         return self.apply("shift", periods=periods, axis=axis, fill_value=fill_value)
 
     def fillna(self, value, limit, inplace: bool, downcast) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        limit :
+            
+        inplace: bool :
+            
+        downcast :
+            
+
+        Returns
+        -------
+
+        """
         return self.apply(
             "fillna", value=value, limit=limit, inplace=inplace, downcast=downcast
         )
 
     def downcast(self) -> "BlockManager":
+        """ """
         return self.apply("downcast")
 
     def astype(
         self, dtype, copy: bool = False, errors: str = "raise"
     ) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        dtype :
+            
+        copy: bool :
+             (Default value = False)
+        errors: str :
+             (Default value = "raise")
+
+        Returns
+        -------
+
+        """
         return self.apply("astype", dtype=dtype, copy=copy, errors=errors)
 
     def convert(
@@ -602,6 +848,25 @@
         timedelta: bool = True,
         coerce: bool = False,
     ) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        copy: bool :
+             (Default value = True)
+        datetime: bool :
+             (Default value = True)
+        numeric: bool :
+             (Default value = True)
+        timedelta: bool :
+             (Default value = True)
+        coerce: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return self.apply(
             "convert",
             copy=copy,
@@ -612,22 +877,63 @@
         )
 
     def replace(self, value, **kwargs) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        value :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         assert np.ndim(value) == 0, value
         return self.apply("replace", value=value, **kwargs)
 
     def replace_list(
         self, src_list, dest_list, inplace: bool = False, regex: bool = False
     ) -> "BlockManager":
-        """ do a list replace """
+        """do a list replace
+
+        Parameters
+        ----------
+        src_list :
+            
+        dest_list :
+            
+        inplace: bool :
+             (Default value = False)
+        regex: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         inplace = validate_bool_kwarg(inplace, "inplace")
 
         # figure out our mask apriori to avoid repeated replacements
         values = self.as_array()
 
         def comp(s: Scalar, mask: np.ndarray, regex: bool = False):
-            """
-            Generate a bool array by perform an equality check, or perform
+            """Generate a bool array by perform an equality check, or perform
             an element-wise regular expression matching
+
+            Parameters
+            ----------
+            s: Scalar :
+                
+            mask: np.ndarray :
+                
+            regex: bool :
+                 (Default value = False)
+
+            Returns
+            -------
+
             """
             if isna(s):
                 return ~mask
@@ -673,26 +979,27 @@
         return bm
 
     def is_consolidated(self) -> bool:
-        """
-        Return True if more than one block with the same dtype
-        """
+        """ """
         if not self._known_consolidated:
             self._consolidate_check()
         return self._is_consolidated
 
     def _consolidate_check(self) -> None:
+        """ """
         dtypes = [blk.dtype for blk in self.blocks if blk._can_consolidate]
         self._is_consolidated = len(dtypes) == len(set(dtypes))
         self._known_consolidated = True
 
     @property
     def is_mixed_type(self) -> bool:
+        """ """
         # Warning, consolidation needs to get checked upstairs
         self._consolidate_inplace()
         return len(self.blocks) > 1
 
     @property
     def is_numeric_mixed_type(self) -> bool:
+        """ """
         return all(block.is_numeric for block in self.blocks)
 
     @property
@@ -702,7 +1009,7 @@
 
     @property
     def is_view(self) -> bool:
-        """ return a boolean if we are a single block and are a view """
+        """ """
         if len(self.blocks) == 1:
             return self.blocks[0].is_view
 
@@ -717,25 +1024,51 @@
 
     def get_bool_data(self, copy: bool = False) -> "BlockManager":
         """
-        Parameters
-        ----------
-        copy : bool, default False
-            Whether to copy the blocks
+
+        Parameters
+        ----------
+        copy: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         self._consolidate_inplace()
         return self._combine([b for b in self.blocks if b.is_bool], copy)
 
     def get_numeric_data(self, copy: bool = False) -> "BlockManager":
         """
-        Parameters
-        ----------
-        copy : bool, default False
-            Whether to copy the blocks
+
+        Parameters
+        ----------
+        copy: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         return self._combine([b for b in self.blocks if b.is_numeric], copy)
 
     def _combine(self, blocks: List[Block], copy: bool = True) -> "BlockManager":
-        """ return a new manager with the blocks """
+        """
+
+        Parameters
+        ----------
+        blocks: List[Block] :
+            
+        copy: bool :
+             (Default value = True)
+
+        Returns
+        -------
+        type
+            
+
+        """
         if len(blocks) == 0:
             return self.make_empty()
 
@@ -755,6 +1088,19 @@
         return type(self).from_blocks(new_blocks, axes)
 
     def get_slice(self, slobj: slice, axis: int = 0) -> "BlockManager":
+        """
+
+        Parameters
+        ----------
+        slobj: slice :
+            
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
 
         if axis == 0:
             new_blocks = self._slice_take_blocks_ax0(slobj)
@@ -772,27 +1118,41 @@
 
     @property
     def nblocks(self) -> int:
+        """ """
         return len(self.blocks)
 
     def copy(self: T, deep=True) -> T:
-        """
-        Make deep or shallow copy of BlockManager
+        """Make deep or shallow copy of BlockManager
 
         Parameters
         ----------
         deep : bool or string, default True
             If False, return shallow copy (do not copy data)
-            If 'all', copy data and a deep copy of the index
-
-        Returns
-        -------
-        BlockManager
+            If 'all', copy data and a deep copy of the index (Default value = True)
+        self: T :
+            
+
+        Returns
+        -------
+
+        
         """
         # this preserves the notion of view copying of axes
         if deep:
             # hit in e.g. tests.io.json.test_pandas
 
             def copy_func(ax):
+                """
+
+                Parameters
+                ----------
+                ax :
+                    
+
+                Returns
+                -------
+
+                """
                 return ax.copy(deep=True) if deep == "all" else ax.view()
 
             new_axes = [copy_func(ax) for ax in self.axes]
@@ -810,25 +1170,29 @@
         copy: bool = False,
         na_value=lib.no_default,
     ) -> np.ndarray:
-        """
-        Convert the blockmanager data into an numpy array.
+        """Convert the blockmanager data into an numpy array.
 
         Parameters
         ----------
         transpose : bool, default False
             If True, transpose the return array.
         dtype : object, default None
-            Data type of the return array.
+            Data type of the return array. (Default value = None)
         copy : bool, default False
             If True then guarantee that a copy is returned. A value of
             False does not guarantee that the underlying data is not
             copied.
         na_value : object, default lib.no_default
-            Value to be used as the missing value sentinel.
-
-        Returns
-        -------
-        arr : ndarray
+            Value to be used as the missing value sentinel. (Default value = lib.no_default)
+        transpose: bool :
+             (Default value = False)
+        copy: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         if len(self.blocks) == 0:
             arr = np.empty(self.shape, dtype=float)
@@ -864,8 +1228,19 @@
 
     def _interleave(self, dtype=None, na_value=lib.no_default) -> np.ndarray:
         """
-        Return ndarray from blocks with specified item order
-        Items must be contained in the blocks
+
+        Parameters
+        ----------
+        dtype :
+             (Default value = None)
+        na_value :
+             (Default value = lib.no_default)
+
+        Returns
+        -------
+        type
+            Items must be contained in the blocks
+
         """
         if not dtype:
             dtype = _interleaved_dtype(self.blocks)
@@ -899,16 +1274,19 @@
         return result
 
     def to_dict(self, copy: bool = True):
-        """
-        Return a dict of str(dtype) -> BlockManager
+        """Return a dict of str(dtype) -> BlockManager
 
         Parameters
         ----------
         copy : bool, default True
+            
+        copy: bool :
+             (Default value = True)
 
         Returns
         -------
         values : a dict of dtype -> BlockManager
+            
 
         Notes
         -----
@@ -924,16 +1302,19 @@
         return {dtype: self._combine(blocks, copy=copy) for dtype, blocks in bd.items()}
 
     def fast_xs(self, loc: int) -> ArrayLike:
-        """
-        Return the array corresponding to `frame.iloc[loc]`.
+        """Return the array corresponding to `frame.iloc[loc]`.
 
         Parameters
         ----------
         loc : int
-
-        Returns
-        -------
-        np.ndarray or ExtensionArray
+            
+        loc: int :
+            
+
+        Returns
+        -------
+
+        
         """
         if len(self.blocks) == 1:
             return self.blocks[0].iget((slice(None), loc))
@@ -959,13 +1340,7 @@
         return result
 
     def consolidate(self) -> "BlockManager":
-        """
-        Join together blocks having same dtype
-
-        Returns
-        -------
-        y : BlockManager
-        """
+        """Join together blocks having same dtype"""
         if self.is_consolidated():
             return self
 
@@ -975,6 +1350,7 @@
         return bm
 
     def _consolidate_inplace(self) -> None:
+        """ """
         if not self.is_consolidated():
             self.blocks = tuple(_consolidate(self.blocks))
             self._is_consolidated = True
@@ -983,7 +1359,17 @@
 
     def iget(self, i: int) -> "SingleBlockManager":
         """
-        Return the data as a SingleBlockManager.
+
+        Parameters
+        ----------
+        i: int :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         block = self.blocks[self.blknos[i]]
         values = block.iget(self.blklocs[i])
@@ -998,15 +1384,33 @@
 
     def iget_values(self, i: int) -> ArrayLike:
         """
-        Return the data for column i as the values (ndarray or ExtensionArray).
+
+        Parameters
+        ----------
+        i: int :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         block = self.blocks[self.blknos[i]]
         values = block.iget(self.blklocs[i])
         return values
 
     def idelete(self, indexer):
-        """
-        Delete selected locations in-place (new block and array, same BlockManager)
+        """Delete selected locations in-place (new block and array, same BlockManager)
+
+        Parameters
+        ----------
+        indexer :
+            
+
+        Returns
+        -------
+
         """
         is_deleted = np.zeros(self.shape[0], dtype=np.bool_)
         is_deleted[indexer] = True
@@ -1041,9 +1445,23 @@
         self._rebuild_blknos_and_blklocs()
 
     def iset(self, loc: Union[int, slice, np.ndarray], value):
-        """
-        Set new item in-place. Does not consolidate. Adds new Block if not
+        """Set new item in-place. Does not consolidate. Adds new Block if not
         contained in the current set of items
+
+        Parameters
+        ----------
+        loc: Union[int :
+            
+        slice :
+            
+        np.ndarray] :
+            
+        value :
+            
+
+        Returns
+        -------
+
         """
         value = extract_array(value, extract_numpy=True)
         # FIXME: refactor, clearly separate broadcasting & zip-like assignment
@@ -1057,6 +1475,17 @@
         if value_is_extension_type:
 
             def value_getitem(placement):
+                """
+
+                Parameters
+                ----------
+                placement :
+                    
+
+                Returns
+                -------
+
+                """
                 return value
 
         else:
@@ -1064,11 +1493,33 @@
                 value = _safe_reshape(value, (1,) + value.shape)
 
                 def value_getitem(placement):
+                    """
+
+                    Parameters
+                    ----------
+                    placement :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     return value
 
             else:
 
                 def value_getitem(placement):
+                    """
+
+                    Parameters
+                    ----------
+                    placement :
+                        
+
+                    Returns
+                    -------
+
+                    """
                     return value[placement.indexer]
 
             if value.shape[1:] != self.shape[1:]:
@@ -1160,17 +1611,23 @@
             self._known_consolidated = False
 
     def insert(self, loc: int, item: Label, value, allow_duplicates: bool = False):
-        """
-        Insert item at selected position.
-
-        Parameters
-        ----------
-        loc : int
-        item : hashable
-        value : array_like
-        allow_duplicates: bool
-            If False, trying to insert non-unique item will raise
-
+        """Insert item at selected position.
+
+        Parameters
+        ----------
+        loc: int :
+            
+        item: Label :
+            
+        value :
+            
+        allow_duplicates: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         if not allow_duplicates and item in self.items:
             # Should this be a different kind of error??
@@ -1223,8 +1680,26 @@
         fill_value=None,
         copy: bool = True,
     ):
-        """
-        Conform block manager to new index.
+        """Conform block manager to new index.
+
+        Parameters
+        ----------
+        new_index :
+            
+        axis: int :
+            
+        method :
+             (Default value = None)
+        limit :
+             (Default value = None)
+        fill_value :
+             (Default value = None)
+        copy: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         new_index = ensure_index(new_index)
         new_index, indexer = self.axes[axis].reindex(
@@ -1246,18 +1721,30 @@
         consolidate: bool = True,
     ) -> T:
         """
-        Parameters
-        ----------
-        new_axis : Index
-        indexer : ndarray of int64 or None
-        axis : int
-        fill_value : object, default None
-        allow_dups : bool, default False
-        copy : bool, default True
-        consolidate: bool, default True
-            Whether to consolidate inplace before reindexing.
-
-        pandas-indexer with -1's only.
+
+        Parameters
+        ----------
+        self: T :
+            
+        new_axis :
+            
+        indexer :
+            
+        axis: int :
+            
+        fill_value :
+             (Default value = None)
+        allow_dups: bool :
+             (Default value = False)
+        copy: bool :
+             (Default value = True)
+        consolidate: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        
         """
         if indexer is None:
             if new_axis is self.axes[axis] and not copy:
@@ -1300,22 +1787,26 @@
     def _slice_take_blocks_ax0(
         self, slice_or_indexer, fill_value=lib.no_default, only_slice: bool = False
     ):
-        """
-        Slice/take blocks along axis=0.
-
+        """Slice/take blocks along axis=0.
+        
         Overloaded for SingleBlock
 
         Parameters
         ----------
         slice_or_indexer : slice, ndarray[bool], or list-like of ints
+            
         fill_value : scalar, default lib.no_default
+             (Default value = lib.no_default)
         only_slice : bool, default False
             If True, we always return views on existing arrays, never copies.
             This is used when called from ops.blockwise.operate_blockwise.
-
-        Returns
-        -------
-        new_blocks : list of Block
+        only_slice: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
+        
         """
         allow_fill = fill_value is not lib.no_default
 
@@ -1413,6 +1904,19 @@
         return blocks
 
     def _make_na_block(self, placement, fill_value=None):
+        """
+
+        Parameters
+        ----------
+        placement :
+            
+        fill_value :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
 
         if fill_value is None:
             fill_value = np.nan
@@ -1425,8 +1929,22 @@
         return make_block(block_values, placement=placement)
 
     def take(self, indexer, axis: int = 1, verify: bool = True, convert: bool = True):
-        """
-        Take items along any axis.
+        """Take items along any axis.
+
+        Parameters
+        ----------
+        indexer :
+            
+        axis: int :
+             (Default value = 1)
+        verify: bool :
+             (Default value = True)
+        convert: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         self._consolidate_inplace()
         indexer = (
@@ -1449,6 +1967,17 @@
         )
 
     def equals(self, other: "BlockManager") -> bool:
+        """
+
+        Parameters
+        ----------
+        other: "BlockManager" :
+            
+
+        Returns
+        -------
+
+        """
         self_axes, other_axes = self.axes, other.axes
         if len(self_axes) != len(other_axes):
             return False
@@ -1483,18 +2012,19 @@
         return True
 
     def unstack(self, unstacker, fill_value) -> "BlockManager":
-        """
-        Return a BlockManager with all blocks unstacked..
+        """Return a BlockManager with all blocks unstacked..
 
         Parameters
         ----------
         unstacker : reshape._Unstacker
+            
         fill_value : Any
             fill_value for newly introduced missing values.
 
         Returns
         -------
-        unstacked : BlockManager
+
+        
         """
         new_columns = unstacker.get_new_columns(self.items)
         new_index = unstacker.new_index
@@ -1521,7 +2051,7 @@
 
 
 class SingleBlockManager(BlockManager):
-    """ manage a single block with """
+    """manage a single block with"""
 
     ndim = 1
     _is_consolidated = True
@@ -1554,8 +2084,18 @@
     def from_blocks(
         cls, blocks: List[Block], axes: List[Index]
     ) -> "SingleBlockManager":
-        """
-        Constructor for BlockManager and SingleBlockManager with same signature.
+        """Constructor for BlockManager and SingleBlockManager with same signature.
+
+        Parameters
+        ----------
+        blocks: List[Block] :
+            
+        axes: List[Index] :
+            
+
+        Returns
+        -------
+
         """
         assert len(blocks) == 1
         assert len(axes) == 1
@@ -1563,30 +2103,55 @@
 
     @classmethod
     def from_array(cls, array: ArrayLike, index: Index) -> "SingleBlockManager":
-        """
-        Constructor for if we have an array that is not yet a Block.
+        """Constructor for if we have an array that is not yet a Block.
+
+        Parameters
+        ----------
+        array: ArrayLike :
+            
+        index: Index :
+            
+
+        Returns
+        -------
+
         """
         block = make_block(array, placement=slice(0, len(index)), ndim=1)
         return cls(block, index)
 
     def _post_setstate(self):
+        """ """
         pass
 
     @property
     def _block(self) -> Block:
+        """ """
         return self.blocks[0]
 
     @property
     def _blknos(self):
-        """ compat with BlockManager """
+        """compat with BlockManager"""
         return None
 
     @property
     def _blklocs(self):
-        """ compat with BlockManager """
+        """compat with BlockManager"""
         return None
 
     def get_slice(self, slobj: slice, axis: int = 0) -> "SingleBlockManager":
+        """
+
+        Parameters
+        ----------
+        slobj: slice :
+            
+        axis: int :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         if axis >= self.ndim:
             raise IndexError("Requested axis not found in manager")
 
@@ -1597,13 +2162,16 @@
 
     @property
     def index(self) -> Index:
+        """ """
         return self.axes[0]
 
     @property
     def dtype(self) -> DtypeObj:
+        """ """
         return self._block.dtype
 
     def get_dtypes(self) -> np.ndarray:
+        """ """
         return np.array([self._block.dtype])
 
     def external_values(self):
@@ -1616,30 +2184,51 @@
 
     @property
     def _can_hold_na(self) -> bool:
+        """ """
         return self._block._can_hold_na
 
     def is_consolidated(self) -> bool:
+        """ """
         return True
 
     def _consolidate_check(self):
+        """ """
         pass
 
     def _consolidate_inplace(self):
+        """ """
         pass
 
     def idelete(self, indexer):
-        """
-        Delete single location from SingleBlockManager.
-
+        """Delete single location from SingleBlockManager.
+        
         Ensures that self.blocks doesn't become empty.
+
+        Parameters
+        ----------
+        indexer :
+            
+
+        Returns
+        -------
+
         """
         self._block.delete(indexer)
         self.axes[0] = self.axes[0].delete(indexer)
 
     def fast_xs(self, loc):
-        """
-        fast path for getting a cross-section
-        return a view of the data
+        """fast path for getting a cross-section
+
+        Parameters
+        ----------
+        loc :
+            
+
+        Returns
+        -------
+        type
+            
+
         """
         raise NotImplementedError("Use series._values[loc] instead")
 
@@ -1649,6 +2238,19 @@
 
 
 def create_block_manager_from_blocks(blocks, axes: List[Index]) -> BlockManager:
+    """
+
+    Parameters
+    ----------
+    blocks :
+        
+    axes: List[Index] :
+        
+
+    Returns
+    -------
+
+    """
     try:
         if len(blocks) == 1 and not isinstance(blocks[0], Block):
             # if blocks[0] is of length 0, return empty blocks
@@ -1675,6 +2277,21 @@
 def create_block_manager_from_arrays(
     arrays, names: Index, axes: List[Index]
 ) -> BlockManager:
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    names: Index :
+        
+    axes: List[Index] :
+        
+
+    Returns
+    -------
+
+    """
     assert isinstance(names, Index)
     assert isinstance(axes, list)
     assert all(isinstance(x, Index) for x in axes)
@@ -1689,7 +2306,23 @@
 
 
 def construction_error(tot_items, block_shape, axes, e=None):
-    """ raise a helpful message about our construction """
+    """
+
+    Parameters
+    ----------
+    tot_items :
+        
+    block_shape :
+        
+    axes :
+        
+    e :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     passed = tuple(map(int, [tot_items] + list(block_shape)))
     # Correcting the user facing error message during dataframe construction
     if len(passed) <= 2:
@@ -1713,6 +2346,21 @@
 
 
 def form_blocks(arrays, names: Index, axes) -> List[Block]:
+    """
+
+    Parameters
+    ----------
+    arrays :
+        
+    names: Index :
+        
+    axes :
+        
+
+    Returns
+    -------
+
+    """
     # put "leftover" items in float bucket, where else?
     # generalize?
     items_dict: DefaultDict[str, List] = defaultdict(list)
@@ -1811,8 +2459,19 @@
 
 def _simple_blockify(tuples, dtype) -> List[Block]:
     """
-    return a single array of a block that has a single dtype; if dtype is
-    not None, coerce to this dtype
+
+    Parameters
+    ----------
+    tuples :
+        
+    dtype :
+        
+
+    Returns
+    -------
+    type
+        not None, coerce to this dtype
+
     """
     values, placement = _stack_arrays(tuples, dtype)
 
@@ -1825,7 +2484,21 @@
 
 
 def _multi_blockify(tuples, dtype=None):
-    """ return an array of blocks that potentially have different dtypes """
+    """
+
+    Parameters
+    ----------
+    tuples :
+        
+    dtype :
+         (Default value = None)
+
+    Returns
+    -------
+    type
+        
+
+    """
     # group by dtype
     grouper = itertools.groupby(tuples, lambda x: x[2].dtype)
 
@@ -1841,15 +2514,50 @@
 
 
 def _stack_arrays(tuples, dtype):
+    """
+
+    Parameters
+    ----------
+    tuples :
+        
+    dtype :
+        
+
+    Returns
+    -------
+
+    """
 
     # fml
     def _asarray_compat(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(x, ABCSeries):
             return x._values
         else:
             return np.asarray(x)
 
     def _shape_compat(x):
+        """
+
+        Parameters
+        ----------
+        x :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(x, ABCSeries):
             return (len(x),)
         else:
@@ -1868,17 +2576,19 @@
 
 
 def _interleaved_dtype(blocks: Sequence[Block]) -> Optional[DtypeObj]:
-    """
-    Find the common dtype for `blocks`.
+    """Find the common dtype for `blocks`.
 
     Parameters
     ----------
     blocks : List[Block]
+        
+    blocks: Sequence[Block] :
+        
 
     Returns
     -------
-    dtype : np.dtype, ExtensionDtype, or None
-        None is returned when `blocks` is empty.
+
+    
     """
     if not len(blocks):
         return None
@@ -1887,8 +2597,16 @@
 
 
 def _consolidate(blocks):
-    """
-    Merge blocks having same dtype, exclude non-consolidating blocks
+    """Merge blocks having same dtype, exclude non-consolidating blocks
+
+    Parameters
+    ----------
+    blocks :
+        
+
+    Returns
+    -------
+
     """
     # sort by _can_consolidate, dtype
     gkey = lambda x: x._consolidate_key
@@ -1906,6 +2624,21 @@
 def _merge_blocks(
     blocks: List[Block], dtype: DtypeObj, can_consolidate: bool
 ) -> List[Block]:
+    """
+
+    Parameters
+    ----------
+    blocks: List[Block] :
+        
+    dtype: DtypeObj :
+        
+    can_consolidate: bool :
+        
+
+    Returns
+    -------
+
+    """
 
     if len(blocks) == 1:
         return blocks
@@ -1937,30 +2670,60 @@
     regex: bool = False,
     mask: Optional[ArrayLike] = None,
 ) -> Union[ArrayLike, bool]:
-    """
-    Compare two array_like inputs of the same shape or two scalar values
-
+    """Compare two array_like inputs of the same shape or two scalar values
+    
     Calls operator.eq or re.search, depending on regex argument. If regex is
     True, perform an element-wise regex matching.
 
     Parameters
     ----------
     a : array_like
+        
     b : scalar or regex pattern
+        
     regex : bool, default False
+        
     mask : array_like or None (default)
+        
+    a: ArrayLike :
+        
+    b: Union[Scalar :
+        
+    Pattern] :
+        
+    regex: bool :
+         (Default value = False)
+    mask: Optional[ArrayLike] :
+         (Default value = None)
 
     Returns
     -------
-    mask : array_like of bool
+
+    
     """
 
     def _check_comparison_types(
         result: Union[ArrayLike, bool], a: ArrayLike, b: Union[Scalar, Pattern],
     ):
-        """
-        Raises an error if the two arrays (a,b) cannot be compared.
+        """Raises an error if the two arrays (a,b) cannot be compared.
         Otherwise, returns the comparison result as expected.
+
+        Parameters
+        ----------
+        result: Union[ArrayLike :
+            
+        bool] :
+            
+        a: ArrayLike :
+            
+        b: Union[Scalar :
+            
+        Pattern] :
+            
+
+        Returns
+        -------
+
         """
         if is_scalar(result) and isinstance(a, np.ndarray):
             type_names = [type(a).__name__, type(b).__name__]
@@ -2006,13 +2769,38 @@
 
 
 def _fast_count_smallints(arr: np.ndarray) -> np.ndarray:
-    """Faster version of set(arr) for sequences of small numbers."""
+    """Faster version of set(arr) for sequences of small numbers.
+
+    Parameters
+    ----------
+    arr: np.ndarray :
+        
+
+    Returns
+    -------
+
+    """
     counts = np.bincount(arr.astype(np.int_))
     nz = counts.nonzero()[0]
     return np.c_[nz, counts[nz]]
 
 
 def _preprocess_slice_or_indexer(slice_or_indexer, length: int, allow_fill: bool):
+    """
+
+    Parameters
+    ----------
+    slice_or_indexer :
+        
+    length: int :
+        
+    allow_fill: bool :
+        
+
+    Returns
+    -------
+
+    """
     if isinstance(slice_or_indexer, slice):
         return (
             "slice",
