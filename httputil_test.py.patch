# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/test/httputil_test.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/test/httputil_test.py
@@ -26,66 +26,88 @@
 
 
 def form_data_args() -> Tuple[Dict[str, List[bytes]], Dict[str, List[HTTPFile]]]:
-    """Return two empty dicts suitable for use with parse_multipart_form_data.
-
-    mypy insists on type annotations for dict literals, so this lets us avoid
-    the verbose types throughout this test.
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        mypy insists on type annotations for dict literals, so this lets us avoid
+        the verbose types throughout this test.
+
     """
     return {}, {}
 
 
 class TestUrlConcat(unittest.TestCase):
+    """ """
     def test_url_concat_no_query_params(self):
+        """ """
         url = url_concat("https://localhost/path", [("y", "y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?y=y&z=z")
 
     def test_url_concat_encode_args(self):
+        """ """
         url = url_concat("https://localhost/path", [("y", "/y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?y=%2Fy&z=z")
 
     def test_url_concat_trailing_q(self):
+        """ """
         url = url_concat("https://localhost/path?", [("y", "y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?y=y&z=z")
 
     def test_url_concat_q_with_no_trailing_amp(self):
+        """ """
         url = url_concat("https://localhost/path?x", [("y", "y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?x=&y=y&z=z")
 
     def test_url_concat_trailing_amp(self):
+        """ """
         url = url_concat("https://localhost/path?x&", [("y", "y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?x=&y=y&z=z")
 
     def test_url_concat_mult_params(self):
+        """ """
         url = url_concat("https://localhost/path?a=1&b=2", [("y", "y"), ("z", "z")])
         self.assertEqual(url, "https://localhost/path?a=1&b=2&y=y&z=z")
 
     def test_url_concat_no_params(self):
+        """ """
         url = url_concat("https://localhost/path?r=1&t=2", [])
         self.assertEqual(url, "https://localhost/path?r=1&t=2")
 
     def test_url_concat_none_params(self):
+        """ """
         url = url_concat("https://localhost/path?r=1&t=2", None)
         self.assertEqual(url, "https://localhost/path?r=1&t=2")
 
     def test_url_concat_with_frag(self):
+        """ """
         url = url_concat("https://localhost/path#tab", [("y", "y")])
         self.assertEqual(url, "https://localhost/path?y=y#tab")
 
     def test_url_concat_multi_same_params(self):
+        """ """
         url = url_concat("https://localhost/path", [("y", "y1"), ("y", "y2")])
         self.assertEqual(url, "https://localhost/path?y=y1&y=y2")
 
     def test_url_concat_multi_same_query_params(self):
+        """ """
         url = url_concat("https://localhost/path?r=1&r=2", [("y", "y")])
         self.assertEqual(url, "https://localhost/path?r=1&r=2&y=y")
 
     def test_url_concat_dict_params(self):
+        """ """
         url = url_concat("https://localhost/path", dict(y="y"))
         self.assertEqual(url, "https://localhost/path?y=y")
 
 
 class QsParseTest(unittest.TestCase):
+    """ """
     def test_parsing(self):
+        """ """
         qsstring = "a=1&b=2&a=3"
         qs = urllib.parse.parse_qs(qsstring)
         qsl = list(qs_to_qsl(qs))
@@ -95,13 +117,20 @@
 
 
 class MultipartFormDataTest(unittest.TestCase):
+    """ """
     def test_file_upload(self):
-        data = b"""\
---1234
-Content-Disposition: form-data; name="files"; filename="ab.txt"
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: form-data; name="files"; filename="ab.txt"
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -111,6 +140,7 @@
         self.assertEqual(file["body"], b"Foo")
 
     def test_unquoted_names(self):
+        """ """
         # quotes are optional unless special characters are present
         data = b"""\
 --1234
@@ -127,6 +157,7 @@
         self.assertEqual(file["body"], b"Foo")
 
     def test_special_filenames(self):
+        """ """
         filenames = [
             "a;b.txt",
             'a"b.txt',
@@ -156,12 +187,18 @@
             self.assertEqual(file["body"], b"Foo")
 
     def test_non_ascii_filename(self):
-        data = b"""\
---1234
-Content-Disposition: form-data; name="files"; filename="ab.txt"; filename*=UTF-8''%C3%A1b.txt
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: form-data; name="files"; filename="ab.txt"; filename*=UTF-8''%C3%A1b.txt
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -171,12 +208,18 @@
         self.assertEqual(file["body"], b"Foo")
 
     def test_boundary_starts_and_ends_with_quotes(self):
-        data = b"""\
---1234
-Content-Disposition: form-data; name="files"; filename="ab.txt"
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: form-data; name="files"; filename="ab.txt"
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -186,11 +229,17 @@
         self.assertEqual(file["body"], b"Foo")
 
     def test_missing_headers(self):
-        data = b"""\
---1234
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -199,12 +248,18 @@
         self.assertEqual(files, {})
 
     def test_invalid_content_disposition(self):
-        data = b"""\
---1234
-Content-Disposition: invalid; name="files"; filename="ab.txt"
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: invalid; name="files"; filename="ab.txt"
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -213,11 +268,17 @@
         self.assertEqual(files, {})
 
     def test_line_does_not_end_with_correct_line_break(self):
-        data = b"""\
---1234
-Content-Disposition: form-data; name="files"; filename="ab.txt"
-
-Foo--1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: form-data; name="files"; filename="ab.txt"
+        
+        Foo--1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -226,12 +287,18 @@
         self.assertEqual(files, {})
 
     def test_content_disposition_header_without_name_parameter(self):
-        data = b"""\
---1234
-Content-Disposition: form-data; filename="ab.txt"
-
-Foo
---1234--""".replace(
+        """data = b"""\
+        --1234
+        Content-Disposition: form-data; filename="ab.txt"
+        
+        Foo
+        --1234--""".replace(
+
+        Parameters
+        ----------
+
+        Returns
+        -------
             b"\n", b"\r\n"
         )
         args, files = form_data_args()
@@ -240,6 +307,7 @@
         self.assertEqual(files, {})
 
     def test_data_after_final_boundary(self):
+        """ """
         # The spec requires that data after the final boundary be ignored.
         # http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html
         # In practice, some libraries include an extra CRLF after the boundary.
@@ -260,7 +328,9 @@
 
 
 class HTTPHeadersTest(unittest.TestCase):
+    """ """
     def test_multi_line(self):
+        """ """
         # Lines beginning with whitespace are appended to the previous line
         # with any leading whitespace replaced by a single space.
         # Note that while multi-line headers are a part of the HTTP spec,
@@ -287,6 +357,7 @@
         )
 
     def test_malformed_continuation(self):
+        """ """
         # If the first line starts with whitespace, it's a
         # continuation line with nothing to continue, so reject it
         # (with a proper error).
@@ -294,6 +365,7 @@
         self.assertRaises(HTTPInputError, HTTPHeaders.parse, data)
 
     def test_unicode_newlines(self):
+        """ """
         # Ensure that only \r\n is recognized as a header separator, and not
         # the other newline-like unicode characters.
         # Characters that are likely to be problematic can be found in
@@ -334,6 +406,7 @@
                     raise
 
     def test_optional_cr(self):
+        """ """
         # Both CRLF and LF should be accepted as separators. CR should not be
         # part of the data when followed by LF, but it is a normal char
         # otherwise (or should bare CR be an error?)
@@ -344,6 +417,7 @@
         )
 
     def test_copy(self):
+        """ """
         all_pairs = [("A", "1"), ("A", "2"), ("B", "c")]
         h1 = HTTPHeaders()
         for k, v in all_pairs:
@@ -361,6 +435,7 @@
             self.assertIsNot(headers.get_list("A"), h1.get_list("A"))
 
     def test_pickle_roundtrip(self):
+        """ """
         headers = HTTPHeaders()
         headers.add("Set-Cookie", "a=b")
         headers.add("Set-Cookie", "c=d")
@@ -371,6 +446,7 @@
         self.assertEqual(sorted(headers.items()), sorted(unpickled.items()))
 
     def test_setdefault(self):
+        """ """
         headers = HTTPHeaders()
         headers["foo"] = "bar"
         # If a value is present, setdefault returns it without changes.
@@ -382,6 +458,7 @@
         self.assertEqual(sorted(headers.get_all()), [("Foo", "bar"), ("Quux", "xyzzy")])
 
     def test_string(self):
+        """ """
         headers = HTTPHeaders()
         headers.add("Foo", "1")
         headers.add("Foo", "2")
@@ -391,45 +468,66 @@
 
 
 class FormatTimestampTest(unittest.TestCase):
+    """ """
     # Make sure that all the input types are supported.
     TIMESTAMP = 1359312200.503611
     EXPECTED = "Sun, 27 Jan 2013 18:43:20 GMT"
 
     def check(self, value):
+        """
+
+        Parameters
+        ----------
+        value :
+            
+
+        Returns
+        -------
+
+        """
         self.assertEqual(format_timestamp(value), self.EXPECTED)
 
     def test_unix_time_float(self):
+        """ """
         self.check(self.TIMESTAMP)
 
     def test_unix_time_int(self):
+        """ """
         self.check(int(self.TIMESTAMP))
 
     def test_struct_time(self):
+        """ """
         self.check(time.gmtime(self.TIMESTAMP))
 
     def test_time_tuple(self):
+        """ """
         tup = tuple(time.gmtime(self.TIMESTAMP))
         self.assertEqual(9, len(tup))
         self.check(tup)
 
     def test_datetime(self):
+        """ """
         self.check(datetime.datetime.utcfromtimestamp(self.TIMESTAMP))
 
 
 # HTTPServerRequest is mainly tested incidentally to the server itself,
 # but this tests the parts of the class that can be tested in isolation.
 class HTTPServerRequestTest(unittest.TestCase):
+    """ """
     def test_default_constructor(self):
+        """ """
         # All parameters are formally optional, but uri is required
         # (and has been for some time).  This test ensures that no
         # more required parameters slip in.
         HTTPServerRequest(uri="/")
 
     def test_body_is_a_byte_string(self):
+        """ """
         requets = HTTPServerRequest(uri="/")
         self.assertIsInstance(requets.body, bytes)
 
     def test_repr_does_not_contain_headers(self):
+        """ """
         request = HTTPServerRequest(
             uri="/", headers=HTTPHeaders({"Canary": ["Coal Mine"]})
         )
@@ -437,11 +535,13 @@
 
 
 class ParseRequestStartLineTest(unittest.TestCase):
+    """ """
     METHOD = "GET"
     PATH = "/foo"
     VERSION = "HTTP/1.1"
 
     def test_parse_request_start_line(self):
+        """ """
         start_line = " ".join([self.METHOD, self.PATH, self.VERSION])
         parsed_start_line = parse_request_start_line(start_line)
         self.assertEqual(parsed_start_line.method, self.METHOD)
@@ -450,12 +550,11 @@
 
 
 class ParseCookieTest(unittest.TestCase):
+    """ """
     # These tests copied from Django:
     # https://github.com/django/django/pull/6277/commits/da810901ada1cae9fc1f018f879f11a7fb467b28
     def test_python_cookies(self):
-        """
-        Test cases copied from Python's Lib/test/test_http_cookies.py
-        """
+        """Test cases copied from Python's Lib/test/test_http_cookies.py"""
         self.assertEqual(
             parse_cookie("chips=ahoy; vienna=finger"),
             {"chips": "ahoy", "vienna": "finger"},
@@ -478,6 +577,7 @@
         )
 
     def test_cookie_edgecases(self):
+        """ """
         # Cookies that RFC6265 allows.
         self.assertEqual(
             parse_cookie("a=b; Domain=example.com"), {"a": "b", "Domain": "example.com"}
@@ -487,9 +587,15 @@
         self.assertEqual(parse_cookie("a=b; h=i; a=c"), {"a": "c", "h": "i"})
 
     def test_invalid_cookies(self):
-        """
-        Cookie strings that go against RFC6265 but browsers will send if set
+        """Cookie strings that go against RFC6265 but browsers will send if set
         via document.cookie.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # Chunks without an equals sign appear as unnamed values per
         # https://bugzilla.mozilla.org/show_bug.cgi?id=169091
