# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/series/test_ufunc.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/series/test_ufunc.py
@@ -17,9 +17,7 @@
 
 @pytest.fixture
 def arrays_for_binary_ufunc():
-    """
-    A pair of random, length-100 integer-dtype arrays, that are mostly 0.
-    """
+    """A pair of random, length-100 integer-dtype arrays, that are mostly 0."""
     a1 = np.random.randint(0, 10, 100, dtype="int64")
     a2 = np.random.randint(0, 10, 100, dtype="int64")
     a1[::3] = 0
@@ -30,6 +28,19 @@
 @pytest.mark.parametrize("ufunc", UNARY_UFUNCS)
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 def test_unary_ufunc(ufunc, sparse):
+    """
+
+    Parameters
+    ----------
+    ufunc :
+        
+    sparse :
+        
+
+    Returns
+    -------
+
+    """
     # Test that ufunc(Series) == Series(ufunc)
     array = np.random.randint(0, 10, 10, dtype="int64")
     array[::2] = 0
@@ -49,6 +60,23 @@
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 @pytest.mark.parametrize("flip", [True, False], ids=["flipped", "straight"])
 def test_binary_ufunc_with_array(flip, sparse, ufunc, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    flip :
+        
+    sparse :
+        
+    ufunc :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that ufunc(Series(a), array) == Series(ufunc(a, b))
     a1, a2 = arrays_for_binary_ufunc
     if sparse:
@@ -75,6 +103,23 @@
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 @pytest.mark.parametrize("flip", [True, False], ids=["flipped", "straight"])
 def test_binary_ufunc_with_index(flip, sparse, ufunc, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    flip :
+        
+    sparse :
+        
+    ufunc :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that
     #   * func(Series(a), Series(b)) == Series(ufunc(a, b))
     #   * ufunc(Index, Series) dispatches to Series (returns a Series)
@@ -106,6 +151,25 @@
 def test_binary_ufunc_with_series(
     flip, shuffle, sparse, ufunc, arrays_for_binary_ufunc
 ):
+    """
+
+    Parameters
+    ----------
+    flip :
+        
+    shuffle :
+        
+    sparse :
+        
+    ufunc :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that
     #   * func(Series(a), Series(b)) == Series(ufunc(a, b))
     #   with alignment between the indices
@@ -145,6 +209,23 @@
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 @pytest.mark.parametrize("flip", [True, False])
 def test_binary_ufunc_scalar(ufunc, sparse, flip, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    ufunc :
+        
+    sparse :
+        
+    flip :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that
     #   * ufunc(Series, scalar) == Series(ufunc(array, scalar))
     #   * ufunc(Series, scalar) == ufunc(scalar, Series)
@@ -172,6 +253,23 @@
 @pytest.mark.parametrize("shuffle", SHUFFLE)
 @pytest.mark.filterwarnings("ignore:divide by zero:RuntimeWarning")
 def test_multiple_output_binary_ufuncs(ufunc, sparse, shuffle, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    ufunc :
+        
+    sparse :
+        
+    shuffle :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that
     #  the same conditions from binary_ufunc_scalar apply to
     #  ufuncs with multiple outputs.
@@ -205,6 +303,19 @@
 
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 def test_multiple_output_ufunc(sparse, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    sparse :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Test that the same conditions from unary input apply to multi-output
     # ufuncs
     array, _ = arrays_for_binary_ufunc
@@ -226,6 +337,21 @@
 @pytest.mark.parametrize("sparse", SPARSE, ids=SPARSE_IDS)
 @pytest.mark.parametrize("ufunc", BINARY_UFUNCS)
 def test_binary_ufunc_drops_series_name(ufunc, sparse, arrays_for_binary_ufunc):
+    """
+
+    Parameters
+    ----------
+    ufunc :
+        
+    sparse :
+        
+    arrays_for_binary_ufunc :
+        
+
+    Returns
+    -------
+
+    """
     # Drop the names when they differ.
     a1, a2 = arrays_for_binary_ufunc
     s1 = pd.Series(a1, name="a")
@@ -236,7 +362,9 @@
 
 
 def test_object_series_ok():
+    """ """
     class Dummy:
+        """ """
         def __init__(self, value):
             self.value = value
 
@@ -260,12 +388,34 @@
     ],
 )
 def test_reduce(values):
+    """
+
+    Parameters
+    ----------
+    values :
+        
+
+    Returns
+    -------
+
+    """
     a = pd.Series(values)
     assert np.maximum.reduce(a) == values[1]
 
 
 @pytest.mark.parametrize("type_", [list, deque, tuple])
 def test_binary_ufunc_other_types(type_):
+    """
+
+    Parameters
+    ----------
+    type_ :
+        
+
+    Returns
+    -------
+
+    """
     a = pd.Series([1, 2, 3], name="name")
     b = type_([3, 4, 5])
 
@@ -275,7 +425,9 @@
 
 
 def test_object_dtype_ok():
+    """ """
     class Thing:
+        """ """
         def __init__(self, value):
             self.value = value
 
@@ -296,6 +448,7 @@
 
 
 def test_outer():
+    """ """
     # https://github.com/pandas-dev/pandas/issues/27186
     s = pd.Series([1, 2, 3])
     o = np.array([1, 2, 3])
