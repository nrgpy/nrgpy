# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/base_value.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/base_value.py
@@ -22,7 +22,9 @@
 
 
 class HelperValueMixin(object):
+    """ """
     def get_root_context(self):
+        """ """
         value = self
         if value.parent_context is None:
             return value.as_context()
@@ -33,26 +35,74 @@
             value = value.parent_context
 
     def execute(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return self.inference_state.execute(self, arguments=arguments)
 
     def execute_with_values(self, *value_list):
+        """
+
+        Parameters
+        ----------
+        *value_list :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference.arguments import ValuesArguments
         arguments = ValuesArguments([ValueSet([value]) for value in value_list])
         return self.inference_state.execute(self, arguments)
 
     def execute_annotation(self):
+        """ """
         return self.execute_with_values()
 
     def gather_annotation_classes(self):
+        """ """
         return ValueSet([self])
 
     def merge_types_of_iterate(self, contextualized_node=None, is_async=False):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+        is_async :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(
             lazy_value.infer()
             for lazy_value in self.iterate(contextualized_node, is_async)
         )
 
     def _get_value_filters(self, name_or_str):
+        """
+
+        Parameters
+        ----------
+        name_or_str :
+            
+
+        Returns
+        -------
+
+        """
         origin_scope = name_or_str if isinstance(name_or_str, Name) else None
         for f in self.get_filters(origin_scope=origin_scope):
             yield f
@@ -64,6 +114,21 @@
                     yield f
 
     def goto(self, name_or_str, name_context=None, analysis_errors=True):
+        """
+
+        Parameters
+        ----------
+        name_or_str :
+            
+        name_context :
+             (Default value = None)
+        analysis_errors :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         from jedi.inference import finder
         filters = self._get_value_filters(name_or_str)
         names = finder.filter_name(filters, name_or_str)
@@ -73,7 +138,21 @@
     def py__getattribute__(self, name_or_str, name_context=None, position=None,
                            analysis_errors=True):
         """
-        :param position: Position of the last statement -> tuple of line, column
+
+        Parameters
+        ----------
+        position :
+            Position of the last statement -> tuple of line, column (Default value = None)
+        name_or_str :
+            
+        name_context :
+             (Default value = None)
+        analysis_errors :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         if name_context is None:
             name_context = self
@@ -92,15 +171,30 @@
         return values
 
     def py__await__(self):
+        """ """
         await_value_set = self.py__getattribute__(u"__await__")
         if not await_value_set:
             debug.warning('Tried to run __await__ on value %s', self)
         return await_value_set.execute_with_values()
 
     def py__name__(self):
+        """ """
         return self.name.string_name
 
     def iterate(self, contextualized_node=None, is_async=False):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+        is_async :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         debug.dbg('iterate %s', self)
         if is_async:
             from jedi.inference.lazy_value import LazyKnownValues
@@ -117,6 +211,17 @@
         return self.py__iter__(contextualized_node)
 
     def is_sub_class_of(self, class_value):
+        """
+
+        Parameters
+        ----------
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         with debug.increase_indent_cm('subclass matching of %s <=> %s' % (self, class_value),
                                       color='BLUE'):
             for cls in self.py__mro__():
@@ -127,6 +232,17 @@
             return False
 
     def is_same_class(self, class2):
+        """
+
+        Parameters
+        ----------
+        class2 :
+            
+
+        Returns
+        -------
+
+        """
         # Class matching should prefer comparisons that are not this function.
         if type(class2).is_same_class != HelperValueMixin.is_same_class:
             return class2.is_same_class(self)
@@ -134,13 +250,24 @@
 
     @memoize_method
     def as_context(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self._as_context(*args, **kwargs)
 
 
 class Value(HelperValueMixin):
-    """
-    To be implemented by subclasses.
-    """
+    """To be implemented by subclasses."""
     tree_node = None
     # Possible values: None, tuple, list, dict and set. Here to deal with these
     # very important containers.
@@ -152,6 +279,19 @@
         self.parent_context = parent_context
 
     def py__getitem__(self, index_value_set, contextualized_node):
+        """
+
+        Parameters
+        ----------
+        index_value_set :
+            
+        contextualized_node :
+            
+
+        Returns
+        -------
+
+        """
         from jedi.inference import analysis
         # TODO this value is probably not right.
         analysis.add(
@@ -163,9 +303,31 @@
         return NO_VALUES
 
     def py__simple_getitem__(self, index):
+        """
+
+        Parameters
+        ----------
+        index :
+            
+
+        Returns
+        -------
+
+        """
         raise SimpleGetItemNotFound
 
     def py__iter__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         if contextualized_node is not None:
             from jedi.inference import analysis
             analysis.add(
@@ -176,46 +338,74 @@
         return iter([])
 
     def py__next__(self, contextualized_node=None):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         return self.py__iter__(contextualized_node)
 
     def get_signatures(self):
+        """ """
         return []
 
     def is_class(self):
+        """ """
         return False
 
     def is_class_mixin(self):
+        """ """
         return False
 
     def is_instance(self):
+        """ """
         return False
 
     def is_function(self):
+        """ """
         return False
 
     def is_module(self):
+        """ """
         return False
 
     def is_namespace(self):
+        """ """
         return False
 
     def is_compiled(self):
+        """ """
         return False
 
     def is_bound_method(self):
+        """ """
         return False
 
     def is_builtins_module(self):
+        """ """
         return False
 
     def py__bool__(self):
-        """
-        Since Wrapper is a super class for classes, functions and modules,
+        """Since Wrapper is a super class for classes, functions and modules,
         the return value will always be true.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return True
 
     def py__doc__(self):
+        """ """
         try:
             self.tree_node.get_doc_node
         except AttributeError:
@@ -224,87 +414,182 @@
             return clean_scope_docstring(self.tree_node)
 
     def get_safe_value(self, default=sentinel):
+        """
+
+        Parameters
+        ----------
+        default :
+             (Default value = sentinel)
+
+        Returns
+        -------
+
+        """
         if default is sentinel:
             raise ValueError("There exists no safe value for value %s" % self)
         return default
 
     def execute_operation(self, other, operator):
+        """
+
+        Parameters
+        ----------
+        other :
+            
+        operator :
+            
+
+        Returns
+        -------
+
+        """
         debug.warning("%s not possible between %s and %s", operator, self, other)
         return NO_VALUES
 
     def py__call__(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         debug.warning("no execution possible %s", self)
         return NO_VALUES
 
     def py__stop_iteration_returns(self):
+        """ """
         debug.warning("Not possible to return the stop iterations of %s", self)
         return NO_VALUES
 
     def py__getattribute__alternatives(self, name_or_str):
-        """
-        For now a way to add values in cases like __getattr__.
+        """For now a way to add values in cases like __getattr__.
+
+        Parameters
+        ----------
+        name_or_str :
+            
+
+        Returns
+        -------
+
         """
         return NO_VALUES
 
     def py__get__(self, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         debug.warning("No __get__ defined on %s", self)
         return ValueSet([self])
 
     def py__get__on_class(self, calling_instance, instance, class_value):
+        """
+
+        Parameters
+        ----------
+        calling_instance :
+            
+        instance :
+            
+        class_value :
+            
+
+        Returns
+        -------
+
+        """
         return NotImplemented
 
     def get_qualified_names(self):
+        """ """
         # Returns Optional[Tuple[str, ...]]
         return None
 
     def is_stub(self):
+        """ """
         # The root value knows if it's a stub or not.
         return self.parent_context.is_stub()
 
     def _as_context(self):
+        """ """
         raise NotImplementedError('Not all values need to be converted to contexts: %s', self)
 
     @property
     def name(self):
+        """ """
         raise NotImplementedError
 
     def get_type_hint(self, add_class_info=True):
+        """
+
+        Parameters
+        ----------
+        add_class_info :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         return None
 
     def infer_type_vars(self, value_set):
-        """
-        When the current instance represents a type annotation, this method
+        """When the current instance represents a type annotation, this method
         tries to find information about undefined type vars and returns a dict
         from type var name to value set.
-
+        
         This is for example important to understand what `iter([1])` returns.
         According to typeshed, `iter` returns an `Iterator[_T]`:
-
+        
             def iter(iterable: Iterable[_T]) -> Iterator[_T]: ...
-
+        
         This functions would generate `int` for `_T` in this case, because it
         unpacks the `Iterable`.
 
         Parameters
         ----------
-
-        `self`: represents the annotation of the current parameter to infer the
-            value for. In the above example, this would initially be the
-            `Iterable[_T]` of the `iterable` parameter and then, when recursing,
-            just the `_T` generic parameter.
-
-        `value_set`: represents the actual argument passed to the parameter
-            we're inferrined for, or (for recursive calls) their types. In the
-            above example this would first be the representation of the list
-            `[1]` and then, when recursing, just of `1`.
+        value_set :
+            
+
+        Returns
+        -------
+
+        
         """
         return {}
 
 
 def iterate_values(values, contextualized_node=None, is_async=False):
-    """
-    Calls `iterate`, on all values but ignores the ordering and just returns
+    """Calls `iterate`, on all values but ignores the ordering and just returns
     all values that the iterate functions yield.
+
+    Parameters
+    ----------
+    values :
+        
+    contextualized_node :
+         (Default value = None)
+    is_async :
+         (Default value = False)
+
+    Returns
+    -------
+
     """
     return ValueSet.from_sets(
         lazy_value.infer()
@@ -313,8 +598,10 @@
 
 
 class _ValueWrapperBase(HelperValueMixin):
+    """ """
     @safe_property
     def name(self):
+        """ """
         from jedi.inference.names import ValueName
         wrapped_name = self._wrapped_value.name
         if wrapped_name.tree_name is not None:
@@ -326,6 +613,21 @@
     @classmethod
     @inference_state_as_method_param_cache()
     def create_cached(cls, inference_state, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return cls(*args, **kwargs)
 
     def __getattr__(self, name):
@@ -334,9 +636,11 @@
 
 
 class LazyValueWrapper(_ValueWrapperBase):
+    """ """
     @safe_property
     @memoize_method
     def _wrapped_value(self):
+        """ """
         with debug.increase_indent_cm('Resolve lazy value wrapper'):
             return self._get_wrapped_value()
 
@@ -344,10 +648,12 @@
         return '<%s>' % (self.__class__.__name__)
 
     def _get_wrapped_value(self):
+        """ """
         raise NotImplementedError
 
 
 class ValueWrapper(_ValueWrapperBase):
+    """ """
     def __init__(self, wrapped_value):
         self._wrapped_value = wrapped_value
 
@@ -356,6 +662,7 @@
 
 
 class TreeValue(Value):
+    """ """
     def __init__(self, inference_state, parent_context, tree_node):
         super(TreeValue, self).__init__(inference_state, parent_context)
         self.tree_node = tree_node
@@ -365,14 +672,17 @@
 
 
 class ContextualizedNode(object):
+    """ """
     def __init__(self, context, node):
         self.context = context
         self.node = node
 
     def get_root_context(self):
+        """ """
         return self.context.get_root_context()
 
     def infer(self):
+        """ """
         return self.context.infer_node(self.node)
 
     def __repr__(self):
@@ -380,6 +690,21 @@
 
 
 def _getitem(value, index_values, contextualized_node):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    index_values :
+        
+    contextualized_node :
+        
+
+    Returns
+    -------
+
+    """
     # The actual getitem call.
     result = NO_VALUES
     unused_values = set()
@@ -407,6 +732,7 @@
 
 
 class ValueSet(object):
+    """ """
     def __init__(self, iterable):
         self._set = frozenset(iterable)
         for value in iterable:
@@ -414,14 +740,33 @@
 
     @classmethod
     def _from_frozen_set(cls, frozenset_):
+        """
+
+        Parameters
+        ----------
+        frozenset_ :
+            
+
+        Returns
+        -------
+
+        """
         self = cls.__new__(cls)
         self._set = frozenset_
         return self
 
     @classmethod
     def from_sets(cls, sets):
-        """
-        Used to work with an iterable of set.
+        """Used to work with an iterable of set.
+
+        Parameters
+        ----------
+        sets :
+            
+
+        Returns
+        -------
+
         """
         aggregated = set()
         for set_ in sets:
@@ -451,10 +796,34 @@
         return 'S{%s}' % (', '.join(str(s) for s in self._set))
 
     def filter(self, filter_func):
+        """
+
+        Parameters
+        ----------
+        filter_func :
+            
+
+        Returns
+        -------
+
+        """
         return self.__class__(filter(filter_func, self._set))
 
     def __getattr__(self, name):
         def mapper(*args, **kwargs):
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             return self.from_sets(
                 getattr(value, name)(*args, **kwargs)
                 for value in self._set
@@ -471,9 +840,23 @@
         return hash(self._set)
 
     def py__class__(self):
+        """ """
         return ValueSet(c.py__class__() for c in self._set)
 
     def iterate(self, contextualized_node=None, is_async=False):
+        """
+
+        Parameters
+        ----------
+        contextualized_node :
+             (Default value = None)
+        is_async :
+             (Default value = False)
+
+        Returns
+        -------
+
+        """
         from jedi.inference.lazy_value import get_merged_lazy_value
         type_iters = [c.iterate(contextualized_node, is_async=is_async) for c in self._set]
         for lazy_values in zip_longest(*type_iters):
@@ -482,21 +865,95 @@
             )
 
     def execute(self, arguments):
+        """
+
+        Parameters
+        ----------
+        arguments :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(c.inference_state.execute(c, arguments) for c in self._set)
 
     def execute_with_values(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(c.execute_with_values(*args, **kwargs) for c in self._set)
 
     def goto(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return reduce(add, [c.goto(*args, **kwargs) for c in self._set], [])
 
     def py__getattribute__(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(c.py__getattribute__(*args, **kwargs) for c in self._set)
 
     def get_item(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet.from_sets(_getitem(c, *args, **kwargs) for c in self._set)
 
     def try_merge(self, function_name):
+        """
+
+        Parameters
+        ----------
+        function_name :
+            
+
+        Returns
+        -------
+
+        """
         value_set = self.__class__([])
         for c in self._set:
             try:
@@ -508,12 +965,25 @@
         return value_set
 
     def gather_annotation_classes(self):
+        """ """
         return ValueSet.from_sets([c.gather_annotation_classes() for c in self._set])
 
     def get_signatures(self):
+        """ """
         return [sig for c in self._set for sig in c.get_signatures()]
 
     def get_type_hint(self, add_class_info=True):
+        """
+
+        Parameters
+        ----------
+        add_class_info :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         t = [v.get_type_hint(add_class_info=add_class_info) for v in self._set]
         type_hints = sorted(filter(None, t))
         if len(type_hints) == 1:
@@ -534,6 +1004,17 @@
         return s
 
     def infer_type_vars(self, value_set):
+        """
+
+        Parameters
+        ----------
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         # Circular
         from jedi.inference.gradual.annotation import merge_type_var_dicts
 
@@ -550,7 +1031,31 @@
 
 
 def iterator_to_value_set(func):
+    """
+
+    Parameters
+    ----------
+    func :
+        
+
+    Returns
+    -------
+
+    """
     def wrapper(*args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return ValueSet(func(*args, **kwargs))
 
     return wrapper
