# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/requests_toolbelt/multipart/decoder.py
+++ b/..//venv/lib/python3.8/site-packages/requests_toolbelt/multipart/decoder.py
@@ -15,19 +15,47 @@
 
 
 def _split_on_find(content, bound):
+    """
+
+    Parameters
+    ----------
+    content :
+        
+    bound :
+        
+
+    Returns
+    -------
+
+    """
     point = content.find(bound)
     return content[:point], content[point + len(bound):]
 
 
 class ImproperBodyPartContentException(Exception):
+    """ """
     pass
 
 
 class NonMultipartContentTypeException(Exception):
+    """ """
     pass
 
 
 def _header_parser(string, encoding):
+    """
+
+    Parameters
+    ----------
+    string :
+        
+    encoding :
+        
+
+    Returns
+    -------
+
+    """
     major = sys.version_info[0]
     if major == 3:
         string = string.decode(encoding)
@@ -39,15 +67,19 @@
 
 
 class BodyPart(object):
-    """
-
-    The ``BodyPart`` object is a ``Response``-like interface to an individual
+    """The ``BodyPart`` object is a ``Response``-like interface to an individual
     subpart of a multipart response. It is expected that these will
     generally be created by objects of the ``MultipartDecoder`` class.
-
+    
     Like ``Response``, there is a ``CaseInsensitiveDict`` object named headers,
     ``content`` to access bytes, ``text`` to access unicode, and ``encoding``
     to access the unicode codec.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -72,32 +104,36 @@
 
 
 class MultipartDecoder(object):
-    """
-
-    The ``MultipartDecoder`` object parses the multipart payload of
+    """The ``MultipartDecoder`` object parses the multipart payload of
     a bytestring into a tuple of ``Response``-like ``BodyPart`` objects.
-
+    
     The basic usage is::
-
+    
         import requests
         from requests_toolbelt import MultipartDecoder
-
+    
         response = request.get(url)
         decoder = MultipartDecoder.from_response(response)
         for part in decoder.parts:
             print(part.headers['content-type'])
-
+    
     If the multipart content is not from a response, basic usage is::
-
+    
         from requests_toolbelt import MultipartDecoder
-
+    
         decoder = MultipartDecoder(content, content_type)
         for part in decoder.parts:
             print(part.headers['content-type'])
-
+    
     For both these usages, there is an optional ``encoding`` parameter. This is
     a string, which is the name of the unicode codec to use (default is
     ``'utf-8'``).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
     def __init__(self, content, content_type, encoding='utf-8'):
@@ -111,6 +147,7 @@
         self._parse_body(content)
 
     def _find_boundary(self):
+        """ """
         ct_info = tuple(x.strip() for x in self.content_type.split(';'))
         mimetype = ct_info[0]
         if mimetype.split('/')[0].lower() != 'multipart':
@@ -127,6 +164,19 @@
 
     @staticmethod
     def _fix_first_part(part, boundary_marker):
+        """
+
+        Parameters
+        ----------
+        part :
+            
+        boundary_marker :
+            
+
+        Returns
+        -------
+
+        """
         bm_len = len(boundary_marker)
         if boundary_marker == part[:bm_len]:
             return part[bm_len:]
@@ -134,13 +184,46 @@
             return part
 
     def _parse_body(self, content):
+        """
+
+        Parameters
+        ----------
+        content :
+            
+
+        Returns
+        -------
+
+        """
         boundary = b''.join((b'--', self.boundary))
 
         def body_part(part):
+            """
+
+            Parameters
+            ----------
+            part :
+                
+
+            Returns
+            -------
+
+            """
             fixed = MultipartDecoder._fix_first_part(part, boundary)
             return BodyPart(fixed, self.encoding)
 
         def test_part(part):
+            """
+
+            Parameters
+            ----------
+            part :
+                
+
+            Returns
+            -------
+
+            """
             return (part != b'' and
                     part != b'\r\n' and
                     part[:4] != b'--\r\n' and
@@ -151,6 +234,19 @@
 
     @classmethod
     def from_response(cls, response, encoding='utf-8'):
+        """
+
+        Parameters
+        ----------
+        response :
+            
+        encoding :
+             (Default value = 'utf-8')
+
+        Returns
+        -------
+
+        """
         content = response.content
         content_type = response.headers.get('content-type', None)
         return cls(content, content_type, encoding)
