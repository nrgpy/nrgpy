# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/IPython/utils/tests/test_path.py
+++ b/..//venv/lib/python3.8/site-packages/IPython/utils/tests/test_path.py
@@ -55,8 +55,15 @@
 
 def setup_module():
     """Setup testenvironment for the module:
-
+    
             - Adds dummy home dir tree
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     # Do not mask exceptions here.  In particular, catching WindowsError is a
     # problem because that exception is only defined on Windows...
@@ -65,8 +72,15 @@
 
 def teardown_module():
     """Teardown testenvironment for the module:
-
+    
             - Remove dummy home dir tree
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     # Note: we remove the parent test dir, which is the root of all test
     # subdirs we may have created.  Use shutil instead of os.removedirs, so
@@ -80,13 +94,19 @@
     and other things that we need to stub in some test functions.
     This needs to be done on a function level and not module level because
     each testfunction needs a pristine environment.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     global oldstuff, platformstuff
     oldstuff = (env.copy(), os.name, sys.platform, path.get_home_dir, IPython.__file__, os.getcwd())
 
 def teardown_environment():
-    """Restore things that were remembered by the setup_environment function
-    """
+    """Restore things that were remembered by the setup_environment function"""
     (oldenv, os.name, sys.platform, path.get_home_dir, IPython.__file__, old_wd) = oldstuff
     os.chdir(old_wd)
     reload(path)
@@ -104,8 +124,7 @@
 @skip_if_not_win32
 @with_environment
 def test_get_home_dir_1():
-    """Testcase for py2exe logic, un-compressed lib
-    """
+    """Testcase for py2exe logic, un-compressed lib"""
     unfrozen = path.get_home_dir()
     sys.frozen = True
 
@@ -119,8 +138,7 @@
 @skip_if_not_win32
 @with_environment
 def test_get_home_dir_2():
-    """Testcase for py2exe logic, compressed lib
-    """
+    """Testcase for py2exe logic, compressed lib"""
     unfrozen = path.get_home_dir()
     sys.frozen = True
     #fake filename for IPython.__init__
@@ -151,7 +169,7 @@
 @skip_win32_py38
 @with_environment
 def test_get_home_dir_5():
-    """raise HomeDirError if $HOME is specified, but not a writable dir"""
+    """ """
     env['HOME'] = abspath(HOME_TEST_DIR+'garbage')
     # set os.name = posix, to prevent My Documents fallback on Windows
     os.name = 'posix'
@@ -162,8 +180,15 @@
 @with_environment
 def test_get_home_dir_8():
     """Using registry hack for 'My Documents', os=='nt'
-
+    
     HOMESHARE, HOMEDRIVE, HOMEPATH, USERPROFILE and others are missing.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     os.name = 'nt'
     # Remove from stub environment all keys that may be set
@@ -171,9 +196,11 @@
         env.pop(key, None)
 
     class key:
+        """ """
         def __enter__(self):
             pass
         def Close(self):
+            """ """
             pass
         def __exit__(*args, **kwargs):
             pass
@@ -253,6 +280,7 @@
 
 @dec.skip_if_not_win32
 def test_get_long_path_name_win32():
+    """ """
     with TemporaryDirectory() as tmpdir:
 
         # Make a long path. Expands the path of tmpdir prematurely as it may already have a long
@@ -268,15 +296,18 @@
 
 @dec.skip_win32
 def test_get_long_path_name():
+    """ """
     p = path.get_long_path_name('/usr/local')
     nt.assert_equal(p,'/usr/local')
 
 
 class TestRaiseDeprecation(unittest.TestCase):
+    """ """
 
     @dec.skip_win32 # can't create not-user-writable dir on win
     @with_environment
     def test_not_writable_ipdir(self):
+        """ """
         tmpdir = tempfile.mkdtemp()
         os.name = "posix"
         env.pop('IPYTHON_DIR', None)
@@ -299,6 +330,7 @@
 
 @with_environment
 def test_get_py_filename():
+    """ """
     os.chdir(TMP_TEST_DIR)
     with make_tempfile('foo.py'):
         nt.assert_equal(path.get_py_filename('foo.py'), 'foo.py')
@@ -319,8 +351,15 @@
 def test_unicode_in_filename():
     """When a file doesn't exist, the exception raised should be safe to call
     str() on - i.e. in Python 2 it must only have ASCII characters.
-
+    
     https://github.com/ipython/ipython/issues/875
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     try:
         # these calls should not throw unicode encode exceptions
@@ -330,9 +369,11 @@
 
 
 class TestShellGlob(unittest.TestCase):
+    """ """
 
     @classmethod
     def setUpClass(cls):
+        """ """
         cls.filenames_start_with_a = ['a0', 'a1', 'a2']
         cls.filenames_end_with_b = ['0b', '1b', '2b']
         cls.filenames = cls.filenames_start_with_a + cls.filenames_end_with_b
@@ -346,11 +387,13 @@
 
     @classmethod
     def tearDownClass(cls):
+        """ """
         cls.tempdir.cleanup()
 
     @classmethod
     @contextmanager
     def in_tempdir(cls):
+        """ """
         save = os.getcwd()
         try:
             os.chdir(cls.tempdir.name)
@@ -359,12 +402,26 @@
             os.chdir(save)
 
     def check_match(self, patterns, matches):
+        """
+
+        Parameters
+        ----------
+        patterns :
+            
+        matches :
+            
+
+        Returns
+        -------
+
+        """
         with self.in_tempdir():
             # glob returns unordered list. that's why sorted is required.
             nt.assert_equal(sorted(path.shellglob(patterns)),
                             sorted(matches))
 
     def common_cases(self):
+        """ """
         return [
             (['*'], self.filenames),
             (['a*'], self.filenames_start_with_a),
@@ -378,6 +435,7 @@
 
     @skip_win32
     def test_match_posix(self):
+        """ """
         for (patterns, matches) in self.common_cases() + [
                 ([r'\*'], ['*']),
                 ([r'a\*', 'a*'], ['a*'] + self.filenames_start_with_a),
@@ -387,6 +445,7 @@
 
     @skip_if_not_win32
     def test_match_windows(self):
+        """ """
         for (patterns, matches) in self.common_cases() + [
                 # In windows, backslash is interpreted as path
                 # separator.  Therefore, you can't escape glob
@@ -398,6 +457,7 @@
 
 
 def test_unescape_glob():
+    """ """
     nt.assert_equal(path.unescape_glob(r'\*\[\!\]\?'), '*[!]?')
     nt.assert_equal(path.unescape_glob(r'\\*'), r'\*')
     nt.assert_equal(path.unescape_glob(r'\\\*'), r'\*')
@@ -407,6 +467,7 @@
 
 @onlyif_unicode_paths
 def test_ensure_dir_exists():
+    """ """
     with TemporaryDirectory() as td:
         d = os.path.join(td, 'âˆ‚ir')
         path.ensure_dir_exists(d) # create it
@@ -418,39 +479,94 @@
             path.ensure_dir_exists(f)
 
 class TestLinkOrCopy(unittest.TestCase):
+    """ """
     def setUp(self):
+        """ """
         self.tempdir = TemporaryDirectory()
         self.src = self.dst("src")
         with open(self.src, "w") as f:
             f.write("Hello, world!")
 
     def tearDown(self):
+        """ """
         self.tempdir.cleanup()
 
     def dst(self, *args):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+
+        Returns
+        -------
+
+        """
         return os.path.join(self.tempdir.name, *args)
 
     def assert_inode_not_equal(self, a, b):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
+        """
         nt.assert_not_equal(os.stat(a).st_ino, os.stat(b).st_ino,
                             "%r and %r do reference the same indoes" %(a, b))
 
     def assert_inode_equal(self, a, b):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
+        """
         nt.assert_equal(os.stat(a).st_ino, os.stat(b).st_ino,
                         "%r and %r do not reference the same indoes" %(a, b))
 
     def assert_content_equal(self, a, b):
+        """
+
+        Parameters
+        ----------
+        a :
+            
+        b :
+            
+
+        Returns
+        -------
+
+        """
         with open(a) as a_f:
             with open(b) as b_f:
                 nt.assert_equal(a_f.read(), b_f.read())
 
     @skip_win32
     def test_link_successful(self):
+        """ """
         dst = self.dst("target")
         path.link_or_copy(self.src, dst)
         self.assert_inode_equal(self.src, dst)
 
     @skip_win32
     def test_link_into_dir(self):
+        """ """
         dst = self.dst("some_dir")
         os.mkdir(dst)
         path.link_or_copy(self.src, dst)
@@ -459,6 +575,7 @@
 
     @skip_win32
     def test_target_exists(self):
+        """ """
         dst = self.dst("target")
         open(dst, "w").close()
         path.link_or_copy(self.src, dst)
@@ -466,6 +583,7 @@
 
     @skip_win32
     def test_no_link(self):
+        """ """
         real_link = os.link
         try:
             del os.link
@@ -478,11 +596,13 @@
 
     @skip_if_not_win32
     def test_windows(self):
+        """ """
         dst = self.dst("target")
         path.link_or_copy(self.src, dst)
         self.assert_content_equal(self.src, dst)
 
     def test_link_twice(self):
+        """ """
         # Linking the same file twice shouldn't leave duplicates around.
         # See https://github.com/ipython/ipython/issues/6450
         dst = self.dst('target')
