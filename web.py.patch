# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/tornado/web.py
+++ b/..//venv/lib/python3.8/site-packages/tornado/web.py
@@ -26,7 +26,9 @@
     import tornado.web
 
     class MainHandler(tornado.web.RequestHandler):
+        """ """
         def get(self):
+            """ """
             self.write("Hello, world")
 
     if __name__ == "__main__":
@@ -169,6 +171,7 @@
 
 
 class _ArgDefaultMarker:
+    """ """
     pass
 
 
@@ -177,13 +180,19 @@
 
 class RequestHandler(object):
     """Base class for HTTP request handlers.
-
+    
     Subclasses must define at least one of the methods defined in the
     "Entry points" section below.
-
+    
     Applications should not construct `RequestHandler` objects
     directly and subclasses should not override ``__init__`` (override
     `~RequestHandler.initialize` instead).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     """
 
@@ -233,6 +242,7 @@
         self.initialize(**kwargs)  # type: ignore
 
     def _initialize(self) -> None:
+        """ """
         pass
 
     initialize = _initialize  # type: Callable[..., None]
@@ -244,10 +254,33 @@
     Example::
 
         class ProfileHandler(RequestHandler):
+            """ """
             def initialize(self, database):
+                """
+
+                Parameters
+                ----------
+                database :
+                    
+
+                Returns
+                -------
+
+                """
                 self.database = database
 
             def get(self, username):
+                """
+
+                Parameters
+                ----------
+                username :
+                    
+
+                Returns
+                -------
+
+                """
                 ...
 
         app = Application([
@@ -261,6 +294,19 @@
         return self.application.settings
 
     def _unimplemented_method(self, *args: str, **kwargs: str) -> None:
+        """
+
+        Parameters
+        ----------
+        *args: str :
+            
+        **kwargs: str :
+            
+
+        Returns
+        -------
+
+        """
         raise HTTPError(405)
 
     head = _unimplemented_method  # type: Callable[..., Optional[Awaitable[None]]]
@@ -273,43 +319,64 @@
 
     def prepare(self) -> Optional[Awaitable[None]]:
         """Called at the beginning of a request before  `get`/`post`/etc.
-
+        
         Override this method to perform common initialization regardless
         of the request method.
-
+        
         Asynchronous support: Use ``async def`` or decorate this method with
         `.gen.coroutine` to make it asynchronous.
         If this method returns an  ``Awaitable`` execution will not proceed
         until the ``Awaitable`` is done.
-
+        
         .. versionadded:: 3.1
            Asynchronous support.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
     def on_finish(self) -> None:
         """Called after the end of a request.
-
+        
         Override this method to perform cleanup, logging, etc.
         This method is a counterpart to `prepare`.  ``on_finish`` may
         not produce any output, as it is called after the response
         has been sent to the client.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
     def on_connection_close(self) -> None:
         """Called in async handlers if the client closed the connection.
-
+        
         Override this to clean up resources associated with
         long-lived connections.  Note that this method is called only if
         the connection was closed during asynchronous processing; if you
         need to do cleanup after every request override `on_finish`
         instead.
-
+        
         Proxies may keep a connection open for a time (perhaps
         indefinitely) after the client has gone away, so this method
         may not be called promptly after the end user closes their
         connection.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if _has_stream_request_body(self.__class__):
             if not self.request._body_future.done():
@@ -332,26 +399,44 @@
 
     def set_default_headers(self) -> None:
         """Override this to set HTTP headers at the beginning of the request.
-
+        
         For example, this is the place to set a custom ``Server`` header.
         Note that setting such headers in the normal flow of request
         processing may not do what you want, since headers may be reset
         during error handling.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         pass
 
     def set_status(self, status_code: int, reason: Optional[str] = None) -> None:
         """Sets the status code for our response.
-
+        
         :arg int status_code: Response status code.
         :arg str reason: Human-readable reason phrase describing the status
             code. If ``None``, it will be filled in from
             `http.client.responses` or "Unknown".
-
+        
         .. versionchanged:: 5.0
-
+        
            No longer validates that the response code is in
            `http.client.responses`.
+
+        Parameters
+        ----------
+        status_code: int :
+            
+        reason: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         self._status_code = status_code
         if reason is not None:
@@ -365,27 +450,57 @@
 
     def set_header(self, name: str, value: _HeaderTypes) -> None:
         """Sets the given response header name and value.
-
+        
         All header values are converted to strings (`datetime` objects
         are formatted according to the HTTP specification for the
         ``Date`` header).
 
+        Parameters
+        ----------
+        name: str :
+            
+        value: _HeaderTypes :
+            
+
+        Returns
+        -------
+
         """
         self._headers[name] = self._convert_header_value(value)
 
     def add_header(self, name: str, value: _HeaderTypes) -> None:
         """Adds the given response header and value.
-
+        
         Unlike `set_header`, `add_header` may be called multiple times
         to return multiple values for the same header.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: _HeaderTypes :
+            
+
+        Returns
+        -------
+
         """
         self._headers.add(name, self._convert_header_value(value))
 
     def clear_header(self, name: str) -> None:
         """Clears an outgoing header, undoing a previous `set_header` call.
-
+        
         Note that this method does not apply to multi-valued headers
         set by `add_header`.
+
+        Parameters
+        ----------
+        name: str :
+            
+
+        Returns
+        -------
+
         """
         if name in self._headers:
             del self._headers[name]
@@ -393,6 +508,17 @@
     _INVALID_HEADER_CHAR_RE = re.compile(r"[\x00-\x1f]")
 
     def _convert_header_value(self, value: _HeaderTypes) -> str:
+        """
+
+        Parameters
+        ----------
+        value: _HeaderTypes :
+            
+
+        Returns
+        -------
+
+        """
         # Convert the input value to a str. This type check is a bit
         # subtle: The bytes case only executes on python 3, and the
         # unicode case only executes on python 2, because the other
@@ -422,18 +548,67 @@
 
     @overload
     def get_argument(self, name: str, default: str, strip: bool = True) -> str:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: str :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         pass
 
     @overload
     def get_argument(  # noqa: F811
         self, name: str, default: _ArgDefaultMarker = _ARG_DEFAULT, strip: bool = True
     ) -> str:
+        """
+
+        Parameters
+        ----------
+        # noqa: F811self :
+            
+        name: str :
+            
+        default: _ArgDefaultMarker :
+             (Default value = _ARG_DEFAULT)
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         pass
 
     @overload
     def get_argument(  # noqa: F811
         self, name: str, default: None, strip: bool = True
     ) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        # noqa: F811self :
+            
+        name: str :
+            
+        default: None :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         pass
 
     def get_argument(  # noqa: F811
@@ -443,23 +618,53 @@
         strip: bool = True,
     ) -> Optional[str]:
         """Returns the value of the argument with the given name.
-
+        
         If default is not provided, the argument is considered to be
         required, and we raise a `MissingArgumentError` if it is missing.
-
+        
         If the argument appears in the request more than once, we return the
         last value.
-
+        
         This method searches both the query and body arguments.
+
+        Parameters
+        ----------
+        # noqa: F811self :
+            
+        name: str :
+            
+        default: Union[None :
+            
+        str :
+            
+        _ArgDefaultMarker] :
+             (Default value = _ARG_DEFAULT)
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._get_argument(name, default, self.request.arguments, strip)
 
     def get_arguments(self, name: str, strip: bool = True) -> List[str]:
         """Returns a list of the arguments with the given name.
-
+        
         If the argument is not present, returns an empty list.
-
+        
         This method searches both the query and body arguments.
+
+        Parameters
+        ----------
+        name: str :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
 
         # Make sure `get_arguments` isn't accidentally being called with a
@@ -477,23 +682,51 @@
     ) -> Optional[str]:
         """Returns the value of the argument with the given name
         from the request body.
-
+        
         If default is not provided, the argument is considered to be
         required, and we raise a `MissingArgumentError` if it is missing.
-
+        
         If the argument appears in the url more than once, we return the
         last value.
-
+        
         .. versionadded:: 3.2
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: Union[None :
+            
+        str :
+            
+        _ArgDefaultMarker] :
+             (Default value = _ARG_DEFAULT)
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._get_argument(name, default, self.request.body_arguments, strip)
 
     def get_body_arguments(self, name: str, strip: bool = True) -> List[str]:
         """Returns a list of the body arguments with the given name.
-
+        
         If the argument is not present, returns an empty list.
-
+        
         .. versionadded:: 3.2
+
+        Parameters
+        ----------
+        name: str :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._get_arguments(name, self.request.body_arguments, strip)
 
@@ -505,23 +738,51 @@
     ) -> Optional[str]:
         """Returns the value of the argument with the given name
         from the request query string.
-
+        
         If default is not provided, the argument is considered to be
         required, and we raise a `MissingArgumentError` if it is missing.
-
+        
         If the argument appears in the url more than once, we return the
         last value.
-
+        
         .. versionadded:: 3.2
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: Union[None :
+            
+        str :
+            
+        _ArgDefaultMarker] :
+             (Default value = _ARG_DEFAULT)
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._get_argument(name, default, self.request.query_arguments, strip)
 
     def get_query_arguments(self, name: str, strip: bool = True) -> List[str]:
         """Returns a list of the query arguments with the given name.
-
+        
         If the argument is not present, returns an empty list.
-
+        
         .. versionadded:: 3.2
+
+        Parameters
+        ----------
+        name: str :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
         """
         return self._get_arguments(name, self.request.query_arguments, strip)
 
@@ -532,6 +793,29 @@
         source: Dict[str, List[bytes]],
         strip: bool = True,
     ) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: Union[None :
+            
+        str :
+            
+        _ArgDefaultMarker] :
+            
+        source: Dict[str :
+            
+        List[bytes]] :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         args = self._get_arguments(name, source, strip=strip)
         if not args:
             if isinstance(default, _ArgDefaultMarker):
@@ -542,6 +826,23 @@
     def _get_arguments(
         self, name: str, source: Dict[str, List[bytes]], strip: bool = True
     ) -> List[str]:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        source: Dict[str :
+            
+        List[bytes]] :
+            
+        strip: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         values = []
         for v in source.get(name, []):
             s = self.decode_argument(v, name=name)
@@ -556,16 +857,27 @@
 
     def decode_argument(self, value: bytes, name: Optional[str] = None) -> str:
         """Decodes an argument from the request.
-
+        
         The argument has been percent-decoded and is now a byte string.
         By default, this method decodes the argument as utf-8 and returns
         a unicode string, but this may be overridden in subclasses.
-
+        
         This method is used as a filter for both `get_argument()` and for
         values extracted from the url and passed to `get()`/`post()`/etc.
-
+        
         The name of the argument is provided if known, but may be None
         (e.g. for unnamed groups in the url regex).
+
+        Parameters
+        ----------
+        value: bytes :
+            
+        name: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         try:
             return _unicode(value)
@@ -577,17 +889,36 @@
     @property
     def cookies(self) -> Dict[str, http.cookies.Morsel]:
         """An alias for
-        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`."""
+        `self.request.cookies <.httputil.HTTPServerRequest.cookies>`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         return self.request.cookies
 
     def get_cookie(self, name: str, default: Optional[str] = None) -> Optional[str]:
         """Returns the value of the request cookie with the given name.
-
+        
         If the named cookie is not present, returns ``default``.
-
+        
         This method only returns cookies that were present in the request.
         It does not see the outgoing cookies set by `set_cookie` in this
         handler.
+
+        Parameters
+        ----------
+        name: str :
+            
+        default: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if self.request.cookies is not None and name in self.request.cookies:
             return self.request.cookies[name].value
@@ -604,18 +935,45 @@
         **kwargs: Any
     ) -> None:
         """Sets an outgoing cookie name/value with the given options.
-
+        
         Newly-set cookies are not immediately visible via `get_cookie`;
         they are not present until the next request.
-
+        
         expires may be a numeric timestamp as returned by `time.time`,
         a time tuple as returned by `time.gmtime`, or a
         `datetime.datetime` object.
-
+        
         Additional keyword arguments are set on the cookies.Morsel
         directly.
         See https://docs.python.org/3/library/http.cookies.html#http.cookies.Morsel
         for available attributes.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: Union[str :
+            
+        bytes] :
+            
+        domain: Optional[str] :
+             (Default value = None)
+        expires: Optional[Union[float :
+            
+        Tuple :
+            
+        datetime.datetime]] :
+             (Default value = None)
+        path: str :
+             (Default value = "/")
+        expires_days: Optional[float] :
+             (Default value = None)
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         # The cookie library only accepts type str, in both python 2 and 3
         name = escape.native_str(name)
@@ -654,30 +1012,54 @@
         self, name: str, path: str = "/", domain: Optional[str] = None
     ) -> None:
         """Deletes the cookie with the given name.
-
+        
         Due to limitations of the cookie protocol, you must pass the same
         path and domain to clear a cookie as were used when that cookie
         was set (but there is no way to find out on the server side
         which values were used for a given cookie).
-
+        
         Similar to `set_cookie`, the effect of this method will not be
         seen until the following request.
+
+        Parameters
+        ----------
+        name: str :
+            
+        path: str :
+             (Default value = "/")
+        domain: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)
         self.set_cookie(name, value="", path=path, expires=expires, domain=domain)
 
     def clear_all_cookies(self, path: str = "/", domain: Optional[str] = None) -> None:
         """Deletes all the cookies the user sent with this request.
-
+        
         See `clear_cookie` for more information on the path and domain
-        parameters.
-
-        Similar to `set_cookie`, the effect of this method will not be
-        seen until the following request.
-
-        .. versionchanged:: 3.2
-
-           Added the ``path`` and ``domain`` parameters.
+
+        Parameters
+        ----------
+        Similar :
+            to
+        seen :
+            until the following request
+        versionchanged :
+            
+        Added :
+            the
+        path: str :
+             (Default value = "/")
+        domain: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         for name in self.request.cookies:
             self.clear_cookie(name, path=path, domain=domain)
@@ -691,28 +1073,47 @@
         **kwargs: Any
     ) -> None:
         """Signs and timestamps a cookie so it cannot be forged.
-
+        
         You must specify the ``cookie_secret`` setting in your Application
         to use this method. It should be a long, random sequence of bytes
         to be used as the HMAC secret for the signature.
-
+        
         To read a cookie set with this method, use `get_secure_cookie()`.
-
+        
         Note that the ``expires_days`` parameter sets the lifetime of the
         cookie in the browser, but is independent of the ``max_age_days``
         parameter to `get_secure_cookie`.
         A value of None limits the lifetime to the current browser session.
-
+        
         Secure cookies may contain arbitrary byte values, not just unicode
         strings (unlike regular cookies)
-
+        
         Similar to `set_cookie`, the effect of this method will not be
         seen until the following request.
-
+        
         .. versionchanged:: 3.2.1
-
+        
            Added the ``version`` argument.  Introduced cookie version 2
            and made it the default.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: Union[str :
+            
+        bytes] :
+            
+        expires_days: Optional[float] :
+             (Default value = 30)
+        version: Optional[int] :
+             (Default value = None)
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         self.set_cookie(
             name,
@@ -725,15 +1126,30 @@
         self, name: str, value: Union[str, bytes], version: Optional[int] = None
     ) -> bytes:
         """Signs and timestamps a string so it cannot be forged.
-
+        
         Normally used via set_secure_cookie, but provided as a separate
         method for non-cookie uses.  To decode a value not stored
         as a cookie use the optional value argument to get_secure_cookie.
-
+        
         .. versionchanged:: 3.2.1
-
+        
            Added the ``version`` argument.  Introduced cookie version 2
            and made it the default.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: Union[str :
+            
+        bytes] :
+            
+        version: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         self.require_setting("cookie_secret", "secure cookies")
         secret = self.application.settings["cookie_secret"]
@@ -755,18 +1171,33 @@
         min_version: Optional[int] = None,
     ) -> Optional[bytes]:
         """Returns the given signed cookie if it validates, or None.
-
+        
         The decoded cookie value is returned as a byte string (unlike
         `get_cookie`).
-
+        
         Similar to `get_cookie`, this method only returns cookies that
         were present in the request. It does not see outgoing cookies set by
         `set_secure_cookie` in this handler.
-
+        
         .. versionchanged:: 3.2.1
-
+        
            Added the ``min_version`` argument.  Introduced cookie version 2;
            both versions 1 and 2 are accepted by default.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: Optional[str] :
+             (Default value = None)
+        max_age_days: float :
+             (Default value = 31)
+        min_version: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         self.require_setting("cookie_secret", "secure cookies")
         if value is None:
@@ -783,8 +1214,19 @@
         self, name: str, value: Optional[str] = None
     ) -> Optional[int]:
         """Returns the signing key version of the secure cookie.
-
+        
         The version is returned as int.
+
+        Parameters
+        ----------
+        name: str :
+            
+        value: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         self.require_setting("cookie_secret", "secure cookies")
         if value is None:
@@ -797,11 +1239,24 @@
         self, url: str, permanent: bool = False, status: Optional[int] = None
     ) -> None:
         """Sends a redirect to the given (optionally relative) URL.
-
+        
         If the ``status`` argument is specified, that value is used as the
         HTTP status code; otherwise either 301 (permanent) or 302
         (temporary) is chosen based on the ``permanent`` argument.
         The default is 302 (temporary).
+
+        Parameters
+        ----------
+        url: str :
+            
+        permanent: bool :
+             (Default value = False)
+        status: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if self._headers_written:
             raise Exception("Cannot redirect after headers have been written")
@@ -815,19 +1270,32 @@
 
     def write(self, chunk: Union[str, bytes, dict]) -> None:
         """Writes the given chunk to the output buffer.
-
+        
         To write the output to the network, use the `flush()` method below.
-
+        
         If the given chunk is a dictionary, we write it as JSON and set
         the Content-Type of the response to be ``application/json``.
         (if you want to send JSON as a different ``Content-Type``, call
         ``set_header`` *after* calling ``write()``).
-
+        
         Note that lists are not converted to JSON because of a potential
         cross-site security vulnerability.  All JSON output should be
         wrapped in a dictionary.  More details at
         http://haacked.com/archive/2009/06/25/json-hijacking.aspx/ and
         https://github.com/facebook/tornado/issues/1009
+
+        Parameters
+        ----------
+        chunk: Union[str :
+            
+        bytes :
+            
+        dict] :
+            
+
+        Returns
+        -------
+
         """
         if self._finished:
             raise RuntimeError("Cannot write() after finish()")
@@ -847,16 +1315,27 @@
 
     def render(self, template_name: str, **kwargs: Any) -> "Future[None]":
         """Renders the template with the given arguments as the response.
-
+        
         ``render()`` calls ``finish()``, so no other output methods can be called
         after it.
-
+        
         Returns a `.Future` with the same semantics as the one returned by `finish`.
         Awaiting this `.Future` is optional.
-
+        
         .. versionchanged:: 5.1
-
+        
            Now returns a `.Future` instead of ``None``.
+
+        Parameters
+        ----------
+        template_name: str :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         if self._finished:
             raise RuntimeError("Cannot render() after finish()")
@@ -923,8 +1402,17 @@
     def render_linked_js(self, js_files: Iterable[str]) -> str:
         """Default method used to render the final js links for the
         rendered webpage.
-
+        
         Override this method in a sub-classed controller to change the output.
+
+        Parameters
+        ----------
+        js_files: Iterable[str] :
+            
+
+        Returns
+        -------
+
         """
         paths = []
         unique_paths = set()  # type: Set[str]
@@ -946,8 +1434,17 @@
     def render_embed_js(self, js_embed: Iterable[bytes]) -> bytes:
         """Default method used to render the final embedded js for the
         rendered webpage.
-
+        
         Override this method in a sub-classed controller to change the output.
+
+        Parameters
+        ----------
+        js_embed: Iterable[bytes] :
+            
+
+        Returns
+        -------
+
         """
         return (
             b'<script type="text/javascript">\n//<![CDATA[\n'
@@ -958,8 +1455,17 @@
     def render_linked_css(self, css_files: Iterable[str]) -> str:
         """Default method used to render the final css links for the
         rendered webpage.
-
+        
         Override this method in a sub-classed controller to change the output.
+
+        Parameters
+        ----------
+        css_files: Iterable[str] :
+            
+
+        Returns
+        -------
+
         """
         paths = []
         unique_paths = set()  # type: Set[str]
@@ -980,16 +1486,36 @@
     def render_embed_css(self, css_embed: Iterable[bytes]) -> bytes:
         """Default method used to render the final embedded css for the
         rendered webpage.
-
+        
         Override this method in a sub-classed controller to change the output.
+
+        Parameters
+        ----------
+        css_embed: Iterable[bytes] :
+            
+
+        Returns
+        -------
+
         """
         return b'<style type="text/css">\n' + b"\n".join(css_embed) + b"\n</style>"
 
     def render_string(self, template_name: str, **kwargs: Any) -> bytes:
         """Generate the given template with the given arguments.
-
+        
         We return the generated byte string (in utf8). To generate and
         write a template as a response, use render() above.
+
+        Parameters
+        ----------
+        template_name: str :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         # If no template_path is specified, use the path of the calling file
         template_path = self.get_template_path()
@@ -1013,12 +1539,19 @@
 
     def get_template_namespace(self) -> Dict[str, Any]:
         """Returns a dictionary to be used as the default template namespace.
-
+        
         May be overridden by subclasses to add or modify values.
-
+        
         The results of this method will be combined with additional
         defaults in the `tornado.template` module and keyword arguments
         to `render` or `render_string`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         namespace = dict(
             handler=self,
@@ -1036,12 +1569,21 @@
 
     def create_template_loader(self, template_path: str) -> template.BaseLoader:
         """Returns a new template loader for the given path.
-
+        
         May be overridden by subclasses.  By default returns a
         directory-based loader on the given path, using the
         ``autoescape`` and ``template_whitespace`` application
         settings.  If a ``template_loader`` application setting is
         supplied, uses that instead.
+
+        Parameters
+        ----------
+        template_path: str :
+            
+
+        Returns
+        -------
+
         """
         settings = self.application.settings
         if "template_loader" in settings:
@@ -1057,13 +1599,22 @@
 
     def flush(self, include_footers: bool = False) -> "Future[None]":
         """Flushes the current output buffer to the network.
-
+        
         .. versionchanged:: 4.0
            Now returns a `.Future` if no callback is given.
-
+        
         .. versionchanged:: 6.0
-
+        
            The ``callback`` argument was removed.
+
+        Parameters
+        ----------
+        include_footers: bool :
+             (Default value = False)
+
+        Returns
+        -------
+
         """
         assert self.request.connection is not None
         chunk = b"".join(self._write_buffer)
@@ -1107,18 +1658,31 @@
 
     def finish(self, chunk: Optional[Union[str, bytes, dict]] = None) -> "Future[None]":
         """Finishes this response, ending the HTTP request.
-
+        
         Passing a ``chunk`` to ``finish()`` is equivalent to passing that
         chunk to ``write()`` and then calling ``finish()`` with no arguments.
-
+        
         Returns a `.Future` which may optionally be awaited to track the sending
         of the response to the client. This `.Future` resolves when all the response
         data has been sent, and raises an error if the connection is closed before all
         data can be sent.
-
+        
         .. versionchanged:: 5.1
-
+        
            Now returns a `.Future` instead of ``None``.
+
+        Parameters
+        ----------
+        chunk: Optional[Union[str :
+            
+        bytes :
+            
+        dict]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if self._finished:
             raise RuntimeError("finish() called twice")
@@ -1164,34 +1728,53 @@
 
     def detach(self) -> iostream.IOStream:
         """Take control of the underlying stream.
-
+        
         Returns the underlying `.IOStream` object and stops all
         further HTTP processing. Intended for implementing protocols
         like websockets that tunnel over an HTTP handshake.
-
+        
         This method is only supported when HTTP/1.1 is used.
-
+        
         .. versionadded:: 5.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self._finished = True
         # TODO: add detach to HTTPConnection?
         return self.request.connection.detach()  # type: ignore
 
     def _break_cycles(self) -> None:
+        """ """
         # Break up a reference cycle between this handler and the
         # _ui_module closures to allow for faster GC on CPython.
         self.ui = None  # type: ignore
 
     def send_error(self, status_code: int = 500, **kwargs: Any) -> None:
         """Sends the given HTTP error code to the browser.
-
+        
         If `flush()` has already been called, it is not possible to send
         an error, so this method will simply terminate the response.
         If output has been written but not yet flushed, it will be discarded
         and replaced with the error page.
-
+        
         Override `write_error()` to customize the error page that is returned.
         Additional keyword arguments are passed through to `write_error`.
+
+        Parameters
+        ----------
+        status_code: int :
+             (Default value = 500)
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         if self._headers_written:
             gen_log.error("Cannot send error response after headers written")
@@ -1222,15 +1805,26 @@
 
     def write_error(self, status_code: int, **kwargs: Any) -> None:
         """Override to implement custom error pages.
-
+        
         ``write_error`` may call `write`, `render`, `set_header`, etc
         to produce output as usual.
-
+        
         If this error was caused by an uncaught exception (including
         HTTPError), an ``exc_info`` triple will be available as
         ``kwargs["exc_info"]``.  Note that this exception may not be
         the "current" exception for purposes of methods like
         ``sys.exc_info()`` or ``traceback.format_exc``.
+
+        Parameters
+        ----------
+        status_code: int :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         if self.settings.get("serve_traceback") and "exc_info" in kwargs:
             # in debug mode, try to send a traceback
@@ -1248,14 +1842,21 @@
     @property
     def locale(self) -> tornado.locale.Locale:
         """The locale for the current session.
-
+        
         Determined by either `get_user_locale`, which you can override to
         set the locale based on, e.g., a user preference stored in a
         database, or `get_browser_locale`, which uses the ``Accept-Language``
         header.
-
+        
         .. versionchanged: 4.1
            Added a property setter.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not hasattr(self, "_locale"):
             loc = self.get_user_locale()
@@ -1268,22 +1869,49 @@
 
     @locale.setter
     def locale(self, value: tornado.locale.Locale) -> None:
+        """
+
+        Parameters
+        ----------
+        value: tornado.locale.Locale :
+            
+
+        Returns
+        -------
+
+        """
         self._locale = value
 
     def get_user_locale(self) -> Optional[tornado.locale.Locale]:
         """Override to determine the locale from the authenticated user.
-
+        
         If None is returned, we fall back to `get_browser_locale()`.
-
+        
         This method should return a `tornado.locale.Locale` object,
         most likely obtained via a call like ``tornado.locale.get("en")``
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def get_browser_locale(self, default: str = "en_US") -> tornado.locale.Locale:
         """Determines the user's locale from ``Accept-Language`` header.
-
+        
         See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4
+
+        Parameters
+        ----------
+        default: str :
+             (Default value = "en_US")
+
+        Returns
+        -------
+
         """
         if "Accept-Language" in self.request.headers:
             languages = self.request.headers["Accept-Language"].split(",")
@@ -1307,34 +1935,40 @@
     @property
     def current_user(self) -> Any:
         """The authenticated user for this request.
-
+        
         This is set in one of two ways:
-
+        
         * A subclass may override `get_current_user()`, which will be called
           automatically the first time ``self.current_user`` is accessed.
           `get_current_user()` will only be called once per request,
           and is cached for future access::
-
+        
               def get_current_user(self):
                   user_cookie = self.get_secure_cookie("user")
                   if user_cookie:
                       return json.loads(user_cookie)
-                  return None
-
-        * It may be set as a normal variable, typically from an overridden
-          `prepare()`::
-
-              @gen.coroutine
-              def prepare(self):
-                  user_id_cookie = self.get_secure_cookie("user_id")
-                  if user_id_cookie:
-                      self.current_user = yield load_user(user_id_cookie)
-
-        Note that `prepare()` may be a coroutine while `get_current_user()`
-        may not, so the latter form is necessary if loading the user requires
-        asynchronous operations.
-
-        The user object may be any type of the application's choosing.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            * It may be set as a normal variable, typically from an overridden
+            `prepare()`::
+            
+            @gen.coroutine
+            def prepare(self):
+            user_id_cookie = self.get_secure_cookie("user_id")
+            if user_id_cookie:
+            self.current_user = yield load_user(user_id_cookie)
+            
+            Note that `prepare()` may be a coroutine while `get_current_user()`
+            may not, so the latter form is necessary if loading the user requires
+            asynchronous operations.
+            
+            The user object may be any type of the application's choosing.
+
         """
         if not hasattr(self, "_current_user"):
             self._current_user = self.get_current_user()
@@ -1342,47 +1976,80 @@
 
     @current_user.setter
     def current_user(self, value: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        value: Any :
+            
+
+        Returns
+        -------
+
+        """
         self._current_user = value
 
     def get_current_user(self) -> Any:
         """Override to determine the current user from, e.g., a cookie.
-
+        
         This method may not be a coroutine.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def get_login_url(self) -> str:
         """Override to customize the login URL based on the request.
-
+        
         By default, we use the ``login_url`` application setting.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.require_setting("login_url", "@tornado.web.authenticated")
         return self.application.settings["login_url"]
 
     def get_template_path(self) -> Optional[str]:
         """Override to customize template path for each handler.
-
+        
         By default, we use the ``template_path`` application setting.
-        Return None to load templates relative to the calling file.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            
+
         """
         return self.application.settings.get("template_path")
 
     @property
     def xsrf_token(self) -> bytes:
         """The XSRF-prevention token for the current user/session.
-
+        
         To prevent cross-site request forgery, we set an '_xsrf' cookie
         and include the same '_xsrf' value as an argument with all POST
         requests. If the two do not match, we reject the form submission
         as a potential forgery.
-
+        
         See http://en.wikipedia.org/wiki/Cross-site_request_forgery
-
+        
         This property is of type `bytes`, but it contains only ASCII
         characters. If a character string is required, there is no
         need to base64-encode it; just decode the byte string as
         UTF-8.
-
+        
         .. versionchanged:: 3.2.2
            The xsrf token will now be have a random mask applied in every
            request, which makes it safe to include the token in pages
@@ -1391,7 +2058,7 @@
            cookies will be converted to version 2 when this method is called
            unless the ``xsrf_cookie_version`` `Application` setting is
            set to 1.
-
+        
         .. versionchanged:: 4.3
            The ``xsrf_cookie_kwargs`` `Application` setting may be
            used to supply additional cookie options (which will be
@@ -1399,6 +2066,13 @@
            ``xsrf_cookie_kwargs=dict(httponly=True, secure=True)``
            will set the ``secure`` and ``httponly`` flags on the
            ``_xsrf`` cookie.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not hasattr(self, "_xsrf_token"):
             version, token, timestamp = self._get_raw_xsrf_token()
@@ -1426,14 +2100,21 @@
 
     def _get_raw_xsrf_token(self) -> Tuple[Optional[int], bytes, float]:
         """Read or generate the xsrf token in its raw form.
-
+        
         The raw_xsrf_token is a tuple containing:
-
+        
         * version: the version of the cookie from which this token was read,
           or None if we generated a new token in this request.
         * token: the raw token data; random (non-ascii) bytes.
         * timestamp: the time this token was generated (will not be accurate
           for version 1 cookies)
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         if not hasattr(self, "_raw_xsrf_token"):
             cookie = self.get_cookie("_xsrf")
@@ -1455,6 +2136,15 @@
     ) -> Tuple[Optional[int], Optional[bytes], Optional[float]]:
         """Convert a cookie string into a the tuple form returned by
         _get_raw_xsrf_token.
+
+        Parameters
+        ----------
+        cookie: str :
+            
+
+        Returns
+        -------
+
         """
 
         try:
@@ -1488,21 +2178,28 @@
 
     def check_xsrf_cookie(self) -> None:
         """Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.
-
+        
         To prevent cross-site request forgery, we set an ``_xsrf``
         cookie and include the same value as a non-cookie
         field with all ``POST`` requests. If the two do not match, we
         reject the form submission as a potential forgery.
-
+        
         The ``_xsrf`` value may be set as either a form field named ``_xsrf``
         or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``
         (the latter is accepted for compatibility with Django).
-
+        
         See http://en.wikipedia.org/wiki/Cross-site_request_forgery
-
+        
         .. versionchanged:: 3.2.2
            Added support for cookie version 2.  Both versions 1 and 2 are
            supported.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # Prior to release 1.1.1, this check was ignored if the HTTP header
         # ``X-Requested-With: XMLHTTPRequest`` was present.  This exception
@@ -1526,16 +2223,23 @@
 
     def xsrf_form_html(self) -> str:
         """An HTML ``<input/>`` element to be included with all POST forms.
-
+        
         It defines the ``_xsrf`` input value, which we check on all POST
         requests to prevent cross-site request forgery. If you have set
         the ``xsrf_cookies`` application setting, you must include this
         HTML within all of your HTML forms.
-
+        
         In a template, this method should be called with ``{% module
         xsrf_form_html() %}``
-
+        
         See `check_xsrf_cookie()` above for more information.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return (
             '<input type="hidden" name="_xsrf" value="'
@@ -1547,24 +2251,36 @@
         self, path: str, include_host: Optional[bool] = None, **kwargs: Any
     ) -> str:
         """Returns a static URL for the given relative static file path.
-
+        
         This method requires you set the ``static_path`` setting in your
         application (which specifies the root directory of your static
         files).
-
+        
         This method returns a versioned url (by default appending
         ``?v=<signature>``), which allows the static files to be
         cached indefinitely.  This can be disabled by passing
         ``include_version=False`` (in the default implementation;
         other static file implementations are not required to support
         this, but they may support other options).
-
+        
         By default this method returns URLs relative to the current
         host, but if ``include_host`` is true the URL returned will be
         absolute.  If this handler has an ``include_host`` attribute,
         that value will be used as the default for all `static_url`
         calls that do not pass ``include_host`` as a keyword argument.
 
+        Parameters
+        ----------
+        path: str :
+            
+        include_host: Optional[bool] :
+             (Default value = None)
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         self.require_setting("static_path", "static_url")
         get_url = self.settings.get(
@@ -1582,7 +2298,19 @@
         return base + get_url(self.settings, path, **kwargs)
 
     def require_setting(self, name: str, feature: str = "this feature") -> None:
-        """Raises an exception if the given app setting is not defined."""
+        """Raises an exception if the given app setting is not defined.
+
+        Parameters
+        ----------
+        name: str :
+            
+        feature: str :
+             (Default value = "this feature")
+
+        Returns
+        -------
+
+        """
         if not self.application.settings.get(name):
             raise Exception(
                 "You must define the '%s' setting in your "
@@ -1590,16 +2318,35 @@
             )
 
     def reverse_url(self, name: str, *args: Any) -> str:
-        """Alias for `Application.reverse_url`."""
+        """Alias for `Application.reverse_url`.
+
+        Parameters
+        ----------
+        name: str :
+            
+        *args: Any :
+            
+
+        Returns
+        -------
+
+        """
         return self.application.reverse_url(name, *args)
 
     def compute_etag(self) -> Optional[str]:
         """Computes the etag header to be used for this request.
-
+        
         By default uses a hash of the content written so far.
-
+        
         May be overridden to provide custom etag implementations,
         or may return None to disable tornado's default etag support.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         hasher = hashlib.sha1()
         for part in self._write_buffer:
@@ -1608,10 +2355,17 @@
 
     def set_etag_header(self) -> None:
         """Sets the response's Etag header using ``self.compute_etag()``.
-
+        
         Note: no header will be set if ``compute_etag()`` returns ``None``.
-
+        
         This method is called automatically when the request is finished.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         etag = self.compute_etag()
         if etag is not None:
@@ -1619,20 +2373,26 @@
 
     def check_etag_header(self) -> bool:
         """Checks the ``Etag`` header against requests's ``If-None-Match``.
-
+        
         Returns ``True`` if the request's Etag matches and a 304 should be
         returned. For example::
-
+        
             self.set_etag_header()
             if self.check_etag_header():
                 self.set_status(304)
-                return
-
-        This method is called automatically when the request is finished,
-        but may be called earlier for applications that override
-        `compute_etag` and want to do an early check for ``If-None-Match``
-        before completing the request.  The ``Etag`` header should be set
-        (perhaps with `set_etag_header`) before calling this method.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            This method is called automatically when the request is finished,
+            but may be called earlier for applications that override
+            `compute_etag` and want to do an early check for ``If-None-Match``
+            before completing the request.  The ``Etag`` header should be set
+            (perhaps with `set_etag_header`) before calling this method.
+
         """
         computed_etag = utf8(self._headers.get("Etag", ""))
         # Find all weak and strong etag values from If-None-Match header
@@ -1649,6 +2409,17 @@
         else:
             # Use a weak comparison when comparing entity-tags.
             def val(x: bytes) -> bytes:
+                """
+
+                Parameters
+                ----------
+                x: bytes :
+                    
+
+                Returns
+                -------
+
+                """
                 return x[2:] if x.startswith(b"W/") else x
 
             for etag in etags:
@@ -1720,23 +2491,40 @@
 
     def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]:
         """Implement this method to handle streamed request data.
-
+        
         Requires the `.stream_request_body` decorator.
-
+        
         May be a coroutine for flow control.
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+
+        Returns
+        -------
+
         """
         raise NotImplementedError()
 
     def _log(self) -> None:
         """Logs the current request.
-
+        
         Sort of deprecated since this functionality was moved to the
         Application, but left in place for the benefit of existing apps
         that have overridden this method.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.application.log_request(self)
 
     def _request_summary(self) -> str:
+        """ """
         return "%s %s (%s)" % (
             self.request.method,
             self.request.uri,
@@ -1744,6 +2532,17 @@
         )
 
     def _handle_request_exception(self, e: BaseException) -> None:
+        """
+
+        Parameters
+        ----------
+        e: BaseException :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(e, Finish):
             # Not an error; just finish the request without logging.
             if not self._finished:
@@ -1772,13 +2571,26 @@
         tb: Optional[TracebackType],
     ) -> None:
         """Override to customize logging of uncaught exceptions.
-
+        
         By default logs instances of `HTTPError` as warnings without
         stack traces (on the ``tornado.general`` logger), and all
         other exceptions as errors with stack traces (on the
         ``tornado.application`` logger).
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        typ: "Optional[Type[BaseException]]" :
+            
+        value: Optional[BaseException] :
+            
+        tb: Optional[TracebackType] :
+            
+
+        Returns
+        -------
+
         """
         if isinstance(value, HTTPError):
             if value.log_message:
@@ -1794,7 +2606,33 @@
             )
 
     def _ui_module(self, name: str, module: Type["UIModule"]) -> Callable[..., str]:
+        """
+
+        Parameters
+        ----------
+        name: str :
+            
+        module: Type["UIModule"] :
+            
+
+        Returns
+        -------
+
+        """
         def render(*args, **kwargs) -> str:  # type: ignore
+            """
+
+            Parameters
+            ----------
+            *args :
+                
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             if not hasattr(self, "_active_modules"):
                 self._active_modules = {}  # type: Dict[str, UIModule]
             if name not in self._active_modules:
@@ -1805,9 +2643,23 @@
         return render
 
     def _ui_method(self, method: Callable[..., str]) -> Callable[..., str]:
+        """
+
+        Parameters
+        ----------
+        method: Callable[... :
+            
+        str] :
+            
+
+        Returns
+        -------
+
+        """
         return lambda *args, **kwargs: method(self, *args, **kwargs)
 
     def _clear_representation_headers(self) -> None:
+        """ """
         # 304 responses should not contain representation metadata
         # headers (defined in
         # https://tools.ietf.org/html/rfc7231#section-3.1)
@@ -1820,9 +2672,9 @@
 
 def stream_request_body(cls: Type[RequestHandler]) -> Type[RequestHandler]:
     """Apply to `RequestHandler` subclasses to enable streaming body support.
-
+    
     This decorator implies the following changes:
-
+    
     * `.HTTPServerRequest.body` is undefined, and body arguments will not
       be included in `RequestHandler.get_argument`.
     * `RequestHandler.prepare` is called when the request headers have been
@@ -1835,10 +2687,18 @@
       until those futures have completed.
     * The regular HTTP method (``post``, ``put``, etc) will be called after
       the entire body has been read.
-
+    
     See the `file receiver demo <https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/>`_
     for example usage.
     """  # noqa: E501
+
+    Parameters
+    ----------
+    cls: Type[RequestHandler] :
+        
+
+    Returns
+    -------
     if not issubclass(cls, RequestHandler):
         raise TypeError("expected subclass of RequestHandler, got %r", cls)
     cls._stream_request_body = True
@@ -1846,6 +2706,17 @@
 
 
 def _has_stream_request_body(cls: Type[RequestHandler]) -> bool:
+    """
+
+    Parameters
+    ----------
+    cls: Type[RequestHandler] :
+        
+
+    Returns
+    -------
+
+    """
     if not issubclass(cls, RequestHandler):
         raise TypeError("expected subclass of RequestHandler, got %r", cls)
     return cls._stream_request_body
@@ -1855,16 +2726,42 @@
     method: Callable[..., Optional[Awaitable[None]]]
 ) -> Callable[..., Optional[Awaitable[None]]]:
     """Use this decorator to remove trailing slashes from the request path.
-
+    
     For example, a request to ``/foo/`` would redirect to ``/foo`` with this
     decorator. Your request handler mapping should use a regular expression
     like ``r'/foo/*'`` in conjunction with using the decorator.
+
+    Parameters
+    ----------
+    method: Callable[... :
+        
+    Optional[Awaitable[None]]] :
+        
+
+    Returns
+    -------
+
     """
 
     @functools.wraps(method)
     def wrapper(  # type: ignore
         self: RequestHandler, *args, **kwargs
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        # type: ignoreself: RequestHandler :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if self.request.path.endswith("/"):
             if self.request.method in ("GET", "HEAD"):
                 uri = self.request.path.rstrip("/")
@@ -1884,16 +2781,42 @@
     method: Callable[..., Optional[Awaitable[None]]]
 ) -> Callable[..., Optional[Awaitable[None]]]:
     """Use this decorator to add a missing trailing slash to the request path.
-
+    
     For example, a request to ``/foo`` would redirect to ``/foo/`` with this
     decorator. Your request handler mapping should use a regular expression
     like ``r'/foo/?'`` in conjunction with using the decorator.
+
+    Parameters
+    ----------
+    method: Callable[... :
+        
+    Optional[Awaitable[None]]] :
+        
+
+    Returns
+    -------
+
     """
 
     @functools.wraps(method)
     def wrapper(  # type: ignore
         self: RequestHandler, *args, **kwargs
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        # type: ignoreself: RequestHandler :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if not self.request.path.endswith("/"):
             if self.request.method in ("GET", "HEAD"):
                 uri = self.request.path + "/"
@@ -1909,13 +2832,20 @@
 
 class _ApplicationRouter(ReversibleRuleRouter):
     """Routing implementation used internally by `Application`.
-
+    
     Provides a binding between `Application` and `RequestHandler`.
     This implementation extends `~.routing.ReversibleRuleRouter` in a couple of ways:
         * it allows to use `RequestHandler` subclasses as `~.routing.Rule` target and
         * it allows to use a list/tuple of rules as `~.routing.Rule` target.
         ``process_rule`` implementation will substitute this list with an appropriate
         `_ApplicationRouter` instance.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -1926,6 +2856,17 @@
         super().__init__(rules)
 
     def process_rule(self, rule: Rule) -> Rule:
+        """
+
+        Parameters
+        ----------
+        rule: Rule :
+            
+
+        Returns
+        -------
+
+        """
         rule = super().process_rule(rule)
 
         if isinstance(rule.target, (list, tuple)):
@@ -1938,6 +2879,21 @@
     def get_target_delegate(
         self, target: Any, request: httputil.HTTPServerRequest, **target_params: Any
     ) -> Optional[httputil.HTTPMessageDelegate]:
+        """
+
+        Parameters
+        ----------
+        target: Any :
+            
+        request: httputil.HTTPServerRequest :
+            
+        **target_params: Any :
+            
+
+        Returns
+        -------
+
+        """
         if isclass(target) and issubclass(target, RequestHandler):
             return self.application.get_handler_delegate(
                 request, target, **target_params
@@ -1947,68 +2903,68 @@
 
 
 class Application(ReversibleRouter):
-    r"""A collection of request handlers that make up a web application.
-
+    """r"""A collection of request handlers that make up a web application.
+    
     Instances of this class are callable and can be passed directly to
     HTTPServer to serve the application::
-
+    
         application = web.Application([
             (r"/", MainPageHandler),
         ])
         http_server = httpserver.HTTPServer(application)
         http_server.listen(8080)
         ioloop.IOLoop.current().start()
-
+    
     The constructor for this class takes in a list of `~.routing.Rule`
     objects or tuples of values corresponding to the arguments of
     `~.routing.Rule` constructor: ``(matcher, target, [target_kwargs], [name])``,
     the values in square brackets being optional. The default matcher is
     `~.routing.PathMatches`, so ``(regexp, target)`` tuples can also be used
     instead of ``(PathMatches(regexp), target)``.
-
+    
     A common routing target is a `RequestHandler` subclass, but you can also
     use lists of rules as a target, which create a nested routing configuration::
-
+    
         application = web.Application([
             (HostMatches("example.com"), [
                 (r"/", MainPageHandler),
                 (r"/feed", FeedHandler),
             ]),
         ])
-
+    
     In addition to this you can use nested `~.routing.Router` instances,
     `~.httputil.HTTPMessageDelegate` subclasses and callables as routing targets
     (see `~.routing` module docs for more information).
-
+    
     When we receive requests, we iterate over the list in order and
     instantiate an instance of the first request class whose regexp
     matches the request path. The request class can be specified as
     either a class object or a (fully-qualified) name.
-
+    
     A dictionary may be passed as the third element (``target_kwargs``)
     of the tuple, which will be used as keyword arguments to the handler's
     constructor and `~RequestHandler.initialize` method. This pattern
     is used for the `StaticFileHandler` in this example (note that a
     `StaticFileHandler` can be installed automatically with the
     static_path setting described below)::
-
+    
         application = web.Application([
             (r"/static/(.*)", web.StaticFileHandler, {"path": "/var/www"}),
         ])
-
+    
     We support virtual hosts with the `add_handlers` method, which takes in
     a host regular expression as the first argument::
-
+    
         application.add_handlers(r"www\.myhost\.com", [
             (r"/article/([0-9]+)", ArticleHandler),
         ])
-
+    
     If there's no match for the current request's host, then ``default_host``
     parameter value is matched against host regular expressions.
-
-
+    
+    
     .. warning::
-
+    
        Applications that do not use TLS may be vulnerable to :ref:`DNS
        rebinding <dnsrebinding>` attacks. This attack is especially
        relevant to applications that only listen on ``127.0.0.1`` or
@@ -2016,7 +2972,7 @@
        (instead of the default of ``r'.*'``) to prevent this risk. The
        ``default_host`` argument must not be used in applications that
        may be vulnerable to DNS rebinding.
-
+    
     You can serve static files by sending the ``static_path`` setting
     as a keyword argument. We will serve those files from the
     ``/static/`` URI (this is configurable with the
@@ -2024,11 +2980,15 @@
     and ``/robots.txt`` from the same directory.  A custom subclass of
     `StaticFileHandler` can be specified with the
     ``static_handler_class`` setting.
-
+    
     .. versionchanged:: 4.5
        Integration with the new `tornado.routing` module.
 
-    """
+    Parameters
+    ----------
+
+    Returns
+    -------
 
     def __init__(
         self,
@@ -2088,7 +3048,7 @@
 
     def listen(self, port: int, address: str = "", **kwargs: Any) -> HTTPServer:
         """Starts an HTTP server for this application on the given port.
-
+        
         This is a convenience alias for creating an `.HTTPServer`
         object and calling its listen method.  Keyword arguments not
         supported by `HTTPServer.listen <.TCPServer.listen>` are passed to the
@@ -2096,14 +3056,27 @@
         (e.g. multi-process mode), do not use this method; create an
         `.HTTPServer` and call its
         `.TCPServer.bind`/`.TCPServer.start` methods directly.
-
+        
         Note that after calling this method you still need to call
         ``IOLoop.current().start()`` to start the server.
-
+        
         Returns the `.HTTPServer` object.
-
+        
         .. versionchanged:: 4.3
            Now returns the `.HTTPServer` object.
+
+        Parameters
+        ----------
+        port: int :
+            
+        address: str :
+             (Default value = "")
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
         """
         server = HTTPServer(self, **kwargs)
         server.listen(port, address)
@@ -2111,9 +3084,20 @@
 
     def add_handlers(self, host_pattern: str, host_handlers: _RuleList) -> None:
         """Appends the given handlers to our handler list.
-
+        
         Host patterns are processed sequentially in the order they were
         added. All matching patterns will be considered.
+
+        Parameters
+        ----------
+        host_pattern: str :
+            
+        host_handlers: _RuleList :
+            
+
+        Returns
+        -------
+
         """
         host_matcher = HostMatches(host_pattern)
         rule = Rule(host_matcher, _ApplicationRouter(self, host_handlers))
@@ -2126,9 +3110,31 @@
             )
 
     def add_transform(self, transform_class: Type["OutputTransform"]) -> None:
+        """
+
+        Parameters
+        ----------
+        transform_class: Type["OutputTransform"] :
+            
+
+        Returns
+        -------
+
+        """
         self.transforms.append(transform_class)
 
     def _load_ui_methods(self, methods: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        methods: Any :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(methods, types.ModuleType):
             self._load_ui_methods(dict((n, getattr(methods, n)) for n in dir(methods)))
         elif isinstance(methods, list):
@@ -2144,6 +3150,17 @@
                     self.ui_methods[name] = fn
 
     def _load_ui_modules(self, modules: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        modules: Any :
+            
+
+        Returns
+        -------
+
+        """
         if isinstance(modules, types.ModuleType):
             self._load_ui_modules(dict((n, getattr(modules, n)) for n in dir(modules)))
         elif isinstance(modules, list):
@@ -2168,6 +3185,19 @@
     def find_handler(
         self, request: httputil.HTTPServerRequest, **kwargs: Any
     ) -> "_HandlerDelegate":
+        """
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         route = self.default_router.find_handler(request)
         if route is not None:
             return cast("_HandlerDelegate", route)
@@ -2191,13 +3221,34 @@
     ) -> "_HandlerDelegate":
         """Returns `~.httputil.HTTPMessageDelegate` that can serve a request
         for application and `RequestHandler` subclass.
-
+        
         :arg httputil.HTTPServerRequest request: current HTTP request.
         :arg RequestHandler target_class: a `RequestHandler` class.
         :arg dict target_kwargs: keyword arguments for ``target_class`` constructor.
         :arg list path_args: positional arguments for ``target_class`` HTTP method that
             will be executed while handling a request (``get``, ``post`` or any other).
         :arg dict path_kwargs: keyword arguments for ``target_class`` HTTP method.
+
+        Parameters
+        ----------
+        request: httputil.HTTPServerRequest :
+            
+        target_class: Type[RequestHandler] :
+            
+        target_kwargs: Optional[Dict[str :
+            
+        Any]] :
+             (Default value = None)
+        path_args: Optional[List[bytes]] :
+             (Default value = None)
+        path_kwargs: Optional[Dict[str :
+            
+        bytes]] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         return _HandlerDelegate(
             self, request, target_class, target_kwargs, path_args, path_kwargs
@@ -2205,12 +3256,23 @@
 
     def reverse_url(self, name: str, *args: Any) -> str:
         """Returns a URL path for handler named ``name``
-
+        
         The handler must be added to the application as a named `URLSpec`.
-
+        
         Args will be substituted for capturing groups in the `URLSpec` regex.
         They will be converted to strings if necessary, encoded as utf8,
         and url-escaped.
+
+        Parameters
+        ----------
+        name: str :
+            
+        *args: Any :
+            
+
+        Returns
+        -------
+
         """
         reversed_url = self.default_router.reverse_url(name, *args)
         if reversed_url is not None:
@@ -2220,11 +3282,20 @@
 
     def log_request(self, handler: RequestHandler) -> None:
         """Writes a completed HTTP request to the logs.
-
+        
         By default writes to the python root logger.  To change
         this behavior either subclass Application and override this method,
         or pass a function in the application settings dictionary as
         ``log_function``.
+
+        Parameters
+        ----------
+        handler: RequestHandler :
+            
+
+        Returns
+        -------
+
         """
         if "log_function" in self.settings:
             self.settings["log_function"](handler)
@@ -2245,6 +3316,7 @@
 
 
 class _HandlerDelegate(httputil.HTTPMessageDelegate):
+    """ """
     def __init__(
         self,
         application: Application,
@@ -2269,12 +3341,38 @@
         start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],
         headers: httputil.HTTPHeaders,
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        start_line: Union[httputil.RequestStartLine :
+            
+        httputil.ResponseStartLine] :
+            
+        headers: httputil.HTTPHeaders :
+            
+
+        Returns
+        -------
+
+        """
         if self.stream_request_body:
             self.request._body_future = Future()
             return self.execute()
         return None
 
     def data_received(self, data: bytes) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        data: bytes :
+            
+
+        Returns
+        -------
+
+        """
         if self.stream_request_body:
             return self.handler.data_received(data)
         else:
@@ -2282,6 +3380,7 @@
             return None
 
     def finish(self) -> None:
+        """ """
         if self.stream_request_body:
             future_set_result_unless_cancelled(self.request._body_future, None)
         else:
@@ -2290,12 +3389,14 @@
             self.execute()
 
     def on_connection_close(self) -> None:
+        """ """
         if self.stream_request_body:
             self.handler.on_connection_close()
         else:
             self.chunks = None  # type: ignore
 
     def execute(self) -> Optional[Awaitable[None]]:
+        """ """
         # If template cache is disabled (usually in the debug mode),
         # re-compile templates and reload static files on every
         # request so you don't need to restart to see changes
@@ -2332,14 +3433,14 @@
 
 class HTTPError(Exception):
     """An exception that will turn into an HTTP error response.
-
+    
     Raising an `HTTPError` is a convenient alternative to calling
     `RequestHandler.send_error` since it automatically ends the
     current function.
-
+    
     To customize the response sent with an `HTTPError`, override
     `RequestHandler.write_error`.
-
+    
     :arg int status_code: HTTP status code.  Must be listed in
         `httplib.responses <http.client.responses>` unless the ``reason``
         keyword argument is given.
@@ -2351,6 +3452,13 @@
         to pass in the status line along with ``status_code``.  Normally
         determined automatically from ``status_code``, but can be used
         to use a non-standard numeric code.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(
@@ -2380,39 +3488,59 @@
 
 class Finish(Exception):
     """An exception that ends the request without producing an error response.
-
+    
     When `Finish` is raised in a `RequestHandler`, the request will
     end (calling `RequestHandler.finish` if it hasn't already been
     called), but the error-handling methods (including
     `RequestHandler.write_error`) will not be called.
-
+    
     If `Finish()` was created with no arguments, the pending response
     will be sent as-is. If `Finish()` was given an argument, that
     argument will be passed to `RequestHandler.finish()`.
-
+    
     This can be a more convenient way to implement custom error pages
     than overriding ``write_error`` (especially in library code)::
-
+    
         if self.current_user is None:
             self.set_status(401)
             self.set_header('WWW-Authenticate', 'Basic realm="something"')
-            raise Finish()
-
-    .. versionchanged:: 4.3
-       Arguments passed to ``Finish()`` will be passed on to
-       `RequestHandler.finish`.
+
+    Parameters
+    ----------
+    RequestHandler :
+        finish
+
+    Returns
+    -------
+
+    Raises
+    ------
+    .
+        versionchanged
+
     """
 
     pass
 
 
 class MissingArgumentError(HTTPError):
-    """Exception raised by `RequestHandler.get_argument`.
-
-    This is a subclass of `HTTPError`, so if it is uncaught a 400 response
-    code will be used instead of 500 (and a stack trace will not be logged).
-
-    .. versionadded:: 3.1
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    Raises
+    ------
+    This
+        is a subclass of
+    code
+        will be used instead of 500
+    .
+        versionadded
+
     """
 
     def __init__(self, arg_name: str) -> None:
@@ -2424,12 +3552,25 @@
     """Generates an error response with ``status_code`` for all requests."""
 
     def initialize(self, status_code: int) -> None:
+        """
+
+        Parameters
+        ----------
+        status_code: int :
+            
+
+        Returns
+        -------
+
+        """
         self.set_status(status_code)
 
     def prepare(self) -> None:
+        """ """
         raise HTTPError(self._status_code)
 
     def check_xsrf_cookie(self) -> None:
+        """ """
         # POSTs to an ErrorHandler don't actually have side effects,
         # so we don't need to check the xsrf token.  This allows POSTs
         # to the wrong url to return a 404 instead of 403.
@@ -2438,42 +3579,75 @@
 
 class RedirectHandler(RequestHandler):
     """Redirects the client to the given URL for all GET requests.
-
+    
     You should provide the keyword argument ``url`` to the handler, e.g.::
-
+    
         application = web.Application([
             (r"/oldpath", web.RedirectHandler, {"url": "/newpath"}),
         ])
-
+    
     `RedirectHandler` supports regular expression substitutions. E.g., to
     swap the first and second parts of a path while preserving the remainder::
-
+    
         application = web.Application([
             (r"/(.*?)/(.*?)/(.*)", web.RedirectHandler, {"url": "/{1}/{0}/{2}"}),
         ])
-
+    
     The final URL is formatted with `str.format` and the substrings that match
     the capturing groups. In the above example, a request to "/a/b/c" would be
     formatted like::
-
+    
         str.format("/{1}/{0}/{2}", "a", "b", "c")  # -> "/b/a/c"
-
+    
     Use Python's :ref:`format string syntax <formatstrings>` to customize how
     values are substituted.
-
+    
     .. versionchanged:: 4.5
        Added support for substitutions into the destination URL.
-
+    
     .. versionchanged:: 5.0
        If any query arguments are present, they will be copied to the
        destination URL.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(self, url: str, permanent: bool = True) -> None:
+        """
+
+        Parameters
+        ----------
+        url: str :
+            
+        permanent: bool :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         self._url = url
         self._permanent = permanent
 
     def get(self, *args: Any, **kwargs: Any) -> None:
+        """
+
+        Parameters
+        ----------
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         to_url = self._url.format(*args, **kwargs)
         if self.request.query_arguments:
             # TODO: figure out typing for the next line.
@@ -2486,69 +3660,76 @@
 
 class StaticFileHandler(RequestHandler):
     """A simple handler that can serve static content from a directory.
-
+    
     A `StaticFileHandler` is configured automatically if you pass the
     ``static_path`` keyword argument to `Application`.  This handler
     can be customized with the ``static_url_prefix``, ``static_handler_class``,
     and ``static_handler_args`` settings.
-
+    
     To map an additional path to this handler for a static data directory
     you would add a line to your application like::
-
+    
         application = web.Application([
             (r"/content/(.*)", web.StaticFileHandler, {"path": "/var/www"}),
         ])
-
+    
     The handler constructor requires a ``path`` argument, which specifies the
     local root directory of the content to be served.
-
+    
     Note that a capture group in the regex is required to parse the value for
     the ``path`` argument to the get() method (different than the constructor
     argument above); see `URLSpec` for details.
-
+    
     To serve a file like ``index.html`` automatically when a directory is
     requested, set ``static_handler_args=dict(default_filename="index.html")``
     in your application settings, or add ``default_filename`` as an initializer
     argument for your ``StaticFileHandler``.
-
+    
     To maximize the effectiveness of browser caching, this class supports
     versioned urls (by default using the argument ``?v=``).  If a version
     is given, we instruct the browser to cache this file indefinitely.
     `make_static_url` (also available as `RequestHandler.static_url`) can
     be used to construct a versioned url.
-
+    
     This handler is intended primarily for use in development and light-duty
     file serving; for heavy traffic it will be more efficient to use
     a dedicated static file server (such as nginx or Apache).  We support
     the HTTP ``Accept-Ranges`` mechanism to return partial content (because
     some browsers require this functionality to be present to seek in
     HTML5 audio or video).
-
+    
     **Subclassing notes**
-
+    
     This class is designed to be extensible by subclassing, but because
     of the way static urls are generated with class methods rather than
     instance methods, the inheritance patterns are somewhat unusual.
     Be sure to use the ``@classmethod`` decorator when overriding a
     class method.  Instance methods may use the attributes ``self.path``
     ``self.absolute_path``, and ``self.modified``.
-
+    
     Subclasses should only override methods discussed in this section;
     overriding other methods is error-prone.  Overriding
     ``StaticFileHandler.get`` is particularly problematic due to the
     tight coupling with ``compute_etag`` and other methods.
-
+    
     To change the way static urls are generated (e.g. to match the behavior
     of another server or CDN), override `make_static_url`, `parse_url_path`,
     `get_cache_time`, and/or `get_version`.
-
+    
     To replace all interaction with the filesystem (e.g. to serve
     static content from a database), override `get_content`,
     `get_content_size`, `get_modified_time`, `get_absolute_path`, and
     `validate_absolute_path`.
-
+    
     .. versionchanged:: 3.1
        Many of the methods for subclasses were added in Tornado 3.1.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     CACHE_MAX_AGE = 86400 * 365 * 10  # 10 years
@@ -2557,15 +3738,40 @@
     _lock = threading.Lock()  # protects _static_hashes
 
     def initialize(self, path: str, default_filename: Optional[str] = None) -> None:
+        """
+
+        Parameters
+        ----------
+        path: str :
+            
+        default_filename: Optional[str] :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         self.root = path
         self.default_filename = default_filename
 
     @classmethod
     def reset(cls) -> None:
+        """ """
         with cls._lock:
             cls._static_hashes = {}
 
     def head(self, path: str) -> Awaitable[None]:
+        """
+
+        Parameters
+        ----------
+        path: str :
+            
+
+        Returns
+        -------
+
+        """
         return self.get(path, include_body=False)
 
     async def get(self, path: str, include_body: bool = True) -> None:
@@ -2653,12 +3859,19 @@
 
     def compute_etag(self) -> Optional[str]:
         """Sets the ``Etag`` header based on static url version.
-
+        
         This allows efficient ``If-None-Match`` checks against cached
         versions, and sends the correct ``Etag`` for a partial response
         (i.e. the same ``Etag`` as the full file).
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         assert self.absolute_path is not None
         version_hash = self._get_cached_version(self.absolute_path)
@@ -2668,8 +3881,15 @@
 
     def set_headers(self) -> None:
         """Sets the content and caching headers on the response.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         self.set_header("Accept-Ranges", "bytes")
         self.set_etag_header()
@@ -2693,8 +3913,15 @@
 
     def should_return_304(self) -> bool:
         """Returns True if the headers indicate that we should return 304.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         # If client sent If-None-Match, use it, ignore If-Modified-Since
         if self.request.headers.get("If-None-Match"):
@@ -2716,39 +3943,61 @@
     @classmethod
     def get_absolute_path(cls, root: str, path: str) -> str:
         """Returns the absolute location of ``path`` relative to ``root``.
-
+        
         ``root`` is the path configured for this `StaticFileHandler`
         (in most cases the ``static_path`` `Application` setting).
-
+        
         This class method may be overridden in subclasses.  By default
         it returns a filesystem path, but other strings may be used
         as long as they are unique and understood by the subclass's
         overridden `get_content`.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        root: str :
+            
+        path: str :
+            
+
+        Returns
+        -------
+
         """
         abspath = os.path.abspath(os.path.join(root, path))
         return abspath
 
     def validate_absolute_path(self, root: str, absolute_path: str) -> Optional[str]:
         """Validate and return the absolute path.
-
+        
         ``root`` is the configured path for the `StaticFileHandler`,
         and ``path`` is the result of `get_absolute_path`
-
+        
         This is an instance method called during request processing,
         so it may raise `HTTPError` or use methods like
         `RequestHandler.redirect` (return None after redirecting to
         halt further processing).  This is where 404 errors for missing files
         are generated.
-
+        
         This method may modify the path before returning it, but note that
         any such modifications will not be understood by `make_static_url`.
-
+        
         In instance methods, this method's result is available as
         ``self.absolute_path``.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        root: str :
+            
+        absolute_path: str :
+            
+
+        Returns
+        -------
+
         """
         # os.path.abspath strips a trailing /.
         # We must add it back to `root` so that we only match files
@@ -2786,17 +4035,30 @@
     ) -> Generator[bytes, None, None]:
         """Retrieve the content of the requested resource which is located
         at the given absolute path.
-
+        
         This class method may be overridden by subclasses.  Note that its
         signature is different from other overridable class methods
         (no ``settings`` argument); this is deliberate to ensure that
         ``abspath`` is able to stand on its own as a cache key.
-
+        
         This method should either return a byte string or an iterator
         of byte strings.  The latter is preferred for large files
         as it helps reduce memory fragmentation.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        abspath: str :
+            
+        start: Optional[int] :
+             (Default value = None)
+        end: Optional[int] :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         with open(abspath, "rb") as file:
             if start is not None:
@@ -2822,11 +4084,20 @@
     @classmethod
     def get_content_version(cls, abspath: str) -> str:
         """Returns a version string for the resource at the given path.
-
+        
         This class method may be overridden by subclasses.  The
         default implementation is a SHA-512 hash of the file's contents.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+        abspath: str :
+            
+
+        Returns
+        -------
+
         """
         data = cls.get_content(abspath)
         hasher = hashlib.sha512()
@@ -2838,6 +4109,7 @@
         return hasher.hexdigest()
 
     def _stat(self) -> os.stat_result:
+        """ """
         assert self.absolute_path is not None
         if not hasattr(self, "_stat_result"):
             self._stat_result = os.stat(self.absolute_path)
@@ -2845,25 +4117,39 @@
 
     def get_content_size(self) -> int:
         """Retrieve the total size of the resource at the given path.
-
+        
         This method may be overridden by subclasses.
-
+        
         .. versionadded:: 3.1
-
+        
         .. versionchanged:: 4.0
            This method is now always called, instead of only when
            partial results are requested.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         stat_result = self._stat()
         return stat_result.st_size
 
     def get_modified_time(self) -> Optional[datetime.datetime]:
         """Returns the time that ``self.absolute_path`` was last modified.
-
+        
         May be overridden in subclasses.  Should return a `~datetime.datetime`
         object or None.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         stat_result = self._stat()
         # NOTE: Historically, this used stat_result[stat.ST_MTIME],
@@ -2879,8 +4165,15 @@
 
     def get_content_type(self) -> str:
         """Returns the ``Content-Type`` header to be used for this request.
-
+        
         .. versionadded:: 3.1
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         assert self.absolute_path is not None
         mime_type, encoding = mimetypes.guess_type(self.absolute_path)
@@ -2899,7 +4192,17 @@
             return "application/octet-stream"
 
     def set_extra_headers(self, path: str) -> None:
-        """For subclass to add extra headers to the response"""
+        """For subclass to add extra headers to the response
+
+        Parameters
+        ----------
+        path: str :
+            
+
+        Returns
+        -------
+
+        """
         pass
 
     def get_cache_time(
@@ -2907,13 +4210,25 @@
     ) -> int:
         """Override to customize cache control behavior.
 
-        Return a positive number of seconds to make the result
-        cacheable for that amount of time or 0 to mark resource as
-        cacheable for an unspecified amount of time (subject to
-        browser heuristics).
-
-        By default returns cache expiry of 10 years for resources requested
-        with ``v`` argument.
+        Parameters
+        ----------
+        path: str :
+            
+        modified: Optional[datetime.datetime] :
+            
+        mime_type: str :
+            
+
+        Returns
+        -------
+        type
+            cacheable for that amount of time or 0 to mark resource as
+            cacheable for an unspecified amount of time (subject to
+            browser heuristics).
+            
+            By default returns cache expiry of 10 years for resources requested
+            with ``v`` argument.
+
         """
         return self.CACHE_MAX_AGE if "v" in self.request.arguments else 0
 
@@ -2922,21 +4237,39 @@
         cls, settings: Dict[str, Any], path: str, include_version: bool = True
     ) -> str:
         """Constructs a versioned url for the given path.
-
+        
         This method may be overridden in subclasses (but note that it
         is a class method rather than an instance method).  Subclasses
         are only required to implement the signature
         ``make_static_url(cls, settings, path)``; other keyword
-        arguments may be passed through `~RequestHandler.static_url`
-        but are not standard.
-
-        ``settings`` is the `Application.settings` dictionary.  ``path``
-        is the static path being requested.  The url returned should be
-        relative to the current host.
-
-        ``include_version`` determines whether the generated URL should
-        include the query string containing the version hash of the
-        file corresponding to the given ``path``.
+
+        Parameters
+        ----------
+        but :
+            are not standard
+        settings :
+            is the
+        is :
+            the static path being requested
+        relative :
+            to the current host
+        include_version :
+            determines whether the generated URL should
+        include :
+            the query string containing the version hash of the
+        file :
+            corresponding to the given
+        settings: Dict[str :
+            
+        Any] :
+            
+        path: str :
+            
+        include_version: bool :
+             (Default value = True)
+
+        Returns
+        -------
 
         """
         url = settings.get("static_url_prefix", "/static/") + path
@@ -2951,12 +4284,21 @@
 
     def parse_url_path(self, url_path: str) -> str:
         """Converts a static URL path into a filesystem path.
-
+        
         ``url_path`` is the path component of the URL with
         ``static_url_prefix`` removed.  The return value should be
         filesystem path relative to ``static_path``.
-
+        
         This is the inverse of `make_static_url`.
+
+        Parameters
+        ----------
+        url_path: str :
+            
+
+        Returns
+        -------
+
         """
         if os.path.sep != "/":
             url_path = url_path.replace("/", os.path.sep)
@@ -2965,22 +4307,46 @@
     @classmethod
     def get_version(cls, settings: Dict[str, Any], path: str) -> Optional[str]:
         """Generate the version string to be used in static URLs.
-
+        
         ``settings`` is the `Application.settings` dictionary and ``path``
         is the relative location of the requested asset on the filesystem.
         The returned value should be a string, or ``None`` if no version
         could be determined.
-
+        
         .. versionchanged:: 3.1
            This method was previously recommended for subclasses to override;
            `get_content_version` is now preferred as it allows the base
            class to handle caching of the result.
+
+        Parameters
+        ----------
+        settings: Dict[str :
+            
+        Any] :
+            
+        path: str :
+            
+
+        Returns
+        -------
+
         """
         abs_path = cls.get_absolute_path(settings["static_path"], path)
         return cls._get_cached_version(abs_path)
 
     @classmethod
     def _get_cached_version(cls, abs_path: str) -> Optional[str]:
+        """
+
+        Parameters
+        ----------
+        abs_path: str :
+            
+
+        Returns
+        -------
+
+        """
         with cls._lock:
             hashes = cls._static_hashes
             if abs_path not in hashes:
@@ -2997,27 +4363,48 @@
 
 class FallbackHandler(RequestHandler):
     """A `RequestHandler` that wraps another HTTP server callback.
-
+    
     The fallback is a callable object that accepts an
     `~.httputil.HTTPServerRequest`, such as an `Application` or
     `tornado.wsgi.WSGIContainer`.  This is most useful to use both
     Tornado ``RequestHandlers`` and WSGI in the same server.  Typical
     usage::
-
+    
         wsgi_app = tornado.wsgi.WSGIContainer(
             django.core.handlers.wsgi.WSGIHandler())
         application = tornado.web.Application([
             (r"/foo", FooHandler),
             (r".*", FallbackHandler, dict(fallback=wsgi_app),
         ])
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def initialize(
         self, fallback: Callable[[httputil.HTTPServerRequest], None]
     ) -> None:
+        """
+
+        Parameters
+        ----------
+        fallback: Callable[[httputil.HTTPServerRequest] :
+            
+        None] :
+            
+
+        Returns
+        -------
+
+        """
         self.fallback = fallback
 
     def prepare(self) -> None:
+        """ """
         self.fallback(self.request)
         self._finished = True
         self.on_finish()
@@ -3025,10 +4412,17 @@
 
 class OutputTransform(object):
     """A transform modifies the result of an HTTP request (e.g., GZip encoding)
-
+    
     Applications are not expected to create their own OutputTransforms
     or interact with them directly; the framework chooses which transforms
     (if any) to apply.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, request: httputil.HTTPServerRequest) -> None:
@@ -3041,21 +4435,58 @@
         chunk: bytes,
         finishing: bool,
     ) -> Tuple[int, httputil.HTTPHeaders, bytes]:
+        """
+
+        Parameters
+        ----------
+        status_code: int :
+            
+        headers: httputil.HTTPHeaders :
+            
+        chunk: bytes :
+            
+        finishing: bool :
+            
+
+        Returns
+        -------
+
+        """
         return status_code, headers, chunk
 
     def transform_chunk(self, chunk: bytes, finishing: bool) -> bytes:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+        finishing: bool :
+            
+
+        Returns
+        -------
+
+        """
         return chunk
 
 
 class GZipContentEncoding(OutputTransform):
     """Applies the gzip content encoding to the response.
-
+    
     See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11
-
+    
     .. versionchanged:: 4.0
         Now compresses all mime types beginning with ``text/``, instead
         of just a whitelist. (the whitelist is still used for certain
         non-text mime types).
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     # Whitelist of compressible mime types (in addition to any types
@@ -3086,6 +4517,17 @@
         self._gzipping = "gzip" in request.headers.get("Accept-Encoding", "")
 
     def _compressible_type(self, ctype: str) -> bool:
+        """
+
+        Parameters
+        ----------
+        ctype: str :
+            
+
+        Returns
+        -------
+
+        """
         return ctype.startswith("text/") or ctype in self.CONTENT_TYPES
 
     def transform_first_chunk(
@@ -3095,6 +4537,23 @@
         chunk: bytes,
         finishing: bool,
     ) -> Tuple[int, httputil.HTTPHeaders, bytes]:
+        """
+
+        Parameters
+        ----------
+        status_code: int :
+            
+        headers: httputil.HTTPHeaders :
+            
+        chunk: bytes :
+            
+        finishing: bool :
+            
+
+        Returns
+        -------
+
+        """
         # TODO: can/should this type be inherited from the superclass?
         if "Vary" in headers:
             headers["Vary"] += ", Accept-Encoding"
@@ -3126,6 +4585,19 @@
         return status_code, headers, chunk
 
     def transform_chunk(self, chunk: bytes, finishing: bool) -> bytes:
+        """
+
+        Parameters
+        ----------
+        chunk: bytes :
+            
+        finishing: bool :
+            
+
+        Returns
+        -------
+
+        """
         if self._gzipping:
             self._gzip_file.write(chunk)
             if finishing:
@@ -3142,20 +4614,46 @@
     method: Callable[..., Optional[Awaitable[None]]]
 ) -> Callable[..., Optional[Awaitable[None]]]:
     """Decorate methods with this to require that the user be logged in.
-
+    
     If the user is not logged in, they will be redirected to the configured
     `login url <RequestHandler.get_login_url>`.
-
+    
     If you configure a login url with a query parameter, Tornado will
     assume you know what you're doing and use it as-is.  If not, it
     will add a `next` parameter so the login page knows where to send
     you once you're logged in.
+
+    Parameters
+    ----------
+    method: Callable[... :
+        
+    Optional[Awaitable[None]]] :
+        
+
+    Returns
+    -------
+
     """
 
     @functools.wraps(method)
     def wrapper(  # type: ignore
         self: RequestHandler, *args, **kwargs
     ) -> Optional[Awaitable[None]]:
+        """
+
+        Parameters
+        ----------
+        # type: ignoreself: RequestHandler :
+            
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         if not self.current_user:
             if self.request.method in ("GET", "HEAD"):
                 url = self.get_login_url()
@@ -3177,12 +4675,19 @@
 
 class UIModule(object):
     """A re-usable, modular UI unit on a page.
-
+    
     UI modules often execute additional queries, and they can include
     additional CSS and JavaScript that will be included in the output
     page, which is automatically inserted on page render.
-
+    
     Subclasses of UIModule must override the `render` method.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, handler: RequestHandler) -> None:
@@ -3193,72 +4698,157 @@
 
     @property
     def current_user(self) -> Any:
+        """ """
         return self.handler.current_user
 
     def render(self, *args: Any, **kwargs: Any) -> str:
-        """Override in subclasses to return this module's output."""
+        """Override in subclasses to return this module's output.
+
+        Parameters
+        ----------
+        *args: Any :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         raise NotImplementedError()
 
     def embedded_javascript(self) -> Optional[str]:
         """Override to return a JavaScript string
-        to be embedded in the page."""
+        to be embedded in the page.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         return None
 
     def javascript_files(self) -> Optional[Iterable[str]]:
         """Override to return a list of JavaScript files needed by this module.
-
+        
         If the return values are relative paths, they will be passed to
         `RequestHandler.static_url`; otherwise they will be used as-is.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def embedded_css(self) -> Optional[str]:
         """Override to return a CSS string
-        that will be embedded in the page."""
+        that will be embedded in the page.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         return None
 
     def css_files(self) -> Optional[Iterable[str]]:
         """Override to returns a list of CSS files required by this module.
-
+        
         If the return values are relative paths, they will be passed to
         `RequestHandler.static_url`; otherwise they will be used as-is.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def html_head(self) -> Optional[str]:
         """Override to return an HTML string that will be put in the <head/>
         element.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def html_body(self) -> Optional[str]:
         """Override to return an HTML string that will be put at the end of
         the <body/> element.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         return None
 
     def render_string(self, path: str, **kwargs: Any) -> bytes:
-        """Renders a template and returns it as a string."""
+        """Renders a template and returns it as a string.
+
+        Parameters
+        ----------
+        path: str :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         return self.handler.render_string(path, **kwargs)
 
 
 class _linkify(UIModule):
+    """ """
     def render(self, text: str, **kwargs: Any) -> str:  # type: ignore
+        """
+
+        Parameters
+        ----------
+        text: str :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         return escape.linkify(text, **kwargs)
 
 
 class _xsrf_form_html(UIModule):
+    """ """
     def render(self) -> str:  # type: ignore
+        """ """
         return self.handler.xsrf_form_html()
 
 
 class TemplateModule(UIModule):
     """UIModule that simply renders the given template.
-
+    
     {% module Template("foo.html") %} is similar to {% include "foo.html" %},
     but the module version gets its own namespace (with kwargs passed to
     Template()) instead of inheriting the outer template's namespace.
-
+    
     Templates rendered through this module also get access to UIModule's
     automatic JavaScript/CSS features.  Simply call set_resources
     inside the template and give it keyword arguments corresponding to
@@ -3266,6 +4856,13 @@
     Note that these resources are output once per template file, not once
     per instantiation of the template, so they must not depend on
     any arguments to the template.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
     def __init__(self, handler: RequestHandler) -> None:
@@ -3275,7 +4872,31 @@
         self._resource_dict = {}  # type: Dict[str, Dict[str, Any]]
 
     def render(self, path: str, **kwargs: Any) -> bytes:  # type: ignore
+        """
+
+        Parameters
+        ----------
+        path: str :
+            
+        **kwargs: Any :
+            
+
+        Returns
+        -------
+
+        """
         def set_resources(**kwargs) -> str:  # type: ignore
+            """
+
+            Parameters
+            ----------
+            **kwargs :
+                
+
+            Returns
+            -------
+
+            """
             if path not in self._resource_dict:
                 self._resource_list.append(kwargs)
                 self._resource_dict[path] = kwargs
@@ -3290,12 +4911,25 @@
         return self.render_string(path, set_resources=set_resources, **kwargs)
 
     def _get_resources(self, key: str) -> Iterable[str]:
+        """
+
+        Parameters
+        ----------
+        key: str :
+            
+
+        Returns
+        -------
+
+        """
         return (r[key] for r in self._resource_list if key in r)
 
     def embedded_javascript(self) -> str:
+        """ """
         return "\n".join(self._get_resources("embedded_javascript"))
 
     def javascript_files(self) -> Iterable[str]:
+        """ """
         result = []
         for f in self._get_resources("javascript_files"):
             if isinstance(f, (unicode_type, bytes)):
@@ -3305,9 +4939,11 @@
         return result
 
     def embedded_css(self) -> str:
+        """ """
         return "\n".join(self._get_resources("embedded_css"))
 
     def css_files(self) -> Iterable[str]:
+        """ """
         result = []
         for f in self._get_resources("css_files"):
             if isinstance(f, (unicode_type, bytes)):
@@ -3317,9 +4953,11 @@
         return result
 
     def html_head(self) -> str:
+        """ """
         return "".join(self._get_resources("html_head"))
 
     def html_body(self) -> str:
+        """ """
         return "".join(self._get_resources("html_body"))
 
 
@@ -3350,6 +4988,31 @@
     clock: Optional[Callable[[], float]] = None,
     key_version: Optional[int] = None,
 ) -> bytes:
+    """
+
+    Parameters
+    ----------
+    secret: _CookieSecretTypes :
+        
+    name: str :
+        
+    value: Union[str :
+        
+    bytes] :
+        
+    version: Optional[int] :
+         (Default value = None)
+    clock: Optional[Callable[[] :
+        
+    float]] :
+         (Default value = None)
+    key_version: Optional[int] :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if version is None:
         version = DEFAULT_SIGNED_VALUE_VERSION
     if clock is None:
@@ -3378,6 +5041,19 @@
         # - value (base64-encoded)
         # - signature (hex-encoded; no length prefix)
         def format_field(s: Union[str, bytes]) -> bytes:
+            """
+
+            Parameters
+            ----------
+            s: Union[str :
+                
+            bytes] :
+                
+
+            Returns
+            -------
+
+            """
             return utf8("%d:" % len(s)) + utf8(s)
 
         to_sign = b"|".join(
@@ -3410,6 +5086,17 @@
 
 
 def _get_version(value: bytes) -> int:
+    """
+
+    Parameters
+    ----------
+    value: bytes :
+        
+
+    Returns
+    -------
+
+    """
     # Figures out what version value is.  Version 1 did not include an
     # explicit version field and started with arbitrary base64 data,
     # which makes this tricky.
@@ -3440,6 +5127,33 @@
     clock: Optional[Callable[[], float]] = None,
     min_version: Optional[int] = None,
 ) -> Optional[bytes]:
+    """
+
+    Parameters
+    ----------
+    secret: _CookieSecretTypes :
+        
+    name: str :
+        
+    value: Union[None :
+        
+    str :
+        
+    bytes] :
+        
+    max_age_days: float :
+         (Default value = 31)
+    clock: Optional[Callable[[] :
+        
+    float]] :
+         (Default value = None)
+    min_version: Optional[int] :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if clock is None:
         clock = time.time
     if min_version is None:
@@ -3470,6 +5184,29 @@
     max_age_days: float,
     clock: Callable[[], float],
 ) -> Optional[bytes]:
+    """
+
+    Parameters
+    ----------
+    secret: Union[str :
+        
+    bytes] :
+        
+    name: str :
+        
+    value: bytes :
+        
+    max_age_days: float :
+        
+    clock: Callable[[] :
+        
+    float] :
+        
+
+    Returns
+    -------
+
+    """
     parts = utf8(value).split(b"|")
     if len(parts) != 3:
         return None
@@ -3499,7 +5236,29 @@
 
 
 def _decode_fields_v2(value: bytes) -> Tuple[int, bytes, bytes, bytes, bytes]:
+    """
+
+    Parameters
+    ----------
+    value: bytes :
+        
+
+    Returns
+    -------
+
+    """
     def _consume_field(s: bytes) -> Tuple[bytes, bytes]:
+        """
+
+        Parameters
+        ----------
+        s: bytes :
+            
+
+        Returns
+        -------
+
+        """
         length, _, rest = s.partition(b":")
         n = int(length)
         field_value = rest[:n]
@@ -3525,6 +5284,27 @@
     max_age_days: float,
     clock: Callable[[], float],
 ) -> Optional[bytes]:
+    """
+
+    Parameters
+    ----------
+    secret: _CookieSecretTypes :
+        
+    name: str :
+        
+    value: bytes :
+        
+    max_age_days: float :
+        
+    clock: Callable[[] :
+        
+    float] :
+        
+
+    Returns
+    -------
+
+    """
     try:
         (
             key_version,
@@ -3559,6 +5339,19 @@
 
 
 def get_signature_key_version(value: Union[str, bytes]) -> Optional[int]:
+    """
+
+    Parameters
+    ----------
+    value: Union[str :
+        
+    bytes] :
+        
+
+    Returns
+    -------
+
+    """
     value = utf8(value)
     version = _get_version(value)
     if version < 2:
@@ -3572,6 +5365,21 @@
 
 
 def _create_signature_v1(secret: Union[str, bytes], *parts: Union[str, bytes]) -> bytes:
+    """
+
+    Parameters
+    ----------
+    secret: Union[str :
+        
+    bytes] :
+        
+    *parts: Union[str :
+        
+
+    Returns
+    -------
+
+    """
     hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)
     for part in parts:
         hash.update(utf8(part))
@@ -3579,10 +5387,36 @@
 
 
 def _create_signature_v2(secret: Union[str, bytes], s: bytes) -> bytes:
+    """
+
+    Parameters
+    ----------
+    secret: Union[str :
+        
+    bytes] :
+        
+    s: bytes :
+        
+
+    Returns
+    -------
+
+    """
     hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)
     hash.update(utf8(s))
     return utf8(hash.hexdigest())
 
 
 def is_absolute(path: str) -> bool:
+    """
+
+    Parameters
+    ----------
+    path: str :
+        
+
+    Returns
+    -------
+
+    """
     return any(path.startswith(x) for x in ["/", "http:", "https:"])
