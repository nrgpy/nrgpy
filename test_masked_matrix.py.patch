# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/matrixlib/tests/test_masked_matrix.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/matrixlib/tests/test_masked_matrix.py
@@ -9,6 +9,7 @@
 
 
 class MMatrix(MaskedArray, np.matrix,):
+    """ """
 
     def __new__(cls, data, mask=nomask):
         mat = np.matrix(data)
@@ -22,13 +23,16 @@
 
     @property
     def _series(self):
+        """ """
         _view = self.view(MaskedArray)
         _view._sharedmask = False
         return _view
 
 
 class TestMaskedMatrix:
+    """ """
     def test_matrix_indexing(self):
+        """ """
         # Tests conversions and indexing
         x1 = np.matrix([[1, 2, 3], [4, 3, 2]])
         x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])
@@ -73,6 +77,7 @@
         assert_equal(3.0, x2.fill_value)
 
     def test_pickling_subbaseclass(self):
+        """ """
         # Test pickling w/ a subclass of ndarray
         a = masked_array(np.matrix(list(range(10))), mask=[1, 0, 1, 0, 0] * 2)
         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
@@ -82,6 +87,7 @@
             assert_(isinstance(a_pickled._data, np.matrix))
 
     def test_count_mean_with_matrix(self):
+        """ """
         m = masked_array(np.matrix([[1, 2], [3, 4]]), mask=np.zeros((2, 2)))
 
         assert_equal(m.count(axis=0).shape, (1, 2))
@@ -92,6 +98,7 @@
         assert_equal(m.mean(axis=1), [[1.5], [3.5]])
 
     def test_flat(self):
+        """ """
         # Test that flat can return items even for matrices [#4585, #4615]
         # test simple access
         test = masked_array(np.matrix([[1, 2, 3]]), mask=[0, 0, 1])
@@ -117,6 +124,7 @@
         assert_equal(b01.mask, np.array([[False, False]]))
 
     def test_allany_onmatrices(self):
+        """ """
         x = np.array([[0.13, 0.26, 0.90],
                       [0.28, 0.33, 0.63],
                       [0.31, 0.87, 0.70]])
@@ -143,6 +151,7 @@
         assert_equal(mXsmall.any(1), np.matrix([True, True, False]).T)
 
     def test_compressed(self):
+        """ """
         a = masked_array(np.matrix([1, 2, 3, 4]), mask=[0, 0, 0, 0])
         b = a.compressed()
         assert_equal(b, a)
@@ -152,12 +161,14 @@
         assert_equal(b, [[2, 3, 4]])
 
     def test_ravel(self):
+        """ """
         a = masked_array(np.matrix([1, 2, 3, 4, 5]), mask=[[0, 1, 0, 0, 0]])
         aravel = a.ravel()
         assert_equal(aravel.shape, (1, 5))
         assert_equal(aravel._mask.shape, a.shape)
 
     def test_view(self):
+        """ """
         # Test view w/ flexible dtype
         iterator = list(zip(np.arange(10), np.random.rand(10)))
         data = np.array(iterator)
@@ -170,19 +181,23 @@
 
 
 class TestSubclassing:
+    """ """
     # Test suite for masked subclasses of ndarray.
 
     def setup(self):
+        """ """
         x = np.arange(5, dtype='float')
         mx = MMatrix(x, mask=[0, 1, 0, 0, 0])
         self.data = (x, mx)
 
     def test_maskedarray_subclassing(self):
+        """ """
         # Tests subclassing MaskedArray
         (x, mx) = self.data
         assert_(isinstance(mx._data, np.matrix))
 
     def test_masked_unary_operations(self):
+        """ """
         # Tests masked_unary_operation
         (x, mx) = self.data
         with np.errstate(divide='ignore'):
@@ -190,6 +205,7 @@
             assert_equal(log(x), np.log(x))
 
     def test_masked_binary_operations(self):
+        """ """
         # Tests masked_binary_operation
         (x, mx) = self.data
         # Result should be a MMatrix
@@ -203,6 +219,7 @@
         assert_(isinstance(hypot(mx, x), MMatrix))
 
     def test_masked_binary_operations2(self):
+        """ """
         # Tests domained_masked_binary_operation
         (x, mx) = self.data
         xmx = masked_array(mx.data.__array__(), mask=mx.mask)
@@ -211,12 +228,15 @@
         assert_equal(divide(mx, mx), divide(xmx, xmx))
 
 class TestConcatenator:
+    """ """
     # Tests for mr_, the equivalent of r_ for masked arrays.
 
     def test_matrix_builder(self):
+        """ """
         assert_raises(np.ma.MAError, lambda: mr_['1, 2; 3, 4'])
 
     def test_matrix(self):
+        """ """
         # Test consistency with unmasked version.  If we ever deprecate
         # matrix, this test should either still pass, or both actual and
         # expected should fail to be build.
