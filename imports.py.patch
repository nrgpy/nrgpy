# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/inference/imports.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/inference/imports.py
@@ -35,14 +35,39 @@
 
 
 class ModuleCache(object):
+    """ """
     def __init__(self):
         self._name_cache = {}
 
     def add(self, string_names, value_set):
+        """
+
+        Parameters
+        ----------
+        string_names :
+            
+        value_set :
+            
+
+        Returns
+        -------
+
+        """
         if string_names is not None:
             self._name_cache[string_names] = value_set
 
     def get(self, string_names):
+        """
+
+        Parameters
+        ----------
+        string_names :
+            
+
+        Returns
+        -------
+
+        """
         return self._name_cache.get(string_names)
 
 
@@ -50,6 +75,19 @@
 # certain imports.
 @inference_state_method_cache(default=NO_VALUES)
 def infer_import(context, tree_name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    tree_name :
+        
+
+    Returns
+    -------
+
+    """
     module_context = context.get_root_context()
     from_import_name, import_path, level, values = \
         _prepare_infer_import(module_context, tree_name)
@@ -72,6 +110,19 @@
 
 @inference_state_method_cache(default=[])
 def goto_import(context, tree_name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    tree_name :
+        
+
+    Returns
+    -------
+
+    """
     module_context = context.get_root_context()
     from_import_name, import_path, level, values = \
         _prepare_infer_import(module_context, tree_name)
@@ -97,6 +148,19 @@
 
 
 def _prepare_infer_import(module_context, tree_name):
+    """
+
+    Parameters
+    ----------
+    module_context :
+        
+    tree_name :
+        
+
+    Returns
+    -------
+
+    """
     import_node = search_ancestor(tree_name, 'import_name', 'import_from')
     import_path = import_node.get_path_for_name(tree_name)
     from_import_name = None
@@ -119,6 +183,21 @@
 
 
 def _add_error(value, name, message):
+    """
+
+    Parameters
+    ----------
+    value :
+        
+    name :
+        
+    message :
+        
+
+    Returns
+    -------
+
+    """
     if hasattr(name, 'parent') and value is not None:
         analysis.add(value, 'import-error', name, message)
     else:
@@ -126,10 +205,22 @@
 
 
 def _level_to_base_import_path(project_path, directory, level):
-    """
-    In case the level is outside of the currently known package (something like
+    """In case the level is outside of the currently known package (something like
     import .....foo), we can still try our best to help the user for
     completions.
+
+    Parameters
+    ----------
+    project_path :
+        
+    directory :
+        
+    level :
+        
+
+    Returns
+    -------
+
     """
     for i in range(level - 1):
         old = directory
@@ -154,18 +245,24 @@
 
 class Importer(object):
     def __init__(self, inference_state, import_path, module_context, level=0):
-        """
-        An implementation similar to ``__import__``. Use `follow`
+    """An implementation similar to ``__import__``. Use `follow`
         to actually follow the imports.
-
+    
         *level* specifies whether to use absolute or relative imports. 0 (the
         default) means only perform absolute imports. Positive values for level
         indicate the number of parent directories to search relative to the
         directory of the module calling ``__import__()`` (see PEP 328 for the
         details).
 
-        :param import_path: List of namespaces (strings or Names).
-        """
+    Parameters
+    ----------
+    import_path :
+        List of namespaces (strings or Names).
+
+    Returns
+    -------
+
+    """
         debug.speed('import %s %s' % (import_path, module_context))
         self._inference_state = inference_state
         self.level = level
@@ -232,6 +329,17 @@
         )
 
     def _sys_path_with_modifications(self, is_completion):
+        """
+
+        Parameters
+        ----------
+        is_completion :
+            
+
+        Returns
+        -------
+
+        """
         if self._fixed_sys_path is not None:
             return self._fixed_sys_path
 
@@ -244,6 +352,7 @@
         )
 
     def follow(self):
+        """ """
         if not self.import_path or not self._infer_possible:
             return NO_VALUES
 
@@ -262,9 +371,19 @@
         )
 
     def _get_module_names(self, search_path=None, in_module=None):
-        """
-        Get the names of all modules in the search_path. This means file names
+        """Get the names of all modules in the search_path. This means file names
         and not names defined in the files.
+
+        Parameters
+        ----------
+        search_path :
+             (Default value = None)
+        in_module :
+             (Default value = None)
+
+        Returns
+        -------
+
         """
         if search_path is None:
             sys_path = self._sys_path_with_modifications(is_completion=True)
@@ -278,8 +397,18 @@
 
     def completion_names(self, inference_state, only_modules=False):
         """
-        :param only_modules: Indicates wheter it's possible to import a
-            definition that is not defined in a module.
+
+        Parameters
+        ----------
+        only_modules :
+            Indicates wheter it's possible to import a
+            definition that is not defined in a module. (Default value = False)
+        inference_state :
+            
+
+        Returns
+        -------
+
         """
         if not self._infer_possible:
             return []
@@ -328,6 +457,25 @@
 
 def import_module_by_names(inference_state, import_names, sys_path=None,
                            module_context=None, prefer_stubs=True):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    import_names :
+        
+    sys_path :
+         (Default value = None)
+    module_context :
+         (Default value = None)
+    prefer_stubs :
+         (Default value = True)
+
+    Returns
+    -------
+
+    """
     if sys_path is None:
         sys_path = inference_state.get_sys_path()
 
@@ -359,8 +507,22 @@
 @plugin_manager.decorate()
 @import_module_decorator
 def import_module(inference_state, import_names, parent_module_value, sys_path):
-    """
-    This method is very similar to importlib's `_gcd_import`.
+    """This method is very similar to importlib's `_gcd_import`.
+
+    Parameters
+    ----------
+    inference_state :
+        
+    import_names :
+        
+    parent_module_value :
+        
+    sys_path :
+        
+
+    Returns
+    -------
+
     """
     if import_names[0] in settings.auto_import_modules:
         module = _load_builtin_module(inference_state, import_names, sys_path)
@@ -429,6 +591,23 @@
 
 def _load_python_module(inference_state, file_io,
                         import_names=None, is_package=False):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    file_io :
+        
+    import_names :
+         (Default value = None)
+    is_package :
+         (Default value = False)
+
+    Returns
+    -------
+
+    """
     module_node = inference_state.parse(
         file_io=file_io,
         cache=True,
@@ -447,6 +626,21 @@
 
 
 def _load_builtin_module(inference_state, import_names=None, sys_path=None):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    import_names :
+         (Default value = None)
+    sys_path :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     project = inference_state.project
     if sys_path is None:
         sys_path = inference_state.get_sys_path()
@@ -465,10 +659,24 @@
 
 
 def load_module_from_path(inference_state, file_io, import_names=None, is_package=None):
-    """
-    This should pretty much only be used for get_modules_containing_name. It's
+    """This should pretty much only be used for get_modules_containing_name. It's
     here to ensure that a random path is still properly loaded into the Jedi
     module structure.
+
+    Parameters
+    ----------
+    inference_state :
+        
+    file_io :
+        
+    import_names :
+         (Default value = None)
+    is_package :
+         (Default value = None)
+
+    Returns
+    -------
+
     """
     path = file_io.path
     if import_names is None:
@@ -511,6 +719,19 @@
 
 
 def load_namespace_from_path(inference_state, folder_io):
+    """
+
+    Parameters
+    ----------
+    inference_state :
+        
+    folder_io :
+        
+
+    Returns
+    -------
+
+    """
     import_names, is_package = sys_path.transform_path_to_dotted(
         inference_state.get_sys_path(),
         folder_io.path
@@ -520,6 +741,19 @@
 
 
 def follow_error_node_imports_if_possible(context, name):
+    """
+
+    Parameters
+    ----------
+    context :
+        
+    name :
+        
+
+    Returns
+    -------
+
+    """
     error_node = tree.search_ancestor(name, 'error_node')
     if error_node is not None:
         # Get the first command start of a started simple_stmt. The error
@@ -550,9 +784,25 @@
 
 def iter_module_names(inference_state, module_context, search_path,
                       module_cls=ImportName, add_builtin_modules=True):
-    """
-    Get the names of all modules in the search_path. This means file names
+    """Get the names of all modules in the search_path. This means file names
     and not names defined in the files.
+
+    Parameters
+    ----------
+    inference_state :
+        
+    module_context :
+        
+    search_path :
+        
+    module_cls :
+         (Default value = ImportName)
+    add_builtin_modules :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
     # add builtin module names
     if add_builtin_modules:
