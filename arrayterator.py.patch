# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/numpy/lib/arrayterator.py
+++ b/..//venv/lib/python3.8/site-packages/numpy/lib/arrayterator.py
@@ -14,14 +14,13 @@
 
 
 class Arrayterator:
-    """
-    Buffered iterator for big arrays.
-
+    """Buffered iterator for big arrays.
+    
     `Arrayterator` creates a buffered iterator for reading big arrays in small
     contiguous blocks. The class is useful for objects stored in the
     file system. It allows iteration over the object *without* reading
     everything in memory; instead, small blocks are read and iterated over.
-
+    
     `Arrayterator` can be used with any object that supports multidimensional
     slices. This includes NumPy arrays, but also variables from
     Scientific.IO.NetCDF or pynetcdf for example.
@@ -36,6 +35,9 @@
         Default is None, which will read as many element as possible
         into memory.
 
+    Returns
+    -------
+
     Attributes
     ----------
     var
@@ -45,13 +47,11 @@
     step
     shape
     flat
-
     See Also
     --------
     ndenumerate : Multidimensional array iterator.
     flatiter : Flat array iterator.
     memmap : Create a memory-map to an array stored in a binary file on disk.
-
     Notes
     -----
     The algorithm works by first finding a "running dimension", along which
@@ -62,23 +62,21 @@
     Blocks are extracted along this dimension, and when the last block is
     returned the process continues from the next dimension, until all
     elements have been read.
-
     Examples
     --------
+    
+    Now we can iterate over ``a_itor``, and it will return arrays of size
+    two. Since `buf_size` was smaller than any dimension, the first
+    dimension will be iterated over first:
     >>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)
     >>> a_itor = np.lib.Arrayterator(a, 2)
     >>> a_itor.shape
     (3, 4, 5, 6)
-
-    Now we can iterate over ``a_itor``, and it will return arrays of size
-    two. Since `buf_size` was smaller than any dimension, the first
-    dimension will be iterated over first:
-
+    
     >>> for subarr in a_itor:
     ...     if not subarr.all():
     ...         print(subarr, subarr.shape) # doctest: +SKIP
     >>> # [[[[0 1]]]] (1, 1, 1, 2)
-
     """
 
     def __init__(self, var, buf_size=None):
@@ -135,38 +133,46 @@
 
     @property
     def flat(self):
-        """
-        A 1-D flat iterator for Arrayterator objects.
-
+        """A 1-D flat iterator for Arrayterator objects.
+        
         This iterator returns elements of the array to be iterated over in
         `Arrayterator` one by one. It is similar to `flatiter`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         See Also
         --------
         Arrayterator
         flatiter
-
         Examples
         --------
         >>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)
         >>> a_itor = np.lib.Arrayterator(a, 2)
-
+        
         >>> for subarr in a_itor.flat:
         ...     if not subarr:
         ...         print(subarr, type(subarr))
         ...
         0 <class 'numpy.int64'>
-
         """
         for block in self:
             yield from block.flat
 
     @property
     def shape(self):
-        """
-        The shape of the array to be iterated over.
-
+        """The shape of the array to be iterated over.
+        
         For an example, see `Arrayterator`.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         """
         return tuple(((stop-start-1)//step+1) for start, stop, step in
