# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/pandas/tests/io/test_html.py
+++ b/..//venv/lib/python3.8/site-packages/pandas/tests/io/test_html.py
@@ -33,11 +33,40 @@
     ]
 )
 def html_encoding_file(request, datapath):
-    """Parametrized fixture for HTML encoding test filenames."""
+    """Parametrized fixture for HTML encoding test filenames.
+
+    Parameters
+    ----------
+    request :
+        
+    datapath :
+        
+
+    Returns
+    -------
+
+    """
     return datapath("io", "data", "html_encoding", request.param)
 
 
 def assert_framelist_equal(list1, list2, *args, **kwargs):
+    """
+
+    Parameters
+    ----------
+    list1 :
+        
+    list2 :
+        
+    *args :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+
+    """
     assert len(list1) == len(list2), (
         "lists are not of equal size "
         f"len(list1) == {len(list1)}, "
@@ -59,6 +88,19 @@
 
 @td.skip_if_no("bs4")
 def test_bs4_version_fails(monkeypatch, datapath):
+    """
+
+    Parameters
+    ----------
+    monkeypatch :
+        
+    datapath :
+        
+
+    Returns
+    -------
+
+    """
     import bs4
 
     monkeypatch.setattr(bs4, "__version__", "4.2")
@@ -67,6 +109,7 @@
 
 
 def test_invalid_flavor():
+    """ """
     url = "google.com"
     flavor = "invalid flavor"
     msg = r"\{" + flavor + r"\} is not a valid set of flavors"
@@ -78,6 +121,17 @@
 @td.skip_if_no("bs4")
 @td.skip_if_no("lxml")
 def test_same_ordering(datapath):
+    """
+
+    Parameters
+    ----------
+    datapath :
+        
+
+    Returns
+    -------
+
+    """
     filename = datapath("io", "data", "html", "valid_markup.html")
     dfs_lxml = read_html(filename, index_col=0, flavor=["lxml"])
     dfs_bs4 = read_html(filename, index_col=0, flavor=["bs4"])
@@ -93,8 +147,20 @@
     scope="class",
 )
 class TestReadHtml:
+    """ """
     @pytest.fixture(autouse=True)
     def set_files(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         self.spam_data = datapath("io", "data", "html", "spam.html")
         self.spam_data_kwargs = {}
         self.spam_data_kwargs["encoding"] = "UTF-8"
@@ -102,10 +168,24 @@
 
     @pytest.fixture(autouse=True, scope="function")
     def set_defaults(self, flavor, request):
+        """
+
+        Parameters
+        ----------
+        flavor :
+            
+        request :
+            
+
+        Returns
+        -------
+
+        """
         self.read_html = partial(read_html, flavor=flavor)
         yield
 
     def test_to_html_compat(self):
+        """ """
         df = (
             tm.makeCustomDataframe(
                 4,
@@ -123,6 +203,7 @@
 
     @tm.network
     def test_banklist_url_positional_match(self):
+        """ """
         url = "http://www.fdic.gov/bank/individual/failed/banklist.html"
         # Passing match argument as positional should cause a FutureWarning.
         with tm.assert_produces_warning(FutureWarning):
@@ -136,6 +217,7 @@
 
     @tm.network
     def test_banklist_url(self):
+        """ """
         url = "http://www.fdic.gov/bank/individual/failed/banklist.html"
         df1 = self.read_html(
             url, match="First Federal Bank of Florida", attrs={"id": "table"}
@@ -146,6 +228,7 @@
 
     @tm.network
     def test_spam_url(self):
+        """ """
         url = (
             "https://raw.githubusercontent.com/pandas-dev/pandas/master/"
             "pandas/tests/io/data/html/spam.html"
@@ -157,6 +240,7 @@
 
     @pytest.mark.slow
     def test_banklist(self):
+        """ """
         df1 = self.read_html(
             self.banklist_data, match=".*Florida.*", attrs={"id": "table"}
         )
@@ -167,6 +251,7 @@
         assert_framelist_equal(df1, df2)
 
     def test_spam(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*")
         df2 = self.read_html(self.spam_data, match="Unit")
         assert_framelist_equal(df1, df2)
@@ -175,88 +260,104 @@
         assert df1[0].columns[0] == "Nutrient"
 
     def test_spam_no_match(self):
+        """ """
         dfs = self.read_html(self.spam_data)
         for df in dfs:
             assert isinstance(df, DataFrame)
 
     def test_banklist_no_match(self):
+        """ """
         dfs = self.read_html(self.banklist_data, attrs={"id": "table"})
         for df in dfs:
             assert isinstance(df, DataFrame)
 
     def test_spam_header(self):
+        """ """
         df = self.read_html(self.spam_data, match=".*Water.*", header=2)[0]
         assert df.columns[0] == "Proximates"
         assert not df.empty
 
     def test_skiprows_int(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=1)
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=1)
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_range(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=range(2))
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=range(2))
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_list(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=[1, 2])
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=[2, 1])
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_set(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows={1, 2})
         df2 = self.read_html(self.spam_data, match="Unit", skiprows={2, 1})
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_slice(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=1)
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=1)
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_slice_short(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=slice(2))
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=slice(2))
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_slice_long(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=slice(2, 5))
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=slice(4, 1, -1))
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_ndarray(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", skiprows=np.arange(2))
         df2 = self.read_html(self.spam_data, match="Unit", skiprows=np.arange(2))
 
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_invalid(self):
+        """ """
         with pytest.raises(TypeError, match=("is not a valid type for skipping rows")):
             self.read_html(self.spam_data, match=".*Water.*", skiprows="asdf")
 
     def test_index(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", index_col=0)
         df2 = self.read_html(self.spam_data, match="Unit", index_col=0)
         assert_framelist_equal(df1, df2)
 
     def test_header_and_index_no_types(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", header=1, index_col=0)
         df2 = self.read_html(self.spam_data, match="Unit", header=1, index_col=0)
         assert_framelist_equal(df1, df2)
 
     def test_header_and_index_with_types(self):
+        """ """
         df1 = self.read_html(self.spam_data, match=".*Water.*", header=1, index_col=0)
         df2 = self.read_html(self.spam_data, match="Unit", header=1, index_col=0)
         assert_framelist_equal(df1, df2)
 
     def test_infer_types(self):
+        """ """
 
         # 10892 infer_types removed
         df1 = self.read_html(self.spam_data, match=".*Water.*", index_col=0)
@@ -264,6 +365,7 @@
         assert_framelist_equal(df1, df2)
 
     def test_string_io(self):
+        """ """
         with open(self.spam_data, **self.spam_data_kwargs) as f:
             data1 = StringIO(f.read())
 
@@ -275,6 +377,7 @@
         assert_framelist_equal(df1, df2)
 
     def test_string(self):
+        """ """
         with open(self.spam_data, **self.spam_data_kwargs) as f:
             data = f.read()
 
@@ -284,6 +387,7 @@
         assert_framelist_equal(df1, df2)
 
     def test_file_like(self):
+        """ """
         with open(self.spam_data, **self.spam_data_kwargs) as f:
             df1 = self.read_html(f, match=".*Water.*")
 
@@ -294,12 +398,14 @@
 
     @tm.network
     def test_bad_url_protocol(self):
+        """ """
         with pytest.raises(URLError):
             self.read_html("git://github.com", match=".*Water.*")
 
     @tm.network
     @pytest.mark.slow
     def test_invalid_url(self):
+        """ """
         try:
             with pytest.raises(URLError):
                 self.read_html("http://www.a23950sdfa908sd.com", match=".*Water.*")
@@ -308,6 +414,7 @@
 
     @pytest.mark.slow
     def test_file_url(self):
+        """ """
         url = self.banklist_data
         dfs = self.read_html(
             file_path_to_url(os.path.abspath(url)), match="First", attrs={"id": "table"}
@@ -318,6 +425,7 @@
 
     @pytest.mark.slow
     def test_invalid_table_attrs(self):
+        """ """
         url = self.banklist_data
         with pytest.raises(ValueError, match="No tables found"):
             self.read_html(
@@ -325,44 +433,64 @@
             )
 
     def _bank_data(self, *args, **kwargs):
+        """
+
+        Parameters
+        ----------
+        *args :
+            
+        **kwargs :
+            
+
+        Returns
+        -------
+
+        """
         return self.read_html(
             self.banklist_data, match="Metcalf", attrs={"id": "table"}, *args, **kwargs
         )
 
     @pytest.mark.slow
     def test_multiindex_header(self):
+        """ """
         df = self._bank_data(header=[0, 1])[0]
         assert isinstance(df.columns, MultiIndex)
 
     @pytest.mark.slow
     def test_multiindex_index(self):
+        """ """
         df = self._bank_data(index_col=[0, 1])[0]
         assert isinstance(df.index, MultiIndex)
 
     @pytest.mark.slow
     def test_multiindex_header_index(self):
+        """ """
         df = self._bank_data(header=[0, 1], index_col=[0, 1])[0]
         assert isinstance(df.columns, MultiIndex)
         assert isinstance(df.index, MultiIndex)
 
     @pytest.mark.slow
     def test_multiindex_header_skiprows_tuples(self):
+        """ """
         df = self._bank_data(header=[0, 1], skiprows=1)[0]
         assert isinstance(df.columns, MultiIndex)
 
     @pytest.mark.slow
     def test_multiindex_header_skiprows(self):
+        """ """
         df = self._bank_data(header=[0, 1], skiprows=1)[0]
         assert isinstance(df.columns, MultiIndex)
 
     @pytest.mark.slow
     def test_multiindex_header_index_skiprows(self):
+        """ """
         df = self._bank_data(header=[0, 1], index_col=[0, 1], skiprows=1)[0]
         assert isinstance(df.index, MultiIndex)
         assert isinstance(df.columns, MultiIndex)
 
     @pytest.mark.slow
     def test_regex_idempotency(self):
+        """ """
         url = self.banklist_data
         dfs = self.read_html(
             file_path_to_url(os.path.abspath(url)),
@@ -374,27 +502,28 @@
             assert isinstance(df, DataFrame)
 
     def test_negative_skiprows(self):
+        """ """
         msg = r"\(you passed a negative value\)"
         with pytest.raises(ValueError, match=msg):
             self.read_html(self.spam_data, match="Water", skiprows=-1)
 
     @tm.network
     def test_multiple_matches(self):
+        """ """
         url = "https://docs.python.org/2/"
         dfs = self.read_html(url, match="Python")
         assert len(dfs) > 1
 
     @tm.network
     def test_python_docs_table(self):
+        """ """
         url = "https://docs.python.org/2/"
         dfs = self.read_html(url, match="Python")
         zz = [df.iloc[0, 0][0:4] for df in dfs]
         assert sorted(zz) == sorted(["Repo", "What"])
 
     def test_empty_tables(self):
-        """
-        Make sure that read_html ignores empty tables.
-        """
+        """Make sure that read_html ignores empty tables."""
         html = """
             <table>
                 <thead>
@@ -419,6 +548,7 @@
         assert len(result) == 1
 
     def test_multiple_tbody(self):
+        """ """
         # GH-20690
         # Read all tbody tags within a single table.
         result = self.read_html(
@@ -449,9 +579,15 @@
         tm.assert_frame_equal(result, expected)
 
     def test_header_and_one_column(self):
-        """
-        Don't fail with bs4 when there is a header and only one column
+        """Don't fail with bs4 when there is a header and only one column
         as described in issue #9178
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         result = self.read_html(
             """<table>
@@ -473,9 +609,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_thead_without_tr(self):
-        """
-        Ensure parser adds <tr> within <thead> on malformed HTML.
-        """
+        """Ensure parser adds <tr> within <thead> on malformed HTML."""
         result = self.read_html(
             """<table>
             <thead>
@@ -503,9 +637,15 @@
         tm.assert_frame_equal(result, expected)
 
     def test_tfoot_read(self):
-        """
-        Make sure that read_html reads tfoot, containing td or th.
+        """Make sure that read_html reads tfoot, containing td or th.
         Ignores empty tfoot
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
         """
         data_template = """<table>
             <thead>
@@ -541,6 +681,7 @@
         tm.assert_frame_equal(result2, expected2)
 
     def test_parse_header_of_non_string_column(self):
+        """ """
         # GH5048: if header is specified explicitly, an int column should be
         # parsed as int while its header is parsed as str
         result = self.read_html(
@@ -565,9 +706,31 @@
 
     @pytest.mark.slow
     def test_banklist_header(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         from pandas.io.html import _remove_whitespace
 
         def try_remove_ws(x):
+            """
+
+            Parameters
+            ----------
+            x :
+                
+
+            Returns
+            -------
+
+            """
             try:
                 return _remove_whitespace(x)
             except AttributeError:
@@ -615,6 +778,7 @@
 
     @pytest.mark.slow
     def test_gold_canyon(self):
+        """ """
         gc = "Gold Canyon"
         with open(self.banklist_data, "r") as f:
             raw_text = f.read()
@@ -626,6 +790,7 @@
         assert gc in df.to_string()
 
     def test_different_number_of_cols(self):
+        """ """
         expected = self.read_html(
             """<table>
                         <thead>
@@ -694,6 +859,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_colspan_rowspan_1(self):
+        """ """
         # GH17054
         result = self.read_html(
             """
@@ -717,6 +883,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_colspan_rowspan_copy_values(self):
+        """ """
         # GH17054
 
         # In ASCII, with lowercase letters being copies:
@@ -750,6 +917,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_colspan_rowspan_both_not_1(self):
+        """ """
         # GH17054
 
         # In ASCII, with lowercase letters being copies:
@@ -780,6 +948,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_rowspan_at_end_of_row(self):
+        """ """
         # GH17054
 
         # In ASCII, with lowercase letters being copies:
@@ -807,6 +976,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_rowspan_only_rows(self):
+        """ """
         # GH17054
 
         result = self.read_html(
@@ -826,6 +996,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_header_inferred_from_rows_with_only_th(self):
+        """ """
         # GH17054
         result = self.read_html(
             """
@@ -852,6 +1023,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_parse_dates_list(self):
+        """ """
         df = DataFrame({"date": date_range("1/1/2001", periods=10)})
         expected = df.to_html()
         res = self.read_html(expected, parse_dates=[1], index_col=0)
@@ -860,6 +1032,7 @@
         tm.assert_frame_equal(df, res[0])
 
     def test_parse_dates_combine(self):
+        """ """
         raw_dates = Series(date_range("1/1/2001", periods=10))
         df = DataFrame(
             {
@@ -874,6 +1047,17 @@
         tm.assert_frame_equal(newdf, res[0])
 
     def test_wikipedia_states_table(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         data = datapath("io", "data", "html", "wikipedia_states.html")
         assert os.path.isfile(data), f"{repr(data)} is not a file"
         assert os.path.getsize(data), f"{repr(data)} is an empty file"
@@ -884,6 +1068,17 @@
         assert np.allclose(result.loc[0, "sq mi"], 665384.04)
 
     def test_wikipedia_states_multiindex(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         data = datapath("io", "data", "html", "wikipedia_states.html")
         result = self.read_html(data, match="Arizona", index_col=0)[0]
         assert result.shape == (60, 11)
@@ -892,6 +1087,7 @@
         assert np.allclose(result.loc["Alaska", ("Total area[2]", "sq mi")], 665384.04)
 
     def test_parser_error_on_empty_header_row(self):
+        """ """
         msg = (
             r"Passed header=\[0,1\] are too many "
             r"rows for this multi_index of columns"
@@ -913,6 +1109,7 @@
             )
 
     def test_decimal_rows(self):
+        """ """
         # GH 12907
         result = self.read_html(
             """<html>
@@ -940,12 +1137,14 @@
         tm.assert_frame_equal(result, expected)
 
     def test_bool_header_arg(self):
+        """ """
         # GH 6114
         for arg in [True, False]:
             with pytest.raises(TypeError):
                 self.read_html(self.spam_data, header=arg)
 
     def test_converters(self):
+        """ """
         # GH 13461
         result = self.read_html(
             """<table>
@@ -971,6 +1170,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_na_values(self):
+        """ """
         # GH 13461
         result = self.read_html(
             """<table>
@@ -996,7 +1196,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_keep_default_na(self):
-        html_data = """<table>
+        """html_data = """<table>
                         <thead>
                             <tr>
                             <th>a</th>
@@ -1010,7 +1210,13 @@
                             <td> NA</td>
                             </tr>
                         </tbody>
-                    </table>"""
+                    </table>
+
+        Parameters
+        ----------
+
+        Returns
+        -------
 
         expected_df = DataFrame({"a": ["N/A", "NA"]})
         html_df = self.read_html(html_data, keep_default_na=False)[0]
@@ -1021,6 +1227,7 @@
         tm.assert_frame_equal(expected_df, html_df)
 
     def test_preserve_empty_rows(self):
+        """ """
         result = self.read_html(
             """
             <table>
@@ -1045,6 +1252,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_ignore_empty_rows_when_inferring_header(self):
+        """ """
         result = self.read_html(
             """
             <table>
@@ -1066,6 +1274,7 @@
         tm.assert_frame_equal(result, expected)
 
     def test_multiple_header_rows(self):
+        """ """
         # Issue #13434
         expected_df = DataFrame(
             data=[("Hillary", 68, "D"), ("Bernie", 74, "D"), ("Donald", 69, "R")]
@@ -1079,6 +1288,17 @@
         tm.assert_frame_equal(expected_df, html_df)
 
     def test_works_on_valid_markup(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         filename = datapath("io", "data", "html", "valid_markup.html")
         dfs = self.read_html(filename, index_col=0)
         assert isinstance(dfs, list)
@@ -1086,10 +1306,22 @@
 
     @pytest.mark.slow
     def test_fallback_success(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         banklist_data = datapath("io", "data", "html", "banklist.html")
         self.read_html(banklist_data, match=".*Water.*", flavor=["lxml", "html5lib"])
 
     def test_to_html_timestamp(self):
+        """ """
         rng = date_range("2000-01-01", periods=10)
         df = DataFrame(np.random.randn(10, 4), index=rng)
 
@@ -1104,6 +1336,21 @@
         ],
     )
     def test_displayed_only(self, displayed_only, exp0, exp1):
+        """
+
+        Parameters
+        ----------
+        displayed_only :
+            
+        exp0 :
+            
+        exp1 :
+            
+
+        Returns
+        -------
+
+        """
         # GH 20027
         data = StringIO(
             """<html>
@@ -1136,6 +1383,17 @@
             assert len(dfs) == 1  # Should not parse hidden table
 
     def test_encode(self, html_encoding_file):
+        """
+
+        Parameters
+        ----------
+        html_encoding_file :
+            
+
+        Returns
+        -------
+
+        """
         base_path = os.path.basename(html_encoding_file)
         root = os.path.splitext(base_path)[0]
         _, encoding = root.split("_")
@@ -1164,13 +1422,16 @@
             raise
 
     def test_parse_failure_unseekable(self):
+        """ """
         # Issue #17975
 
         if self.read_html.keywords.get("flavor") == "lxml":
             pytest.skip("Not applicable for lxml")
 
         class UnseekableStringIO(StringIO):
+            """ """
             def seekable(self):
+                """ """
                 return False
 
         bad = UnseekableStringIO(
@@ -1184,22 +1445,47 @@
             self.read_html(bad)
 
     def test_parse_failure_rewinds(self):
+        """ """
         # Issue #17975
 
         class MockFile:
+            """ """
             def __init__(self, data):
                 self.data = data
                 self.at_end = False
 
             def read(self, size=None):
+                """
+
+                Parameters
+                ----------
+                size :
+                     (Default value = None)
+
+                Returns
+                -------
+
+                """
                 data = "" if self.at_end else self.data
                 self.at_end = True
                 return data
 
             def seek(self, offset):
+                """
+
+                Parameters
+                ----------
+                offset :
+                    
+
+                Returns
+                -------
+
+                """
                 self.at_end = False
 
             def seekable(self):
+                """ """
                 return True
 
         good = MockFile("<table><tr><td>spam<br />eggs</td></tr></table>")
@@ -1210,10 +1496,23 @@
 
     @pytest.mark.slow
     def test_importcheck_thread_safety(self, datapath):
+        """
+
+        Parameters
+        ----------
+        datapath :
+            
+
+        Returns
+        -------
+
+        """
         # see gh-16928
 
         class ErrorThread(threading.Thread):
+            """ """
             def run(self):
+                """ """
                 try:
                     super().run()
                 except Exception as err:
