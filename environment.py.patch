# Patch generated by Pyment v0.3.3

--- a/..//venv/lib/python3.8/site-packages/jedi/api/environment.py
+++ b/..//venv/lib/python3.8/site-packages/jedi/api/environment.py
@@ -24,20 +24,29 @@
 
 
 class InvalidPythonEnvironment(Exception):
-    """
-    If you see this exception, the Python executable or Virtualenv you have
+    """If you see this exception, the Python executable or Virtualenv you have
     been trying to use is probably not a correct Python version.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
 
 
 class _BaseEnvironment(object):
+    """ """
     @memoize_method
     def get_grammar(self):
+        """ """
         version_string = '%s.%s' % (self.version_info.major, self.version_info.minor)
         return parso.load_grammar(version=version_string)
 
     @property
     def _sha256(self):
+        """ """
         try:
             return self._hash
         except AttributeError:
@@ -46,6 +55,7 @@
 
 
 def _get_info():
+    """ """
     return (
         sys.executable,
         sys.prefix,
@@ -54,10 +64,16 @@
 
 
 class Environment(_BaseEnvironment):
-    """
-    This class is supposed to be created by internal Jedi architecture. You
+    """This class is supposed to be created by internal Jedi architecture. You
     should not create it directly. Please use create_environment or the other
     functions instead. It is then returned by that function.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     _subprocess = None
 
@@ -68,6 +84,7 @@
         self._get_subprocess()
 
     def _get_subprocess(self):
+        """ """
         if self._subprocess is not None and not self._subprocess.is_crashed:
             return self._subprocess
 
@@ -113,15 +130,32 @@
         return '<%s: %s in %s>' % (self.__class__.__name__, version, self.path)
 
     def get_inference_state_subprocess(self, inference_state):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+
+        Returns
+        -------
+
+        """
         return InferenceStateSubprocess(inference_state, self._get_subprocess())
 
     @memoize_method
     def get_sys_path(self):
-        """
-        The sys path for this environment. Does not include potential
+        """The sys path for this environment. Does not include potential
         modifications from e.g. appending to :data:`sys.path`.
 
-        :returns: list of str
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            list of str
+
         """
         # It's pretty much impossible to generate the sys path without actually
         # executing Python. The sys path (when starting with -S) itself depends
@@ -132,6 +166,7 @@
 
 
 class _SameEnvironmentMixin(object):
+    """ """
     def __init__(self):
         self._start_executable = self.executable = sys.executable
         self.path = sys.prefix
@@ -140,22 +175,45 @@
 
 
 class SameEnvironment(_SameEnvironmentMixin, Environment):
+    """ """
     pass
 
 
 class InterpreterEnvironment(_SameEnvironmentMixin, _BaseEnvironment):
+    """ """
     def get_inference_state_subprocess(self, inference_state):
+        """
+
+        Parameters
+        ----------
+        inference_state :
+            
+
+        Returns
+        -------
+
+        """
         return InferenceStateSameProcess(inference_state)
 
     def get_sys_path(self):
+        """ """
         return sys.path
 
 
 def _get_virtual_env_from_var(env_var='VIRTUAL_ENV'):
     """Get virtualenv environment from VIRTUAL_ENV environment variable.
-
+    
     It uses `safe=False` with ``create_environment``, because the environment
     variable is considered to be safe / controlled by the user solely.
+
+    Parameters
+    ----------
+    env_var :
+         (Default value = 'VIRTUAL_ENV')
+
+    Returns
+    -------
+
     """
     var = os.environ.get(env_var)
     if var:
@@ -173,6 +231,17 @@
 
 
 def _calculate_sha256_for_file(path):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+
+    Returns
+    -------
+
+    """
     sha256 = hashlib.sha256()
     with open(path, 'rb') as f:
         for block in iter(lambda: f.read(filecmp.BUFSIZE), b''):
@@ -181,14 +250,20 @@
 
 
 def get_default_environment():
-    """
-    Tries to return an active Virtualenv or conda environment.
+    """Tries to return an active Virtualenv or conda environment.
     If there is no VIRTUAL_ENV variable or no CONDA_PREFIX variable set
     set it will return the latest Python version installed on the system. This
     makes it possible to use as many new Python features as possible when using
     autocompletion and other functionality.
 
-    :returns: :class:`.Environment`
+    Parameters
+    ----------
+
+    Returns
+    -------
+    type
+        class:`.Environment`
+
     """
     virtual_env = _get_virtual_env_from_var()
     if virtual_env is not None:
@@ -202,6 +277,7 @@
 
 
 def _try_get_same_env():
+    """ """
     env = SameEnvironment()
     if not os.path.basename(env.executable).lower().startswith('python'):
         # This tries to counter issues with embedding. In some cases (e.g.
@@ -242,6 +318,7 @@
 
 
 def get_cached_default_environment():
+    """ """
     var = os.environ.get('VIRTUAL_ENV') or os.environ.get(_CONDA_VAR)
     environment = _get_cached_default_environment()
 
@@ -257,6 +334,7 @@
 
 @time_cache(seconds=10 * 60)  # 10 Minutes
 def _get_cached_default_environment():
+    """ """
     try:
         return get_default_environment()
     except InvalidPythonEnvironment:
@@ -269,22 +347,49 @@
 
 def find_virtualenvs(paths=None, **kwargs):
     """
-    :param paths: A list of paths in your file system to be scanned for
+
+    Parameters
+    ----------
+    paths :
+        A list of paths in your file system to be scanned for
         Virtualenvs. It will search in these paths and potentially execute the
-        Python binaries.
-    :param safe: Default True. In case this is False, it will allow this
+        Python binaries. (Default value = None)
+    safe :
+        Default True. In case this is False, it will allow this
         function to execute potential `python` environments. An attacker might
         be able to drop an executable in a path this function is searching by
         default. If the executable has not been installed by root, it will not
         be executed.
-    :param use_environment_vars: Default True. If True, the VIRTUAL_ENV
+    use_environment_vars :
+        Default True. If True, the VIRTUAL_ENV
         variable will be checked if it contains a valid VirtualEnv.
         CONDA_PREFIX will be checked to see if it contains a valid conda
         environment.
-
-    :yields: :class:`.Environment`
+        
+        :yields: :class:`.Environment`
+    **kwargs :
+        
+
+    Returns
+    -------
+
     """
     def py27_comp(paths=None, safe=True, use_environment_vars=True):
+        """
+
+        Parameters
+        ----------
+        paths :
+             (Default value = None)
+        safe :
+             (Default value = True)
+        use_environment_vars :
+             (Default value = True)
+
+        Returns
+        -------
+
+        """
         if paths is None:
             paths = []
 
@@ -325,14 +430,22 @@
 
 
 def find_system_environments(**kwargs):
-    """
-    Ignores virtualenvs and returns the Python versions that were installed on
+    """Ignores virtualenvs and returns the Python versions that were installed on
     your system. This might return nothing, if you're running Python e.g. from
     a portable version.
-
+    
     The environments are sorted from latest to oldest Python version.
-
+    
     :yields: :class:`.Environment`
+
+    Parameters
+    ----------
+    **kwargs :
+        
+
+    Returns
+    -------
+
     """
     for version_string in _SUPPORTED_PYTHONS:
         try:
@@ -344,12 +457,21 @@
 # TODO: this function should probably return a list of environments since
 # multiple Python installations can be found on a system for the same version.
 def get_system_environment(version, **kwargs):
-    """
-    Return the first Python environment found for a string of the form 'X.Y'
+    """Return the first Python environment found for a string of the form 'X.Y'
     where X and Y are the major and minor versions of Python.
 
-    :raises: :exc:`.InvalidPythonEnvironment`
-    :returns: :class:`.Environment`
+    Parameters
+    ----------
+    version :
+        
+    **kwargs :
+        
+
+    Returns
+    -------
+    type
+        class:`.Environment`
+
     """
     exe = which('python' + version)
     if exe:
@@ -367,19 +489,45 @@
 
 
 def create_environment(path, safe=True, **kwargs):
-    """
-    Make it possible to manually create an Environment object by specifying a
+    """Make it possible to manually create an Environment object by specifying a
     Virtualenv path or an executable path and optional environment variables.
 
-    :raises: :exc:`.InvalidPythonEnvironment`
-    :returns: :class:`.Environment`
-
-    TODO: make env_vars a kwarg when Python 2 is dropped. For now, preserve API
+    Parameters
+    ----------
+    path :
+        
+    safe :
+         (Default value = True)
+    **kwargs :
+        
+
+    Returns
+    -------
+    type
+        class:`.Environment`
+        
+        TODO: make env_vars a kwarg when Python 2 is dropped. For now, preserve API
+
     """
     return _create_environment(path, safe, **kwargs)
 
 
 def _create_environment(path, safe=True, env_vars=None):
+    """
+
+    Parameters
+    ----------
+    path :
+        
+    safe :
+         (Default value = True)
+    env_vars :
+         (Default value = None)
+
+    Returns
+    -------
+
+    """
     if os.path.isfile(path):
         _assert_safe(path, safe)
         return Environment(path, env_vars=env_vars)
@@ -387,8 +535,18 @@
 
 
 def _get_executable_path(path, safe=True):
-    """
-    Returns None if it's not actually a virtual env.
+    """Returns None if it's not actually a virtual env.
+
+    Parameters
+    ----------
+    path :
+        
+    safe :
+         (Default value = True)
+
+    Returns
+    -------
+
     """
 
     if os.name == 'nt':
@@ -403,6 +561,17 @@
 
 
 def _get_executables_from_windows_registry(version):
+    """
+
+    Parameters
+    ----------
+    version :
+        
+
+    Returns
+    -------
+
+    """
     # The winreg module is named _winreg on Python 2.
     try:
         import winreg
@@ -430,12 +599,36 @@
 
 
 def _assert_safe(executable_path, safe):
+    """
+
+    Parameters
+    ----------
+    executable_path :
+        
+    safe :
+        
+
+    Returns
+    -------
+
+    """
     if safe and not _is_safe(executable_path):
         raise InvalidPythonEnvironment(
             "The python binary is potentially unsafe.")
 
 
 def _is_safe(executable_path):
+    """
+
+    Parameters
+    ----------
+    executable_path :
+        
+
+    Returns
+    -------
+
+    """
     # Resolve sym links. A venv typically is a symlink to a known Python
     # binary. Only virtualenvs copy symlinks around.
     real_path = os.path.realpath(executable_path)
@@ -464,6 +657,17 @@
 
 
 def _is_unix_safe_simple(real_path):
+    """
+
+    Parameters
+    ----------
+    real_path :
+        
+
+    Returns
+    -------
+
+    """
     if _is_unix_admin():
         # In case we are root, just be conservative and
         # only execute known paths.
@@ -483,6 +687,7 @@
 
 
 def _is_unix_admin():
+    """ """
     try:
         return os.getuid() == 0
     except AttributeError:
